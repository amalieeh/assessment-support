{"lineItemSourcedId":70328409,"ext_inspera_assessmentRunTitle":"IT2810 1 Webutvikling","ext_inspera_assessmentRunExternalId":"MTk0fHxJVDI4MTB8fDF8fE1BUFBFNi0yfHwyMDIwfHwxMg==","ext_inspera_maxTotalScore":30,"ext_inspera_candidates":[{"result":{"sourcedId":11538508,"ext_inspera_userAssessmentSetupId":7140137,"ext_inspera_userAssessmentId":4841129,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Chan Timmy (10165)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":32416271,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2148,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Komponentene i React kan ha states. ( i class comps this.state, og i func comps useState()). Disse states skal generelt brukes inn i komponenten selv, og kan ikke enkelt aksesseres fra andre komponenter.<\/p><p>&#160;<\/p><p>Det noen m&#229;te &#229; aksessere states til andre komponenter. F&#248;rst og fremst bruker med props passing. En parent kan sende en callback function til child component, slik at en child component kan sende en state oppover i hierachy slik at parent kan vite state til child. Dette er oppover state passing. Nedover er generelt ikke n&#248;dvendig, siden en rerender vil oppdatere alle childcomponents. Det er ogs&#229; mulig m&#229; aksessere states via refs, noe som er ikke anbefalt. Dette antas at child component er class component, slik at man kan utnytte this.state, eller at det er en func component og bruker useMemo eller lignende... Alle disse nevnte m&#229;tene &#229; dele states er kun ment for enkle bruk. N&#229;r en state skal deles til mange componenter lang fra hverandr ei hierarchien, m&#229; man utnytte andre teknologier.<\/p><p>&#160;<\/p><p>Vi har ContextAPI som er en relativt ny l&#248;sning for &#229; dele states mellom 2 componenter som ligger langt borte fra hverandre i hierarchien. Man m&#229; ha en consumer eller bruker hooks for &#229; aksessere en tilstanden i en context provider. Det kan bli problematisk n&#229;r man har flere context providers, slik at strukturen blir rotete.<\/p><p>&#160;<\/p><p>S&#229; vi har Redux store som fikser dette. Redux eksisterte f&#248;r contextAPI, og bruker actions og reducers til &#229; definere globale states. Flere reducers kan kombineres via combineReducers() til en &#34;store&#34; (engelsk). Man kan tenke at en store er appens tilstand. Videre er det mulig &#229; bruke react-redux-context, og da er det mulig &#229; bruke redux p&#229; en m&#229;te som context hvis man vil. I Redux, bruker man gjerne useSelector og useDispatch til &#229; &#34;koble sammen&#34; en component til en state, og useDispatch til &#229; oppdatere en state i store. useSelector vil rerender en component dersom den tilstanden i store er endret. useDispatch() vil bli kj&#248;rt men en gang, men venter til litt senere og kj&#248;rer sammen med alle andre dispatch calls. Dette er stemmer i likhet med hvordan dispatch generelt funker.<\/p><p>&#160;<\/p><p>Mobx er en annen Redux lignende library. Her gj&#248;r MobX sine datastrukturer observerbare, og krever mindre boilerplate koding enn Redux, men begge funker generelt p&#229; samme m&#229;te. MobX er generelt brukt sammen med ContextAPI til &#229; lage en store.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2827,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en state-management library for React. Her er ideen &#229; bruke&#160;&#34;atoms&#34; og &#34;selectors&#34; som app tilstanden. Fra Core-concepts siden, kan man se at en atom er en tilstand som componenter kan subscribes til. Det kan gj&#248;res via useRecoilState, som er erstatning til &#34;useState&#34; fra React. En rerender av komponenter som har subsriba vil skje n&#229;r en atom oppdateres.<\/p><p>&#160;<\/p><p>Her syns jeg det er relevant &#229; sammenligne det med Redux.<\/p><p>&#160;<\/p><p>Atom&#160;er en &#34;shared-state&#34; og innholder verdier som kan anses som applikasjonens tilstand. S&#229; det er kan sammenlignes med reducer i Redux<\/p><p>&#160;<\/p><p>Selector er en &#34;derived-state&#34; og brukes til &#229; definere state som er basert p&#229; andre atoms. her defineres det gjerne getters og setters for &#229; gj&#248;re det enklere &#229; bruke. Dette er en ny concept og kan derfor vanskelig &#229; sammenligne med redux. Men det kan gj&#248;res ved &#34;store&#34;, siden begge bruker useSelector og useDispatch.<\/p><p>&#160;<\/p><p>Redux krever mye kode for &#229; definere en store, fordi det er mye boilerplates som m&#229; skrives. Recoil bruker atoms og selectors&#160;istendenfor payloadActions, reducer og store i React. Recoil klarer dette ved &#229; utnytte&#160;data-flow graph mellom atoms og selectors slik at det er un&#248;dvendig &#229; definere en store.&#160;S&#229; Recoil gir st&#248;rre frihet og mindre kode.<\/p><p>&#160;<\/p><p>Recoil (samme som React) er lagd av Facebook og det er en stor fordel med tanke p&#229; om prosjektet kommer til &#229; overleve konkurransen.<\/p><p>&#160;<\/p><p>Ved kortsikt, er Recoil ganske ny, og det er derfor relativt lite l&#230;ringsmuligheter. Dette library er derfor muligens vanskelig for nybegynnere i React, og ikke er s&#229; god til &#229; lese docs.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2182,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST&#160;API og GraphQL kan begge brukes p&#229; serveren. Begge er stateless, men det er mange forskjeller. Her har vi en liste p&#229; disse.<\/p><p>&#160;<\/p><p>Alle endpoints i REST API er URI (som st&#248;tter parametre). Man kan aksessere disse som en hvilken som helst nettadresse (http). Som en konsekvens, kan REST responses bli indekset og cachet ved bruk av innebygde nettleser funksjonalitet. Bruk av caching p&#229; clienten kan &#248;ke effektivitet og skalerbarhet. GraphQL i den andre h&#229;nden er ikke nettadresse, og innebygde caching i nettlesere blir derfor ikke brukt.<\/p><p>&#160;<\/p><p>REST API st&#248;tter mange typer responses, mens Graphql st&#248;tter kun JSON (eller en json som en spesifikt for graphql). GraphQL st&#248;tter ogs&#229; typing og validering av request og responses, slik at det blir mer strukturert.<\/p><p>&#160;<\/p><p>I graphql, kan man utf&#248;re SQL lignende requests mot databasen, fra&#160;clienten. Det vil si at man kan f&#229; serveren til &#229; hente akkurat det man vil, og ikke mer enn det man vil. Alts&#229; ikke &#34;overfetching&#34; (for mye)&#160;eller &#34;underfetching&#34; (for lite). REST st&#248;tter ikke dette hvor mindre en definerer en query param som tar inn en &#34;SQL query&#34; streng. Dette er sterkt ikke anbefalt pga. &#34;SQL injection&#34; eller lignende vulnerabilities. GraphQL gj&#248;r det p&#229; en mer sikker m&#229;te.<\/p><p>&#160;<\/p><p>I REST, har vi &#233;n endpoint gj&#248;r &#233;n ting. Og med det samme kall, vil alltid det program kj&#248;rt, og det som returneres&#160;er basert p&#229; det som st&#229;r i databasen. Hva som returneres er definert i serveren. Det kan v&#230;re bra med tanke p&#229; at det er enkelt &#229; forst&#229; API&#39;et og det er enkelt &#229; bruke, siden det er forutsigbar. Dette kan derimot v&#230;re d&#229;rlig hvis man har lyst til &#229; hente kun &#233;n verdi fra hele returnerte objektet, s&#229; er dette ikke enkelt &#229; gj&#248;re. I tillegg, n&#229;r man skal hente flere verdier enn det endpoints st&#248;tter, m&#229; man utf&#248;re flere api kall. Men tanke p&#229; effektivetet, kan det godt hende at det kan ta flere roundtrips av data transmitt mellom client og server&#160;f&#248;r en blir forn&#248;yd med det endelige resultatet. Gj&#248;r man dette i graphql, kan man gj&#248;re det i et kall. Det er forresten mulig &#229; gj&#248;re det i et kall i REST ogs&#229;, men da m&#229; dette v&#230;re definert i serveren og har en endpoint for det. Dette er ikke n&#248;dvendig i GraphQL, siden database query er definert i clienten. I GraphQL har man mye frihet.<\/p><p>&#160;<\/p><p>GraphQL blir stadig mer kjent, mens REST er allerede standaren. REST er generelt en del enklere &#229; sette seg i enn GraphQL, blant annet pga. l&#230;ringsmuligheter.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11539492,"ext_inspera_userAssessmentSetupId":7139982,"ext_inspera_userAssessmentId":4841122,"dateLastModified":"2020-12-01T10:01:21Z","ext_inspera_startTime":"2020-12-01T08:00:08Z","ext_inspera_endTime":"2020-12-01T10:01:21Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Wangen-Eriksen Martin (10158)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33642064,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2120,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere m&#229;ter &#229; dele tilstand i React applikasjoner. Noen er best for enkle applikasjoner andre er bedre for komplekse of hyppig oppdaterte applikasjoner. Alle deler de at de gj&#248;r det mulig &#229; dele state mellom flere komponenter.&#160;<\/p><p>&#160;<\/p><p><strong>Props / callback functions<\/strong><\/p><p>Props er kort for properties og er et attributt/variabel knyttet til en komponent. Komponenten tar inn gitte verdier (input). F eks &#60;<strong>Film <\/strong>data = {data} /&#62;. I dette tilfelle er blir data sendt nedover i hierakiet og data som befinner seg et annet sted enn Film blir sendt videre til Film komponenten. Props variablen er immutable noe som betyr at Film komponenten ikke kan endre props-verdien. Props kan kun sende stater nedover i hierakiet, men det er mulig &#229; sende callbackfunskjoner. Dette gj&#248;r det mulig for en komponent nede i hierakiet til &#229; endre en variabel lenger oppe.&#160; N&#229;r en bruker props for dataflyt lagres ofte data i state i hver komponent. Det gj&#248;res litt forskjellig i class-components og functional components (useState vs this.state), men det viktige her er at det kun i scopet til komponenten.<br />Props er en fin m&#229;te &#229; komme igang med deling av state og brukes alltid, men i varierende grad i React applikasjoner. En ulempe med props er at de ikke kan dele informasjon p&#229; tvers/horisontalt av hierakiet kun direkte oppover og nedover.<\/p><p>&#160;<\/p><p><strong>Context API<\/strong><\/p><p>Context API-et tillater &#229; dele informasjon uten &#229; manuelt sende props ned hvert eneste lag. Context brukes ofte n&#229;r man noen av prosjektes state er &#34;globalt&#34; og det skal deles med mange komponenter som ikke n&#248;dvendigvis har samme parent. Context tar i bruk en provider som wrappes rundt en parent, det er ogs&#229; denne som inneholder staten.. Alle children av denne komponenten har da muligheten til &#229; consume denne Contexten. Med andre ord den har tilgang p&#229; staten.&#160;<\/p><p>Context er en &#34;enkel&#34; m&#229;te &#229; lage en global state p&#229;. I tillegg er det greit fordi det lar en enklere tilgjengeliggj&#248;re states rundt om i komponent hierakiet. En ulempe med Context er at det ikke er hensiktsmessig n&#229;r staten den inneholder oppdateres ofte. Det er fordi dette re-renderer applikasjonen hver gang. Ogs&#229; hvis staten er for kompleks er det mer hensiksmessig og ikke bruke Context.&#160;<\/p><p>&#160;<\/p><p><strong>Redux/Mobx<\/strong><\/p><p>I prosjekter med en kompleks state som skal brukes i mange av komponentene er det hensiksmessig &#229; bruke en state managment ls&#248;ning som Mobx eller Redux. Da slipper man mye av props passing, call back funksjoner og andre ting som kan forvirre og skape tr&#248;bbel. Med Redux vil staten lagres i en store og kun v&#230;re mulig og oppdatere via action og reducer. Dette vil f&#248;re til en oppdatering av komponenter som bruker dataen.&#160;<br /><br />En ulempe med Redux/Mobx er at det er mye boiler plate kode. Dette gj&#248;r at barrieren er st&#248;rre for &#229; starte med det. Men positiv ting med det er at det gj&#248;r det mulig &#229; fullt dele variabler globalt, oppdatere hyppig og ha en kompleks state.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3031,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Hva er det?<\/p><p>Recoil er, i likhet med Redux og Mobx,&#160;et state managment bibliotek for react. Recoil er lagt for &#229; v&#230;re simplistisk og likt som react. N&#229;r man bruker det kan det minne veldig om &#229; ta i bruk useState hooken. Recoil best&#229;r hovedsakelig av to ting. Atoms og selectors. Recoil deler staten i flere deler. Disse kalles atoms. Atoms er deler av staten og oppdateres og subscribes av komponenter. Flere komponenter kan subscribe samme atom. Dersom et atom oppdateres, oppdateres alle komponenter som subscriber til det. En selector er en funkson som tar inn et atom og re evaluerer seg selv basert p&#229; den nye verdien. Et av problemene Recoil har fokusert p&#229; &#229; fikse er codesplitting. Hvor barna til en parent deler seg i flere markante branches. Det er da umulig &#229; dele data p&#229; tvers av l&#248;v-barna uten &#229; sende data helt opp for s&#229; helt ned igjen. Dette er et problem for context og props, men ikke for Redux.<\/p><p>&#160;<\/p><p>Sammenlign<\/p><p>Der hvor redux har mye boiler plate kode har recoil klart seg nesten helt uten dette. Redux har mye set up for &#229; fikse store, reducers og actions. Alt dette m&#229; med for &#229; kunne h&#229;ndtere og dele states i en applikasjon. For recoil virker ting enklere enn det. Der kan atoms lages i runtime i en komponent og er da tilgjengelig andre steder for de som kan trenge det. Recoil ligner og, i syntaks, mer p&#229; vanlig react kode. Recoil har staten sin i flere atoms som kan defineres og eksistere forskjellige steder i applikasjonen. Redux derimot har alle statene lagret i en store&#160;som er et definert sted. Recoil trenger ikke engang &#229; definere en store.&#160;<br />For &#229; oppdatere en state i Redux bruker en dispatch metoder for &#229; fyre av actions. Det samme gj&#248;res i Recoil med selectors.<br />I en komponent som skal ta i bruk en global state bruker man i Redux useSelector og useDispatch til &#229; hente verdi og oppdatere verdi. I Recoil gj&#248;res dette&#160;med useRecoilValue, useRecoilState.&#160;<\/p><p>&#160;<\/p><p>Fordeler / Ulemper<\/p><ul>\t<li>Recoil er boiler-plate free som gj&#248;r det enklere &#229; ta i bruk en for eksempel Redux<\/li>\t<li>Lagd for &#229; ligne p&#229; react s&#229; er kanskje enklere &#229; forst&#229;<\/li>\t<li>Recoil eliminerer en del re renders&#160;<\/li>\t<li>Recoil kan tas i bruk uten &#229; restrukturere prosjektet helt. Dette kan ikke redux<\/li>\t<li>Recoil blir mindre kode totalt enn redux<\/li><\/ul><p>&#160;<\/p><ul>\t<li>Recoil er ganske nytt s&#229; det er f&#229; ressurser til det online, uten om dokumentasjonen<\/li>\t<li>Mangel p&#229; debugging verkt&#248;y<\/li><\/ul><p>&#160;<\/p><p>https://recoiljs.org/docs/basic-tutorial/atoms<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>https://bigcheeseapp.com/2020/07/12/recoil-vs-redux-react-state-management-2020/?fbclid=IwAR3QvAaNTpcWV2MrdyhdhuT7Jz2KlwD3imqLncaU8lJ4g3WKIxhKLmPL1l4<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1964,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><br /><strong>REST<\/strong><br />N&#229;r man bruker REST definerer man et eller flere endepunkter for get, put, post og delete requests. Requestene endrer p&#229; ressurser ved URI og HTTP requester. Ressursene har alle hver sin unike adresse som forklarer hva den gj&#248;r.&#160;Fordeler med REST er at man kan bruke caching som gj&#248;r det mer effektivt og skalerbart. Den intuitive m&#229;ten &#229; skrive requesten p&#229; gj&#248;r det enkelt &#229; forst&#229; hvilke data som returneres. Dette gj&#248;r det ogs&#229; lettere &#229; skrive. Ulempe med REST er at&#160;du kan ende opp med veldig mange endepunkter og det blir overfetching, alts&#229; at du f&#229;r returnert mer data enn n&#248;dvendig. REST brukes ofte sammen med MERN stacken.<\/p><p>&#160;<\/p><p><strong>Graphql<\/strong><\/p><p>Graphql er query basert og man sender da sp&#248;rringer etter data. Sp&#248;rringen definerer b&#229;de s&#248;k og dataen som skal returneres. I graphql er det kun et endepunkt, men siden en bruker sp&#248;rringer er det enkelt &#229; f&#229; tak i kun dataen man er ute etter og man slipper da overfetching. Graphql st&#248;tter kun json formatet, men til gjengjeld er det et typesystem som tilgjengeliggj&#248;r validering. En ulempe graphql har er at det ikke tillater caching i HTTP-laget. P&#229; en annen side er det enkelt &#229; sette opp med tredjepartskomponenter, og man trenger <strong>kun en<\/strong> sp&#248;rring for &#229; f&#229; &#248;nsket data. Grapql brukes ofte sammen med GRAND stacken.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>REST er en arkitektur for kommunikasjon mellom server og tjeneste, men grapql p&#229; en annen side er mer et query-spr&#229;k.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11542701,"ext_inspera_userAssessmentSetupId":7140057,"ext_inspera_userAssessmentId":4841318,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:01:24Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ekpete Sebastian Vildalen (10077)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303572,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2353,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State i React er et object som finnes i komponenter. State er til for &#229; oppdatere (rendre) komponenten n&#229;r det er gjort en endring p&#229; staten. Dette gj&#248;res ved this.setState(). State opprettes i constructor, og state blir behandlet inni komponenten. En komponent som har state kalles &#34;stateful&#34;. Komponenter er ofte i et hierarki der en har parents og childs. Props og states er m&#229;ten disse deler informasjon p&#229;. Props sendes ned i return-statement til en parent, og der legger man inn children og hvilke props som skal sendes ned, og hva disse inneholder. I en children kan man da hente ut props ved &#34;this.props.whatever&#34;, for &#229; finne whatever-verdi fra parent.&#160;<\/p><p>&#160;<\/p><p>Som i mye av programmering, er det alltid lurt &#229; &#34;sentralisere&#34; kode som blir brukt mye. Dermed kan det v&#230;re nyttig med verkt&#248;y for state management. Det finnes flere av disse, med forskjellige use-cases, men noe nav de mest popul&#230;re er Context, Redux og Mobx. Det som er felles med disse er at n&#229;r det blir for mange stateful komponenter og mye data som endrer seg, s&#229; vil det v&#230;re lurt &#229; ha et fast sted der info ligger.<\/p><p>&#160;<\/p><p>I Redux s&#229; har du en global state, og ikke en state for&#160;hvert enkelt komponent. Denne globale staten er lagret i en store, som er treet som bestemmer staten til alle komponenter. Her vil du ha noen komponenter som er parents som har kontakt med den globale staten. Disse kalles smarte komponenter. Eneste m&#229;ten &#229; endre en state p&#229; er ved actions. En action kommuniserer med reducers om &#229; oppdatere en state. Dette er da eneste m&#229;ten &#229; sende data fra applikasjonen til store, og denne dataen kommer fra fra API-kall, endringer i UI eller ved brukerinteraksjoner i applikasjonen. Staten er jo plassert i store, og store har i tillegg tilgang p&#229; alle tidligere states, slik at man kan g&#229; tilbake. Noe som ogs&#229; er viktig er at en state ikke endres p&#229;, men den erstattes med en ny en. Reducer bruekr n&#229;v&#230;rende state + action, og lager en ny state. Dermed er state immutable, siden du ikke endrer den direkte, men lager en kopi og erstatter.&#160;<\/p><p>&#160;<\/p><p>MobX er et alternativ til Redux, og er ogs&#229; global state management. MobX gj&#248;r at komponenter kan observere datastrukturer. MobX har mindre boilerplate-kode enn Redux, s&#229; det er blir dermed mindre endringer i koden. Her har man ogs&#229; stor fleksibilitet i design av state.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2406,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I forrige oppgave nevnte jeg flere state mangament verkt&#248;y, som blant annet Redux. Recoil er et nytt state management for React, og er laget av Facebook (som ogs&#229; har React). Recoil vil l&#248;se samme problemet som de andre ved global state management. En av de st&#248;rste fordelene ved det er enkelheten og at det er lett &#229; bruke og l&#230;re seg. Det er laget for &#229; fungere og &#34;tenke&#34; som React. Dermed, hvis man kan React, s&#229; skal det v&#230;re greit &#229; sette seg inn i Recoil. Recoil bruker blant annet hooks, som en react-utvikler er veldig godt kjent med.&#160;<\/p><p>&#160;<\/p><p>Recoils hovedkonsepter er &#34;Atoms&#34; og &#34;Selectors&#34;. Atoms er deler av state, og de kan oppdateres. Atoms kan bli laget i runtime, og kan bli brukt istedenfir en react komponent state. Et atom kan brukes i flere komponenter, og disse vil da dele state. Et atom har ogs&#229; en unik key som brukes for debugging og noen APIer. De har ogs&#229; en default value (likt som states). Selector er funksjon som tar inn atomer eller andre selectorer som input. En komponent kan &#34;subscribe&#34; til selector og n&#229;r selector blir oppdatert s&#229; blir komponenten re-rendered.&#160;<\/p><p>&#160;<\/p><p>Det er enklere &#229; bruke Recoil enn Redux.&#160;Redux har jo en del boilerplate-kode som du m&#229; ha med i programmet ditt. I forrige oppgave nevnte jeg at MobX har mindre slik kode, og Recoil videref&#248;rer dette konseptet ved &#229; ha s&#229; lite boilerplate som mulig. Med Recoil slipper man &#229; restrukturere prosjektet sitt s&#229; mye, fra det React allerede setter opp for deg.&#160;<\/p><p>&#160;<\/p><p>Sammenlignet med Context, s&#229; vil Recoil v&#230;re en fordel. Context gj&#248;r at enhver endring p&#229; state vil gj&#248;re at alle komponenter som bruker den staten vil re-rendres. Dette vil ikke skje med Recoil pga. hvordan det er satt opp med atomer og selectors.&#160;<\/p><p>&#160;<\/p><p>Ulemper med Recoil er at det er veldig nytt bibliotek med mindre dokumentasjon og f&#230;rre med erfaring fra det. I tillegg s&#229; har det ikke like mange &#34;tools&#34; som f.eks Redux for &#229; holde styr p&#229; alle statesene i hele applikasjonen.&#160;<\/p><p>En annen ulempe er at Recoil fortsatt er i en eksperimentell fase, s&#229; det kan v&#230;re en risk &#229; bruke det i en stor applikasjon (hvis man skulle st&#248;tte p&#229; problemer som ikke er l&#248;selig). Her kan det v&#230;re lurere &#229; bruke et mer etablert state management system som f.eks. Redux. Redux har masse dokumentasjon, samt&#160;st&#248;tte fra biblioteker og utvidelser.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2299,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>API er interface som gj&#248;r at programmer kan dele info med hverandre. Du har et API p&#229; en server som en klient kan snakke med. REST API er regler for hvordan API gj&#248;r at klient og server kan snakke sammen. Et kall blir gjort til API, og API returnerer infromasjon fra databasen. REST st&#229;r for Representation State Transfer. Som man ser i navnet, s&#229; handler det om overf&#248;ring av tilstand.&#160;Her brukes HTTP-request med f.eks. GET og POST. Eksempelvis: GET blir definert i URL til endepunktet, og blir skrevet med API-kall. GET etc, blir jo definert i URIen.<\/p><p>Dataen blir ofte returnert som JSON-objekt, avhengig av hvilket API en bruker. En begrensning med REST er at hvis man trenger data fra to forskjellige endpoints, s&#229; s&#229; m&#229; man sende to forskjellige requests til REST APIet. I GraphQL kan hente ut info fra forskjellige steder i et enkelt kall (query).&#160;<\/p><p>&#160;<\/p><p>GraphQL er et &#34;query language&#34; som bruker HTTP. GraphQL&#160;forenkler infoen du f&#229;r, og fokuserer p&#229;&#160;hastighet. GraphQL bruker query language til &#229; selektere infoen den tar inn til akkurat det man trenger og sp&#248;r om, men REST API gir deg all infoen uansett. Dermed, siden du kan begrense dataen du f&#229;r til det du trenger, blir GraphQL mer effektiv enn REST API. To vanlige&#160;problemer i REST er at du enten henter for mye informasjon, eller for lite informasjon, avhengig av hva som er tilgjengelig p&#229; endepunktet.&#160;<\/p><p>Et til poeng med REST er at tjeneren ikke skal huske&#160;klientens foresp&#248;rsel.<\/p><p>&#160;<\/p><p>Dersom GraphQL er raskere og mer skreddersydd, s&#229; vil den v&#230;re bedre der man trenger mye forskjellig og spesifikk data fra forskjellige steder.&#160;<\/p><p>&#160;<\/p><p>En fordel med begge to er at de enkle &#229; bruke, men GraphQL kan v&#230;re vanskeligere &#229; implementere.&#160;Det er kanskje ikke like lurt &#229; bruke GraphQL i sm&#229; applikasjoner, der det enkelt kan brukes REST. Dette fordi det kan legge til mye un&#248;dvending kompleksitet i applikasjonen. REST API er ogs&#229; sett p&#229; som &#34;best practice&#34;, mens GraphQL er up and coming.&#160;<\/p><p>&#160;<\/p><p>En forskjell mellom de to er at REST API<em> kan&#160;<\/em>returnere JSON.objekter, men GraphQL kun bruker JSON.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535198,"ext_inspera_userAssessmentSetupId":7139967,"ext_inspera_userAssessmentId":4841228,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Fossum Mathias Strømstad (10190)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331119,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2262,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State management er et viktig konsept i React. Data flyter hierakrisk i det vi kaller for komponenttreet v&#229;rt. Dataen flyter &#34;ovenifra&#34; og &#34;ned&#34;. Det betyr at barna i treet kan arve tilstanden til sine foreldre. Denne dataen kan vi lagre i props og sende ned til barna i komponenttreet. Tilstanden pr&#248;ver vi derfor &#229; flytte h&#248;yt opp i hierarkiet fordi tilstanden kun p&#229;virker barna til komponenten med tilstanden. Dermed kan den aktuelle tilstanden dekke flere barnekomponentener som er avhengig av tilstanden. Fordelen er at det er lett for utvikleren &#229; identifisere hvor dataen kommer fra. I det tilfellet at noe ikke fungerer, kan man i utgangspunktet enkelt&#160;finne frem til hvor den eventuelle feilen ligger.<\/p><p>&#160;<\/p><p>En nyere teknikk i React er Context. I tradisjonell react m&#229; man dataen flyte gjennom hver komponent til den aktuelle komponenten. Context APIet unng&#229;r dette. Et klassisk eksempel er applikasjoner med st&#248;tte for operativsystemer i dark mode. Tradisjonelt sett m&#229;tte tilstanden om at dark mode er aktivert gjennom hver eneste komponent. Context kunne ha l&#248;st dette ved at man pakker inn applikasjonen i en provider. Denne globale provideren kan s&#229; fortelle alle de andre komponentene hvilket tema som er valgt. Disse komponentene kalles da consumere av provideren. Redux og MobX er ogs&#229; state management biblioteker som tiln&#230;rmer seg samme oppgave, men med forskjellige implementasjoner<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2769,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt state management bibliotek. Det finnes allerede andre state management biblioteker som react-redux. Recoil minner om Redux, men deler dataen sin inn i to enheter,&#160;<em>atoms<\/em>&#160;og&#160;<em>selectors.&#160;<\/em>I redux dispatcher en action n&#229;r et event har forekommet. Det foreg&#229;r via en reducer. I Recoil fungerer det p&#229; samme m&#229;te, men via en selector. Denne selectoren er en funksjon. N&#229;r selectoren oppdateres vil alle komponentene som abonnerer p&#229; selecotren re-rendre.&#160;<\/p><p>&#160;<\/p><p>Atoms inneholder en tilstand andre komponenter kan abonnere p&#229;. N&#229;r tilstanden oppdateres, vil re-rendrer de abonnerte komponentene.&#160;Akkurat som selectors<\/p><p>&#160;<\/p><p>Redux krever veldig mye boilerplate for &#229; fungere. Derfor m&#229; mye av prosjektet ditt endres dersom du implementerer redux sent i utviklingen. Dette er en av recoils styrker. Feks trenger du ikke &#229; opprette noe lokal store. Dette gj&#248;r Recoil automatisk for deg.<\/p><p>&#160;<\/p><p>En kanskje litt mindre &#229;penbar ulempe med recoil er at det er i en tidlig fase. Dermed kan store prosjekter kvie seg for &#229; benytte seg av noe som kanskje ikke blir industristandarden.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1966,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST API gir tilgang til mange endepunkter med forskjellig lagret data. Graphql operer p&#229; et endepunkt og du querrier dataen p&#229; dette endepunktet. I REST verden ville du da ha trengt flere endepunkter basert p&#229; hvor du henter dataen din fra (feks fra to forskjellige APIer). Siden GrapQL er et query spr&#229;k kan du flette skjemaer fra forskjellige APIer i til et datasett.<\/p><p>&#160;<\/p><p>REST har flere endepunket og dermed enklere &#229; HTTP cache fordi det er lett &#229; gjenkjenne tildligere bes&#248;kte endepunkter. Siden GraphQL server ikke leverer&#160;sin data p&#229; forskjellige&#160;endepunkter m&#229; caching foreg&#229;r i implementasjoen din. Apollo platformen har dette f.eks innebygd<\/p><p>&#160;<\/p><p>REST henter ut et komplett datasett uansett om hvor mye du trenger. Dermed kan du f&#229; overfetching. GraphQL sin styrke er at du kan kun querie p&#229; n&#248;yaktig den dataen du trenger.&#160;<\/p><p>&#160;<\/p><p>Siden REST f&#248;lger HTTP standarden i mye st&#248;rre grad enn GraphQL, vil du f&#229; ut HTTP statuskoder med utfallet av requested ditt. GraphQL f&#248;lger ikke samme standard s&#229; dataen du f&#229;r ut av queriet ditt m&#229; du parse for &#229; finne ut av om det er en feil eller ikke.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://dev.to/chandan/recoil-vs-redux-the-ultimate-react-state-management-face-off-35b<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://blog.logrocket.com/5-reasons-you-shouldnt-be-using-graphql-61c7846e7ed3/<\/p><p>https://developer.akamai.com/blog/2018/10/29/overview-graphql-query-parsing-and-caching-edge#:~:text=According%20to%20the%20GraphQL%20caching,to%20build%20a%20cache%20key.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535538,"ext_inspera_userAssessmentSetupId":7139919,"ext_inspera_userAssessmentId":4841287,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ørke Anne Mosvold (10013)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35012510,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1175,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For &#229; lagre&#160;tilstand for en komponent er den enkleste l&#248;sningen lokal komponent-state, der man lagrer tilstanden til komponenten lokalt. Hele komponenten har da tilgang til tilstande, men ingen andre komponenter i hierarkiet har tilgang. Dataflyt l&#248;ses med props som sendes nedover i hierarkiet med&#160;attributtsyntaks&#160;p&#229; komponenter. Hele denne komponeten vil da ha tilgang til de propsene som blir sendt. Man kan sende&#160;callback-funksjoner som props for &#229; sende data opp i hierarkiet. Dette fungerer fint i sm&#229; og enkle applikasjoner. Men hvis en tilstand trengs i flere komponeter eller skal sender langt opp/ned i hierarkiet er dette en d&#229;rlig l&#248;sning. Da b&#248;r man bruke global state management p&#229; de tilstandene som trengs i flere komponenter. Noen av de&#160;mest brukte&#160;l&#248;sningene for dette er REACT Context API (for React), Redux og Mobx. Hvis man bruker GraphQL og Apollo til backend og database, kan man ogs&#229; bruke Apollo til state management. Man b&#248;r fortsatt bruke lokal state der man kan. REACT Context API er en enkel l&#248;sning for global state i React der man enkelt lager en global state som alle komponenter i hierarkiet har tilgang til, men det egner seg ikke veldig godt for komplekse tilstander og tilstander som endres ofte. Redux lagrer state ett sted(i en store) som alle komponenter kan f&#229; tilgang til. Storen kan endres med dispatch-metoden som tar inn actions og den globale staten endres med reducers. Mobx bruker prinsippet observable. Det lages en observable state og alle komponenter som trenger denne staten gj&#248;res til obserbat&#248;rer. Denne l&#248;sningen krever mindre kode og er enkel&#160;og skalerbar.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2875,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management p&#229; samme m&#229;te som Redux og Mobx. Recoil baserer seg p&#229; atoms og selectors som komponenter f&#248;lger med p&#229;. Atoms inneholder state og kan brukes til b&#229;de lokal og blobal state. N&#229;r et atom blir laget har alle komponenter tilgang til denne og kan subscribe p&#229; denne staten. Alle komponenter som subscriber p&#229; en tilstand som blir endret vil re-render, p&#229; samme m&#229;te som med Redux og Mobx. En selector er en funksjon som brukes til &#229; gj&#248;re beregninger og lignende p&#229; atoms og de blir kj&#248;rt hver kan atomet det bruker endres. Dette gj&#248;r at man kan ha f&#230;rrest mulig atoms og resten av dataen kan man beregne med selectors. Komponenter kan ogs&#229; subscribe p&#229; selectors og for en komponent ser atoms og selectors like ut. En av fordelene med Recoil er at bare de komponentene som faktisk bruker staten og atomet som blir endret vil re-render, i tillegg er det lite kode som trengs for &#229; implementere Recoil. Det er ogs&#229; spesifikt for React, noe Redux og Mobx ikke er. Recoil kan h&#229;ndtere b&#229;de synkrone og asynkrone funksjoner, avledet tilstand og code-splitting og har alikevel lite boilerplate kode. Det er ogs&#229; mye lettere &#229; sette seg inn i enn mange andre state management bibliotek. Hovedfordelen i forhold til Redux og Mobx er mindre boilerplate kode og at det er lettere &#229; l&#230;re og &#229; sette seg inn i. Ulempene med Recoil er at det er veldig nytt og det har derfor lite debugging verk&#248;ty og ting er fortsatt litt underveis. I dokumentasjonen er det fortsatt flere funksjonaliterer som ikke er ferdige. Men det virker alikevel som at man enkelt kan sette opp fullt fungerende state management med Recoil.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;&#160;<\/p><p>https://recoiljs.org<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee&#160;<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2673,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Hovedforskjellen mellom REST API og GraphQL er at REST er bregrenset til &#229; kommuniserere med en ressurs om gangen, mens GraphQL er mer fleksibel p&#229; dette. Hvis du med REST trenger data fra flere enn en ressurs m&#229; du sende flere foresp&#248;rsler&#160;til serveren. Hvis du f.eks vil ha informasjon om en bok og forfatterer m&#229; du med stor sannsynlighet f&#248;rst&#160;sende en foresp&#248;rsel for &#229; bok objektet og s&#229; bruke forfatter id fra bok objektet til &#229; sende&#160;en ny foresp&#248;rsel for &#229; f&#229; forfatter objektet. Dette kalles underfetching.&#160;Med GraphQL p&#229; den andre siden blir all data betraktet som en graf og er derfor koblet samme og du kan da&#160;hente all n&#248;dvendig data med &#233;n foresp&#248;rsel. Du definerer hvilke data du trenger og p&#229; hvilke form du vil ha det og sender &#233;n foresp&#248;rsel om det til serveren. Du kan da f&#229; data fra flere enheter samtidig fordi alt henger sammen.&#160;En annen forskjell handler om overfetching. N&#229;r man bruker REST API vil du alltid f&#229; tilbake det fullstendige settet av data. Det er ikke mulig &#229; begrense responsen man f&#229;r fra serveren. Med GraphQL kan man spesifisere hvilke attributter som skal inkluderes i svaret fra serveren og p&#229; den m&#229;ten begrense menden data som blir sendt. GraphQL har ogs&#229; et skjema som definerer hva som er gyldige foresp&#248;rsler og det blir returerrt feilmeldinger som json hvis det skjer en feil.&#160;Andre forskjeller er at GraphQL ikke har implisitt caching i HTTP-laget og at det kun brukes&#160;JSON for utveksling av data.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p><p>https://goodapi.co/blog/rest-vs-graphql<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535608,"ext_inspera_userAssessmentSetupId":7140051,"ext_inspera_userAssessmentId":4841214,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Allport Patrick Moen (10020)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34401768,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2017,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har innebygt funksjonalitet for &#229; kunne sende informasjon fra parent til child i formen av props. Dette er da immutable informasjon som blir sendt ned til en instans som ofte passer vanligvis&#160;i et spesielt format. Ofte s&#229; blir dette formatet definert ved en interface, da en vil ofte sende samme&#160;<strong>TYPER<\/strong>&#160;av data til like barn (men ikke n&#248;dvendigvis samme data til samme instans, bare like typer). Barnet kan da bruke denne informasjonen.&#160;<br /><br />I tillegg s&#229; har react &#34;State&#34; som er en intern kilde med informasjon som instansen kan aksessere. Ofte s&#229; blir dette definert via props, men trenger ikke n&#248;dvendigvis &#229; v&#230;re det. Dette kan referere til f.eks. ting som en counter. Ofte s&#229; blir dette satt ved setState(), da state er immutable, og den eneste m&#229;ten en kan endre p&#229; state er ved &#229; lage en ny immutable state og erstatte tidligere state med den nye state&#39;n. (Ved bruk av hooks).&#160;<br /><br />For &#229; kunne sende data oppover tilbake til parent, s&#229; l&#248;ses dette ved at parent sender ned en callback-funksjon som kan trigges av childet (og sette inn parametre om mulig). Ved trigging, s&#229; f&#229;r parent-komponentet en respons som de kan utf&#248;re en handling basert p&#229; dette. Dessverre, s&#229; kan en ende opp med &#229; sende veldig mye props igjennom komponenter som ikke trenger de, da f.eks. app-component har data til et l&#248;vnode-komponent. Dette kalles da prop-drilling og er en kjent problemstilling i &#34;vanlig&#34; React.<br /><br />En har utviklet forskjellige tredjeparts (og f&#248;rsteparts mtp context) bibiliotek som kan gj&#248;re state management enklere. En har Mobx, Redux og ContextApi. Avhengig av hvordan prosjektet er satt opp, s&#229; kan det v&#230;re hensiktsmessig &#229; bruke en av disse tre.<br /><br />Redux er super skalerbart, bruker funksjonelle actions, er lettere &#229; debugge (da en sender bare et bestemt sett med actions til store&#39;n), har lett inntegrering av authentication og&#160;har immutable store-state. I tillegg, s&#229; har den det som en kaller for &#34;One source of truth&#34;, dvs. en sentral store som har all relevant informasjon. I tillegg, s&#229; har den en god funksjonalitet, der om en endrer state, s&#229; finner den ut hvilke kompoenter som m&#229; oppdaterer seg, og rerendrer bare disse. Dessverre, s&#229; har redux en del ulemper ogs&#229;. Den har mye boilerplate-kode, da en trenger reducers, store og actions. I tillegg, s&#229; f&#248;rer en sentral store til at en m&#229; hente hele store&#39;n, selv om en bare trenger en liten bit av dataen som er lagret der. Dette er da ueffektivt. I tillegg, s&#229; har redux en h&#248;yere l&#230;ringskurve enn f.eks mobX, da denne boilerplate-koden m&#229; en ogs&#229; forst&#229; hvordan de jobber sammen for &#229; endre (og hente ut) store-state.<br /><br />Mobx er noe p&#229; det helt andre siden av spektrumet. Den er lettere &#229; l&#230;re, har flere stores, har mutable state og har ikke like mye boilerplatekode. Men som et resultat av dette, s&#229; er den vanskeligere &#229; debugge (da du ikke har functional actions og immutable state) og en m&#229; s&#248;rge for at de conjunktive delene i store&#39;ene er synkronisert(eller overlapper ikke i det hele tatt). MobX har fors&#229;vidt mindre overhead enn Redux<\/p><p>&#160;<\/p><p>ContextAPI er facebook sin egen state manager og som et resultat f&#248;rer til tiln&#230;rmet lik null overhead n&#229;r implementert. ContextAPI er satt opp lignende til Redux, med context og providers, men har noen forskjeller i at alle kan se state, men ikke n&#248;dvendigvis skrive til state. Den har &#34;one source of truth&#34;, den ung&#229;r &#34;prop drilling&#34; og den har global tilgang til denne sentrale kilden. En ulempe med ContextAPI er at den f&#248;rer til rerender av hele siden n&#229;r data blir oppdatert. Dermed er den ikke en 100% &#34;erstatning&#34; av state-mangers som redux/mobx, men kan suppleres til &#229; ha annen data som ikke trengs &#229; rerendres hele tiden, som f.eks. Theme.<\/p><p>&#160;<\/p><p>Redux: Mye overhead+boilerplate,en store, immutable, tar tid &#229; sette opp, skalerer veldig bra. B&#248;r brukes i store prosjekter<\/p><p>&#160;<\/p><p>MobX: Skalerer ikke like bra, flere stores, mutable state, tar lite tid &#229; sette opp, lite boilerplate, b&#248;r brukes i mindre prosjekter<\/p><p>&#160;<\/p><p>ContextAPI: Ingen overhead, one source of truth, alle kan lese, men ikke alle kan skrive. B&#248;r brukes p&#229; data som trengs bare &#229; oppdateres en gang per session, da en endring i Context f&#248;rer til en rerender av hele siden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2653,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil har mange like aspekter som andre state management tools (f.eks redux), men med fokus p&#229; &#229; angripe problemene som redux har samtidig som den opprettholder fordelene til redux. Det ser ogs&#229; ut som den vil fylle hullet som eksisterer mellom redux og contextAPI.<\/p><p>&#160;<\/p><p>&#160;Et problem med redux, er at for &#229; kunne hente ut noe informasjon ut ifra store s&#229; m&#229; en hente ut all informasjonen samtidig. Recoil mitigerer dette ved &#229; implementere selectors, hvor en kan eksplisitt si hva en vil hente ut ifra atoms for &#229; forhindre &#34;overfetching&#34; av un&#248;dvendig data.<\/p><p>&#160;<\/p><p>I tillegg, s&#229; ser det ut som recoil er skrevet for folk som er kjent med &#34;vanilla&#34; React, da syntaksen ligner veldig p&#229; react state management. (Refererer spesielt til setState() og setting av state i useRecoilState() ). I tillegg, s&#229; ser det ut som recoil skal mitigere en av problemene til contextAPi, hvor en m&#229; rerender hele siden n&#229;r en endrer en state. Recoil ser ut som de l&#248;ser det ved &#229; s&#248;rge for at de eneste komponentene som m&#229; endre seg, er de som er lytter p&#229; informasjonen til den ene store&#39;en.&#160;I den sansen, s&#229; ligner Recoil litt p&#229; mobx ogs&#229; mtp at en har flere atoms (&#34;stores&#34;) som inneholder informasjon om tilstanden. Dette bryter litt med redux og dets &#34;single source of truth&#34;, og f&#248;rer til at en m&#229; s&#248;rge for at alle atoms (og dets lyttere)&#160;er 100% disjunkte, ellers kan dette f&#248;re til uforventede konsekvenser og gj&#248;re debugging vanskeligere.<\/p><p>&#160;<\/p><p>Dette betyr at i Recoil sitt funksjonsomr&#229;de, s&#229; b&#248;r en s&#248;rge for &#229; bryte ned atoms sine datafelt til sine minste deler, slik at komponentene trenger s&#229; f&#229; deler av et atom som mulig (definert ved en selector), slik at n&#229;r andre deler av atoms blir oppdatert, s&#229; trenger en ikke &#229; rerender andre komponenter. Dette ligger da fors&#229;vidt i navnet &#34;atom&#34;. En annen fordel er at en ikke trenger mye boilerplate-kode. Dette er et stort problem med redux, da en m&#229; sette opp types, stores, reducers osv.<\/p><p>&#160;<\/p><p>Slik det ser ut s&#229; er det et global state management tool som ligner p&#229; en blanding av redux/mobx med syntaksen til vanilla react og med fokus p&#229; &#229; utbedre problemene til redux. Dette involverer en litt annen tankegang (dvs &#229; bryte ned data i sine atomiske deler), og bruke selectors for &#229; hente ut eksplisitt det en trenger. Dette forhindrer rerenders av un&#248;dvendige komponenter, og s&#248;rger for at en slipper &#229; hente ut hele storen. Dette f&#248;rer ogs&#229; til at en ikke trenger &#229; forholde seg til b&#229;de local state og global state, men heller at en kan ha en global state, som en bruker en selector til &#229; forholde seg til. Dette f&#248;rer til at en ikke trenger &#229; sende ting ned via props fra parent til child, men heller at alle komponenter kan v&#230;re &#34;uavhengige&#34; mtp state i forhold til hverandre. Den har ogs&#229; immutable state, men kan endres ved &#229; sende setState, som ikke trengs &#229; defineres av types men heller at en m&#229; lage en ny valid state og sende den opp til atom igjen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1221,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Forskjellen med RESTAPI og Graphql er m&#229;ten de transmitterer dataen p&#229;. RestAPI sender en HTTP-request til et endepunkt, som basert p&#229; det endepunktet (og type http-metoder) vil sende tilbake et sett med data. I motsetning til dette, s&#229; vil Graphql sende alle requests til samme endepunkt, men vil ha et sett med felter som beskriver hva requesten vil ha, fremfor hvilket endepunkt den vil koble til. Dette f&#248;rer til at frontend ikke trenger &#229; ta stilling til endepunkter og metode av request, men mer hvilke data den vil f&#229; tilbake igjen. RestAPI derimot m&#229; jobbe sammen med backenden for &#229; vite hvilke data den kommer til &#229; f&#229; tilbake, hvilken metode den m&#229; bruke og&#160;hvilke endepunkter den m&#229; koble til for &#229; f&#229; den dataen. Dersom endepunktet endrer seg, s&#229; m&#229; frontend fetch&#39;en endre seg ogs&#229;.&#160;<br /><br />En fordel i fav&#248;r av graphql er at dette forhindrer s&#229;kalt &#34;overfetching&#34;. Dette er da at frontenden ikke f&#229;r un&#248;dvendig data som den m&#229; umiddelbart kaste. I tillegg, s&#229; kan graphql ogs&#229; forhindre underfetching, dvs at en m&#229; utf&#248;re to requests for &#229; hente ut dataen fremfor en. Dette er da fordi graphql ser p&#229; databasen som en tilkoblet sett med tabeller, fremfor individuelle tabeller som en m&#229; pull&#39;e.<\/p><p>&#160;<\/p><p>Til tross for at RestAPI har disse problemene i teorien, s&#229; har disse blitt mitigert i praksis. Dette er fordi RESTApi har s&#229; bra st&#248;tte i milj&#248;et, at det har blitt utbedret l&#248;sninger for &#229; forhindre dette. Ett eksempel er mongoDB&#39;s $Project metode, som spesifiserer hvilke felt som skal sendes tilbake i en tabell (eller collection som MongoDB kaller det). Dette er da for &#229; forhindre overfetching. Underfetching kan mitigeres ved at alt er koblet til samme unike identifier, slik at en m&#229; ikke finne data igjennom en annen tabell. En stor fordel som graphql fortsatt har er at den ikke trenger &#229; forholde seg til endepunkter, noe som restapi m&#229; gj&#248;re.<\/p><p>&#160;<\/p><p>En ulempe med GraphQL er at den ofte returnerer 200 OK etter hver query. Dette gj&#248;r feilh&#229;ndtering litt vanskeligere, da til tross for at backenden potensielt kan feile, s&#229; m&#229; en utf&#248;re feilh&#229;ndtering basert p&#229; meldingen en f&#229;r tilbake og ikke n&#248;dvendigvis statuskoden til GraphQL-meldingen. Dette er fordi GraphQL alltid vil sende en post-melding. I tillegg, s&#229; st&#248;tter restAPI caching, da endepunktene vil alltid sende tilbake samme data igjen og igjen i motsetning til graphql hvor en (i teorien) m&#229; utf&#248;re et nytt databases&#248;k hver gang.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537079,"ext_inspera_userAssessmentSetupId":7139941,"ext_inspera_userAssessmentId":4841529,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Barstad Caroline (10015)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303772,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2614,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React h&#229;ndteres dataflyt enkelt ved hjelp av props og state. I klassekomponenter har men en super-konstrukt&#248;r som tar inn props som er immutable -&#62; f&#248;rer til at man ogs&#229; bruker en state som kan endres (endres ikke direkte, men overskriver tidligere state). Etter innf&#248;ring av react hooks bruker man oftere funksjonelle komponenter som bruker useState og useEffect som henholdsvis endrer staten til den spesifikke variabelen i komponenten med useState, og kan re-rendere siden med useEffect dersom noe i state er endret.<\/p><p>&#160;<\/p><p>Stateh&#229;ndtering blir ofte brukt i React-applikasjoner, fordi uten noe som h&#229;ndtererer det kan det bli problemer med inkonsistens (f&#229;r kanskje ikke oppdatert alle variabler som skal oppdateres) og redundans (noen variabler lagres feks flere ganger i ulike komponenter). Da fungererer dataflyten ved at man sender ting ned i komponenthierarkiet -&#62; parent-komponenten m&#229; sende en callback-funksjon dersom child-komponenten skal endre p&#229; noe fordi den ikke kan sende ting oppover, noe som kan bli tungvint i lengden.<\/p><p>&#160;<\/p><p>I React kan disse problemene l&#248;ses p&#229; ulike m&#229;ter. En mulighet, som er mer og mer brukt etter innf&#248;ringen av React Hooks er Context APIet. Med Context f&#229;r man tilgang til props uten &#229; m&#229;tte sende det gjennom alle children-komponentene manuelt. Context vil re-rendere etter hver oppdatering, og det er egnet for globale states som brukes av mange komponenter og&#160;ikke oppdateres s&#229; ofte - det kan v&#230;re feks tema p&#229; nettsiden, brukerkontoer eller andre innstillinger. Context er ogs&#229; veldig greit fordi det ikke har noen tredjeparts-avhengigheter i react.<\/p><p>&#160;<\/p><p>Redux er et annet alternativ for stateh&#229;ndtering. P&#229; lik linje som Context, har Redux en global state som gj&#248;r at flere komponenter kan bruke staten uten &#229; m&#229;tte g&#229; gjennom komponenttreet. Staten lagres i en store som er innkapslet i form av at den kun er read-only, hvor man bruker dispatch-actions og reducers&#160;for &#229; endre storen. I reducerne tar man inn en type handling (feks SET_COUNTRIES) og en payload (countries) som sier at vi oppdaterer countries i storen til &#229; ha verdiene som sendes inn som payload. Man oppdaterer det ikke direkte, men overskriver det som allerede ligger der. Redux passer bra til state av ting som oppdateres ofte<\/p><p>&#160;<\/p><p>MobX er et tredje alternativ for stateh&#229;ndtering. Det inneholder ogs&#229; h&#229;ndtering av globale states. Det er veldig enkelt og skalerer bra, i tillegg til &#229; v&#230;re fleksibelt. I motsetning til redux inneholder det veldig lite boilerplate-kode og p&#229;virker i mindre grad koden din.&#160;Alle endringer vil bli tracket i kj&#248;retid og&#160;komponentene&#160;kj&#248;rer n&#229;r det er behov for det. Det f&#248;rer til at det ikke er mulig &#229; lage en inkosistent state fordi alle handlinger som endrer staten automatisk skjer og blir prosessert.<\/p><p>&#160;<\/p><p>Kilder til MobX:&#160;https://mobx.js.org/getting-started<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2160,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for &#229; h&#229;ndtere state. Det bruker atoms som lagres og kan brukes av ethvert komponent, hvor komponenten&#160;da &#34;subscriber&#34; p&#229; atomet slik at dersom det skjer endringer vil den rerendere automatisk. P&#229; en m&#229;te kan man sammenligne det med Context ved bruke av hooks hvor man setter initiell state (useState vs useRecoilState), og ting renderes automatisk (useEffect vs automatisk rerender av komponenter som er subscribed).&#160;<\/p><p>&#160;<\/p><p>I tillegg har biblioteket selectors som er en &#34;transformasjon&#34; av den originalle staten, alts&#229;&#160;rene&#160;funksjoner som tar inn staten og gj&#248;r en endring p&#229; den. Feks kan man ha atom som inneholder en tekst, mens man har en selector som er en funksjon som beregner lengden av tekststrengen.&#160;<\/p><p>&#160;<\/p><p>Man kan ogs&#229; sammenligne Recoil med Redux. I Redux lager man en store for &#229; lagre global state, mens man i Recoil ikke trenger en egen store fordi alt som lagres i atoms kan brukes andre steder. Redux bruker actions via dispatch-metoden for &#229; endre p&#229; ting i storen, mens Recoil bruker selectors. Recoil har ogs&#229; st&#248;tte for asynkron lagring, men det har ikke Redux.<\/p><p>&#160;<\/p><p>Under utvikling kan man m&#229;tte endre mye struktur i prosjektet for &#229; innf&#248;re Redux&#160;hvis man ikke har brukt det fra starten av og har st&#248;rre oppstartskostnad.&#160;Recoil virker mye enklere &#229; implementere ettersom man kan lage atoms som kan brukes i alle komponenter, og ting blir oppdatert automatisk uten &#229; m&#229;tte legge til dispatch-funksjoner i hver komponent. Siden man unng&#229;r en stor store i recoil, kan det v&#230;re hensiktsmessig &#229; bruke til prosjekter som er store og komplekse hvor man endrer mange komponenter som m&#229; rendere p&#229; nytt basert p&#229; state. I tillegg er det mindre kode som m&#229; skrives ved bruk av recoil.&#160;<\/p><p>&#160;<\/p><p>En ulempe med bruk av recoil som stateh&#229;ndtering i et prosjekt er at det er i eksperimenteringsfasen, og det finnes ikke like mye dokumentasjon p&#229; det som p&#229; redux. P&#229; store prosjekter, hvor det kanskje egentlig er best &#229; bruke recoil i teorien, er det fortsatt en st&#248;rre &#34;trygghet&#34; med &#229; bruke redux siden det er s&#229;pass godt integrert med mye dokumentasjon allerede.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2346,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er et API som har v&#230;rt i bruk lenge og det finnes derfor mye dokumentasjon om. Det sendes HTTP-requests hvor man feks kan bruke GET-metoden for &#229; hente fra databasen eller POST-metoden for &#229; poste til databasen (denne henter ogs&#229; fra databasen samtidig) n&#229;r man sender kall til APIet. Disse kallene er definert ved endepunktet (URI) du skal hente fra og hvilken metode du skal bruke. I REST kan man ha flere definerte endepunkter, hvor ressursene du skal ha er definert i URI-en (feks hvilke params man henter inn eller hvilke queries). Man f&#229;r returnert et helt objekt ved et kall, som kan f&#248;re til overfetching. Man m&#229; ogs&#229; fetche til forskjellige endepunkter hvis du vil ha informasjon om to ulike objekter.<\/p><p>&#160;<\/p><p>GraphQL p&#229; sin side er veldig enkelt &#229; bruke og konfigurere, men det kan v&#230;re vanskeligere &#229; faktiske implementere fra bunn. Det er et query-spr&#229;k, som vil si at man kan skreddersy hva man skal fetche fra APIet. I motsetning til REST, fetcher man fra ett endepunkt i REST-apiet, men man kan hente flere objekter i ett kall. Det gj&#248;r at man ikke overfetcher, som begrenser hvor mye prosessering som kreves for &#229; fetche. Man underfetcher heller ikke fordi man kan hente all data man trenger med ett kall.<\/p><p>&#160;<\/p><p>REST har som sagt v&#230;rt i bruk lenge, men det finnes ikke noe rammeverk eller lignende for &#229; bruke det og det kan v&#230;re mye &#229; sette seg inn i. GraphQL er enkelt &#229; sette seg inn i og trenger ikke noe ekstra dokumentasjon for &#229; bruke.&#160;REST skalerer veldig bra i motsetning til GraphQL som ikke gj&#248;r det fordi man m&#229; hardkode mye queries. I tillegg har REST en h&#248;yere ytelse enn GraphQL har ettersom GraphQL ikke har implisitt caching i HTTP-laget, mens REST cacher p&#229; klienten slik at fetching skjer mer effektivt. Det er vanskeligere &#229; v&#230;re konsekvent med hvordan REST API skal brukes/lages, men med GraphQL er det mer definert hva APIet gj&#248;re og det er derfor lettere &#229; h&#229;ndtere. REST brukes gjerne med Express/Node, mens GraphQL bruker ofte Apollo/Neo4j i backend.<\/p><p>&#160;<\/p><p>Kilder:&#160;https://goodapi.co/blog/rest-vs-graphql<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533145,"ext_inspera_userAssessmentSetupId":7139948,"ext_inspera_userAssessmentId":4841152,"dateLastModified":"2020-12-01T10:01:23Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:23Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Smestad Carl (10163)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330864,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1630,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React s&#229; er tilstand (state) interne variabler for komponenten. Ved bruk av en klassebasert komponent kan man oppdatere tilstanden ved hjelp av setState(). Hvis man har en funksjonell komponent har man tilgang til hooks og kan da anvende useState(). Her kan man da f.eks ha en eller flere useStates til &#229; definere et st&#248;rre objekt (n&#248;sted ogs&#229; ved behov)&#160;eller ha flere sm&#229;. Eksempelvis under kan man se muligheten til &#229; enten definere state som et personsobjekt, eller splitte ut informasjonen i flere:<\/p><p><br />const [person, setPerson] = useState({firstName: &#34;ola&#34;, lastName: &#34;nordmann&#34;, age: 22})<\/p><p>const [firstName, setFirstName] = useState(&#34;ola&#34;)<\/p><p>const [lastName, setLastName] = useState(&#34;nordmann&#34;)<\/p><p>const [age, setAge] = useState(22)<br /><br />State og dataflyt kommer gjerne h&#229;nd i h&#229;nd gjennom at state ikke&#160;trenger og settes og holdes internt i komponenten som bruker den, men kan f.eks. settes i forelder-komponenten ogs&#229; sender man n&#248;dvendig state ned gjennom props. Komponenten har ogs&#229; mulighet til &#229; oppdatere staten til forelder-komponenten ved at man sender med en callback-funksjon for &#229; oppdatere state. Et godt eksempel p&#229; denne flyten kan implementeres av en modal. Her holder forelder-komponenten informasjon om modalen skal vises eller ikke, mens modalen vil andvende callback-funksjonen til selv &#229; ha mulighet til &#229; skjule seg&#160;ved et brukertrykk.<br /><br />Hvis man &#248;nsker like komponenter, men med visse ulike interne variabler kan man ta i bruk props (properties). Dette er verdier som gies til komponenten da den opprettes. Disse er immutable og kan da ikke endres av barnet som mottar prop&#39;en.<br />&#160;<\/p><p>State er et veldig sentralt tema i React, s&#229; det er en rekke andre m&#229;ter &#229; kontrollere og forenkle prossessen med state. React har innebygd muligheten til &#229; sende data gjennom hvor som helst i komponent-treet uten &#229; m&#229;tte sende props manuelt gjennom hvert barn. Dette gj&#248;res med Context. I tillegg kan man anvende et globalt state management library slik som Redux som er et mer omfattende enn context. Tanken her er at man skal ha en &#34;single source of truth&#34; for &#229; forsikre seg at tilstanden er slik man forventer. For b&#229;de Redux og Context vil alle komponenter som har subscribet til informasjon om en viss state bli rerenderet n&#229;r den informasjonen oppdateres.<br /><br />&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2457,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et rammeverk for state management. P&#229; listen over l&#230;ringsm&#229;l har vi &#34;Kunnskap og ferdigheter i state management (Context, Redux, MobX etc)&#34;, s&#229; jeg kommer til &#229; sammenlikne det med Context og Redux.<\/p><p>&#160;<\/p><p>M&#229;ten Recoil har l&#248;st state managementet p&#229; er ved at man kan opprette delt tilstand (atoms) som komponentene kan subscribe til gjennom selectors. Disse selectorene kan endre p&#229; tilstanden enten synkront eller asynkront.&#160;I likhet med b&#229;de Context og Redux s&#229; wrapper man koden et sted i treet der man &#248;nsker at barna skal ha tilgang til den delte tilstanden med en definert komponent av rammeverket (RecoilRoot for recoil og Provider for Redux/Context).&#160;<br /><br />Recoil har en rekke forbedringer&#160;sammenliknet med Context. Gjennom Context n&#229;r tilstanden ble endret, hvis man da har satt Provideren rundt f.eks. App-komponenten kan dette f&#248;re til at hele komponent-treet blir re-rendret. I tillegg kan Context bare lagre en enkelt verdi, og ikke et uendelig set med verdier der hver av dem har egne consumers. Dette har recoil l&#248;st ved &#229; anvende en &#34;directed graph orthogonal&#34; som er festet til React-treet. I praksis betyr dette at vi f&#229;r fordelene som Redux har med &#229; kunne subscribe til mindre deler av den globale staten og mulighet til &#229; splitte opp kode.&#160;<br /><br />Redux l&#248;ser samme problem, men p&#229; en annen m&#229;te. Der har man en global store med reducer(s). hver reducer har sin egen initial-state, actions og types. I utgangspunktet er redux actions synkront slik at hvis man skal gj&#248;re asynkrone kall slik som api-kall, s&#229; trenger man middleware slik som thunk eller saga. Dette er l&#248;st fra f&#248;r av med Recoil. Dermed ser man at recoil har fikset litt p&#229; redux ogs&#229;, og det&#160;med mye mindre boilerplate kode.<\/p><p>&#160;<\/p><p>Under utvikling kan jeg se styrken av recoil da den b&#229;de har sterk funksjonalitet og en pen syntax. Den fungerer meget likt som useState-hooken der man sender med det globale state-objektet (atom) istedenfor initialValue. Det krever lite ekstra energi &#229; ta i bruk dette rammeverket sammenliknet med Context og i hvert fall Redux. Selv om Recoil har en Dev Tool, synes jeg ikke at den er like nyttig og bra som den til Redux.<\/p><p><br />Kilde:&#160;https://recoiljs.org/docs/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2827,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST (Representational state transfer) er en akitektur stil som definerer visse begrensninger for &#229; lage web services. Ved bruk av HTTP s&#229; har man tilgang til GET, PUT, POST, DELETE, HEAD, PATCH, CONNECT, OPTIONS og TRACE, der man b&#229;de kan bruke browserens caching og definere URI til &#229; dientifisere ressursene. GraphQL har de samme begrensningene som REST, men organiserer all dataen som en graph der nodene er definert av et schema, mens kantene er forholdet mellom nodene.<br /><br />I praksis s&#229; er alle GraphQL-kall post-requester og vil alltid returnere 200OK hvis forsp&#248;rselen g&#229;r igjennom. For REST s&#229; f&#229;r man diverse feilkoder som hjelper utvikleren/brukeren &#229; kode hva som gikk galt. Dermed m&#229; utvikleren av GraphQL-apiet selv legge p&#229; evt feilkoder og error-meldinger for &#229; h&#229;ndtere dette.<\/p><p>&#160;<\/p><p>N&#229;r man henter data fra et API-endepunkt med REST s&#229; f&#229;r man all informasjonen p&#229; det endepunktet, mens med GraphQL m&#229; man eksplisitt definere hva man vil ha tilbake. Dermed slipper man over/under-fetching av data med GraphQL. Ulempen med dette er om man &#248;nsker alt p&#229; api-endepunktet med alle postene, s&#229; m&#229; man i GraphQL manuelt be om&#160;informasjonen i queryen da det ikke finnes en m&#229;te &#229; hente alt. For REST er det veldig vanlig &#229; definere sv&#230;rt mange API-endepunkter som gir ulike dataset i svaret, mens for GraphQL trenger man bare et endepunkt. GraphQL har et eget type-system som gir muligheten til &#229; generere dokumentasjon selv, fange skrive/type-feil og lage en interaktiv debugger.<\/p><p>&#160;<\/p><p>En stor fordel med GraphQL mtp at man kun f&#229;r det man ber om er at komponenter / subscribers av et endepunkt ikke n&#248;dvendigvis brekker ved oppdaterte felter for et schema. Eksempelvis om man har en blogg-post slik som dette (pseudokode):<br />&#160;<br />export class BlogPost {<\/p><p>&#160; &#160; id!: number,<br />&#160; &#160; title!: string,<br />&#160; &#160; body!: string,<\/p><p>&#160; &#160; // Legger p&#229; nytt felt,<\/p><p>&#160; &#160; author?: string<\/p><p>}<\/p><p>&#160;<\/p><p>Hvis man da har en komponent som looper over blogg-postens informasjon og rendrer dette til brukeren, s&#229; f&#229;r ikke komponenten informasjon om author f&#248;r man ber om det i queryen. For REST kunne man da brukket noe eller renderet noe uventet hvis man ikke tok h&#248;yde for at endepunktet kunne endre seg.<br /><br />Typisk vil man alltid motta JSON som svar av graphql (evt gzip), mens for REST s&#229; kan man motta vanlig tekst, JSON m.m.<br /><br />Hvis man henter et stort datasett, s&#229; er m&#229;ten man paginerer (henter deler av datasettet) l&#248;st ulikt ogs&#229;. I REST kan man f.eks hente de f&#248;rste 100 postene p&#229; endepunktet /posts/0:99. Hvis man da vil ha de neste hundre kan man gj&#248;re et nytt query til /posts/100:199. Med graphql har man ingen endepunkter p&#229; denne m&#229;ten, men man kan ta ibruk cursors. Hvis datasettet er for stort til &#229; v&#230;re med i responsen, har man tilgang til en cursor, som er peker til de neste X antall resultatene.&#160;<br />&#160;<\/p><p>Kilder:&#160;<br />https://en.wikipedia.org/wiki/Representational_state_transfer<br />Eksamen IT2810 Webutvikling, h&#248;sten 2018.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533254,"ext_inspera_userAssessmentSetupId":7139978,"ext_inspera_userAssessmentId":4841389,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Amundsen Andreas (10151)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443730,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1122,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Hooks (useState/useCallback)<\/strong><\/p><p><u>Hva<\/u><\/p><p>Vi kan bruke useState-hooken for &#229; holde state i et komponent i React. Her kan vi lagre alt fra objekter, strenger, tall og lister.<\/p><p>&#160;<\/p><p><u>Hvordan<\/u><\/p><p>En useState-hook kan sendes nedover i treet, for eksempel med bruk av <em>context <\/em>eller &#229; sende direkte som en prop til et komponent-barn. Barnet kan da lytte og oppdatere staten definert i foreldre-komponentet.<\/p><p>&#160;<\/p><p>Det er ogs&#229; verdt &#229; nevne useCallback. Denne lar oss oppdatere state et annet sted i komponentreet, for et gitt komponent.<\/p><p>&#160;<\/p><p><strong>Context<\/strong><\/p><p><u>Hva<\/u><\/p><p>Context lar oss dele funksjoner og variabler mellom komponenter i et tre, uten &#229; m&#229;tte sende disse nedover hvert eneste komponent.<\/p><p>&#160;<\/p><p><u>Hvordan<\/u><\/p><p>Man wrapper komponentene som vi &#248;nsker &#229; dele dataen mellom i en <em>provider, <\/em>og kan sende med variabler og funksjoner inn i den. Context konsumerer og oppdaterer state p&#229; &#248;verste niv&#229;, og oppdaterer hele treet n&#229;r en endring skjer.<\/p><p>&#160;<\/p><p><strong>Redux<\/strong><\/p><p><u>Hva<\/u><\/p><p>Redux er et state-management rammeverk, og brukes gjerne for &#229; h&#229;ndtere tilstand i st&#248;rre applikasjoner. Det krever en del oppsett, og kan v&#230;re krevende &#229; sette seg inn i, men er mer oversiktlig og skalerbart enn <em>context<\/em>.<\/p><p>&#160;<\/p><p><u>Hvordan<\/u><\/p><p>Redux er satt opp slik at man sender med en <em>action<\/em> til en <em>reducer<\/em>, og reduceren tar seg av logikk som for eksempel lagre til <em>store. <\/em><\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3599,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Hva er RecoilJS<\/strong><\/p><p>RecoilJS er et eksperimentellt state-management rammeverk for React.<\/p><p>&#160;<\/p><p>I Recoil s&#229; lagres state i atomer, som man b&#229;de kan oppdatere og lytte p&#229;. N&#229;r et atom blir oppdatert, blir ogs&#229; alle komponenter som lytter p&#229; det atomet re-rendret.<\/p><p>&#160;<\/p><p><u>Et eksempel<\/u><\/p><p><em>Vi definerer atomet<\/em><\/p><p>const usernameState = atom({<\/p><p>&#160; key: &#39;user&#39;<\/p><p>&#160; username: &#39;Ola Nordmann&#39;<\/p><p>})<\/p><p>&#160;<\/p><p><em>Vi subscriber til atomet<\/em><\/p><p>const [username, setUsername] = useRecoilState(usernameState)<\/p><p>&#160;<\/p><p><em>Vi oppdaterer atomet<\/em><\/p><p>setUsername(&#39;Webdev Webdevsen&#39;)<\/p><p>&#160;<\/p><p><em>Vi viser hva som er lagret i atomet<\/em><\/p><p>return (<\/p><p>&#160; {username}<\/p><p>)<\/p><p>&#160;<\/p><p>Det er ogs&#229; verdt &#229; nevne selectors. En selector er en funksjon som tar inn atoms og andre selectors som input, og blir kalt n&#229;r disse f&#229;r nye verdier. Fordelen med dette er at vi slipper &#229; h&#229;ndtere logikk tilknyttet staten i selve atomet og unng&#229;r redundans.<\/p><p>&#160;<\/p><p><strong>Sammenligning med tilsvarende rammeverk<\/strong><\/p><p>RecoilJS er alts&#229; en del av familien med <em>Context, Redux og MobX, <\/em>som alle pr&#248;ver &#229; l&#248;se samme problem, nemlig h&#229;ndtering av tilstand.<\/p><p>&#160;<\/p><p><u>Redux vs RecoilJS<\/u><\/p><p>- Sammenlignet med redux, s&#229; krever det langt mindre &#34;boilerplate&#34;-kode for &#229; kunne lagre state.<\/p><p>&#160;<\/p><p>- I motsetning til Redux, er det en langt mindre bratt l&#230;ringskurve, for &#229; kunne implementere state. Redux er komplekst og tidkrevende &#229; sette seg inn i, men som vi ser i eksempelet over er det langt enklere og forst&#229;elig.<\/p><p>&#160;<\/p><p>- I motsetning til redux som er synkront men kan bli asynkront med middleware, s&#229; er recoil asynkront by default. I prinsippet vil dette si at vi med redux i utgangspunktet ikke kan gj&#248;re API-kall by default, men det kan vi i RecoilJS<\/p><p>&#160;<\/p><p>- I motsetning til redux, er ikke RecoilJS like enkel &#229; teste<\/p><p>&#160;<\/p><p>- I motsetning til redux, s&#229; er RecoilJS mer &#34;react-ete&#34; enn redux, da det deler fellestrekk med hooks, slik som navnekonvensjoner<\/p><p>&#160;<\/p><p><u>Context vs RecoilJS<\/u><\/p><p>- I motsetning til context, s&#229; slipper vi &#229; re-rendre hele treet, n&#229;r noe oppdateres. Vi trenger kun &#229; oppdatere det komponentet som subsriber til atomet. Dette gj&#248;r applikasjonen mer effektiv.<\/p><p>&#160;<\/p><p>- I likehet med Context, s&#229; wrapper vi komponenttreet med henholdsvis <em>RecoilRoot <\/em>og <em>provider<\/em><\/p><p>&#160;<\/p><p>- Ulikt Context, s&#229; trenger vi kun &#229; wrappe komponenttreet med en tag. N&#229;r mange providere introduseres medf&#248;rer dette at det blir vanskelig &#229; vedlikeholde og videreutvikle koden.<\/p><p>&#160;<\/p><p><u>MobX vs RecoilJS<\/u><\/p><p>- I likhet med MobX, s&#229; oppdateres kun de komponentene som lytter p&#229; staten, n&#229;r den blir oppdatert.<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper med RecoilJS<\/strong><\/p><p><u>Fordeler<\/u><\/p><p>- Slipper un&#248;dvendig re-rendring<\/p><p>- Mindre boilerplate<\/p><p>- Deler mange likheter med React i seg selv (navnekonvensjoner mm) og enkelt &#229; sette seg inn i<\/p><p>- Enkelt &#229; implementere i en eksisterende l&#248;sning<\/p><p>&#160;<\/p><p><u>Ulemper<\/u><\/p><p>- RecoilJS er et relativt nytt og ikke minst eksperimentellt rammeverk, og inneholder h&#248;yst sannsynelig ulike bugs. Dersom en utvikler er kommet langt i utviklingsprosessen, og st&#248;ter p&#229; et problem f&#229; andre har kommet over, kan det v&#230;re tidkrevende &#229; feils&#248;ke dette<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p><p>https://mariosfakiolas.com/blog/recoiljs-is-meant-to-rock-your-react-world/<\/p><p>https://recoiljs.org/<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2440,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Overordnede forskjeller<\/strong><\/p><p>Helt overordnet er REST API en arkitektur, mens GraphQL er et query-language<\/p><p>&#160;<\/p><p><u>Design<\/u><\/p><p>For &#229; kunne designe et REST API m&#229; du ha tilstrekkelig med kunnskap om hva klienten trenger av data, og hvordan denne skal struktureres. For eksempel, hva skal returneres dersom klienten sp&#248;r om data tilh&#248;rende en bruker?<\/p><p>&#160;<\/p><p>Med GraphQL derimot kan man i prinsippet begynne &#229; lage API&#39;et fra dag &#233;n, ettersom klienten selv velger akkuratt hva slags data som skal hentes. N&#229;r man har skaffet tilstrekkelig med data om hvordan brukeren gj&#248;r sp&#248;rringer, s&#229; kan man optimalisere API&#39;et.<\/p><p>&#160;<\/p><p><u>Over/under fetching<\/u><\/p><p>GraphQL legger til rette for at vi kan vi kan be om akkuratt den dataen vi trenger, slik at vi verken henter for mye eller for lite data.<\/p><p>&#160;<\/p><p>Eksempelvis kan jeg skrive f&#248;lgende sp&#248;rring, og f&#229; returnert tittel og artist<\/p><p>&#160;<\/p><p>sang(id: &#34;123abc&#34;) {<\/p><p>&#160; tittel,<\/p><p>&#160; artist<\/p><p>}<\/p><p>&#160;<\/p><p>Alternativet med et REST API vil gjerne v&#230;re &#229; sende en request til song/123abc, men f&#229; returnert <u>all<\/u> informasjon lagret om den sangen. Dette kalles <em>over fetching. <\/em><\/p><p>&#160;<\/p><p><u>Versionering av API<\/u><\/p><p>Med et GraphQL s&#229; trenger du ikke &#229; versjonere API&#39;et, s&#229; lenge man kun legger til felt i skjemaet, og ikke endrer/fjerner gamle.<\/p><p>&#160;<\/p><p>Dersom klienten gjennom et REST API gj&#248;r et kall og forventer &#229; f&#229; en logo p&#229; /logo, men backend-utvikleren har endret hva som returneres p&#229; det endepunktet, vil det v&#230;re en <em>breaking change<\/em> for klienten. Backend utvikleren m&#229; da introdusere en ny versjon av API&#39;et, for &#229; sikre bakoverkompabilitet (for eksempel v2/logo_animert)<\/p><p>&#160;<\/p><p>En klient som snakker med et GraphQL API derimot kan selv velge om <em>logo_animert<\/em> skal hentes eller ikke.<\/p><p>&#160;<\/p><p><u>Caching<\/u><\/p><p>GraphQL st&#248;tter ikke caching by default, og dette er noe som m&#229; l&#248;ses med for eksempel Redis-server, som er en in-memory database.<\/p><p>&#160;<\/p><p>REST API derimot st&#248;tter caching by default.<\/p><p>&#160;<\/p><p><u>API analyse<\/u><\/p><p>Det er lettere &#229; analysere et REST API, sammenlignet med GraphQL, grunnet mangelen p&#229; verkt&#248;y for GraphQL. Dette skyldes nok at GraphQL er en relativt ny teknologi sammenlignet med REST, og situasjonen vil nok bli annerledes i fremtiden, n&#229;r flere og flere verkt&#248;y kommer p&#229; banen.<\/p><p>&#160;<\/p><p><strong>S&#230;regent for GraphQL<\/strong><\/p><p><u>Dokumentasjon<\/u><\/p><p>Out-of-the-box s&#229; dokumenterer GraphQL seg selv, n&#229;r man skriver sp&#248;rringer. Dette er sv&#230;rt hensiktsmessig n&#229;r andre utviklere skal bruke API&#39;et.<\/p><p>&#160;<\/p><p><u>Feilh&#229;ndtering<\/u><\/p><p>GraphQL er god p&#229; &#229; si i fra om feil i sp&#248;rringen, f&#248;r man sender den. Dersom du bruker TypeGraphQL med TypeORM og GraphQLCodeGenerator i prosjektet ditt, introduserer du TypeScript i API&#39;et, og ender opp med typesikre, ferdig genererte, sp&#248;rringer.<\/p><p>&#160;<\/p><p><u>Query sandbox<\/u><\/p><p>By default s&#229; f&#248;lger det med en sandbox i GraphQL, hvor man interaktivt kan skrive sp&#248;rringer og se hva som returneres. Dette gj&#248;r det enklere &#229; oppdage feil i utviklingsprosessen<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://goodapi.co/blog/rest-vs-graphql<\/p><p>https://www.youtube.com/watch?v=AYZOHt6kz6Y<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534108,"ext_inspera_userAssessmentSetupId":7140090,"ext_inspera_userAssessmentId":4841239,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Larsen Jane Wiik (10042)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":17588348,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":901,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React applikasjoner er sammensatt av et hierarki av komponenter. Hver av disse komponentene kan ha en egen state. For &#229; dele state mellom flere komponenter, kan disse sendes nedover hierarkiet gjennom react props eller oppover i hierarkiet med funksjoner. N&#229;r et komponents state endres, re-rendres kun dette komponentet.&#160;<\/p><p>Dersom det er mange av komponentene som er avhengige av den samme staten (f.eks tema, innloggings informasjon etc.) kan det fort bli rotete dersom en skal sende en state f.eks. fra &#248;verst i hierarkiet og til en komponent lenger nede, da staten ogs&#229; m&#229; sendes gjennom de komponentene som er p&#229; niv&#229;ene i mellom (dette f&#248;res ogs&#229; til at alle disse komponentene re-rendes n&#229;r tilstanden endrer seg, noe som ikke er bra for ytrelsen til applikasjonen).&#160;<\/p><p>For &#229; l&#248;se dette problemet har det senere blitt innf&#248;rt global state. Global state g&#229;r ut p&#229; at state som er felles for flere kompoenter kan lagres og h&#229;ndteres i en egen &#34;store&#34; som de komponentene som &#248;nsker kan hente ut ifra eller endre p&#229; staten. For &#229; gj&#248;re dette kan en f.eks. bruke reacts egen Context API eller andre eksterne state management systemer som Redux eller Mobx. N&#229;r en skal bruke hver av disse avhenger av den enkelte applikasjonen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":4003,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Redux, MobX, Context APi og n&#229; Recoil tilbyr alle en m&#229;te &#229; lage et sted for &#229; lagre delt data og for &#229; re-rendre kun de komponentene som endres. Redux og MobX er begge basert p&#229; Flux-arkitekturen, mens Context API ble introdusert som et enklere alternativ. Recoil fors&#248;ker &#229; l&#248;se de begrensningene Context API har, jeg kommer derfor til &#229; fokusere p&#229; forskjellen mellom React Context og Recoil og forklare kort om Redux og MobX p&#229; slutten.&#160;<\/p><p>&#160;<\/p><p>Recoil er et bibliotek som h&#229;nderer global state. React Context&#160;er enkel og kompatibel med react applikasjoner, men har noen ulemper som Recoil fors&#248;ker &#229; l&#248;se:&#160;<\/p><p>- Staten til et komponent kan kun deles ved &#229; sende den opp til en felles forelder (ancestor), dette inneb&#230;rer at mange kompoenter m&#229; re-rendres n&#229;r staten til en komponent endrer seg.&#160;<\/p><p>- React Context kan kun lagre &#233;n verdi, ikke et uendelig antall verdier som har forskjellige forbrukere.&#160;<\/p><p>- Problemene over gj&#248;r det vanskelig &#229; dele koden som er i toppen av komponent-treet og de som er i bunnen (som er avhengige av staten som finnes i toppen).&#160;<\/p><p>&#160;<\/p><p>Recoil lar oss definere delt tilstand ved &#229; deklarere en &#34;atom&#34;-funksjon, som er en enhet med tilstand (kan erstatte et komponents lokale tilstand/ v&#230;re delt mellom flere komponenter). Alle komponentene som bruker det samme atomet, deler tilstand. Det fine med Recoil er at for &#229; oppdatere og lese tilstanden, kan en bruke hooks (useRecoilState) som fungerer som reacts useState, bare at tilstanden n&#229; kan deles mellom flere komponenter. Dette gj&#248;r biblioteket lett &#229; sette seg inn i og bruke for en som er kjent med React fra f&#248;r. Noen komponenter bruker ikke staten direkte, men bruker den som utgangspunkt i videre beregninger av dataen. For &#229; gj&#248;re dette bruker Recoil selectors som henter verdien til atomer eller andre selectors. N&#229;r noen av disse verdiene oppdateres, vil ogs&#229; selectoren oppdateres.&#160;Selectorer holder selv oversikt over hvilke komponenter som trenger dem, og hva slags tilstand de er avhengig av. For &#229; lese fra en selector, kan hooken useRecoilValue() brukes og for &#229; sette staten kan useSetRecoilState(), useRecoilState() gj&#248;r begge deler.&#160;<\/p><p>Fordelen med Recoil er alts&#229; at den kan h&#229;ndtere b&#229;de synkrone og asynkrone funksjoner, state som er utledet (dervived)&#160;og code-splitting bra uten vanskelig syntaks og mye boilerplate kode i motsetning til f.eks Redux.&#160;<\/p><p>&#160;<\/p><p>Redux og MobX baserer seg begge p&#229; Flux-arkitekturen, men som skiller seg ut p&#229; viktige m&#229;ter. Redux initialiserer en store der en holder den globale tilstanden. Tilstanden&#160;i storen en immutable, og actions p&#229;kaller forandringer i store. Reducers bruker til &#229; oppdatere tilstanden. MobX gj&#248;r datastrukturer observerbare og komponenter kan gj&#248;res til observat&#248;rer. I motsetning til Redux kan MobX kan ha flere stores. For &#229; endre tilstanden, brukes actions, men kan ogs&#229; oppdateres uten &#229; trigge en action. Dette gj&#248;r det vanskelig &#229; holde styr p&#229; un&#248;dvendige tilstandsoppdateringer i komplekse applikasjoner. Det er mer boilerplate kode i Redux, og er generelt vanskeligere &#229; l&#230;re seg. Til gjengjeld er Redux mye brukt, godt dokumentert og gir deg mer kontroll over dataflyten. Hva du bruker i din applikasjon kommer derfor an p&#229; kompleksiteten til applikasjonen, samt hva du selv er komfortabel med og &#248;nsker &#229; bruke.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2279,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er begge m&#229;ter vi kan kommunisere med serveren p&#229;.<\/p><p>Hovedforskjellene mellom disse to er at n&#229;r vi bruker REST API m&#229; vi forholde oss til flere endepunkter mot databasen, mens i GraphQl forholder vi oss bare til ett og bruker egendefinerte skjemaer som beskriver funksjonaliteten som er tilgjengelige for klientene. Til &#229; skrive/ lese&#160;den dataen vi &#248;nsker brukes resolvers, queries og mutations, mens REST bruker URL-er som peker til endepunktene, og POST, PUT, GET, DELETE metoder som spesifiserer hva som skal gj&#248;res. Fordelen med GraphQL vs rest her er at vi kan hente n&#248;yaktig den dataen vi &#248;nsker ved &#229; spesifisere hvilke felter fra dataen i databasen vi &#248;nsker. Ved REST API er et problem at vi ofte f&#229;r mer data enn det vi trenger fordi vi henter ned all dataen fra det spesifiserte endepunktet. Dette er et problem kjent som &#34;overfetching&#34;. Fordelen med REST API er at det er litt enklere &#229; sette seg inn i enn GraphQL.&#160;<\/p><p>En annen forskjell mellom disse er caching. REST API kan benytte seg av en caching mekanisme som default st&#248;ttes av alle nettlesere fordi URLen er en globalt unik id, GraphQL m&#229; legge til id i feltet selv, eller bruke tredjepartsbiblioteker&#160;for &#229; f&#229; til det samme.&#160;GraphQL er kun et sp&#248;rrespr&#229;k, og for &#229; implementere det&#160;m&#229; vi dra inn tredjepartskomponenter som Apollo.&#160;<\/p><p>REST API er alts&#229; lettere &#229; komme i gang med enn GraphQL, en kan lage sitt eget API kun ved &#229; bruke REST og det er lett &#229; kun forholde seg til URL-er som endepunkter. GraphQL er mer komplekst, men gir oss til gjengjeld st&#248;rre muligheter for &#229; spesifisere hva slags data vi &#248;nsker, noe som kan v&#230;re en fordel ved store applikasjoner. Det er noe st&#248;rre startkostnader da det er flere ting &#229; sette seg inn i.&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534833,"ext_inspera_userAssessmentSetupId":7140038,"ext_inspera_userAssessmentId":4841317,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Myrvoll Benedicte Helen (10044)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331294,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3635,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React vil man som regel organisere komponentene sine i et hierarki, der data kan flyte fra toppen og ned, men ikke fra bunnen og opp. Dataflyten g&#229;r dermed kun en vei. M&#229;ten dataen sendes nedover er via&#160;s&#229;kalte &#34;props&#34;, som funger som argumenter som kan g&#229; fra en foreldrekomponent, ned til&#160;barnekomponentene.<\/p><p>&#160;<\/p><p>I React er tilstand noe som opprinnelig kun h&#229;ndteres innad i en komponent, og den er ikke tilgjengelig eller synlig for de andre komponentene. For &#229; gi tilgang til en komponent sin state vil den i utgangspunktet m&#229;tte sende den ned til barnekomponentene som props. Disse barnekomponentene vil likevel fremdeles ikke vite hvilken komponent som opprinnelig holder styr p&#229; tilstanden, men vil kunne utnytte seg av den og f&#229; oppdateringer p&#229; den.&#160;Ofte vil man ogs&#229; &#34;l&#248;fte&#34; den lokale tilstanden til en komponent opp til en foreldrekomponent, slik at barnekomponentene enklere kan synkroniseres.<br /><br />M&#229;ten man initialiserer&#160;tilstand i en komponent avhenger av hva slags komponent du har laget. Om du har en klassekomponent, vil state initialiseres ved &#229; bruke this.state i konstrukt&#248;ren, og deretter kan den endres ved &#229; bruke this.setState. Dette skrives p&#229; formen &#34;this.state = {name: &#34;&#34;}&#34;.&#160;I en funksjonell komponent vil man kunne bruke&#160;useState-hooken til &#229; initialisere tilstand. Dette skrives p&#229; formen &#34;[name, setName] = useState(&#34;&#34;)&#34;.<br /><br />Props kan g&#229; hele veien fra komponenten i&#160;toppen av hierarkiet, ned til den nederste komponenten om man &#248;nsker, men om det er data&#160;som trenger &#229; sendes gjennom flere komponenter hver gang, vil det ofte v&#230;re mer hensiktsmessig &#229; gj&#248;re disse&#160;globale. Dette kan man gj&#248;re via context apiet, eller via biblioteker som Redux og MobX. Her vil man kunne samle ulike data og states, og gi komponenter direkte aksess til disse uten at de m&#229; sendes gjennom hele hierarkiet. Du kan ogs&#229; gi komponenter aksess til funksjoner som oppdaterer dataen eller tilstanden.<br /><br />Redux og MobX sine biblioteker er spesielt verdifulle &#229; bruke n&#229;r mengden med globale states og data blir stor,&#160;uoversiktlig og kompleks. De gir deg muligheten til &#229; enkelt h&#229;ndtere alle de globale tilstandene i webappen din, og dele disse mellom komponentene dine p&#229; en oversiktlig m&#229;te.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>&#160;<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://redux.js.org/understanding/thinking-in-redux/motivation<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2161,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tilstandsh&#229;ndterings bibliotek som er laget spesifikt for React. I Recoil representeres tilstand som &#34;atomer&#34;, som komponenter implisitt kan abonnere p&#229; gjennom &#229; lese de. Om en komponent trenger &#229; b&#229;de lese og skrive til et&#160;atom kan man bruke useRecoilState, som ligner p&#229; bruken av useState-hooken. I Recoil har man ogs&#229; &#34;selectors&#34; som er funksjoner som kan ta i mot atomer eller andre selectors som argument, og basert p&#229; disse&#160;modifisere tilstanden eller annen data. Dette gj&#248;r at man kan bygge dynamisk data som har avhengigheter mot annen data. Eksempelvis kan man opprette et atom for tilstanden til filtrering p&#229; en todo-list,&#160;og lage en selector som tar inn b&#229;de denne tilstanden og tilstanden til selve listen, og modifiserer presentasjonen av listen basert endringer i disse tilstandene.<br /><br />En av de store forskjellene mellom spesielt Redux og Recoil er at Redux er veldig mye mer boilerplate, mens Recoil er rimelig enkelt &#229; bruke &#34;out of the box&#34;. I Redux vil du m&#229;tte sette opp en store, lage reducers og actions, og legge inn useSelector og useDispatch i komponentene som skal lese og skrive til tilstandene i store. Med Recoil vil du slippe &#229; lage en store, og kan begynne &#229; opprette atomer og selectors som komponenter kan f&#229; lesetilgang til direkte, og kan skrivetilgang til med hjelp av useRecoilState. Recoil vil nok for mange v&#230;re mer intuitivt ogs&#229;, om man er vant med hooks og &#34;Reactsk tankegang&#34;. Recoil er ogs&#229; en bedre l&#248;sning en context apiet n&#229;r det kommer til &#229; h&#229;ndtere st&#248;rre mengder states. Jeg kan ikke se noen umiddelbare ulemper ved biblioteket, men ettersom det er rimelig nytt i motsetning til Redux og MobX er det ikke like velbrukt og gjennomtestet i virkelige produksjonsmilj&#248;er, og kan derfor by p&#229; uante problemer.&#160;<br /><br />Kilder:<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://recoiljs.org/docs/basic-tutorial/selectors<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1366,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er to m&#229;ter &#229; sette opp web APIer p&#229;. REST API er det som har v&#230;rt tradisjonelt brukt&#160;over mange &#229;r, mens Graphql er relativt nytt.<br /><br />Med REST vil man f&#229; tilgang til og muligheten til &#229; manipulere dataen gjennom uniforme og tilstandsl&#248;se requests til endepunkter. Res kan enkelt caches. Operasjonene man bruker over HTTP er GET, POST, PUT og DELETE. REST er rimelig enkelt &#229; sette opp og bruke, men er lite fleksible og byr p&#229; visse problemer. En av de st&#248;rste problemene er overfetching, som oppst&#229;r n&#229;r man &#248;nsker &#229; hente en viss subdata fra et endepunkt, men uansett vil f&#229; hele dataobjektet som respons. Et eksempel p&#229; dette er n&#229;r man vil hente alderen p&#229; alle personene som er lagret, og sender en request til endepunktet /persons. Man vil ikke kunne f&#229; kun den delen av objektene med alder, men ogs&#229; f&#229; resten av personobjektet som kan inneholde navn, bosted, tlf.nr osv. Et annet problem er underfetching, som oppst&#229;r n&#229;r et endepunkt ikke har all dataen man trenger.<br /><br />Med GraphQL vil disse problemene l&#248;ses, da man kan opprette queries der man kan definere hvor mye eller lite data man &#248;nsker &#229; hente, og slipper unna &#229; f&#229; mer eller mindre enn man trenger. I graphQL utnytter man seg ogs&#229; av grafstruktur, som gir en sammenknytning mellom dataene man kan hente. Et eksempel her er at man har eiere og leiligheter som data, og kan sende et query for &#229; b&#229;de kun f&#229; informasjon om leiligheten, et query for &#229; f&#229; informasjon om leiligheten og den som eier leiligheten, og et query for &#229; f&#229; informasjon om leiligheten, den som eier den, og alle de andre leilighetene som denne personen eier. Slik f&#229;r du et nettverk av informasjon som du enkelt kan f&#229; tilgang til. Med graphQL kan du ogs&#229; definere typer p&#229; dataen du henter. Nedsiden er at graphQl krever mer oppsett, og kan v&#230;re mer komplisert. Det har heller ikke caching i HTTP laget, og krever mer for &#229; sammenkoble klient og tjener.<br /><br /><br />Kilder:<br /><br />https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://restfulapi.net/<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535780,"ext_inspera_userAssessmentSetupId":7140093,"ext_inspera_userAssessmentId":4842157,"dateLastModified":"2020-12-01T10:31:21Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:31:21Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gundersen Henrik (10230)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33683041,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2956,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For local state, state i en komponent, kan en bruke&#160;hooken useState:<\/p><p>&#160;<\/p><p>useState: const [count, setCount] = useState(0);<\/p><p>Returnerer et par:&#160;count variabelen som holder p&#229; state verdien, og og funksjonen setCount som oppdaterer verdien. Argumentet i useState setter initialverdien. Du kan bruke dette flere ganger innenfor en komponent for &#229; holde flere state verdier.&#160;<\/p><p>&#160;<\/p><p>I React-applikasjoner &#248;nsker man &#229; ha et fornuftig komponent-hierarki og&#160;at dataflyten kun g&#229;r &#233;n vei. Vi &#248;nsker gjerne at parent componenten oppdaterer child komponenten, f.eks. Chat oppdaterer ChatMessage. Dette gj&#248;res ved &#229; sende ned &#34;props&#34; til child komponenten. Disse er immutable og kan kun endres i parent komponenten.&#160;Om vi &#248;nsker &#229; sende dataflyten oppover, er det mulig sende callback funksjoner som props som gj&#248;r at child komponentene kan bruke disse funksjonene for &#229; sette state p&#229; parent komponenten.&#160;<\/p><p>&#160;<\/p><p>N&#229;r applikasjonene blir st&#248;rre og en &#248;nsker variabler/state som skal aksesseres p&#229; ulike niv&#229;er i komponent treet kan vi innf&#248;re global state management. P&#229; denne m&#229;ten unng&#229;r vi ogs&#229; prop drilling som skjer ved &#229; sende props fra parent til child gjennom andre child i hierarkiet. Dette skjer ved at vi flytter state ut av komponentene og har det som en egen enhet, og definerer mekanismer for &#229; endre p&#229; denne.&#160;<\/p><p>Det finnes ulike l&#248;sninger for global state management, som Redux, Mobx.&#160;<\/p><p>Redux definerer ulike actions, basert p&#229; hvilken type action vil en &#34;pure&#34; function (reducer) oppdatere applikasjons tilstanden gitt i en store.&#160;<\/p><p>I Mobx oppdateres ogs&#229; staten ved actions, men en trenger ikke reducers. N&#229;r data endres i staten trigges det automatisk en re-render av komponentene.&#160;<\/p><p>Med Redux&#160;bruker vi&#160;veldefinerte actions og reducers som gir god innsyn i hva som skjer, imens Mobx abstraherer dette mer og har fokus p&#229; enkel syntaks.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2379,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en implementasjon for global state management. Det er implementert som en rettet graf til React applikasjonstreet. State endringer (dataflyt) vil flyte fra &#34;atomer&#34; (r&#248;ttene til grafen) gjennom pure functions, &#34;selectors&#34;, og til komponentene.&#160;<\/p><p>&#160;<\/p><p>Disse atomene er egne enheter som inneholder state. Disse kan oppdateres og abonneres p&#229;. Komponeter som abonnerer p&#229; atomet re-renderer ved oppdatert verdi. Hvert atom er unikt, noe som gir enkel debugging.&#160;<\/p><p>&#160;<\/p><p>En selector er en pure function som brukes for &#229; kalkulere utledet data som er basert p&#229; state. Dette hindrer redundans i state p&#229; grunn av staten lagret i atomene er minimert, og alt annet blir kalkulert ut i fra denne.&#160;<\/p><p>&#160;<\/p><p>Recoil vs. Redux&#160;<\/p><p>Recoil lar en ha shared state gjennom atoms og dataflyt ved selectors uten &#229; m&#229;tte deale med &#229; lage stores og re-rendre hele App komponent treet med state oppdateringene. Dette gir mye mindre boilerplate kode med Recoil enn Redux.&#160;<\/p><p>&#160;<\/p><p>Recoil vs. Context API&#39;et<\/p><p>Recoil l&#248;ser to problemstillinger ved context API&#39;et:&#160;<\/p><ul>\t<li>Komponent staten kan kun bli delt ved &#229; pushe det opp i komponent hieratkiet til felles parent komponenter, som leder til en re-rendering.&#160;<\/li>\t<li>Context kan kun lagre en enkelt verdi, ikke et ubestem sett av verdier.&#160;<\/li><\/ul><p>&#160;<\/p><p>Fordel Recoil:&#160;<\/p><p>Recoil er utviklet av Facebook, som ogs&#229; vedlikeholder React s&#229; en kan se p&#229; dette som p&#229;litelig.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2605,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er et arkitektur konsept for nettverks-basert software. GraphQL er et sp&#248;rrespr&#229;k med et sett med verkt&#248;y som opererer over et enkelt endepunkt med HTTP.<\/p><p>&#160;<\/p><p>REST har ett eller flere endepunkter for fetching eller skriving av data ved hjelp av URI eller HTTP requests. I REST er det definert hvilke data som skal returneres,&#160;du vil alltid f&#229; tilbake et komplett datasett. S&#229; om du &#248;nsker &#229; hente ut spesifikke felter data fra et objekt vil du m&#229;tte hente alle feltene. Dette problemet er beskrevet som overfetching. GraphQL&#160;bruker kun ett endepunkt og bruker ulike sp&#248;rringer for &#229; hente ut akkurat de feltene med data en er interessert i, p&#229; den m&#229;ten sparer man mye prosessering. Disse sp&#248;rringen e m&#229; en definere p&#229; forh&#229;nd.&#160;<\/p><p>&#160;<\/p><p>Videre, med flere forskjellige endepunkter m&#229; en gjerne sende flere requests til REST API&#39;et for &#229; hente ut data som er relatert til hverandre. En fordel med flere endepunkter er enkelheten ved &#229; jobbe med det. Ved &#229; ha ett spesifikt endepunkt der en henter ut spesifikk data gj&#248;r det enkelt &#229; forst&#229; gangen i det og kunne manipulere dette. I Graphql kan dette v&#230;re en brattere l&#230;ringskurve men vise seg &#229; gi&#160;<\/p><p>&#160;<\/p><p>I REST kan en benytte seg av caching-mekanismen som st&#248;ttes i alle browsere, dette er det mangel p&#229; med GraphQL.&#160;<\/p><p>&#160;<\/p><p>En fordel med GraphQL er at det bruker et sterkt type system for &#229; definere funksjonaliteten til API&#39;et. Alle typene blir skrevet i et schema som fungerer som en retningslinje p&#229; hvordan klienten kan aksessere data fra serveren. P&#229; den m&#229;ten kan frontend og backend gj&#248;re uavhengig utvikling etter at schema er definert. Dette kan minske avstand mellom server og klient, men kan ogs&#229; v&#230;re en fordel n&#229;r det kommer til validering.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11536305,"ext_inspera_userAssessmentSetupId":7139987,"ext_inspera_userAssessmentId":4841203,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Meyer Julie Skutle (10129)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33722440,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3595,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt er bra for at applikasjoner skal kunne v&#230;re dynamiske. Vi trenger det fordi en teact-applikajson er bygd opp av komponenter, og hvis vi forandrer en komponent (feks adder et tall i en boks&#34; og et helt annet komponent skal ha tilgang til denne forandringen fordi den trenger det til feks &#229; forandre en tekst (&#34;du har 10kr i boksen&#34;). React s&#248;rger for denne dataflyten selv med state og props.<\/p><p>Den abstrakte strukturen i react-applikasjoner er trestruktur, med mor og barn-komponenter. Dette hjelper med &#229; sende tilstand (state/props) ned til barn. Man kan ogs&#229; sende state tilbake til forelder igjen i treet. Dette kan gj&#248;res med en callback-funksjon, som betyr at en barnekomponent har en funksjon som endrer staten til foreldrekomponent over.<\/p><p>Man kan gj&#248;re state-oppdateringer med helt enkle hooks. Dette er bra fordi det er enkelt og ryddig, men kan v&#230;re dumt fordi det er ikke s&#229; veldig dynamisk iforhold til komponent-treet som en helhet.&#160;<\/p><p>Context fungerer slik at du wrapper en &#34;branch&#34; av komponenter med en provider, ogs&#229; kan hvilket som helst barn provide contexten med en state. Dette kan gj&#248;re koden lettere &#229; debugge og lettere &#229; h&#229;ndere staten, fordi contexten er et eget objekt utenfro selve treet. (feks et barn har en besteforelder som har et annet barnebarn igjen, og det f&#248;rste barnebarnet p&#248;nsker &#229; oppdatere staten til det andre (&#34;kusine&#34;). Provideren oppdaterer staten, til contexten, og contexten sender og oppdaterer staten for alle de komponentene som er wrappet inn i &#34;branchen&#34;.<\/p><p>Props er ikke dynamisk, og endres ikke. Den defineres n&#229;r en komponent blir oprettet - og barna f&#229;r propsene sendt nedover hvis de ogs&#229; skal bruke den. React s&#248;rger for denne dataflyten selv.<\/p><p>State er dynamisk, og vi kan definere og oppdatere de. Dette kan vi gj&#248;lre via enten klasse eller funksjonelle komponenter. N&#229;r react innf&#248;rte hooks-calls ble det lettere &#229; lage klassekomponenter, og det kan derfor v&#230;re greie &#229; oppdatere state via dette. Det er lettere fordi det krever mindre kode og ryddigere kode. Hvis vi har usestate i en useeffect oppdateres den hver gang et eller annet i denne komponenten oppdateres, uavh. Om det feks er synlig eller ikke i applikasjonen.<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; h&#229;ndtere state p&#229; er via biblioteket redux. Man lager en store som storer staten, ogs&#229; kan komponenter v&#230;re tilhengere av denne storen. Det er gunstig fordi det er lettere &#229; se hvor feilen er, og er immutable (forandrer ikke staten direkte, men lager en kopi og forandrer kopien istedet). Videre lager man egne reducers . disse fungerer slik at du putter inn en action-type(string) i en kopmponent som skal forandre staten - action typen blir sendt til storen, som inneholder alle statene. alle statene har egne reducers (feks slices) og actiontypen blir sendt til alle recuserene. inni reducerene er det definert at hvis actiontypen er denne, gj&#248;r dette. alts&#229; hvis du sender inn en actiontype increment i en komponent, blir stringen sendt i alle recuserene, men bare de som bruker action-typen increment oppdaterer selve staten til den tilh&#248;rene staten sin. Man kan hente ut staten via en useselector-hookcall. Redux har til sin ulempe &#229; trenge mye koding. Redux er ryddig og strukturert fordi biblioteket h&#229;ndtere state et helt annet sted enn i react-treet, men har ulempen i at boilerplaten er stor.&#160;<\/p><p>&#160;<\/p><p>Mobx er et annet bibliotek for state-logikk. Mobx fungerer p&#229; samme m&#229;te som redux i form av at state-logikken skjer distinkt fra komponent-treet. Til kontrast fra redux har mobx mindre boilerplate, noe som er gunstig i store prosjekter. redux har ulempen av at du m&#229; skrive mye kode. feks i v&#229;rt prosjekt nummer tre, brukte vi redux for state-logikk til hele prosjektet, og en stor prosentandel av koden v&#229;rt ble brukt til redux-logikk. Dette kan v&#230;re positivt hvis det f&#248;rer til dynamisk og lett h&#229;ndterlig prosjekt, men siden mobx og recoil p&#229; den andre siden har mindre boilerplate, kan det v&#230;re lettere &#229; bruke disse i store prosjektet for eksempel.<\/p><p>En ulempe er at mobx-sin state er mutable, noe osm kan gj&#248;re det vansekligere &#229; finne hvor feilen har skjedd under debuggingen og testingen.&#160;&#160;<\/p><p>&#160;<\/p><p>Mobx og redux-strukturen gj&#248;r det lett for utviklere &#229; skrive godt fungerende tester for prosjektene sine, da som nevnt, staten er lagret og h&#229;ndtert andre steder enn i komponent-treet. dermed kan det debugges og bli testet enklere, da staten ikke er n&#248;stet opp og ned i treet.&#160;<\/p><p>&#160;<\/p><p>Mobx og redux kan du oppdatere og hente ut staten uansett hvor du er hen i komponent-treet.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2784,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som st&#248;tter opp mot state-h&#229;ndtering. Den lager et eget state-tre ortogonalt p&#229; react-treet. l&#248;vnodene p&#229; recoil-treet kalles atoms, og det er her staten ligger. Staten er alts&#229; delt inn i fler deler med states. Siden st&#229;r nitti grader er atomene i direkte kontakt med selve react-treet = lettere &#229; f&#229; informasjon om staten. Fler komponenter kan subscribe til et atom, disse komponentene deler da state. Atomsene er biter med state som blir oppdatert gjennom funksjoner kaldt selectors.<\/p><p>&#160;<\/p><p>Recoil&#160;er utvikliet av facebook,&#160;til kontrast fra redux og mobx som er utviklet av andre bedrifter. Dette er gunstig fordi strukturen og &#34;tankesettet&#34; er ment for &#229; v&#230;re s&#229; likt react som mulig, og dette kan gj&#248;re det lettere brukbart i applikasjonen sin (fordi samme tnakem&#229;te = mindre forvirring = ryddigere oppi hode = mer forst&#229;else av hvordan bruke de sammen = mest optimal l&#248;sning for applikasjonen). (immiterer hooks-callene som usestate osv.)<\/p><p>&#160;<\/p><p>Recoil er ogs&#229; gunstig i forhold til redux fordi den har ikke mye overfl&#248;dig koding (boilerplate for redux er ganske mye kode). Det eneste man trenger er atoms, diverse usehooks for subscribing og oppdatere de, og selectors, som f&#229;r inn atoms, og oppdateres ettersom atomsene oppdateres.&#160;<\/p><p>Context er en annen m&#229;te &#229; h&#229;ndtere state p&#229;, og er ogs&#229; utviklet av facebook. En ulempe med context er at en &#34;branch&#34; (forklaring p&#229; hva jeg mener med branch&#160;i spm.1) kan v&#230;re stor, og n&#229;r staten oppdateres, m&#229; hele &#34;branchen&#34; re-rendres, noe som ofte er overfl&#248;dig. Dessuten er context sin utstrekning ikke s&#229; stor, da man bare kan lagre en verdi via provideren. Dette gj&#248;r det ugunstig for feks den &#34;&#248;verste&#34; foreledren i context-branchen &#229; kunne splittes i fler deler, da denne liksom skal ha hovedansvaret&#160;for denne staten som blir delt av barna&#160;(siden bare en state og denne har hovedansvaret, for mye &#34;ansvar&#34;).<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":735,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er begge metoder for &#229; fetche og logikken for &#229; store data p&#229; en server. Begge sender HTTP-requests til serveren for &#229; hente &#248;nskelig data. En vesentlig hovedforskjell er at GraphQL sin arkitetktur er noder og kanter, der hver node er et objekt med felter (feks katt med navn, alder f&#248;dselsdato). REST APIet inneholder et sett med regler som objektene m&#229; f&#248;lge.<\/p><p>&#160;<\/p><p>En annen vesentlig forskjell er at n&#229;r du gj&#248;r en sp&#248;rring til en graphql-server, vil denne g&#229; gjennom alle nodene via kantene, starter p&#229; rot-noden, og n&#248;ste seg gjennom til den finner &#248;nskelig(e) objekt(er). P&#229; den m&#229;ten f&#229;r klienten akkurat de objektene de &#248;nsker, og de trenger bare &#229; gj&#248;re sp&#248;rringen en gang. REST p&#229; den andre siden, f&#229;r du hele datasettet inn n&#229;r du gj&#248;r sp&#248;rringen,&#160; for &#229; s&#229; loope-gjennom til du feks f&#229;r alle kattene som heter julenisse. Hvis det er fler objekter enn en liste med katter, og du trenger data i den andre, m&#229; du gj&#248;re to sp&#248;rringer, mens i graphql trenger du bare &#229; gj&#248;re en, s&#229; lenge de har samme feltene.&#160; Dette er kanskje den viktigste forskjellen, at graphql s&#248;rger for at det ikke blir over-fetching, eller under-fetching av data.<\/p><p>En annen forskjell er at n&#229;r en klient bruker rest-api, er det et sett med regler en m&#229; f&#248;lge for setting opp av prosjektet sitt. Dette samsvarer ikke alltid like godt med en klients behov for m&#229;ter &#229; hente og lagre data p&#229;, da dette stadig er i endring. REST er lite dynamisk. Hvis man bruker graphql p&#229; den andre siden, er det opp til bruker selv hvordan strukturen til dataene sine skal v&#230;re, ogs&#229; vil serveren returnere strukturen med data etter hva bruker har definert selv.<\/p><p>&#160;<\/p><p>En annen forskjell er at n&#229;r du lager din egen graphql, m&#229; du skrive egen kode for logikken p&#229; hvordan du vil treet ditt skal v&#230;re strukturert. Du lager egne schemaer, der opsettet her definerer hvordan strukturen p&#229; kantene og endepunktet er. Dette trenger du ikke via rest, der du til kontrast bare gj&#248;r sp&#248;rringer direkte. Mao. kan boilerplaten til graphl bli stor, mens hos rest er den ikke-eksisterende. Og som jeg har diskutert, er lite kode &#248;nskelig. P&#229; den andre siden er ikke alltid det slik hvis konsekvensene av dette er en mindre dynamisk l&#248;sning.&#160;<\/p><p>&#160;<\/p><p>Graphql er sv&#230;rt dynamisk og gj&#248;r det derfor lettere for frontend-utviklere og backend-utviklere &#229; samarbeide. blir strukutren p&#229; frontenden forandret, kan man ogs&#229; forandre backenden. Strukturen burde v&#230;re nogenlunde lik, og derfor har amn bedre fors&#229;telse av prosjektet som helhet.&#160;<\/p><p>en ulempe er at forntent-utvikelr m&#229; ha forst&#229;else av hvordan backenden fungerer for &#229; ta i bruk den optimalt, mens via rest trenger man bare &#229; vite hvordan man gj&#248;r api-sp&#248;rringene.&#160;<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://graphql.org/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11536310,"ext_inspera_userAssessmentSetupId":7139946,"ext_inspera_userAssessmentId":4841149,"dateLastModified":"2020-12-01T10:01:23Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:23Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nummedal Sigrun Asheim (10018)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330979,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2111,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er bygd opp av komponentar. Desse komponentane deleler p&#229; data som blir sendt mellom komponentar.Denne dataen blir i React kalla properties. Data kan deretter bli h&#229;ndtert internt i ein enkelt komponent ved &#229; bli oppdatert, dette blir kalla state management i React.&#160;<\/p><p>&#160;<\/p><p>Alt etter om ein brukar ein React klasse-komponent eller ein funksjonell komponent er det ulike metodar for &#229; definere states og properties.&#160;<\/p><p>&#160;<\/p><p>B&#229;de for klassekomponentar og funksjonelle komponentar vil ein komponent ta inn properties slik om ein tar inn eit argument i ein funksjon.<\/p><p>&#160;<\/p><p>I ein funksjonell komponent kan vi bruke noko som blir kalla ein state-hook. Denne blir definert ved &#229; lage ein variabel saman med ein tilh&#248;yrande funksjon som kan bli brukt i komponenten for &#229; oppdatere tilstanden. React &#34;rendrer&#34; tidvis komponentane slik at oppdatering av ein&#160;state vil bli reflekter i DOM. Om vi kombinerer ein state oppdatering med en useEffect s&#229; vil React automatisk rendre innholdet n&#229;r ein endring skjer.&#160;<\/p><p>&#160;<\/p><p>I ein klassekomponent vil states og properties bli definert i konstrukt&#248;ren men hovduprinsippa er noks&#229; like. Ein klassekomponent brukar ComponentDidMount istaden for useEffect.&#160;<\/p><p>&#160;<\/p><p>P&#229; denne m&#229;ten kan komponentar dele p&#229; data og data kan bli sendt nedover fr&#229; ein foreldrekomponent til ein barnekomponent. Denne metoden i seg sj&#248;lv dekkar derimot ikkje problemet om &#229; sende data fr&#229; ein barnekomponent til ein foreldrekomponent.&#160;<\/p><p>&#160;<\/p><p>Redux og Mobx og Context Apiet&#160;er verkt&#248;y som ofte blir brukt i React applikasjonar for &#229; forenkle og forbetre dataflyten og tilstandsh&#229;ndtering. Alle verkt&#248;ya h&#229;ndterar global state - alts&#229; at dei tilgjengeleggjer data for alle komponentar uten &#229; m&#229;tte passe properties nedover i React-treet. Contect APIet blir ofte brukt til enkel state h&#229;ndtering der staten ikkje blir oppdaert like ofte, som f.eks skifte tema p&#229; ei nettside. APIet blei heller ikkje utvikla for &#229; brukas til hyppige endringar. Til dette kan me bruke&#160;Redux og MobX og Recoil. Det vil blir forklart meir rundt desse verkt&#248;ya i neste sp&#248;rsm&#229;l.&#160;<\/p><p>&#160;<\/p><p>En stor fordel for oss ved &#229; bruke Redux i dette prosjektet var &#229; kunne fetche data ein gong, lagre i store, og bruke den i alle komponentane.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2758,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>B&#229;de Recoil, MobX og Redux er verk&#248;ty for &#229; h&#229;ndtere dataflyt og oppdatering av data. Ved bruk av desse vil data vera tilgjengeleg for alle komponentar.&#160;<\/p><p>&#160;<\/p><p>Recoil best&#229;r av atoms som er states. Desse kan bli &#34;abonert&#34; p&#229; av komponentar og dei kan bli oppdatert. Selectorar kan oppdatere atom, og selectorane kan og bli abonert p&#229;.&#160;N&#229;r eit atom blir oppdatert vil alle komponentar som abonnerar p&#229; atomet bli rendra p&#229; nytt. Recoil er basert p&#229; state-hooks og kan derfor berre brukast i funksjonelle komponentar. Etter eit atom er laga kan ein bruke det i ein komponent ved &#229; lage ein state hook. For &#229; hente atomet brukar ein setRecoilState istaden for useState og ein hentar ut selectoren ved &#229; bruke useRecoilValue.&#160;<\/p><p>&#160;<\/p><p>I dette prosjektet brukte vi Redux til dataflyt og global data. Eit lignande verktly er MobX.<\/p><p>Felles for verkt&#248;ya er at dei opprettar ein &#34;store&#34; eller fleire (for mobx) som lagrar data og vil vera tilgjengeleg for alle komponentar.&#160;<\/p><p>&#160;<\/p><p>Redux best&#229;r av actions og reducers for data. Dataen blir lagra som javascript-object i ein store. Ein reducer er ein funksjon som held p&#229; tilstanden til ein state og bestem kva action ein skal utf&#248;re p&#229; dataen basert p&#229; eit inputparameter. Reduceren kan samanlignast med Recoil sine atom. MobX derimot brukar ikkje reducers, men p&#229; litt same m&#229;te som Recoil vil dataen vera observerbar og ha lyttarar som sikrar same funksjon.<\/p><p>&#160;<\/p><p>Redux og MobX actions kan samanlignast med Recoil sin selector. Desse funksjoanne utf&#248;rer endringar p&#229; staten. MobX og Redux lagar all dataen i ein stores som alle komponentar har tilgang p&#229;. Det vil vera mogleg for ein barnekomponent &#229; oppdatere den, for deretter at en foreldrekomponent brukar den oppdaterte dataen, slik som var eit problem utan desse verkt&#248;ya. Recoil har ingen store men dataen i eit atom vil vera globalt.&#160;<\/p><p>&#160;<\/p><p>Recoil og MobX har ein fordel n&#229;r det kjem til l&#230;ringskurve og &#34;enkelheit&#34;. Det er lette verkt&#248;y &#229; sette seg inn i utan &#229; m&#229;tte skrive alt for mykje kode. Redux krev mykje kode for &#229; sette opp reducers og action, noko som kan vera tidkrevande og kanskje lite viktig i eit lite prosjekt. Recoil er lettast av alle tre.&#160;<\/p><p>Du trenger&#160; heller ikke lage en store ved bruk av recoil som letter brukker.&#160;<\/p><p>&#160;<\/p><p>Recoil vil kun kunne brukast i funksjonelle komponentar. Mobx fungerar best i klassekomponentar medan Redux fungerar p&#229; ein bra m&#229;te i begge typane.<\/p><p>N&#229;r det kjem til performance vil&#160;MobX vera det beste valget.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>&#160;<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p><p>&#160;<\/p><p>https://recoiljs.org/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2294,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>Nokon av dei st&#248;rste problema med REST er at du m&#229; definere mange endepunkter for &#229; f&#229; tak dataen&#160;i ein stor applikasjon. I tillegg kan ein ikkje lage spesielle queries, men alt so mer p&#229; endrepunktet blir returnert. Dette kan f&#248;re til at meir data enn du treng vil bli returnert. I tillegg m&#229; du gjere fleire API kall for &#229; f&#229; tak i den den passande dataen sidan du kanskje m&#229; bruke ulike&#160;endepunkt.&#160;Dette blir kalla under og overfetching. Under utvikling av endepunkt m&#229; utviklarane tenke p&#229; korleis front-enden er oppbygd, og endringar av front-enden vil f&#248;re til endrinar i endepunkt.<\/p><p>&#160;<\/p><p>I GraphQL er det ikkje ein URL tilh&#248;yrande ein funksjon. Ved eit kall f&#229;r serveren ein request og hentar ein GraphQL query. Den kallar deretter p&#229; ein resolver for kvart felt i Querien. Resultatet blir sendt tilbake som ein response til klienten. Det vil ogs&#229; berre bli brukt eit endepunkt.&#160;<\/p><p>Dette &#229;pnar for nesta sp&#248;rringar, der ein kan sp&#248;rre etter den eksakte dataen ein er ute etter. Data blir ikke over-eller underfetcha.&#160;Dette er den viktigaste skilnaden mellom REST og GraphQL. Dette gir GraphQL&#160;betre ytelse.<\/p><p>&#160;<\/p><p>I REST er cache innebygd i HTTP spesifikasjoner som APIer kan utnytte. Sidan GraphQL brukar berre eit endepunkt er det opp til utviklaren &#229; definere og sikre at cache blir implementert og fungerar p&#229; riktig m&#229;te.&#160;<\/p><p>&#160;<\/p><p>GraphQL har eit typesystem som kan bestemme om eit GraphQL query et gyldig eller ikkje. Dette let klientar og serverar effektiv informera utviklarar n&#229;r ein ugyldig foresp&#248;rsler er laga. Dette er ikkje mogleg p&#229; denne m&#229;ten ved bruk av REST.<\/p><p>&#160;<\/p><p>I eit lite prosjekt kan det argumenterast for &#229; bruke REST d&#229; GraphQL innf&#248;rer typar, queries og resolvar som kunne blitt gjort enklare med REST.&#160;<\/p><p>&#160;<\/p><p>Ein anna fordel med REST er at det st&#248;ttar&#160;ulik type data-struktur medan GraphQL berre&#160;kan brukast p&#229; JSON.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>&#160;<\/p><p>https://medium.com/@devathon_/graphql-vs-rest-in-2020-12817ea49e4e<\/p><p>https://www.moesif.com/blog/technical/graphql/REST-vs-GraphQL-APIs-the-good-the-bad-the-ugly/<\/p><p>https://graphql.org/learn/validation/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11537607,"ext_inspera_userAssessmentSetupId":7140037,"ext_inspera_userAssessmentId":4841215,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Holtet Magnus Lauritzen (10218)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34591462,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2068,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er vanlig &#229; skille mellom funksjonelle og klassebaserte komponenter i React.<\/p><p>&#160;<\/p><p>For &#229; h&#229;ndtere state i funksjonelle komponenter er hooks veien &#229; g&#229;.<\/p><p>Hooken useState returnerer en state-verdi samt en funksjon for &#229; oppdatere denne verdien.<\/p><p>&#160;<\/p><p>Eks:<\/p><p>const [role, setRole] = useState(&#34;student&#34;);<\/p><p>For &#229; oppdatere verdien til role ville man kalt setRole, feks&#160;<em>setRole(&#34;Professor&#34;)<\/em><\/p><p>&#160;<\/p><p>I klassebaserte React-komponenter setter man state i klassen selv. Dette foreg&#229;r gjerne i konstrukt&#248;ren.<\/p><p>Eks: <em>class MinKlasse extends React.Component { constructor(props) { super(props); this.state = {role: &#34;Student&#34;}; }<\/em><\/p><p>&#160;<\/p><p>For &#229; oppdatere i en klassebasert komponent bruker man gjerne this.setState(); Her er parameteret state-objektet med ny, oppdatert verdi.&#160;<\/p><p>Eks: <em>this.setState({role: &#34;Professor&#34;});<\/em><\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; ha global state, en state som flere komponenter har tilgang til. Her har React et innebygd system som heter Context. Context gj&#248;r det enkelt &#229; sende data rundt i treet, uten at dataen m&#229; sendes som props gjennom hvert enkelt ledd.&#160;Da wrapper man treet i en Context-provider, og s&#229; kan man i &#34;barna&#34; bruke en hook kalt useContext for &#229; f&#229; tak i dataen som ligger globalt. For st&#248;rre og mer avanserte prosjekter er det gjerne vanlig &#229; bruke Redux for &#229; h&#229;ndtere global context.<\/p><p>&#160;<\/p><p>Et viktig moment med state er at man aldri skal sette state direkte. Det er verdt &#229; nevne at det eneste stedet man kan modifisere state direkte, er i konstrukt&#248;ren til en klassebasert komponent. State skal settes gjennom callback-funksjoner.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>I React er det vanlig at dataflyten g&#229;r &#233;n vei, og det er ovenfra og ned. Man sender data nedover i hierarkiet ved hjelp av props. Dersom man &#248;nsker &#229; oppdatere state og eller data som ligger utenfor ens eget komponent, s&#229; sender man med en callbackfunksjon for &#229; h&#229;ndtere dette.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av Context er det vanlig &#229; gj&#248;re callbackfunksjoner som oppdaterer den globale staten tilgjengelig, dersom det er hensiktsmessig at child-components skal kunne manipulere denne. Redux gj&#248;r det p&#229; samme vis, dog med noe annen syntax.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#216;nsker kort &#229; nevne lifecycle-metodene ogs&#229;. For at React skal kunne kj&#248;re effektivt trengs det &#229; frigj&#248;re ressurser n&#229;r et komponent ikke lenger er i bruk.<\/p><p>&#160;<\/p><p>componentDidMount() kj&#248;res n&#229;r komponentet er rendret til DOM&#39;en. componentDidUpdate() kj&#248;res s&#229; fort en komponent er oppdatert, og componentWillUnmount n&#229;r et komponent er unmountet (fjernet fra DOM&#39;en). Disse tre samles i hooken useEffect().<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2227,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil.Js er et statemanagement-bibliotek for React.&#160;&#160;&#197; ikke vite hvor staten m&#229; eksistere og hvor den skal brukes gj&#248;r det vanskelig &#229; splitte opp koden i hensiktsmessige biter. Recoil.js har til hensikt &#229; l&#248;se dette.<\/p><p>&#160;<\/p><p>For &#229; l&#248;se det overnevnte problemet definerer Recoil.js rettede grafer som ligger inne i og utenp&#229; treet. Endringer i data flyter gjennom grafen i form av pure functions (ingen side effects) og inn i komponentene.<\/p><p>&#160;<\/p><p>Et av hovedmomentene med Recoil er bruken av Atoms og Subscribers.&#160;<\/p><p>Et atom er en form for state. Det er mulig &#229; oppdatere denne staten, og man kan subscribe til den. Dersom atomet oppdateres, s&#229; vil alle komponenter som subsriber til det, oppdateres de ogs&#229;. Et typisk problem med Context er at store deler av treet re-rendres dersom data endrer seg. Dette l&#248;ser da atoms. Videre tillater Context kun at man kan lagre &#233;n verdi, - det l&#248;ses ogs&#229; her.<\/p><p>&#160;<\/p><p>P&#229; samme m&#229;te som man i Context wrapper den delen av treet som skal ha tilgang til staten i en provider, s&#229; wrapper man i Recoil.js elementene i en RecoilRoot.&#160;<\/p><p>&#160;<\/p><p><u>Om man kjapt sammenligner Redux med Recoil er det noen ting som skiller seg ut:<\/u><\/p><p>F&#248;rst og fremst handler det om tiln&#230;rmingen til React. Redux er en sate-container for JavaScript apper generelt, - det er med andre ord ikke bare laget for React. Recoil p&#229; sin side er det, og det gj&#248;r tankesettet og utviklingsprosessen enklere. Det reduserer ogs&#229; mengde boilerplate.<\/p><p>&#160;<\/p><p>Videre har ikke Redux innebygget st&#248;tte for asynkron funksjonalitet. Dersom en bruker Redux kan dette l&#248;ses ved bruk av diverse middleware, eks: Thunk. Recoil.js p&#229; sin side har innebygget st&#248;tte for dette gjennom eksempelvis selector-hooksene.&#160;<\/p><p>&#160;<\/p><p>Basert p&#229; det lille jeg rakk &#229; lese, s&#229; virker det som at Recoil ligger over Context, og under Redux og MobX. Det har til hensikt &#229; l&#248;se problemer man ikke kan med Context, men det er ikke like kraftig som Redux og MobX. Da Recoile er forholdsvis nytt, mangler det en del verkt&#248;y, logikk og tankesett som allerede er godt etablert i de to sistnevnte rammeverkene. Et godt eksempel er f.eks debugging, - der er spesielt Redux sine verkt&#248;y helt r&#229;.<\/p><p>&#160;<\/p><p>Med andre ord:<\/p><p>Dersom man har et lite til medium stort prosjekt der splitting av state er det viktigste, og man f&#248;ler at Context ikke dekker behovet, s&#229; passer Recoil bra. Om det blir st&#248;rre og mer komplekst &#248;nsker man nok &#229; se i retning Redux.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>https://medium.com/swlh/a-quick-glance-at-recoil-d276c22c7efe<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2875,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>F&#248;rst og fremst er REST og GraphQL to vidt forskjellige ting&#160;Et REST API er et konsept for nettverksbasert programvare, mens GraphQL p&#229; den annen side er et querylanguage, schema og et verkt&#248;ysett. GraphQL gir&#160;en spesifikasjon og et sett med tilgjengelige verkt&#248;y som arbeider mot et spesifikt endepunkt over HTTP.&#160;<\/p><p>&#160;<\/p><p>I et REST-API ligger ressursene p&#229; ulike endepunkter, i motsetning til et GraphQL-API der alt aksesseres vi asamme endepunkt. Typisk kan man hente brukere i et REST API ved GET&#160;&#34;../api/v1/users&#34;. I et&#160;GraphQL-API m&#229;tte man skrevet en spesifikk sp&#248;rring for alle brukere.<\/p><p>&#160;<\/p><p>Et REST-API returnerer all dataen p&#229; endepunktet, alltid. Det er en veldig vanskelig oppgave &#229; designet et REST-API som alltid gir n&#248;yaktig den dataen brukeren trenger. Om man heller tenker p&#229; datasettet som en graf, derav&#160;GraphQL, blir det betraktelig enklere &#229; f&#229; tilgang p&#229; all n&#248;dvendig data til enhver tid, og da intet mer eller mindre.&#160;N&#229;r det gj&#248;res en sp&#248;rring mot et&#160;GraphQL-API, s&#229; spesifiserer man spesifikt hvilken data man &#248;nsker &#229; returnert, noe som resulterer i at man slipper overfetching, - at man f&#229;r returnert mer data enn man trenger. Et annet vanlig problem med REST-APIer er at et endepunkt n&#248;dvendigvis gir all dataen man &#248;nsker, underfetching. Man m&#229; da gjerne gj&#248;re x antall nye sp&#248;rringer mot andre endepunkter for &#229; hente resten.<\/p><p>&#160;<\/p><p><em>Eks:<\/em><\/p><p>Anta at en spesifikk bruker har et sett med emner registrert p&#229; seg selv, og man &#248;nsker navn p&#229; 5 andre studenter som tar samme emne. F&#248;rst m&#229; man hente brukeren blant alle brukerne, videre m&#229; man hente alel emnene og finne det spesifikke emnet. Deretter m&#229; man se p&#229; en oversikt over studenter knyttet til det respektive emnet og hente ut fem av dem.&#160;<\/p><p>&#160;<\/p><p>Et REST-API m&#229; dokumenteres manuelt selv, mens et GraphQL-API er selvdokumenterende. Dette er tidsbesparende, og det gj&#248;r det enklere &#229; bruke. Videre er det vanlig &#229; versjonere REST-API&#39;er, - det gj&#248;r man strengt tatt i GraphQL ogs&#229;, men det blir ikke p&#229; samme vis. Man forholder seg fortsatt til samme endepunkt, men s&#229; vil man oppleve at det selvdokumenterende API&#39;et formidler at viss funksjonalitet etc. er deprecated.&#160;<\/p><p>&#160;<\/p><p>En ulempe med et GraphQL-API fremfor et&#160;REST-API er dataen det returnerer. Et REST-API kan returnere varierte datatyper, mens&#160;GraphQL utelukkende returnerer JSON.<\/p><p>&#160;<\/p><p>Mange mener det er vanskeligere &#229; cache i GraphQL i motsetning til et REST-API, - typisk da hos en CDN. Dette argumentet er gydlig, men jeg synes ikke det st&#229;r veldig sterkt da det er veldig naturlig &#229; benytte seg av Redis uansett. Det er annerledes, ja, men jeg synes ikke det er en stor drawback for GraphQL.&#160;<\/p><p>&#160;<\/p><p>Rate-limiting er mye enklere i et REST-API. Siden man i et GraphQL-API lar en brukeren selv velge hva en henter ut, s&#229; kan man ikke i forkant av en sp&#248;rring vite hvor mange sp&#248;rringer som f&#248;lger. Det finnes noen verkt&#248;y for &#229; h&#229;ndtere dette, men det er langt mer tungvindt enn ved REST.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker et kraftig typesystem, og Schemaene som defineres fungerer som en kontrakt mellom frontend og backend. Alt&#160;GraphQL-API&#39;et tilbyer havner i Schemaet, og det gir klare instruksjoner for hvordan en klient kan aksessere dataen. Et REST-API tilbyr ikke noe liknende, og man er derfor helt avhengig av manuell dokumentasjon eller pr&#248;ving og feiling. En klar fordel med disse schemaene er at dersom en skal teste og eller mocke dataen, s&#229;&#160;<u>vet<\/u>&#160;man hvilken struktur dataen har, og man trenger ingen kommunikasjon med backenden for &#229; finne det ut. Videre s&#229; sikrere det kraftige typesystemet oss mot mange feil.&#160;<\/p><p>&#160;<\/p><p>Et REST-API er ofte enklere &#229; skalere enn et GraphQL-API. Man trenger et nytt endepunkt og noe som h&#229;ndterer det, s&#229; er man oppe og g&#229;r.<\/p><p>&#160;<\/p><p>Det er ogs&#229; enklere &#229; monitorere REST-APIer. Hvor lang tid en sp&#248;rring tar etc. er forholdsvis enkelt &#229; avdekke ved &#229; se p&#229; de ulike endepunktene som kalles, men dette er mye vanskeligere i et GraphQL-api da det kun har ett endepunkt &#229; forholde seg til. Nesting i en GraphQL gj&#248;r at x antall resolvers kalles, og kompleksiteten for &#229; monitorere dette blir fort stor.<\/p><p>&#160;<\/p><p>---<\/p><p>Det er vanskelig &#229; sammenligne GraphQL og REST og finne en sikker vinner, spesielt da det ikke er s&#229; svart/hvitt. Det blir sagt at det er som &#229; sammenligne SQL med noSQL. Det er noen tilfeller der det ene er bedre enn det andre, og ellers den andre over den f&#248;rste. Det er viktig at man setter seg godt inn i hva man ofrer ved valg av den ene eller andre.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://goodapi.co/blog/rest-vs-graphql<\/p><p>https://www.moesif.com/blog/technical/graphql/REST-vs-GraphQL-APIs-the-good-the-bad-the-ugly/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533470,"ext_inspera_userAssessmentSetupId":7140010,"ext_inspera_userAssessmentId":4841300,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Finsås Ingvild Telle (10100)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":29551302,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1806,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>I React kan man&#160;implementere dataflyt oppover i et komponenthierarkiet ved &#229;&#160;sende data fra foreldrekomponent til barnekomponent ved bruk av props (callbacks).&#160; Overf&#248;rer igjen data fra barnekomponent to foreldrekomponent for &#229; sette state p&#229; foreldrekomponenten.&#160;<\/p><p>&#160;<\/p><p>Ofte trengs en state flere steder i hierarkiet. L&#248;sningen beskrevet ved props , hvor en state flyttes opp til n&#230;rmeste foreldrenode og sendes nedover via props,&#160;kan f&#248;re til mye redundans.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av en&#160;state management l&#248;sning, kan data sendes neodver i komponent-treet uten &#229; m&#229;tte sende props nedover manuelt p&#229; hvert niv&#229;.&#160;Det finnes en rekke state management l&#248;sninger&#160;som blant annet MobX, Redux og React&#160;Context. Redux og Mobx lar deg samle state en plass og gir deg mekanismene for &#229; endre og lese state der du trenger det i komponenthierarkiet (hentet fra H2018 eksamen).&#160;<\/p><p>&#160;<\/p><p>Redux har&#160;strenge retningslinjer for beste praksis ved bruk av actions og reducers. Dette&#160;f&#248;rer til mye boiler plate ettersom det er mye setup kode som m&#229; implementeres. I Redux har man en enkelt store og en single source of truth for hele applikasjonen. State kan bare forandres via dispact av actions, og state&#160;kan ikke manipuleres med directe i store. Dette gj&#248;r det lettere &#229; debugge.&#160;<\/p><p>&#160;<\/p><p>I Mobex er staten mulig &#229;&#160;forandre direkte,&#160;som vil si at det er lettere &#229; oppdatere staten med nye verdier. Ettersom det er stor fleksibiltet i design av state er Mobex&#160;lettere &#229; implementere, men f&#248;rer til at testing og vedlikehold kan bli vanskelig pga uforutsett output. Det er ogs&#229; mulig med flere stores.&#160;<\/p><p>&#160;<\/p><p>Context er et fint hjelpemiddel n&#229;r det ikke er mye data som endres. En Context lages for&#160;hver unike del av dataen som skal v&#230;re tilgjengelig gjennom komponent-treet. Man m&#229; implementere en provider og consumer for hver datadel. En provider gj&#248;r state tilgjengelig for alle &#160;barnekomponentene (tar i bruk consumer). Dersom data endres, s&#229; rendres alle barnekomponentene som tar i bruk consumer p&#229; nytt. Det er mulig &#229;&#160;splitte opp i flere Context.&#160;Context er bare en m&#229;te &#229; dele verdier i et nested komponent-tre, og ikke sett p&#229; som et&#160;state management tool.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3408,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et eksperimentelt JavaScript state management bibliotek for React. Recoil best&#229;r i all hovedsak av to ting - Atoms(gir state)&#160;og Selectors (beregner&#160;verdier basert p&#229; state).&#160;<\/p><p>&#160;<\/p><p>I Redux avfyres handlinger ved dispatch-metoden.&#160;I Recoil avfyrer vi handlinger og endrer den eksisterende delte staten (til atomet)&#160;ved hjelp av selectors. Sammenlignet med Redux s&#229; gir Recoil mindre&#160;boilerplate. I stedet for actions, middlewares og&#160;reducers, gir Recoil bare &#233;n lagring for delt data (atoms) og&#160;hooks for &#229; koble komponenter til den staten. Recoil har ytelsesfordeler sammenlignet med Redux, men bare hvis appen din er kompleks nok.&#160;Recoil&#160;fjerner litt boiler plate sammenlignet med Redux.&#160;<\/p><p>&#160;<\/p><p>P&#229; grunn av ulemper med&#160;Redux (boilerplate osv)&#160;blir Context API ofte tatt i bruk. Men Context kan v&#230;re uforutsigbart, og ikke bygget for h&#248;yfrekvente oppdateringer, samt mangel p&#229;&#160;muligheten til &#229; lagre ubestemte verdier i stedet for en enkelt verdi. Ut i&#160; fra nettressurser&#160;l&#248;ser Recoil mange av problemene st&#248;rre applikasjoner st&#229;r overfor n&#229;r du bruker eksisterende Context API.<\/p><p>&#160;<\/p><p>(L&#248;sningen for Recoil minner litt om Mobx, men Recoil kan gi mindre boilerplate hvis kombinert med React Hooks.)<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Fordeler:<\/p><p>- Recoil eliminerer un&#248;dvendige re-renders som skjer n&#229;r du bruker Context API eller Redux.<\/p><p>-&#160;Recoil lar deg koble til den bestemte staten, noe som er en enorm ytelsesfordel. (Ikke som med global state i&#160; Redux).<\/p><p>-&#160;Det er ogs&#229; mulig &#229; bruke Recoil delvis. Appen din trenger ikke v&#230;re helt avhengig av den.&#160;<\/p><p>- Fjerner boilerplate (som er ulempen med Redux).&#160;<\/p><p>- Mange p&#229; nettet argumenterer for at det er lett &#229; l&#230;re ettersom det er lignende eksisterende state managment biblioteker der ute<\/p><p>-&#160;&#160;Recoil leveres med asynkron st&#248;tte uten tredjepartsbiblioteker.<\/p><p>-&#160;I motsetning til Redux eller Context API lagres ikke state globalt hvor som helst, staten&#160;er inkrementell og distribuert, noe som gj&#248;r kodedeling mulig.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>- Nytt bibliotek og man er ikke&#160; helt kjent med bruken, og finnes dermed ikke de st&#248;rste nettressursene.<\/p><p>-&#160;Hvis prosjektet st&#229;r overnfor&#160;ytelsesproblemer, er Recoil et flott alternativ. Eller er det ikke alltid n&#248;dvendig &#229; endre eksisterende l&#248;sning.<\/p><p>- Recoil har enda ikke et fullt ut st&#248;ttet state observing verkt&#248;y som Redux middleware, i Recoil er observer hook forstatt i utviklingsfasen.<\/p><p>- Mangel p&#229; debug-verkt&#248;y<\/p><p>- Ikke noen offisiell st&#248;tte for &#229; rendre p&#229; serversiden<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1964,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest er en overordnet arkitektur/design for web-basert klient/tjener kommunikasjon, mens GraphQL er et sp&#248;rrespr&#229;k (m&#229; ta i bruk feks Apollo Client med GraphQL).<\/p><p>&#160;<\/p><p>For det f&#248;rste har REST API flere endepunkt (GET, POST,...), mens GraphQL har ett endepunkt (POST) hvor man sender alle queriesene.&#160;&#160;Siden REST har mange endepunkter, skilt p&#229; HTTTP verb, s&#229; er det fare for over- og under fetching. Dersom du kun er interessert i &#229; hente navnet p&#229; en matrett, s&#229; f&#229;r du i tillegg ingredienser, varighet osv (over fetching). Av og til m&#229; det hentes data fra to forksjellige steder (under fetching). Med GraphQL ber du eksplisitt bare om den informasjonen du trenger, og det er dermed enklere &#229; holde rede p&#229; hvilke felt som blir brukt, i motsetning til REST.&#160;<\/p><p>&#160;<\/p><p>Hvordan request sendes til server ulik. REST er&#160;URL-drevet&#160;mens GraphQL baseres&#160;p&#229;&#160;Query spr&#229;k.<\/p><p>&#160;<\/p><p>Cashing p&#229; klienten er effektivt ved REST, ettersom cashing er bygget inn i HTTP spesifikasjonen som REST utnytter. Det er vanskeligere &#229; cache i GraphQL ettersom det ikke f&#248;lger&#160; HTTP spesifikasjonen for cashing, og det opp til utvikler &#229; s&#248;rge for korrekt implementasjon av caching.&#160;Cache p&#229; nettverksniv&#229; er viktig, da det kan redusere trafikkmengden til en server eller holde data som er ofte tilgjengelig i n&#230;rheten av klienten.&#160;<\/p><p>&#160;<\/p><p>En REST API er basert p&#229; JSON som ikke kan gi typekontroll. GraphQL har et type system som&#160;i hovedsak forteller klienten hvordan den kan f&#229; tilgang til data. Dette gir god kjennskap til datastrukturen og er nyttig for at b&#229;de frontend og backend-team kan jobbe uavhengig. Samtidig gir det kompleksitet, mer&#160;typer, resolvers ol,&#160;som kan gj&#248;res mye enklere med REST.<\/p><p>&#160;<\/p><p>GraphQL lar utviklere gj&#248;re endringer p&#229; klientsiden uten &#229; rote med serveren. Dette gj&#248;res gjennom mutations, som gj&#248;r at man kan&#160;endre eller oppdatere i databasen.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533587,"ext_inspera_userAssessmentSetupId":7139933,"ext_inspera_userAssessmentId":4841298,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hansen Marit Fredrikke (10220)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34118173,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1662,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er flere definisjoner p&#229; hva state management er. Et forslag p&#229; en definisjoner hvordan data kommer ut og inn i databasen. Eksempler p&#229; dette kan v&#230;re &#229; ta i bruk Context, Redux eller MobX.&#160;<\/p><p>(https://medium.com/super-declarative/understanding-state-management-and-why-you-never-will-dd84b624d0e)<\/p><p>&#160;<\/p><p>Props brukes i react for &#229; sende data og variabler til ulike komponenter. React er komponentbasert og en kan se p&#229; komponent arkitekturen som en tre struktur, der App er &#248;verst. For &#229; unng&#229; &#229; sende alle elementene nedover treet gjennom props kan en ta i bruk Context.&#160;<\/p><p>(https://changelog.com/posts/when-and-when-not-to-reach-for-redux)<\/p><p>&#160;<\/p><p>Andre m&#229;ter for &#229; lagre variabler er useState og setState. Dette lagres innad i en komponent og en kan lagre verdier. Session- og local storrage kan ogs&#229; taes i bruk. Dette er former for HTML web storage. Session storrage lagrer verdier helt frem til fanen p&#229; nettleseren lukkes ned, mens local storrage lagrer verdier ogs&#229; etter fanen er lukket. HTML web storrage virker i React, s&#229; vi tok i bruk dette i prosjekt 3. Det virker ikke p&#229; samme m&#229;te i React Native, som utvikler en app, s&#229; i prosjekt 4a m&#229;tte vi finne andre l&#248;snigner p&#229; dette.&#160;&#160;<\/p><p>&#160;<\/p><p>Valget om Redux eller MobX skal tas i bruk avhenger av hvilket produkt som skal utvikles. For en relativt liten applikasjon kan de tv&#230;re hensiktsmessig &#229; ta i bruk MobX. Redux har en brattere l&#230;ringskurve og vil heller egne seg bedre til et st&#248;rre prosjekt. Samtidig kan det v&#230;re lurt &#229; velge den trejdeparts komponenten utviklerene er vandt med dersom en av dem skiller seg ut i stor grad. Redux er et bra valg dersom du forventer at det blir en del feils&#248;king, siden Redux gir god kontroll p&#229; dataflyten.&#160;<\/p><p>(https://www.imaginea.com/redux-vs-mobx-what-you-need-to-know/)<\/p><p>&#160;<\/p><p>P&#229; prosjktet tok vi i bruk GraphQL p&#229; server siden&#160;sammen med Apollo Server. Dette, sammen med Apollo Client gjorde slik at vi ikke trengte &#229; ta i bruk Redux eller MobX, siden deres funksjonalitet var alerede dekket med Apollo i kombinasjon med GraphQL.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2743,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et annet state management system som kan taes i bruk for &#229; h&#229;ndere dataflyt i React. Biblioteket forkserer p&#229; delene atoms og selectors. Atomer er enheter av tilstander. Komponenter kan abonere p&#229; atomer og bli oppdatert. Selectors er funksjoner<\/p><p>(https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee)<\/p><p>(https://recoiljs.org/docs/introduction/core-concepts)<\/p><p>&#160;<\/p><p>Som utvilker burde man ta i bruk allerede innebygde state management, men React har noen begrensninger, som gj&#248;r det mer hendiktsmessig &#229; installere for eksempel Recoil. En begrensning er med props som er nevnt i forrige svar. React komponentene er i en trestruktur og det er sjanse for at hele treet m&#229; lastes p&#229; nytt dersom en komponent oppdateres. Recoil tilbyr en l&#248;sning som forbedrer dette. Tilstander kan oppdateres uten at hele komponenter endres og hele treet m&#229; lastes opp p&#229; nytt.&#160;<\/p><p>(https://recoiljs.org/docs/introduction/motivation)<\/p><p>&#160;<\/p><p>Ut fra det jeg har lest meg opp p&#229; Recoil n&#229; virker det som om det er lett &#229; ta i bruk og l&#230;ringskurven er mindre bratt. Det kan minne litt om useState og setState fra react, som er greit &#229; ta i bruk. Recoil virker simpelt. I forhold til MobX og Redux virker det som om mye logik m&#229; implementeres p&#229; egenh&#229;nd for &#229; oppn&#229; samme kompleksitet som MobX og Redux. P&#229; den ene siden kan dette v&#230;re en ulempe, siden utvikleren m&#229; bruke tid p&#229; &#229; implementere samme logikk. P&#229; dn andre siden er det ikke sikkert at appen trenger alle samme funksjonaliteter som MobX og Redux, slik at Recoil kan v&#230;re et fint alternativ for sm&#229; og mellomstore apper.&#160;<\/p><p>(https://medium.com/swlh/a-quick-glance-at-recoil-d276c22c7efe)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL er basert p&#229; query som defineres og du kan sp&#248;r etter data og f&#229; akkuratt det du spurte etter. REST API p&#229; den andre siden m&#229; man muligens gj&#248;re flere kall for &#229; f&#229; ut samme type data, i tillegg til at du kan risikere &#229; f&#229; ekstra data som er un&#248;dvendig. Med GraphQL f&#229;r man tilgang til playground, som gj&#248;r det lettere &#229; verifisere at man henter riktig data og queryene er riktige. REST har flere endepunkt, mens GraphQL kun har et endepunkt. GraphQL er nyere og ment til &#229; dekke flere av problemene til REST.<\/p><p>&#160;<\/p><p>REST kan minne om hvordan en nettleser finner riktig nettside med POST og GET request siden APIet forteller hvordan flere systemer snakker sammen. GraphQL p&#229; den andre siden er kun koblet opp til databasen. Dersom noe skal hentes i databasen er det raskere med GraphQL, siden det kun blir et kall og REST m&#229; gj&#248;re flere.<\/p><p>&#160;<\/p><p>REST casher til nettverkslaget, noe GraphQL ikke gj&#248;r. Cahsingen gindrer at det blir mye trafikk mot samme server p&#229; en gang. Siden GraphQL er direkte koblet til serveren kan det hende at det blir mye press mot samme server. I GraphQL m&#229; man definere models, typeDefs og relsolvers. Ved mindre apper kan implementeringen av GraphQL gj&#248;re applikasjonen mer komplekst enn ved for eksempel REST.<\/p><p>&#160;<\/p><p>(Tidligere eksamensoppgaver og gruppens readme)<\/p><p>(https://www.wikipendium.no/IT2810_Web_Development#graphql)<\/p><p>(https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d)<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533648,"ext_inspera_userAssessmentSetupId":7140066,"ext_inspera_userAssessmentId":4841153,"dateLastModified":"2020-12-01T10:01:23Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:23Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Baskaran Noran (10207)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35187543,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2406,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React s&#229; har man en funksjon kalt useState som kan brukes til &#229; oppdatere komponenten n&#229;r det skjer endringer i den. I tillegg kan man bruke props til &#229; &#34;proppe&#34; ned data til komponenter som ligger under denne foreldre komponenten. Vi har ogs&#229; funksjoner som useEffect som gj&#248;r at vi i de funksjonelle komponentene kan gj&#248;re useEffect avhengig av staten til den komponenten og kj&#248;re hver gang den rendrer/re-rendrer. Essensielt har den useEffect samme bruksomr&#229;de som noen av funksjoene i React.Component for eksempel componentDidMount og componentDid som kj&#248;res i de klassebaserte komponentene.&#160;<br />Vi har ogs&#229; context-apiet som vi brukte i prosjekt 2 som kan bli brukt for data som vi anser som global og skal bli brukt av flere komponenter.&#160;<\/p><p>I tillegg har vi metoder for &#229; gj&#248;re states globale via for eksempel Redux til &#229; gj&#248;re states global eller Recoil fra neste oppgave som gj&#248;r at vi kan sette infromasjon vi trenger opp i et h&#248;yere niv&#229;.&#160;<\/p><p>&#160;<\/p><p>https://reactjs.org/docs/react-component.html<\/p><p>https://reactjs.org/docs/context.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1779,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en state management bibliotek for react. S&#229; i forhold til Redux eller Apollo ( som kan fungere som state manager) s&#229; har de en fordel med at de ikke er utviklet for bare &#229; brukes med react, de er mer generelle. Og redux er noen &#229;r eldre med en stor community med mye ressurser bak. Men Siden recoil er mer spesifikk for react s&#229; er det en fordel om du vet at applikasjonen skal v&#230;re bygget via kun react. En stor fordel er at det er veldig lite setup og fungerer og ser ut som useState funksjonen til react bare at den kan tenkes som at vi l&#248;fter staten opp et niv&#229; (kanskje globalt) og kan bli brukt at alle komponenter i niv&#229;et under til &#229; styre dataen i atomet og atomet vil updates n&#229;r dataen blir endret. Mens i Redux som jeg personlig brukte trengte jeg mye mer kode for &#229; sette opp redux men da kunne jeg lett sette opp mange flere ting til &#229; v&#230;re global og det var verdt det siden det gjor det enkelt &#229; debugge i browser med redux devtools. Problemet med at s&#229; mye er gobal er at vi kan f&#229; mye re-renders og det blir lettere &#229; finkontrollere dette via Recoil.&#160;<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2676,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De viktigste forskjellene er at i graphql kan men hente ut data basert p&#229; de feltene man vil ha fordi et er et sp&#248;rrespr&#229;k og man slipper da og f&#229; mye un&#248;dvendig data, mens i et vanlig REST-api s&#229; vil man f&#229; alle feltene uansett og det tar ressurser og man beh&#248;ver kanskje ikke alle. Et godt ekempel p&#229; hvor dette kan passe inn er for eksempel hvis man lager en nettside som viser info om filmer. N&#229;r en bruker trykker p&#229; en av filmene f&#229;r &#229; se mer informasjon om det objektet kan man hente ut kun feltene som man trenger og vil vise. Men i hvis du for eksempel vil ha en tabell med land, hovdestader osv. Som kort sagt bruker nesten alle feltene s&#229; kan det lett gj&#248;res med et vanlig REST- API. En annen forskjell er at hvis du har flere endpoints s&#229; m&#229; du bruke flere requests i&#160;vanlig REST-API for &#229; hente/skrive den samme informasjonen som du ville ha gjort i graphql der du i en request hente all denne dataen. Men i graphql har du ikke den default chaching mekanismen som finnes i REST.&#160;&#160;<\/p><p>Kilde:&#160;https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534312,"ext_inspera_userAssessmentSetupId":7140052,"ext_inspera_userAssessmentId":4841186,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Grødem Espen Kolberg (10148)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33652161,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1908,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Prinsippet i React er en dataflyt hvor data sendes nedover i komponent hieraktiet. En har&#160;parent komponenter, som sender data nedover til child komponenter, og som i et st&#248;rre bilde, med andre komponenter danner et komponenthierarki.&#160;Props er verdiene som gir n&#229;r en komponent opprettes, og er verdier som ikke kan endre(de sendes nedover). Hver komponent har ogs&#229; &#34;interne&#34; tilstander, state, som kan endres i komponenten. Disse brukes for &#229; lagre komponenters data som ikke er statiske prop-verdier.<\/p><p>&#160;<\/p><p>React har en mengde metoder for &#229; sette opp(mount), oppdater og ta ned(unmount) komponenter basert p&#229; tilstandsendringer. Lifecycle metoder er metoder som brukes under en &#34;livssyklus&#34; til en komponent, for &#229; feks s&#248;rge for at en komponent er oppdatert med de gjeldenede verdiene. Lifecycle metoder brukes med klasse-komponenten. React hooks er introdusert i etterkant av lifecycle metoder, og gir funksjonalitet som erstatning for det du trenger klasse til.&#160;Her brukes useState for &#229; h&#229;ndtere state, og useEffect som erstatning for lifecycle metoder(hentet fra forelesningsslides, Introduksjon til prosjekt 2, side 19).&#160;<\/p><p>&#160;<\/p><p>Selvom grunnprinsippet i React er at data sendes nedover, vil dette ikke bli gunstig i st&#248;rre applikajsoner. Selv om det finnes callback funksjoner, som ogs&#229; kan sendes nedover som props slik at komponentene kan endre tilstander hos parent komponenter. Grunnen til dette er det vil bli komplisert &#229; implementere og vanskelig &#229; ha oversikt.&#160;<\/p><p><br />Derfor har man i React ogs&#229; globale tilstander. Context gj&#248;re det mulig &#229; dele variabler p&#229; tvers av komponenttreet, og brukes prim&#230;rt n&#229;r mange komponenter skal ha tilgang til en variabel. Dette gj&#248;res ved &#229; definere en provider, som en &#34;pakker&#34; rundt komponentene som skal ha tilgang. Komponentene kan n&#229; f&#229; tilgang til, og endre og oppdatere variabelen.&#160;<\/p><p>&#160;<\/p><p>For global&#160;tilstandsh&#229;ndtering har du ogs&#229; Mobx og Redux.&#160;<\/p><p>Redux er en eldre l&#248;sning, og en mer manuell l&#248;sning. Her dispatcher man en action til en reducer som oppdaterer tilstander p&#229; en store. Action er handlingen som gj&#248;re, reducer er funksjonen som ikke endrer tilstanden, men som generer en ny tilstand(Redux har immutable store). Komponentene som er avhengig av tilstanden informeres om oppdateringen, og endres. Redux har kun en store, men en kan ha b&#229;de en og flere reducere.&#160;<\/p><p>&#160;<\/p><p>Mobx er en litt annen l&#248;sning, og en mer automatisk l&#248;sning med mindre oppsett(boilerplate code). Her defineres verdier som observable. N&#229;r en observable verdi oppdaters vil alt som avhenger av den oppdateres. Komponentene som er avhengig av verdien defineres som observer, som alts&#229; &#34;lytter&#34; etter endringer.&#160;<\/p><p>Handling vil utl&#248;se en action, som endrer observable state, som varsles videre til komponenter som avhenger av endringer.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2738,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for tilstandsh&#229;ndtering. Recoil pr&#248;ver &#229; l&#248;se problemet&#160;med komplisert oppsett og mye boilerplate code for liknende bibliotek.&#160;Konseptet g&#229;r ut p&#229; &#229; definere atomer og selectors. Atomene er tilstander som flyter gjennom selectorene som er funksjoner, ned i komponentene.&#160;Komponentene kan &#34;subscribe&#34; til atomene og hvis flere komponenter subscriber til samme atom deler komponentene tilstand.&#160;<\/p><p>&#160;<\/p><p>Atom, defineres med en n&#248;kkel, og en verdi og p&#229; samme m&#229;te som useState defineres en tilstand ved hjelp av useRecoilState.&#160;Selctors brukes for &#229; regne ut resultatet av tilstandsendringer og de&#160;kan endre tilstanden til et atom.&#160;En komponent kan &#34;subscribe&#34; p&#229; b&#229;de en selector og et atom.&#160;<\/p><p>&#160;<\/p><p>Lignende l&#248;sninger som er p&#229; pensumlister en feks Redux og Mobx.&#160;<\/p><p>Felles for de alle er tilstandsh&#229;ndtering, og &#229; tilgjengeliggj&#248;re tilstander for flere komponenter. I motsetning til Redux og Mobx, vil ikke Recoil har en store.&#160;Istedenfor &#229; lagre mange tilstander i en store, blir tilstandene&#160;regnet ut av selektorene slik at det er s&#229; f&#229; atomer som mulig i systemet.&#160;<\/p><p>&#160;<\/p><p>Redux og Mobx krever i st&#248;rre grad en konfigurer og oppsett. Redux spesielt trenger mye boilerplate code, og er kanskje derfor ikke det beste &#229; g&#229; for med mindre prosjekter da mye forberedelse m&#229; gj&#248;res for &#229; holde oversikt over et mindre antall tilstander. Mobx er en mer automatisert l&#248;sning, men sammenlignet med Redux er det mindre skalerbart og&#160;det er mindre formbart. I Mobx har en ogs&#229; kun en store, i Redux m&#229; man ha minimum en men kan ogs&#229; ha flere.&#160;<\/p><p>Andre ulikheter nevnes i oppgave 1.&#160;<\/p><p>&#160;<\/p><p>En annen tilstandh&#229;ntering er context, og en av fordelene med Recoil fremfor context er hvis tilstanden i context endres, vil alle komponenter re-rendres. Dette gjelder ogs&#229; komponenter hvor dataen ikke endres. Siden et atom er en individuell state, bare komponenter som subrscriber til atomet re-rendres. Liknende problemer gjelder ogs&#229; for Redux.&#160;<\/p><p>&#160;<\/p><p>Recoil har mye felles med liknende tilstandsh&#229;nteringer. Feks med useRecoilState som minner mye om React Hooks for tilstandsh&#229;ndtering. I tillegg pakker den, som feks Redux, inn komponentene som en variabel skal v&#230;re tilgjengelig for.&#160;<\/p><p>&#160;<\/p><p>I motsetning til Recoil er Redux en&#160;veldefinert og godt etablert l&#248;sning. Recoil er et ungt bibliotek.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2479,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest - Representational State Transter er en overordnet arkitektur for web-basert klient/tjener- kommunikasjon med fokus p&#229; lesing og skriving av ressurser.&#160; APIet designet for &#229; utnytte eksisterende protokoller, og prinsippene er tilstandsl&#248;s kommunikasjon.&#160;Kommunikasjonen&#160;med&#160;ressursene gj&#248;res via URI, hvor det er en unik URI for hver enkelt ressurs. HTTP foresp&#248;rselene GET, PUT, POST, DELETE brukes for &#229; lese, endre, opprette og slette ressurser. Ressursene&#160; er statiske. Rest er et b&#229;de godt etablert og&#160;dokumentert API.<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k for ditt API, hvor dataen er organisert som en graf. Objektene blir organisert som noder og forholdet mellom dem blir&#160;respresentert som kanter. Brukeren definerer i JSON hva slags data som skal hentes,&#160;hvor en definerer b&#229;de s&#248;k og hvilke data som hentes. Alle Graph oppsett har et skjema, med objekt-type og navn. En definerer ogs&#229; et query hvor man definerer hva som kan v&#230;re med i sp&#248;rringene.&#160;<\/p><p>&#160;<\/p><p>Forskjellene mellom Graph og Rest blant annet hvordan data hentes. Rest henter informasjonen sin fra statiske endepunkt hvor et eller flere av disse endepunktene brukes for &#229; lese, skive eller endre p&#229; ressursen gjennom URI og HTTP request. En har alts&#229; et endepunkt for feks henting av data, og et til &#229; skrive data, men det kan ogs&#229; v&#230;re flere. Her skiller graph og rest seg fra hverandre ved at Graph kun har et endepunkt.&#160;<\/p><p>Dette kan for begge b&#229;de v&#230;re en fordel og en ulempe. Oppbygningen med flere endepunkter, gir utvikleren mer designfrihet og muligheter til &#229; forme ting etter eget behov. Graph har kun et endepunkt, og gj&#248;r&#160;mer automatisk, alts&#229; uten at brukeren beskriver hvordan oppgaver skal gj&#248;res. Ved oppbygning av st&#248;rre applikasjoner, m&#229; en ta en vurdering p&#229; kompleksiteten ved flere endepunkter vs muligheten til &#229; designe etter eget &#248;nske.&#160;<\/p><p>&#160;<\/p><p>En annen forksjell er skillet mellom hvordan Rest og Graph henter data. Som nevnt er Graph sp&#248;rringsbasert, alts&#229; at en bruker ved henting av data kun spesifirere hvilke datafelter som vil hentes. Det gj&#248;r at Graph ikke henter for mye data(overfetcher). Rest har ikke den samme l&#248;sningen.&#160;Ved henting av objekter lider Rest av overfetching(henting av for mye data). Et eksempel er ved henting av enkeltobjekter, og en skal feks kun bruke et felt(feks navn).<\/p><p>En kan da hente hele objektet og kun bruke navnet(overfetching), eller ha flere endepunkter som gj&#248;r applikasjonen mer kompleks. &#197; ha et endepunkt for alle datafelter er ikke gunstig.&#160;<\/p><p>&#160;<\/p><p>Graph har ikke implisitt caching i HTTP-laget, noe som Rest har.&#160;<\/p><p>Rest er tilstandsl&#248;s og har et fokus p&#229; skriving og lesing av ressruser. Det vil si at det ikke er noe minne, som husker hva du har hentet og en m&#229; f.eks med sortering, hente all dataen p&#229; nytt.&#160;<\/p><p>&#160;<\/p><p>Graph har ogs&#229; et typesystem som gj&#248;r det mulig &#229; validere dataen som hentes opp mot datatypen.<\/p><p>Graph er ogs&#229; lettere &#229; oppdatere/endre dataen din, da man kun spessifiserer og henter nye felter.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537431,"ext_inspera_userAssessmentSetupId":7139972,"ext_inspera_userAssessmentId":4841161,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Thon Ingvild Løver (10073)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35159146,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2780,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I react har man et komponenttre, en struktur som beskriver hvordan komponenter henger sammen og forholder seg til hverandre. Komponenter kan ha barn og foreldrekomponenter kan sende state til sine barnekomponenter som props. For &#229; sende state oppover i komponenttreet, kan man implementere den delte tilstanden i en foreldrekomponent, dette kalles &#229; l&#248;fte opp tilstanden (lifting state up). State er lokal og kan ikke ses fra utsiden av en komponent. Bruken av state i en komponent variere utfra type komponent. Er det en klassekomponent kan man kalle lokal state med this.state og sette state i en konstrukt&#248;r og med setState. I en funksjonell komponent bruker man useState hook. I en klassekomponent har man i tillegg livssyklusmetoder som kalles n&#229;r komponenten er rendret i DOMen, n&#229;r props eller state endres, n&#229;r komponenten er i ferd med &#229; fjernes fra Domen; componentDidMount, componentDidUpdate og componentWillUnmount.<\/p><p>Det kan bli komplisert &#229; sende state langt opp eller ned i treet, eller det kan v&#230;re det er veldig mange komponenter som trenger &#229; f&#229; tak i tilstanden, da kan det l&#248;nne seg med global state. Ved &#229; ha global state kan alle komponenter i treet f&#229; tak i tilstanden. Dette kan implementeres p&#229; flere forskjellige m&#229;ter. Man kan bruke context API, lett &#229; bruke, men fungerer ikke like godt hvis man har en state som endres ofte eller state som er kompleks. Man har ogs&#229; de kjente bibliotekene redux og mobx. Begge har sine fordeler og ulemper, redux har kun en store, mens mobx kan ha flere. Mobx er lettere &#229; starte med og enklere &#229; sette seg inn i, men redux er forutsigbar, enklere &#229; holde oversikt over endringer og mye mer popul&#230;r.<\/p><p>Det er ogs&#229; mulig &#229; bruke html web storage (localStorage og sessionStorage) til &#229; midlertidig lagre en global tilstand. Da er den enkel &#229; f&#229; tak i fra alle komponentene i treet.<\/p><p>State kan ligne p&#229; props men har ikke helt samme dataflyt. En state b&#248;r ikke forandres fra utsiden av komponenten, state kan v&#230;re asynkron, og er foranderlig, derfor burde den ikke aksesseres fra barnekomponenter, men kan sendes som props. Stare skal brukes til &#229; lagre lokal tilstand for akkurat den komponenten. Props er ikke foranderlige, s&#229; hvis de sendes nedover til en barnekomponent kan de ikke forandres. Prop-drilling er n&#229;r man sender props lenger og lenger ned i komponenttreet, dette kan v&#230;re mye jobb og da kan det l&#248;nne seg med en global variabel. Props kan sendes oppover i treet ved &#229; bruke callbackfunksjoner.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p><p>https://reactjs.org/docs/lifting-state-up.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1720,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for react. Det kan se ut som en utfordrer til redux og mobx, spesielt tilpasset react. P&#229; samme m&#229;te som mobx ser det ut som recoil har en slags observer-observable struktur der komponenter som leser av verdien til et atom(en tilstand)&#160; vil automatisk abonnere p&#229; dette atomet dvs at hvis dette atomet endres vil alle abonnerende komponenter re-rendres. Da unng&#229;r man at hele treet m&#229; rerendres og dermed blir det mer effektivt.<\/p><p>I stedet for useState har recoil sin egen useRecoilState og useRecoilValue.<\/p><p>I forhold til redux virker det lettere &#229; sette seg inn og har mindre boilerplate-kode. Man trenger ingen store eller mye oppsett, kun atoms og selectors. Siden Recoil er s&#229;pass nytt er det nok utviklet med redux og context API i tankene og for &#229; forbedre det som allerede finnes. Med recoil trenger man ikke &#229; re-rendre hele komponenttreet n&#229;r state oppdaterers. Recoil er lagd for react og er dermed tilpassa oppf&#248;rsel og innebygd funksjonalitet som react har. Det betyr at nye oppdateringer i react vil v&#230;re kompatible med recoil. Det skal v&#230;re enkelt &#229; splitte kode og bygger videre p&#229;/forbedrer innebygde tilstandsh&#229;ndtering i react.<\/p><p>En ulempe med recoil kan v&#230;re at det kun fungerer for funksjonelle komponenter og ikke klassekomponenter. Dette kan v&#230;re et problem for mange som fortsatt bruker klassekomponenter. Allikevel s&#229; virker det som p&#229; utviklinga at de fleste g&#229;r over til kun funksjonelle komponenter etter det var mulig &#229; bruke hooks til tilstand i funksjonelle komponenter.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2164,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest er laget for &#229; v&#230;re et &#34;best-practice&#34; api og har regler som m&#229; f&#248;lges. Det m&#229; v&#230;re en klient-server arkitektur, uten tilstand, cacheable, uniform grensesnitt, lagdelt system. (https://restfulapi.net/)<\/p><p>N&#229;r man bruker rest m&#229; man definere flere endepunkter, ett endepunkt for hver type data som skal hentes. For eksempel /Movies for &#229; hente filmer og /users for &#229; hente brukere. I tillegg har man kanskje en /movies/title eller en movie/director osv slik at man m&#229; sende mange requests. Dette gj&#248;r at man kan hente for mye data, overfetching, hvis man f.eks bare er ute etter en spesiell film. Rest kan ogs&#229; gi problemer med underfetching fordi en funksjon kun kan kommunisere med en request i motsetning til graphql. Det betyr at man m&#229; sende mange request hvis man vil ha mer data samtidig, dette kan ogs&#229; resultere i un&#248;dvendige mange requests. En viktig del av rest er rounting, navigering til riktige endepunkter, /movies/title er et eksempel p&#229; en rute, som brukes for &#229; aksessere riktig endepunkt. Dette brukes ikke i graphQL.<\/p><p>&#160;<\/p><p>GraphQL er nyere og laget for &#229; l&#248;se noen av problemene med rest, spesielt overfetching. Med graphQL definerer man et skjema med typer som definerer hvordan en klinet kan aksessere data. Ved &#229; ha sterk typing vil ogs&#229; systemet bli mer robust, klienten kan kun f&#229; den typen data som er definert. Ulemper med graphQL er at man kun kan bruke JSON-data og at man ikke kan bruke caching som man kan med REST.&#160;<\/p><p>Man unng&#229;r overfetching med graphQL fordi man kan lage spesifikke queries. Man kan ha en quey for &#229; hente alle filmer og en query for &#229; hente kun en spesifik, slik at man f&#229;r akkurat det man vil ha og ikke alt. Med graphQL har man ogs&#229; fordelen av en mindre isolert frontend-backend kommunikasjon. Ved forandringer i frontend vil man sannsynligvis m&#229;tte gj&#248;re endringer i endepunktene i backend med rest. Frontend er avhengig av hva slags endepunkter man har i backend, dette kan gj&#248;re det tungvint &#229; gj&#248;re forandringer i frontend. Med graphQL er dette lettere fordi man har et skjema, en kontrakt mellom frontend og backend p&#229; hvordan data kan aksesserers, n&#229;r den er satt kan de fortsette med utviklingen hver for seg. Ved endringer i frontend vil det ikke beh&#248;ves forandringer i backend.<\/p><p>GraphQL-skjemaer kan enkelt testes med playground, hvis man kj&#248;rer backend lokalt kan man bruke localhost:port/playgorund og teste alle queries og mutations med databasen. Rest kan testes med f.eks postman.<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://jelvix.com/blog/graphql-vs-rest<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11539732,"ext_inspera_userAssessmentSetupId":7140005,"ext_inspera_userAssessmentId":4841213,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Østbye Johan August (10043)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45160090,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1977,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-appliksjoner er bygd opp av flere komponenter som enten er lagd av utviklerene eller mer generelle komponenter som tilbys av react eller andre 3. parts bibloteker. Disse komponentene er bygg for &#229; kunn eie data som er n&#248;dvendig for den spesifikke komponenten eller for de komponentene som kommer lenger ned&#160; i komponenttreet.<\/p><p>Data som har en effekt p&#229; hvordan den spesifikke komponenten ser ut skal lagres i states som ved endringer bygger uien for komponenten p&#229; nytt. Utenom dette er det ogs&#229; mulig &#229; laste komponenten p&#229; nytt og spesifisere forskjellig funksjoner som skal kj&#248;res gjennom funksjonene componentdidupdate(), useEffect, componentdid(un)mount og mange andre react hooks.<\/p><p>For det meste s&#229; blir data sendt nedover komponenttreet av den grunn av om det skulle bli sendt opp, s&#229; m&#229;tte app komponenten ha altfor mye un&#248;dvendig funsjonalitet, og det ville f&#248;rt til un&#230;dvendig mange rerenderinger. Av samme grunn blir data som skal v&#230;re tilgjenelig for alle komponenter ofte lagret i react sin egen context-funksjonalitet som gj&#248;r en verdi tilgjengelig for alle consumer-komponenter og komponentene under. Dersom oppdateringene i context skjer for ofte kan derimot en Redux for react v&#230;re et bedre alternativ som er bedre p&#229; preformance og kan funkere som middleware for apicalls.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2735,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoiljs funker som en mellom ting av redux og react states. Recoiljs gj&#248;r det mulig for flere komponenter &#229; dele verdier, men til forskjell fra redux s&#229; sendes verdien om &#248;nskelig med en setfunksjon til &#229; oppdatere staten (i motsetning til &#229; m&#229;tte implementere dispatch).<\/p><p>Recoil gj&#248;r det ogs&#229; mulig &#229; kombinere localstorage for &#229; lagre verdiene, som kan gj&#248;res p&#229; en vesentlig letter m&#229;te en med redux eller context (hvor man for&#160; context sitt tilfelle m&#229; wrappe en state i en ny funksjon som implementerer localstoragefunksjonaliteten).<\/p><p>Recoil har ogs&#229; mulighet til &#229; laste inn data fra apier/databaser asynkront, hvor man vanligvis i redux ville brukt middleware. Fordelen Redux har over Recoil er at redux lar deg lagre et objekt som ikke n&#248;dvendig vis trenger &#229; v&#230;re synlig for brukeren, til forskjell for recoil som bruker det til &#229; oppdatere komponenter. Derimot er Recoil mer simpel, og krever midre kode for &#229; sette opp enn redux (som krever actions, actiontypes, reducers og noen ganger middleware og services). Disse m&#229; ofte ogs&#229; kombineres, men dette kan recoil ogs&#229; kan gj&#248;re gjennom en &#34;parent&#34;-selector som implementerer flere andre selectorer og returnere dem som et ebjekt slik som redux.<\/p><p>Den st&#248;rste ulempen med Reciol akkurat n&#229; er at den ikke har kommet serlig langt i utviklingsfasen og dersom man velger &#229; bruke den, s&#229; m&#229; man regne med &#229; bruke en del til p&#229; debugging og muligens hjelpe prosjektet fem til stadiet hvor en selv kan f&#229; akkurat det man &#248;nsket seg fra bibloteket<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2137,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av hovedforskjellene mellom rest og graphql er at med graphql s&#229; kan clienten selv bestemme hvilke verdier en vil ha, serveren tilbyr alts&#229; heledatasettet, og clienten er selv ansvarlig for &#229; bestemme hva som er relevandt for dem. Med rest derimot risikerer man &#229; f&#229; for mye data en n&#248;dvendig, som f&#248;rer til un&#248;dvendig mye bruk av nettkapasitet. Og enda v&#230;rre om man f&#229;r for lite data og m&#229; gj&#248;re flere requests for &#229; sette sammen dataobjektet til clienten.<\/p><p>&#160;<\/p><p>Rest og graphql har ogs&#229; forskjellig metoder for &#229; hente og endre data. Post bruker GET, UPDATE, POST, DELETE, og noen andre mindre brukte, mens graphql burker query for handlinger som ikke endrer databasen, og mutation for de som gj&#248;r det. Hvor vidt dette er en forskjell som teller kommer ned til preferanse, men n&#229;r det er sagt s&#229; er rest sine definisjoner litt mer lettleste.<\/p><p>&#160;<\/p><p>Versjonsh&#229;ndtering er en stor forskjell mellom rest og grapql. Rest apier er versjonsbaserte, og vil ofte slutte &#229; oppdatere gamle versjoner. Dette kan skape problemer for applikasjoner som aktivt bruker disse. Graphql derimot har ingen form for versjon og vil aldri slutte &#229; fungere for andre applikasjoner med mindre hele prosjektet legges ned. Dette skjer ved at gamle funksjoner ikke blir slettet, men heller depricated, som gir brukeren en varsel om at verdien eller funksjonen ikke lenger blir brukt og at det sannsynligvis finnes et bedre alternativ tilgjengelig. Dokumentasjonen vil da ogs&#229; gjemme denne funksjonen under depricated, slik at dokumentasjonen holdes ryddig. En annen god ting ved &#229; ikke ha versjonsh&#229;ndering er at apiet kan bli oppdatert raskere gjennom raskere iterasjoner som slipper &#229; endre p&#229; mye data p&#229; serversiden.<\/p><p>&#160;<\/p><p>Graphql kommer ogs&#229; ofte med en innebygd &#34;playground&#34; men dokumentasjon og schemas automatisk generert for brukeren. Med rest s&#229; m&#229; man n&#248;ye seg med dokumentasjonengitt av de som utviklet apiet og en annen applikasjon som postman eller worst case nettleseren som man bruker til vanlig.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535689,"ext_inspera_userAssessmentSetupId":7140139,"ext_inspera_userAssessmentId":4841321,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Norbye Jonatan (10216)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":65926997,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1172,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For dataflyt i React-applikasjoner brukes hovedsakelig state, props og global state.<\/p><p>&#160;<\/p><p>State er interne variabler i&#160;et komponent,&#160;som f&#248;rer til en re-rendring av komponentet (og dens barn)&#160;dersom variablene endres.<\/p><p>&#160;<\/p><p>Props er data som sendes fra et komponent til et annet komponent det har en direkte link til, enten gjennom &#60;Component prop={prop}/&#62; som et direkte child av et annet komponent eller f. eks. gjennom en &#60;Link/&#62; tag fra React Navigation som videresender brukeren til en ny URL.<\/p><p>Props er immutable (kan ikke endres), s&#229; de brukes typisk til &#229; sende informasjon mellom komponenter, for s&#229; &#229; bli behandlet i mottager-komponentets state om det er en verdi som skal kunne endres.<\/p><p>&#160;<\/p><p>Global state er i bunn og grunn data som lagres &#233;n plass som som kan hentes og oppdateres fra alle komponenter i prosjektet. Mulighet til &#229; unng&#229; props-drilling (sende callbacks gjennom mange funksjoner for &#229; kunne sende data oppover i hierarkiet, eller &#229; sende props gjennom mange komponenter for &#229; sende det nedover) ettersom props m&#229; ha en direkte link for &#229; sendes mens global state kan hentes direkte fra ethvert komponent.<\/p><p>Praktisk teknikk for &#229; ha &#233;n versjon av informasjonen lagret p&#229; en sentral plass for &#229; unng&#229; at forskjellige deler av koden har tilsvarende variabler med forskjellig verdi.<\/p><p>&#160;<\/p><p>Global state gj&#248;r i likhet med state at komponentet som bruker informasjonen skal re-rendres n&#229;r dataene endres, og kan ogs&#229; ha muligheter som Redux har for &#229; definere hvilke data i den globale staten det skal lytte til for &#229; unng&#229; un&#248;dvendige rendringer av komponenter.<\/p><p>Refererer da til<\/p><p>const mapStateToProps = (state: {reviews: StateType}) =&#62; { const {datafield} = state return {datafield} };<\/p><p>export default connect(mapStateToProps)(Component);<\/p><p>Hvor man kun lytter til state.datafield variabelen.<\/p><p>&#160;<\/p><p>Global state kan utf&#248;res p&#229; mange m&#229;ter, som med Redux, MobX, Apollo, RecoilJS, ++.<\/p><p>Typisk felles er at de har et wrapper-objekt som legges rundt root-komponentet som gj&#248;r at alle komponenter i prosjektet kan n&#229; dem, og egne funksjoner for &#229; kalle p&#229; og lytte til globale variabler som brukes i komponentene.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3607,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et global state management bibliotek, som jeg her vil sammenligne med Redux fra l&#230;ringsm&#229;lene ettersom de begge er global state management biblioteker, Redux har v&#230;rt et eksempel fra l&#230;ringsm&#229;lene og jeg har brukt det i ett av prosjektene.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Recoil krever p&#229; samme m&#229;te som Redux at man wrapper root-komponentet i et provider-element som gj&#248;r staten tilgjengelig for alle komponentene inne i root-komponentet.<\/p><p>&#160;<\/p><p>I recoil bruker man hovedsakelig funksjonene atom og selector for &#229; foreta interaksjoner p&#229; den globale staten, sammenlignet med reducers i redux.<\/p><p>&#160;<\/p><p>Bruksmessig gir recoil et preg av at det ligner mer p&#229; hvordan useState fungerer i React enn det Redux gj&#248;r, med at de benytter seg av samme syntaks, eks: const [value, setValue] = useRecoilState(currentValueState), som kan gj&#248;re det mer intuitivt &#229; bruke. P&#229; samme m&#229;te som state krever det heller ikke noe mer enn useRecoilState for at komponentet lytter til endringer p&#229; staten, mens man i Redux m&#229; bruke connect(mapStateToProps, mapDispatchToProps)(Component) for &#229; oppdatere staten.<\/p><p>&#160;<\/p><p>Av dokumentasjonen ser ogs&#229; Recoil ut til &#229; v&#230;re raskere &#229; sette opp for &#229; sm&#229; variabler ettersom det kun krever &#229; definere et atom, som s&#229; kan hentes med useRecoilState koden over, og s&#229; opereres p&#229; p&#229; lik m&#229;te som useState(), mens Redux krever oppsett av reducere som definerer hva som skal v&#230;re i objektet og hordan det skal oppdateres, samt actions som definerer hvilke type handlinger som er tillatt.<\/p><p>&#160;<\/p><p>Bruksmessig sett ser Recoil ut til &#229; f&#248;lge mer i kode-stilen til React ellers, og f&#248;lger bruk av hooks som man er vant til fra annen React kode, som kan gj&#248;re prosjektet mer oversiktlig og forst&#229;elig som en helhet enn f. eks. redux.<\/p><p>&#160;<\/p><p>Ettersom det har v&#230;rt en trend &#229; bruke funksjons-komponenter i det siste st&#248;tter tilsynelatende Recoil JS kun dette og ikke class-komponenter (og det planlegger de &#229; fortsette med https://github.com/facebookexperimental/Recoil/issues/63), s&#229; dersom man &#248;nsker &#229; bruke class-komponenter ser Redux, MobX, eller andre biblioteker ut til &#229; v&#230;re veien &#229; g&#229;.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Recoil er for n&#229; p&#229; versjon 0.1.1 fra 30. oktober 2020 (https://recoiljs.org/blog), og det at de er i en versjon som starter med 0. vil ofte si at det som utvikles er i en beta-versjon og ikke er like stabilt som andre mer etablerte&#160;l&#248;sninger.<\/p><p>Fra https://github.com/facebookexperimental/Recoil/graphs/commit-activity ser det ikke ut som biblioteket har commits fra f&#248;r 3. mai 2020, som vil tilsi at det er veldig nytt, og poengene under med potensielle breaking changes og lite community-dokumentasjon blir da forsterket.<\/p><p>&#160;<\/p><p>Ettersom det ogs&#229; ligger i github-organisasjonen Facebook experimental sier ogs&#229; noe om hvilket tidlig stadie biblioteket er i.<\/p><p>N&#229;r det er i et s&#229; tidlig stadie kan de heller ikke offisielt si at det st&#248;ttes av f. eks React Native (https://recoiljs.org/blog#react-native-experimental), som gj&#248;r at verdien av gjenbruk av kode mellom web-l&#248;sning og app-l&#248;sning vil synke drastisk om man &#248;nsker &#229; utvikle for begge.<\/p><p>&#160;<\/p><p>Dette kan p&#229;virke bruken av biblioteket negativt ettersom nylig-utviklede biblioteker kan ha funksjonalitet som endres etter at flere begynner &#229; ta det i bruk og oppdager problematiske features/bugs. Dette kan gj&#248;re det mer sannsynlig at de implementerer breaking-changes i nye versjoner enn det ville v&#230;rt i mer etablerte bibliotek. Dette kan da f&#248;re til at du er avhengig av &#229; f&#248;lge n&#248;ye med p&#229; utviklingen av biblioteket for &#229; kunne oppgradere og at det er vanskelig &#229; finne dokumentasjon for den versjonen du har om biblioteket beveger seg fort forover.<\/p><p>&#160;<\/p><p>En annen negativt aspekt sammenlignet med mer etablerte l&#248;sninger er at dokumentasjonen p&#229; siden kan v&#230;re mindre utviklet enn mer etablerte l&#248;sninger kan ha. Til sammenligning har Redux tutorials (https://redux.js.org/tutorials/essentials/part-1-overview-concepts) en sidemeny som inneholder store mengder artikler (dropper tidkrevende telling, men det er mange), mens (https://recoiljs.org/docs/basic-tutorial/atoms) har et mindre antall.<\/p><p>Dette inkluderer ogs&#229; utvikler-verkt&#248;y som f. eks. chrome developer tools, som det er planlagt &#229; slippe en prototype for (https://recoiljs.org/blog#future-work), men det er da en prototype som nok ligger et stykke bak developer tools til andre biblioteker.<\/p><p>&#160;<\/p><p>Utover hva slags dokumentasjon biblioteket tilbyr alene vil det ogs&#229; p&#229;virke hvor mye dokumentasjon som er tilgjengelig p&#229; stackoverflow, medium, youtube, etc. som uavhengige utviklere har laget, som kan gj&#248;re det lettere &#229; finne informasjon og l&#248;se problemer. Til sammenligning har &#34;redux js&#34; 15.2&#160;millioner s&#248;keresultater p&#229; google mens &#34;recoil js&#34; har 2.02 millioner.<\/p><p>Her skal det ogs&#229; nevnes at 2 millioner, til tross for at mange av s&#248;keresultatene nok ikke er rettet direkte mot facebook&#39;s recoil-bibliotek, er en imponerende mengde for et s&#229; ungt bibliotek. Det at det er utviklet av facebook gj&#248;r ogs&#229; at det er en stor interesse for veldig mange &#229; pr&#248;ve det ut og utvikle dokumentajson p&#229; det ettersom det er antatt at det kommer til &#229; v&#230;re veldig popul&#230;rt, hvilket gj&#248;r at denne negative siden raskt minsker.<\/p><p>&#160;<\/p><p>Et positivt aspekt ved &#229; bruke et nytt bibliotek som recoil er at det er laget etter redux, mobx, apollo og lignende biblioteker, av utviklere som har brukt disse bibliotekene og avdekket potensiale i hvordan de kan forbedres. Dette kan gj&#248;re at utviklingen g&#229;r enklere og at verkt&#248;yet er mer effektivt.<\/p><p>&#160;<\/p><p>I tillegg kan det ikke ignoreres at recoil utvikles av facebook, som vil tilsi at til tross for sitt tidlige stadie s&#229; har det en veldig stor sannsynlighet for &#229; fortsette &#229; bli utviklet og forbedret, og det er ikke usannsynlig at det kan bli veldig popul&#230;rt ettersom facebook er en stor akt&#248;r i markedet.<\/p><p>&#160;<\/p><p>Generelt sett vil jeg tenke at det kan v&#230;re et veldig praktisk og h&#229;ndterlig bibliotek &#229; utvikle i, men man b&#248;r v&#230;re forberedt p&#229; &#229; m&#248;te p&#229; bugs og breaking changes etterhvert som biblioteket utvikler seg og nye behov oppst&#229;r. Personlig ville jeg nok ventet litt lenger med &#229; bruke det p&#229; et prosjekt jeg er avhengig av &#229; kunne vedlikeholde og oppdatere. Definitivt noe som ser interessant &#229; teste p&#229; mindre prosjekter hvor det ikke er s&#229; kritisk om det er noe som ender opp med &#229; ikke fungere.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2249,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I et REST API har man typisk ett endepunkt per ressurs, noe som gj&#248;r hvert endepunkt mer separert og kan gj&#248;re det enklere &#229; teste, samtidig som andre endepunkter ikke trenger &#229; bli p&#229;virket av et enkelt endepunkt.<\/p><p>&#160;<\/p><p>Et stort problem med denne tiln&#230;rmingen er at man normalt sett vil ha ut forskjellig data som har en relasjon, som mennesker og deres handlekurv i en nettbutikk, hvor man da typisk vil v&#230;re n&#248;dt til &#229; sende en foresp&#248;rsel for handlekurven, en for personen og en for hvert produkt, som f&#248;rer til en stor mengde foresp&#248;rsler for ett sett av informasjon som ofte brukes sammen.<\/p><p>&#160;<\/p><p>GraphQL er et query-spr&#229;k som til forskjell fra REST APIer gir muligheten til &#229; utf&#248;re flere sp&#248;rringer i ett, og hvor man i foresp&#248;rselen ogs&#229; kan spesifisere n&#248;yaktig hvilke informasjon man &#248;nsker &#229; bli returnert, i motsetning til REST som returnerer et forh&#229;ndsdefinert resultatsett.<\/p><p>Dette f&#248;rer til at sp&#248;rringene blir en mindre belastning p&#229; nettverket, b&#229;de fordi det er f&#230;rre av dem men ogs&#229; fordi det kan finnes store mengder informasjon om et resultatsett man ikke trenger &#229; sende ettersom den ikke er forespurt.<\/p><p>Dette kan ogs&#229; v&#230;re et problem for GraphQL, ettersom det kan v&#230;re vanskelig &#229; kontrollere hvilke slags sp&#248;rringer APIet godkjenner, s&#229; det kan v&#230;re mulig for eksterne &#229; komponere arbeidskrevende sp&#248;rringer av un&#248;dvendig st&#248;rrelse som kan p&#229;virke responstiden til APIet og i verste fall kr&#230;sje det.<\/p><p>&#160;<\/p><p>En annen forskjell mellom REST og GraphQL er at REST kan sende alle typer data som kan sendes over nettet, som f. eks. bilder, mens GraphQL er begrenset til tekst. Dette er noe som ofte kan overkommes med &#229; konvertere dataene til tekst (f. eks. base64) eller &#229; peke til ressurser (f. eks. en URL til et bilde p&#229; nett), men som fortsatt er en vesentlig forskjell p&#229; de to som kan gj&#248;re dem gunstige til &#229; utf&#248;re forskjellige oppgaver.<\/p><p>&#160;<\/p><p>N&#229;r det kommer til caching kan REST APIer benytte seg av cachen som er inkludert i HTTP-spesifikasjonene (mange muligheter, liten tid, noen av dem tilgjengelige her https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching).<\/p><p>Ettersom GraphQL ikke f&#248;lger HTTP-spesifikasjonene har de ikke de&#160;samme innebygde mulighetene for caching, s&#229; man er mer avhengig av &#229; sette det opp selv, eller &#229; ha et bibliotek, etc. som tar seg av det. Dette gj&#248;r at man kan v&#230;re n&#248;dt til &#229; implementere caching de stedene man &#248;nsker &#229; koble seg til APIet, som for eksempel i frontend-koden, mens man i REST APIer kan definere regler for caching p&#229; webserveren hvor APIet kj&#248;res.<\/p><p>&#160;<\/p><p>REST APIer f&#229;r ogs&#229; fordelen av HTTP-routing ved &#229; f&#248;lge HTTP-spesifikasjoner, som gj&#248;r at forskjellige endepunkter kan h&#229;ndteres av forskjellige mikroservicer, i forskjellige spr&#229;k p&#229; forskjellige servere for &#229; v&#230;re s&#229; effektive som mulig og gj&#248;re det lettere &#229; skalere sidelengs.<\/p><p>&#160;<\/p><p>En annen stor forskjell er hvor gamle de forskjellige l&#248;sningene er. If&#248;lge denne artikkelen (https://blog.readme.com/the-history-of-rest-apis/) ble REST APIet introdusert i &#229;r 2000, mens GraphQL ble utviklet internt i facebook fra 2012 og publisert i 2015 (https://foundation.graphql.org/).<\/p><p>Dette har medf&#248;rt at REST har v&#230;rt en standard i mye lenger tid enn GraphQL, samtidig som GraphQL har f&#229;tt en god fartstid og blitt godt etablert.<\/p><p>Dette gj&#248;r igjen at store mengder av verkt&#248;y man har for &#229; arbeide med og teste APIer i utgangspunktet har hatt st&#248;tte for REST APIer men ikke GraphQL. Et eksempel p&#229; dette er Postman, et veldig kjent verkt&#248;y for &#229; b&#229;de utf&#248;re interaktsjoner og teste APIer, som ikke fikk GraphQL st&#248;tte f&#248;r juni 2019 (https://blog.postman.com/postman-v7-2-supports-graphql/).<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535727,"ext_inspera_userAssessmentSetupId":7140055,"ext_inspera_userAssessmentId":4841284,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Karstad Ådne (10143)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":25912610,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2010,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For &#229; ha dataflyt mellom komponenter i React bruker man tradisjonelt props. Disse brukes ved at man sender man data fra en komponent inn i neste, slik at det g&#229;r fra ytre-komponent til indre-komponent (react kaller det top-down). I andre situasjoner kan det hende man er n&#248;dt til &#229; synkronisere data p&#229; tvers av komponenter og sende dataflyt oppover (alts&#229; fra barnekomponent til forelderkomponent). Dette kan bli utfordrende &#229; gj&#248;re ved hjelp av tradisjonelle midler, og det er her global state management kommer inn.<\/p><p>&#160;<\/p><p>En av de st&#248;rre utfordringene med &#229; h&#229;ndtere tilstand i applikasjoner (s&#230;rlig st&#248;rre applikasjoner) er &#229; holde tilstanden konsekvent (consistent). Det er fort gjort at tilstanden blir &#34;ut av synk&#34; med lokale variabler, og at dataflyten derfor ikke er konsistent. Det er flere bilbiotek / l&#248;sninger som har fors&#248;kt &#229; finne enkle og gode metoder for &#229; holde tilstanden sikker og konsistent.<\/p><p>&#160;<\/p><p>De som er nevnverdige i dette faget er MobX, Redux, React Context API, og muligens Apollo Client.<\/p><p>&#160;<\/p><p>React Context API er nok det enkleste &#229; bruke. Da bruker man en enkel react Hook for &#229; sette tilstanden til &#233;n enkelt variabel. `const LanguageContext = React.createContext(&#39;en&#39;)` for &#229; sette en languagecontext til &#229; v&#230;re engelsk. Man m&#229; da wrappe de komponentene som skal ha tilgang til denne tilstanden ved hjelp av &#39;&#60;LanguageContext.Provder value=&#39;no&#39;&#62; ... komponenter ... &#60;/ LanguageContext.Provider&#62;&#39;.<\/p><p>Legg merke til at jeg n&#229; endret tilstanden til norsk, og at den jeg satte i createContext kun er den initielle verdien til tilstanden.<\/p><p>Ulempe med Context API er at man kun kan ha enkeltvariabler, man kan ikke ha mer kompliserte dataformer. I tillegg vil det raskt bli veldig komplisert dersom man har mange variabler man &#248;nsker &#229; h&#229;ndtere tilstanden til. Det vil derfor v&#230;re viktig &#229; v&#230;re sv&#230;rt viktig &#229; vurdere hvilke variabler man beh&#248;ver &#229; kontrollere tilstanden til gjennom context apiet, og om det v&#230;re vil v&#230;re like greit &#229; benytte props for &#229; sende data ned til komponenter. Dersom det blir for komplisert, s&#230;rlig dersom man skal h&#229;ndtere data som kommer fra en server vil det v&#230;re l&#248;nnsomt &#229; kunne benytte seg av eksterne bibliotek.<\/p><p>&#160;<\/p><p>MobX og Redux er to gode alternativ n&#229;r det kommer til &#229; h&#229;ndtere mer kompliserte tilstander, og disse fungerer ganske likt (ikke helt likt). De fors&#248;ker &#229; &#34;beskytte&#34; en global state og kaller denne for <em>the single source of truth<\/em>. Det handler hovedsakelig om at denne skal v&#230;re skrive-beskyttet (p&#229; en m&#229;te enkapsulert), og at alle variabler / data som flyter til komponentene skal bli utledet fra denne tilstanden.<\/p><p>Redux, som eksempel, wrapper applikasjonen i noe de kaller &#34;store&#34;. Alle de globale variablene (alts&#229; tilstanden) blir lagret i &#34;store&#34;, og alle komponenter som er innenfor wrapperen kan aksessere disse &#34;globale&#34; variablene.<\/p><p>For &#229; endre tilstanden m&#229; man gjerne &#34;dispatche&#34; en handling til tilstandsh&#229;ndtering. Denne vil tolke handlingen og utf&#248;re endringen s&#229; raskt som mulig, samtidig som at den automatisk synkroniserer tilstanden. Det er derfor viktig at dette er den eneste m&#229;ten &#229; endre tilstanden, og at man deretter utleder/deriverer variabelene ut fra denne <em>single source of truth<\/em>.<\/p><p>&#160;<\/p><p>Apollo Client brukes hovedsakelig for &#229; interagere med server, men har i tillegg utviklet metoder for &#229; h&#229;ndtere lokal (&#34;global&#34;) tilstand. Det som Apollo fors&#248;ker &#229; gj&#248;re er &#229; bruke Cache som <em>single source of truth<\/em> ved at man i cachen synkroniserer b&#229;de &#34;remote&#34; data og lokal data. Det gir dem en unik mulighet til &#229; sette opp sp&#248;rringer som b&#229;de henter ut &#34;remote&#34; og lokal data i samme sp&#248;rring. Dette er nok en av de st&#248;rste forskjellene fra Apollo og de andre bibliotekene, det at man Apollo selv h&#229;ndterer &#34;flettingen&#34; av lokal og remote data i en tilstand. I de andre bibliotekene skillder man sp&#248;rringene fra server, og man m&#229; selv skrive hvordan man ( om man &#248;nsker ) legger disse dataene i en tilstand hos klienten.<\/p><p>&#160;<\/p><p>- Apollo Client: https://www.apollographql.com/docs/react/local-state/local-state-management/<\/p><p>- MobX: https://mobx.js.org/getting-started.html<\/p><p>- React Context API: https://reactjs.org/docs/context.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2158,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil virker &#229; v&#230;re en videreutvikling av React Context API som h&#229;ndterer tilstanden i klientapplikasjonen. Det som snakkes om er at tilstandsh&#229;ndteringen i react er s&#230;rlig begrenset, men at det er et &#248;nske om &#229; beholde semantikk og oppf&#248;rsel tilsvarende s&#229; lik React som mulig. De argumenterer derfor med at det er en fordel &#229; bruke Recoil over andre bibliotek som tilbyr tilstandsh&#229;ndteringsl&#248;sninger, nettopp fordi Recoil l&#248;sningen er en god og naturlig utvidelse av React biblioteket.<\/p><p>&#160;<\/p><p>Jeg synes forklaringen deres:<br /><em>&#34;Recoil defines a directed graph orthogonal to but also intrinsic and attached to your React tree. State changes flow from the roots of this graph (which we call atoms) through pure functions (which we call selectors) and into components.<\/em>&#34;<\/p><p>minner veldig om MobX sin l&#248;sning som bruker et graf-tre for &#229; lagre tilstanden, og man m&#229; sende &#34;actions&#34; (i form av events eller lignende, som i bunn og grunn er funksjoner) for &#229; endre tilstanden.<\/p><p>&#160;<\/p><p>For min del h&#248;res det veldig fint ut at de har laget et enkelt grensesnitt hvor man like enkelt setter tilstanden som lokal tilstand, ved at de har tatt seg av enkapsulering (h&#229;ndtering av hvordan det faktisk fungerer). Det gj&#248;r det enkelt for utviklere &#229; fokusere p&#229; utviklingen og at man ikke har en stor oppstartskostnad ved &#229; sette opp masse &#34;boilerplate&#34; kode for &#229; komme i gang. Dette er s&#230;rlig et stor skille fra hvordan Redux fungerer, hvor man m&#229; sette opp ganske mye kode for &#229; f&#248;rst komme i gang.<\/p><p>P&#229; en annen side, kan det v&#230;re negativt at Recoil har enkapsulert alt av oppsett. Det gir l&#248;sningen f&#230;rre muligheter til &#229; tilpasses etter behov, fordi det opperer p&#229; en &#34;plug and play&#34; form. Jeg vil tro at det er ulike behov for ulike utviklere. Typisk vil nye utviklere, og muligens mindre bedrifter eller &#34;freelancers&#34; ha veldig stort utbytte av en slik l&#248;sning, fordi de er s&#229; lite oppstartskostnad og man kan raskt komme i gang med utviklingen. P&#229; den annen side, vil jeg tro at st&#248;rre selskap med st&#248;rre ressurser og mange flere behov for tilpasning vil synes en l&#248;sning som Redux eller MobX er &#229; foretrekke. MobX er for eksempel veldig tydelig at de ikke dikterer hvordan arkitekturen til applikasjonen skal v&#230;re (nederst: https://mobx.js.org/getting-started.html).<\/p><p>&#160;<\/p><p>En ulempe med Recoil er i tillegg at det er react spesifikt (s&#229; vidt jeg forst&#229;r), noe l&#248;sninger som Redux og MobX ikke er. Det vil si at dersom man har &#34;l&#229;st&#34; seg til Recoil og etter hvert begynner p&#229; et prosjekt i Angular, Vue eller andre rammeverk, s&#229; vil man ikke kunne bruke Recoil.<\/p><p>&#160;<\/p><p>For &#229; oppsummere virker det som at recoil har ganske lik l&#248;sning som MobX og Redux, men at de gj&#248;r alt enklere og med en mindre oppstartskostnad (mindre boilerplate). Jeg har definitivt lyst til &#229; velge Recoil til mitt neste prosjekt p&#229; grunn av simplisiteten. Det er en stor fordel at semantikken og oppf&#248;rselen er s&#229; lik React, noe som jeg tror vil gj&#248;re det enklere &#229; forst&#229; og komme i gang med Recoil. Det man b&#248;r vurdere at om man vil jobbe utelukkende med React i arbeidet sitt fremover, dersom man skal det tror jeg Recoil vil v&#230;re en utmerket l&#248;sning. Dersom man for eksempel jobber i en bedrift som benytter andre rammeverk ville jeg vurdert &#229; brukt en av de andre bibliotekene som er nevnt, fordi man da kan bruke kunnskap om disse i de andre prosjektene.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2115,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og Graphql benyttes for &#229; hente ut data fra en server, eller endre dataen p&#229; en server. I et REST API sender man sp&#248;rringer til endepunkt, f.eks &#39;https://example.api/users&#39;. Et slikt api er veldig tilpasningsorientert, og man kan tilordne det akkurat slik man &#248;nsker. Man forh&#229;ndsdefinerer hvilke felter man skal kunne hente ut, eller endre typisk gitt ved det man kaller serializers. Det er god st&#248;tte for &#229; bestemme &#34;permissions&#34;, slik at ulike brukere skal kunne hente ut ulik informasjon av de samme endepunktene.<\/p><p>&#160;<\/p><p>GraphQL er et type &#34;samlingspunkt&#34;, eller &#34;allokeringsside&#34;. Man sp&#248;r etter data fra den ene plassen og f&#229;r n&#248;yaktid den dataen man sp&#248;r etter. Det er viktig &#229; huske p&#229; at man kan bruke GraphQL som en allokering forran et REST API, men at man ogs&#229; kan bruke graphql uten rest api. For &#229; hente ut data med graphql definerer man en type &#34;payload&#34; som man sender med i requesten, denne skal inneholde en spesifikk graphql sp&#248;rring. Typisk p&#229; formen... (beklager lite kreativ sp&#248;rring)<\/p><p>`{<\/p><p>users {<\/p><p>&#160; name<\/p><p>&#160; age<\/p><p>&#160; dogs {<\/p><p>&#160;&#160;&#160; name<\/p><p>&#160; }<\/p><p>}`<\/p><p>Graphql tar deretter &#229; tolker denne sp&#248;rringen og henter ut relevant data, og sender KUN den dataen som blir sp&#248;rt etter tilbake.<\/p><p>For &#229; forklare dette i mer detalj se for deg at man bruker graphql forran et rest api, slik at graphql er det som henter ut fra apiet. Videre se for deg at apiet har to endepunkt, &#39;api/users&#39; og &#39;api/dogs&#39;.<br />Dersom graphql <strong>IKKE<\/strong> brukes, vil man v&#230;re n&#248;dt til &#229; sende GET-request til begge endepunktene, og man vil muligens f&#229; mye mer data enn det man trenger. Fra users kan man f.eks f&#229; alt av &#39;address&#39;, &#39;phone-number&#39;, mm. Og fra dogs kan man f&#229; &#39;breed&#39;, &#39;color&#39;, &#39;age&#39;, osv.<br />P&#229; den m&#229;ten slipper man det man kan kalle for &#34;overfetching&#34; av data, der klienten sitter med mer data enn den egentlig trenger. Eller motsatt &#34;underfetching&#34; dersom man ikke f&#229;r den dataen man trenger, dette vil typisk skje derom utviklerne av rest apiet har serializert bort mer enn n&#248;dvendig (lite relevant fordi hvis det er utviklet av samme folk vil man kunne endre dette enkelt, dersom det er et eksternt api vil man typisk ikke vite om feltene...).<\/p><p>&#160;<\/p><p>En annen betydelig forskjell fra rest og graphql er at rest st&#248;tter flere formatter enn graphql. Graphql st&#248;tter kun JSON formatet, der rest i bunn og grunn er ubegrenset. P&#229; den annen side, (tror jeg) at JSON har blitt en standard innenfor rest api, der xml var standarden f&#248;r (fortsatt mulig dette blir mye brukt enn&#229;?).<\/p><p>&#160;<\/p><p>En annen stor fordel med graphql er versjonering. Der man i rest-apier typisk vil versjonere ved hjelp av for eksempel &#39;api/v2/...&#39;, og at man da muligens m&#229; endre en del kode for &#229; tilpasse seg disse endringene, f&#229;r man ikke samme problematikk i graphql. I graphql som nevnt ovenfor sp&#248;r man om n&#248;yaktid den dataen man har behov for, det vil derfor si at utviklerne av serveren enkelt kan legge til et nytt felt uten at dette skal v&#230;re et problem. N&#229;r klienten som sp&#248;r etter felt vil integrere det nye feltet legger de det enkelt og greit til i sp&#248;rringen til &#39;api.com/graphql&#39;.<\/p><p>&#160;<\/p><p>En av de st&#248;rre fordelene med rest api er caching av requests. Data som f&#248;lger med en GET-request b&#248;r v&#230;re cacheable, og POST-request data kan v&#230;re cachable dersom det har en expiry (typisk auth tokens). Caching kan skje hos server eller klient, og form&#229;let er &#229; redusere belastningen p&#229; serveren, eller netttrafikkbelastningen. For eksempel kan det v&#230;re fordel sluttbruker &#229; kunne cache data lokalt p&#229; klienten dersom den har d&#229;rlig nettilkobling, da man slipper &#229; f&#229; en &#34;laggy&#34; opplevelse av applikasjonen.<\/p><p>Likevell, synes jeg det finnes mange gode l&#248;sninger for caching n&#229;r man bruker graphql. Jeg har nevnt litt av det tidligere, som for eksmepel ved bruk av Apollo Client f&#248;lger det med caching st&#248;tte &#34;ut av boksen&#34;.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Litt inspirasjon fra:<\/p><p>- LF eksamen 2019<\/p><p>- https://restfulapi.net/caching/<\/p><p>- https://www.blog.duomly.com/rest-api-vs-graphql-comparison/<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535820,"ext_inspera_userAssessmentSetupId":7139908,"ext_inspera_userAssessmentId":4841137,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nasiribehrouz Sepehr (10114)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330788,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1782,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React best&#229;r tar i bruk hierarkisk dataflyt med flyt at props (property) og states i det hierarkiske treet.&#160;<\/p><p>States i React er innebygd og inneholder &#34;property values&#34; som tilh&#248;rer gjeldende komponent. Ved &#229; sende props nedover til child eller oppover i treet har man mulighet til &#229; sende data gjennom applikasjonen som vil tillate endring, avlesing og manipulasjon av verdier p&#229; tvers av applikasjonen, som kalles for prop drilling som viser til prosessen man m&#229; g&#229; gjennom for &#229; hente data til forskjellige deler ac komponent-treet. Det finnes flere verkt&#248;y som mobX, Redux og Context som gj&#248;r denne jobben enklere og mer oversiktlig som vil bli diskutert.<\/p><p>Context API<\/p><p>React har et innebygd Context API som tillater en slik dataflyt uten &#229; m&#229;tte sende props opp- eller nedover komponenttreet, alts&#229; s&#229;kalte globale verdier som tillater forskjellige komponenter som ligger forskjellige steder i treet &#229; dele verdier uten &#229; m&#229;tte traversere gjennom treet og sende verdier. Dette f&#229;r man til gjennom &#229; wrappe komponentene inn i et context API og definere variabler som er tiltenkt, for s&#229; &#229; hente inn verdier gjennom useContext hos den enkelte komponentene. states i ContextAPI er immutable og krever derfor hooks med userstate og setstate til &#229; endre p&#229; states.<\/p><p>Dersom verdier i context API som blir benyttet av komponenter bli oppdatert, f&#248;rer dette til re-rendring av alle komponenter som bruker den verdien, som betyr at man helst vil ha globale verdier som ikke oppdateres ofte slik at komponentene kan unng&#229; un&#248;dvendig re-rendering.<\/p><p>Redux&#160;<\/p><p>Redux er den mest popul&#230;re m&#229;ten &#229; behandle states p&#229; som ogs&#229; tillater komponenter &#229; bruke globale variabler. Redux best&#229;r av en global store der all data ligger lagret i &#34;store&#34; og som kan aksesseres fra de forskjellige komponentene. Redux lagrer verdiene i JSON format og kan ta i bruk reducers til &#229; splitte store i logisk separate deler. Reducers er &#34;pure functions&#34; som betyr at states er forutsigbare og kan g&#229;s tilbake til dersom det er n&#248;dvendig. her er det ogs&#229; viktig &#229; nevne at states i redux er immutable (uforanderlige) og m&#229; derfor oppdateres av s&#229;kalte reducers. reducers kan bli sett p&#229; som en subset av store som har muligheten til &#229; endre states. Redux er vel egnet til &#229; bli brukt i st&#248;rre prosjekter og er skalerbart, men som krever en del &#34;boiler plate code&#34;.<\/p><p>i motsetning til Context, kan verdier som blir brukt av komponenter bli endret uten at det f&#248;rer til en re-rendering av siden som er en fordel, ettersom man kan ha states som ofte endrer verdi i store i motsetning til Context uten &#229; trigge en re-rendering. Dette gjelder ogs&#229; for MobX.<\/p><p>MobX<\/p><p>I motsetning til redux har mobX muligheten til &#229; ha flere &#34;stores&#34; slik som redux, der disse er logisk adskilt. MobX har mer abstrahering i forhold til Redux som gj&#248;r det ofte enklere &#229; forst&#229; og ta i bruk verkt&#248;yet for state management. MobX har heller ingen reducers som betyr at verdier kan bli endret og satt p&#229; tvers av applikasjonstreet som kan f&#248;re til uforutsigbarhet og vanskeligere &#229; debugge og teste i motsetning til Redux, som er enklere &#229; teste og finne feil. MobX egner seg vel til &#229; bli brukt i mindre applikasjoner eller applikasjoner som deler domene som kan ta i bruk spesifikke stores, som er et av fordelene til MobX.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2998,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en ny type state management bibliotek som minner om en blanding av Context API som Redux i form at dets virkem&#229;te. Recoil tar i bruk wrapping-metoden der det kreves en wrapper rundt komponentene for &#229; tillate manipulasjon og tilgang til dets states som minner om Context API. Recoil bruker atoms som er en state som har mulighet til &#229; lagre en form for data (string, number, array osv.) slik som React state, men som kan bli lest og satt til overalt i applikasjonen. atoms er immutable p&#229; samme m&#229;te som states i Redux og React states Komponenter som leser av verdier for den spesifikke &#34;atom&#34;, blir kalt for subscribers og oppdatering av atom vil f&#248;re til rerendering av alle komponenter som benytter seg av denne, som minner om Context API (se oppgave 1 for mer forklaring av ContextAPI).<\/p><p>atoms krever en initialisering med en unik n&#248;kkel og en default verdi for initialisering og har en fuksjon kalt selector som er bygd p&#229; samme m&#229;te, men som henter (selector) de verdiene i en atom som man &#248;nsker &#229; vise (som for eksempel om man &#248;nsker &#229; filtrere en atom som inneholder en liste med tall). selectors tar i bruk en get-funksjon som henter verdier og kan utf&#248;re forskjellige operasjoner som for eksempel filtrering av datasettet, og blir brukt i lik m&#229;te som atoms med useRecoilValue. Recoil muliggj&#248;r en m&#229;te &#229; mappe states fra react-components via data-flow graf, som ogs&#229; tillater asynkrone funksjoner i grafen, som blir sett p&#229; som et av fordelene med Recoil.<\/p><p>Recoil har mange likheter mellom Redux, mobX og Context API. slik som redux er det ikke n&#248;dvendig &#229; re-rendre alle komponenter dersom en state blir oppdatert og trenger kun &#229; re-rendre komponenter som benytter seg av de endrede states. Recoil har likheter med MobX der det er mulig &#229; endre states overalt i applikasjonen, som kan gj&#248;re utviklingsprosessen enklere, men som kan f&#248;re til uforutsigbare endringer og vanskeligheter med debugging og testing. Recoil bruker en wrapper slik som Context API for &#229; muliggj&#248;re state management som minner om ContextAPI og tar i bruk tilsvarende funksjoner som useState og setState (useRecoilValue &#38; selectors). Ettersom Recoil minner veldig om state management som allerede finnes i React, vil fordelene med Recoil potensielt v&#230;re at det er en enklere overgang og l&#230;ringskurve for de som har tidligere erfaring fra React, samtidig som det kreves mindre kode enn i forhold til for eksempel redux (boiler plate code) for &#229; f&#229; en fungerende state management. Potensielle ulemper i Recoil er etter min mening at det kan bli vanskelig &#229; debugge og ikke ha en global store slik som i redux med single source of truth, som gj&#248;r det mer uoversiktelig for utenforst&#229;ende &#229; sette seg inn i den potensielle applikasjonen som bruker Recoil.<\/p><p><br />&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2246,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API&#160; og GraphQL er to forskjellige m&#229;ter &#229; sende state over http mellom for eksempel en backend og en frontend. REST er den tradisjonelle metoden &#229; transportere state, mens graphQL innf&#248;rer en ny metode &#229; transportere data p&#229;.<\/p><p>REST bruker et sett med predefinerte stateless operasjoner (GET, POST, PUT, DELETE) til &#229; sende request til endepunkter for &#229; utf&#248;re det &#248;nskede arbeidet og endepunktene m&#229; ogs&#229; h&#229;ndtere disse. GraphQL tar i bruk en annen metode for &#229; utf&#248;re slike operasjoner med kun en POST operasjon til et endepunkt som kan utf&#248;re de samme operasjonene som REST uten &#229; ha behov for forskjellige endepunkter og queries. Dette er et av de st&#248;rste forskjellene mellom REST og GraphQL der REST krever spesifikke endepunkter for &#229; hente spesifikk data, mens GraphQL h&#229;ndterer dette gjennom kun ett endepunkt og h&#229;ndterer en query.<\/p><p>GraphQL ser p&#229; &#34;alt&#34; som en graf i motsetning til REST der alt er koblet sammen som muliggj&#248;r det ovennevnte, noe REST ikke gj&#248;r og ser p&#229; forskjellige endepunkter som uavhengige noder. Det gj&#248;r at graphQL gj&#248;r det mulig gjennom queries &#229; sende requests som er spesifisert med hvilken data man sender og hva man &#248;nsker &#229; f&#229; i respons, for s&#229; &#229; kun f&#229; den responsen man &#248;nsker uten ekstra innhold som REST ofte gj&#248;r. I REST er det ikke mulig &#229; spesifisere om man &#248;nsker deler av resultatsettet.<\/p><p>Vi kan ta for oss en database med b&#248;ker som et eksempel som lettere vil forklare dette. Dersom man &#248;nsker &#229; f&#229; vite utgivnings&#229;r for en spesifikk bok gjennom REST (og antar at endepunktet returnerer bok-objektet), vil man sende en request over http der man &#248;nsker &#229; hente boken, der REST sender et JSON objekt som inneholder all lagret info om denne boken og den som forespurte utgivnings&#229;r mottar da mer informasjon enn det som ble forespurt. dette kalles ofte for overfetching. I graphQL er det derimot mulig &#229; sende en request for denne boken med en &#248;nsket respons p&#229; kun utgivnings&#229;r.<\/p><p>En motsetning til overfetching i REST er dersom man &#248;nsker &#229; f&#229; vite hvem forfatteren til boken er som er referert til i boken. REST m&#229; da gj&#248;re to kall, f&#248;rst p&#229; boken, for s&#229; &#229; bruke reference key til forfatter i boken til &#229; gj&#248;re ny query for &#229; hente ut informasjon om forfatteren. dette kalles for underfetching. GraphQL kan derimot gj&#248;re dette p&#229; en request der den foresp&#248;r begge samtidig, som for eksempel: get(book {title, author {name}}) og f&#229; det &#248;nskede resultatet.&#160;<\/p><p>De st&#248;rste forskjellene mellom disse to er at REST er et konsept for stateoverf&#248;ring som er mer utbredt og har et stort brukerbase, mens graphQL er et sp&#248;rrespr&#229;k med queries med mindre brukerbase. REST API har flere spesifikke endepunkter uten mulighet for klienten &#229; foresp&#248;rre spesifikk respons og m&#229; h&#229;ndtere responsen selv, i motsetning til graphQL der man kan foresp&#248;rre en spesifikk respons.GraphQL l&#248;ser problemet med over og under fetching, men som samtidig ikke har eksplisitt caching i HTTP-laget der tidligere respons kan bli brukt p&#229; nytt uten h&#229;ndtering i serversiden, noe REST oppn&#229;r. det er likevel mulig for graphQL &#229; cahce, men det kreves da mer jobb enn i REST.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535953,"ext_inspera_userAssessmentSetupId":7140077,"ext_inspera_userAssessmentId":4841194,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Røhne Amund Lunke (10040)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35108898,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1457,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r man utvikler i react har man en rekke mekanismer som man kan bruke for dataflyt.&#160;<\/p><p>&#160;<\/p><p>State:&#160;<\/p><p>- State lagrer variabler lokalt i et komponent. N&#229;r det skjer endringer i disse variablene vil komponentet og alle dets barnekomponenter bli rendret p&#229; nytt. I et klassekomponent vil man endre state gjennom setState, mens i et funksjonelt komponent vil man bruke useState hooken.&#160;<\/p><p>&#160;<\/p><p>Props:&#160;<\/p><p>- Props er variabler som kan gis til et komponent, for &#229; flytte informasjon nedover i komponent hierarkiet. Om man &#248;nsker &#229; flytte informasjon oppver i treet ved hjelp av props, vil man definere en funksjon i foreldrekomponentet som man sender ned som et prop i komponentet man &#248;nsker &#229; sende opp fra. Barnekomponentet kaller deretter p&#229; denne funksjonen, som igjen endrer state i foreledrekomponentet. Dette kan fort bli rotete, og man ender ofte opp med funksjoner i komponenter hvor det ikke n&#248;dvendigvis gir mening &#229; ha de (feks n&#230;rmeste forelder for to komponenter).&#160;<\/p><p>&#160;<\/p><p>Context:&#160;<\/p><p>- Context brukes til &#229; dele en state med mange komponenter, og gjerne dypt nede i komponentstrukturen uten &#229; m&#229;tte sende props hele veien ned. P&#229; denne m&#229;ten unng&#229;r man s&#229;kalt prop-drilling. I contextet kan man skrive hooks som kan brukes til &#229; endre staten, er dermed immutable. Et problem med denne l&#248;sningen er at komponentene som konsumerer contextet&#160;vil oppdateres (re-rendres) ved endring og er dermed mer egnet for variabler som oppdateres sjeldent, da kan det v&#230;re &#248;nskelig &#229; heller bruke verkt&#248;y som redux eller mobx.&#160;<\/p><p>&#160;<\/p><p>Tredjeparts:&#160;<\/p><p>&#160;<\/p><p>Redux:&#160;<\/p><p>- Redux er et tredjepartsbibliotek med st&#248;tte for react. Det lar deg definere actions, reducers og en store som man kan lese fra og skrive informasjon til. Storen er i immutable, og informasjonen oppdateres ved &#229; &#34;dispatche&#34; actions som gj&#248;r endringer i store ved hjelp av en reducer. Man kan lage flere stores som kombineres sammen til en st&#248;rre store, men det vil aldri v&#230;re mulighet for &#229; kunne laste inn hver enkelt store individuelt. Redux er kjent for &#229; v&#230;re mer skalerbart enn det mobx er.&#160;<\/p><p>&#160;<\/p><p>Mobx:&#160;<\/p><p>- Mobx er et alternativ til redux, som ofte blir betraktet som enklere &#229; l&#230;re seg, til tross for at redux er det mer popul&#230;re valget. De st&#248;rste forskjellene er at man alltid har minst 2 stores, en for UI og en for domain. I tillegg kan storen endres hvor som helst, og ikke kun gjennom actions. At man kan ha flere stores f&#248;rer til at man kan hente mindre mengder informasjon om gangen, og dermed lage en mer effektiv applikasjon/nettside.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3333,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil ser ut til &#229; v&#230;re et veldig&#160;<em>lightweight&#160;<\/em>bibliotek for state behandling. Hooks brukes for &#229; hente og endre state, p&#229; lik m&#229;te som med useState, men p&#229; et globalt niv&#229;.&#160;Biblioteket ser ogs&#229; ut til &#229; v&#230;re utviklet p&#229; en slik m&#229;te at det skal v&#230;re enkelt for noen med erfaring med React &#229; sette seg inn i.&#160;<\/p><p>&#160;<\/p><p>vs Redux:&#160;<\/p><p>- I motsetning til Redux kan den globale staten bli endret hvor som helst, som igjen kan f&#248;re til at det blir vanskeligere &#229; teste funskjonaliteten skikkelig. I tillegg er det ikke &#233;n enkelt state &#229; forholde seg til, som igjen kan skape forvirring om&#160;<em>atoms&#160;<\/em>har overlapp i informasjonen de inneholder (<em>single source of truth<\/em>).&#160;<\/p><p>- Man slipper &#229; skrive actions, reducers og h&#229;ndtering av store, noe som reduserer boilerplate i stor grad.&#160;<\/p><p>- Det ser ut til &#229; v&#230;re enklere &#229; l&#230;re seg, da koden er sammenlignbar med React hooks.&#160;<\/p><p>- Recoil har mer effektiv bruk av ressurser da ikke hele staten alltid m&#229; lastes inn.&#160;<\/p><p>&#160;<\/p><p>vs MobX:&#160;<\/p><p>- P&#229; samme m&#229;te som med MobX kan state endres hvor som helst.&#160;<\/p><p>- Lettere &#229; l&#230;re seg Recoil om man har tidligere erfaring med React.<\/p><p>&#160;<\/p><p>vs Context API:&#160;<\/p><p>- Begge deler state ved &#229; wrapper flere barnekomponenter.&#160;<\/p><p>- Recoil oppdaterer ikke alle komponenter med en kobling til komponentet som blir wrappet, kun de komponentene som abonnerer p&#229; selectors eller atoms hvor det skjer en endring i state. Man &#248;nsker alts&#229; minimale mengder med informasjon i atoms, og heller abstrahere mye informasjon ut av selectors for &#229; unng&#229; flest mulige re-renders.&#160;&#160;<\/p><p>&#160;<\/p><p>Alt i alt virker det som at Recoil er en fin mellomting mellom Context og Redux/MobX. Det er enklere &#229; l&#230;re seg, krever langt mindre kode enn Redux, men sprer koden rundt i komponentene som kan gj&#248;re kodebasen vanskeligere &#229; vedlikeholde og skalere.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2185,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API:&#160;<\/p><p>- Man lager <strong>flere <\/strong>endepunkter for &#229; hente spesifikk informasjon. M&#229; dermed ofte gj&#248;re flere requests for &#229; hente tilstrekkelig informasjon.&#160;<\/p><p>- Har ofte problemer med &#229; hente for mye eller for lite informasjon (over- og underfetching)<\/p><p>- Bruker HTTP requestene, GET, PUT, POST, DELETE for &#229; hente, endre, legge til, og slette informasjon.&#160;<\/p><p>- Er langt mer etablert enn graphql.&#160;<\/p><p>- REST er i utgangspunktet et nettverkskonsept/designfilosofi&#160;for api endepunkter.&#160;<\/p><p>- Benytter browser caching i stor grad.&#160;<\/p><p><br />Graphql:&#160;<\/p><p>- Bruker HTTP POST requests for alt.&#160;<\/p><p>- Henter informasjon fra <strong>et<\/strong> endepunkt, og bruker queries i en post body (fremfor URI queries/parametere)&#160;for &#229; definere hva man &#248;nsker tilbake.&#160;<\/p><p>- Definerer akkurat hva slags informasjon man &#248;nsker &#229; hente og hva man vil at skal bli returnert i queryet. Har som regel ikke problemer med over- og underfetching p&#229; grunn av dette. F&#248;rer til mer effektive applikasjoner.&#160;<\/p><p>- Graphql er i utgangspunktet et queryspr&#229;k og verkt&#248;ysett.&#160;<\/p><p>- Benytter ikke browser caching i utgangspunktet (tredjepartskode som feks Apollo har st&#248;tte for dette).&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11538274,"ext_inspera_userAssessmentSetupId":7140043,"ext_inspera_userAssessmentId":4841244,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:07Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Synnestvedt Christoffer (10007)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330550,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er flere m&#229;ter &#229; h&#229;ndtere state og dataflyt p&#229; i React. Den &#34;enkleste&#34; av disse er ved bruk av lokal state som gj&#248;res med enten klasser eller ved hooken useState() i funksjonelle komponenter. Her vil state v&#230;re tilgjengjelig for kun den komponenten den brukes i med mindre man sender den nedover i komponenthierarkiet gjennom props, eller oppover gjennom funskjoner. Dette gj&#248;res ved at child komponenten tar inn en funksjon fra parent, s&#229; n&#229;r noe skjer i child komponenten kan det endre state i parent. Videre har vi context API&#39;et som brukes for &#229; h&#229;ndtere global data, s&#229; her slipper man &#229; sende data gjennom hierarkiet manuelt. Det er alts&#229; en metode for &#229; definere data globalt slik at det kan brukes av alle komponentene. Man kan bruke dette p&#229; data som er ment &#229; brukes av mange komponenter som ligger ulike steder i hierarkiet.<\/p><p>&#160;<\/p><p>Videre har vi state management rammeverkene Redux og MobX. I Redux lagrer man dataen i en read-only store og bruker dispatch-metoden som tar inn en action for &#229; endre dataen. For &#229; hente ut dataen bruker man useSelector hooken. F&#229;r alle komponentene skal ha tilgang til dataen m&#229; man &#34;wrappe&#34; applikasjonen i redux sin &#60;Provider&#62;. N&#229;r en komponent endrer p&#229; noe av dataen og kaller dispatch metoden vil alle reducere i storen lytte etter endringer, og den/de reducerne som har riktig type i switch statementet sitt vil utf&#248;re funksjonen sin.<\/p><p>MobX handler mer om &#229; gj&#248;re datastrukturer observerbare og komponenter til observat&#248;rer. Her oppretter man ogs&#229; en &#34;store&#34; som gj&#248;res observerbar slik at komponentene som observerer storen kan reagere p&#229; endringer.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3812,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React, s&#229; det kan med andre ord ikke benyttes i applikasjoner basert p&#229; andre rammeverk. Det benytter seg av atoms, som er state enheter som kan oppdateres og lyttes til av komponenter. S&#229; n&#229;r et atom endrer seg vil alle komponentene som lytter til dette atomet re-rendre. Det ser ut som at atoms kan brukes p&#229; samme m&#229;te som lokal state, bare at det er globalt s&#229; alle komponenter som lytter til det vil ha tilgang. M&#229;ten man bruker det i komponenter er ved hjelp av hooken useRecoilState, og bruken av denne er akkurat den samme som useState hooken for lokal state i React. Biblioteket virker som en blanding av MobX og lokal state. Det jeg mener med det er at det har noe av de samme konseptene som MobX med tanke p&#229; observeable og observer, og at det i komponentene brukes p&#229; samme m&#229;te som lokal state i funksjonelle komponenter. Recoil har ogs&#229; noe som heter selector. Dette kan brukes for &#229; lage dynamiske datasett som er avhengige av annen data. Her kan man for eksempel lage en selector som sorterer/filtrer en liste med objekter. Siden en selector er avhengig av andre states vil den oppdatere resultatet dersom en av de endres. I en selector kan man ogs&#229; gj&#248;re asynkrone kall til en database for &#229; hente ut data. Dette gj&#248;res ved &#229; returnere et Promise eller bruke en asynkron funksjon. Resultatet vil caches s&#229; kallet vil bare utf&#248;res en gang per unike input. Recoil st&#248;tter React Suspense slik at man kan fange opp om selectoren jobber med &#229; returnere data. Selectorene kan ogs&#229; h&#229;ndtere feil dersom sp&#248;rringen til databasen feiler.<\/p><p>&#160;<\/p><p>S&#229; for &#229; oppsummere virker det som at Recoil er mer brukervennlig og lettere &#229; sette seg inn i enn MobX og Redux, ettersom bruken ligner en del p&#229; lokal state i funksjonelle komponenter. Atoms virker som en veldig grei m&#229;te &#229; h&#229;ndtere global state og alle komponenter som lytter til atomet vil oppdateres n&#229;r verdien til atomet endres. Videre virker selectors som et kraftig verkt&#248;y for &#229; utf&#248;re operasjoner som er avhengig av state. Kombinasjonen av selector og atoms gj&#248;r at man ikke trenger &#229; ha mye data i atomet, ettersom man kan benytte seg av selectorene for &#229; f&#229; hente ut data basert p&#229; det som ligger i atomet.<\/p><p>&#160;<\/p><p>Biblioteket er veldig nytt og er i versjon 0.1.1 s&#229; det er mye experimental. Ettersom det er s&#229;pass nytt vil jeg kanskje ikke begynt &#229; bruke det i produksjon med det f&#248;rste. Dette fordi det mest sannsynlig vi komme en del oppdateringer som kan p&#229;virke utviklingen relativt raskt. Jeg ville kanskje vurdert &#229; begynne &#229; bruke det i produksjon n&#229;r neste major release kommer ettersom det mest sannsynlig vil v&#230;re implementert en del ny funksjonalitet og den funksjonaliteten som er der n&#229; vil v&#230;re godt testet. Siden det er i en s&#229; tidlig fase er det heller ikke s&#229; veldig mye funksjonalitet som er implementert og det er mulig det mangler st&#248;tte for andre rammeverk. Biblioteket har ogs&#229; begrenset/ingen developer tools for weblesere, men ser at de planlegger &#229; gi ut en for google chrome. [fra blogen til dokumentasjonen]<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1803,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av de st&#248;rste forskjellene mellom de er hvordan man henter data p&#229;. I REST definerer man endepunkter som man aksesserer gjennom URI, mens i GraphQL sender man sp&#248;rringer direkte til serveren der man ettersp&#248;r konkret data og s&#229; f&#229;r man tilbake JSON objekt med den dataen man &#248;nsket. S&#229; dersom man &#248;nsker &#229; hente ut en del forskjellig data m&#229; man med REST innom mange forskjellige endepunkter som vil f&#248;re til at man kan overfetche (f&#229; for mye data) eller underfetche (f&#229; for lite), mens i GraphQL vil man kunne f&#229; til dette med en sp&#248;rring. Grunnen til at REST vil kunne f&#229; problemer med over- og underfetching er at det er serveren som bestemmer hvordan dataen ser ut og gjennom kall til URIen vil man f&#229; ut et datasett p&#229; en gitt form. I GraphQL vil klienten som sagt kunne definere hva man skal f&#229; tilbake fra serveren, s&#229; her skal det ikke v&#230;re noen fare for &#229; f&#229; tilbake for mye eller for lite.<\/p><p>Videre bruker REST caching automatisk gjennom webleseren, men man kan ogs&#229; definere cachen selv. I GraphQL er det ingen form for automatisk caching s&#229; dette m&#229; man opprette p&#229; egenh&#229;nd dersom man &#248;nsker &#229; ta det i bruk.<\/p><p>GraphQL returnerer utelukkende JSON, mens i et REST API man har laget selv kan man definere hva slags data som skal returneres til klienten.<\/p><p>GraphQL baserer seg p&#229; skjema der man definerer objekt typer og typen til feltene i objektet (name: String!). Dette gj&#248;r at n&#229;r man gj&#248;r sp&#248;rringer til databasen kan man sjekke med skjemaet for &#229; hvite hva slags type feltene i resultatet vil ha. Dette brukes ogs&#229; n&#229;r man skal oppdatere innholdet i databasen gjennom mutations.<\/p><p>I REST benytter man av tilstandsl&#248;se operasjoner som PUT, POST, GET og DELETE for &#229; si hva man vil gj&#248;re i endepunktet. Disse er tilstandssl&#248;se som betyr at de tjeneren ikke trenger &#229; huske klientens foresp&#248;rsler.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11540050,"ext_inspera_userAssessmentSetupId":7140047,"ext_inspera_userAssessmentId":4841243,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hensvold Torleif Naadland (10104)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":16521217,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1306,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>F&#248;rst og fremst har vi muligheten for tilstand(state) i hver komponent, gjennom objekter eller bruk av hooks ved funksjonelle komponenter. Dette er generelt greit s&#229; lenge det kun er komponenten som har behov for &#229; benytte denne tilstanden.<\/p><p>&#160;<\/p><p>Med en gang vi trenger tilgang til tilstanden til en komponent i en komponent i et underhierarki eller i &#34;parent&#34;-komponenter m&#229; vi starte med mer kompliserte teknikker.<\/p><p>Den man f&#248;rst m&#248;ter p&#229; er ofte det som kalles &#34;prop drilling&#34; dersom man trenger &#229; g&#229; gjennom flere lag med komponenter for &#229; komme til komponenten som trenger tilgang til tilstanden. Dette betyr at man i alle lagene med komponenter mellom komponenten som har tilstanden og komponenten som trenger tilgang sender tilstanden og funksjonen for endring av tilstanden som &#34;props&#34; til hvert lag/hver komponent, og er generelt en d&#229;rlig l&#248;sning da dette er vanskeligere &#229; vedlikeholde og holde orden p&#229;.<\/p><p>Man kan heller bruke global tilstand gjennom Context eller et tredjeparts-bibliotek for tilstandsh&#229;ndtering som Redux eller MobX. Context er innebygd i React, og i det minste bruker Redux Context som underliggende API, men legger p&#229; en del ekstra for &#229; pr&#248;ve &#229; gj&#248;re det enklere &#229; bruke og utvide bruksomr&#229;dene.<\/p><p>&#160;<\/p><p>Ved bruk av Context eller andre tilstandsh&#229;ndteringsmetoder er det generelt slik at man kaller en metode for &#229; oppdatere tilstanden, man oppdaterer ikke tilstanden direkte. Dette er for &#229; sikre at programflyten blir riktig, slik at n&#229;r tilstanden oppdateres gjennom oppdateringsmetoden er det ikke flere tilstandsendringer som skjer samtidig, og at alt som har bedt om &#229; f&#229; oppdatering ved tilstandsendring f&#229;r denne oppdateringen.<\/p><p>&#160;<\/p><p>Tilstandsh&#229;ndteringsmetoder krever vanligvis &#229; v&#230;re den &#248;verste komponenten, eller i hvertfall kan det ikke gj&#248;re noe med komponenter h&#248;yere i hierarkiet enn seg selv. Komponenter som &#248;nsker &#229; bruke tilstanden hekter seg p&#229; og f&#229;r deretter oppdateringer n&#229;r noe skjer med tilstanden de har hektet seg p&#229;. Med tredjepartsbibliotekene er det gjort enklere &#229; ha flere tilstandsverdier/-variabler man kan hekte seg p&#229; i samme tilstandsh&#229;ndteringsobjekt, slik at man kan separere oppdateringer til kun de komponentene som faktisk m&#229; endre seg ved tilstandsoppdatering.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Dataflyt g&#229;r generelt kun &#232;n vei, fra h&#248;yt i hierarkiet og nedover. Det er dette som er enklest gjennom &#229; bruke props. Men det er mulig &#229; sende dataflyt til komponenter h&#248;yere i hierarkiet, det krever bare at man faktisk legger til rette for det med &#229; gi de lavere komponentene tilgang til metoder for &#229; oppdatere eller sende data til de komponentene gjennom props.<\/p><p>Generelt b&#248;r dette unng&#229;s, siden det gj&#248;r det vanskeligere &#229; vedlikeholde og &#229; holde oversikt over dataflyt. Da b&#248;r heller global tilstand eller lignende brukes.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2917,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil&#160;beskriver seg selv som et tilstandsh&#229;ndteringsbibliotek for React. Det betyr i bunn og grunn at det skal hjelpe til &#229; h&#229;ndtere tilstand i applikasjoner som bruker React.<\/p><p>&#160;<\/p><p>For det f&#248;rste ser det ut til at Recoil kun kan brukes til funksjonelle komponenter, mens Redux i det minste har mulighet til &#229; late som at ting er &#34;props&#34; slik at objektbaserte komponenter kan bruke tilstanden.<\/p><p>&#160;<\/p><p>Det ser ut til at Recoil ikke trenger en definert &#34;store&#34; hvor tilstanden h&#248;rer hjemme, og da alts&#229; ikke har behov for at &#34;reducers&#34; er laget for &#229; kunne bruke tilstandsh&#229;ndteringen.<\/p><p>Recoil bruker &#34;atom&#34; litt p&#229; samme m&#229;te som stores i Redux, men hvert &#34;atom&#34; er bare &#232;n tilstand/variabel i tilstand, mens stores ofte inneholder mye tilstand i bruk av Redux.<\/p><p>&#160;<\/p><p>Recoil ser ut til &#229; ligne mye mer p&#229; React i bunn og grunn, og bruker useRecoilState(), som er tett opptil vanlige React hooks som useState(), og ser ut til &#229; oppf&#248;re seg p&#229; samme m&#229;te. Men n&#229;r man oppdaterer state i en komponent med useRecoilState() ser det ut til at det egentlig oppdatere et &#34;atom&#34;, som igjen fyrer av en oppdatering om at den har blitt oppdatert og at komponenter som har &#34;subscribed&#34; til det atomet m&#229; oppdatere.<\/p><p>Dette er mye enklere enn Redux, hvor man m&#229; sette opp &#34;reducers&#34; med definerte &#34;actions&#34; for &#229; kunne oppdatere tilstanden.<\/p><p>Redux har mye tyngre innl&#230;ring og fastere m&#229;ter &#229; brukes p&#229;, som gj&#248;r kode mer rigid med mye mer boilerplate-kode for &#229; f&#229; til, mens Recoil ser ut til &#229; v&#230;re veldig minimalistisk og funksjonelt.<\/p><p>&#160;<\/p><p>Dette med &#229; m&#229;tte definere &#34;actions&#34; og sette opp &#34;reducers&#34; kan v&#230;re b&#229;de fordel og ulempe med Redux, siden det kan v&#230;re noe som tar altfor mye tid og krefter &#229; sette opp for en liten applikasjon, mens det for en stor monolitt av en applikasjon kan v&#230;re veldig kjekt &#229; vite at man har all logikken samlet p&#229; ett sted og har litt bedre kontroll p&#229; denne m&#229;ten.<\/p><p>P&#229; samme m&#229;te vil da Recoil ha litt motsatte fordeler og ulemper, ved at det er veldig mye enklere &#229; bruke i starten av et prosjekt, men n&#229;r prosjektet blir stort nok kan det gj&#248;re det mye mindre oversiktlig siden man kan oppdatere tilstanden p&#229; veldig mange forskjellige m&#229;ter i forskjellige komponenter. Dette b&#248;r kunne fikses litt med &#229; kun &#34;subscribe&#34; til state changes i selve komponenten, og lage egne klasser for &#229; oppdatere tilstand. Men dette begynner da &#229; ligne p&#229; Redux med &#34;reducers&#34; igjen.<\/p><p>Dette kan jo fors&#229;vidt v&#230;re positivt i og med at det ser ut til at det skal v&#230;re mulig &#229; starte raskt og iterativt tidlig, og s&#229; systematisere etter hvert som &#34;scope&#34; blir st&#248;rre og man f&#229;r litt mindre oversiktlig prosjekt.<\/p><p>&#160;<\/p><p>Sjekket litt rundt og forskjellige kilder ser ut til &#229; tilsi at Recoil kun kan brukes med React, mens Redux og andre tilstandsh&#229;ndteringsbibliotek kan brukes uten React. Dette st&#248;ttes egentlig av at Recoil selv spesifikt sier at det er for React.<\/p><p>&#160;<\/p><p>Det ser ut til at Recoil kommer til &#229; bli et meget bra bibliotek for tilstandsh&#229;ndtering, men enn s&#229; lenge er det veldig f&#229; som bruker det, det er ikke s&#229; mye god dokumentasjon og eksempler som bruker det p&#229; de utrolig mange m&#229;tene som folk kan ha lyst til &#229; bruke det p&#229;, i motsetning til de allerede eksisterende bibliotekene som har veldig mange som bruker dem og de aller fleste sp&#248;rsm&#229;l rundt bruken av dem er besvart gjennom blogger, StackOverflow, og annet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2297,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API best&#229;r i bunn og grunn av mange endepunkter som hver tilsvarer en foresp&#248;rsel til database eller i det minste &#232;n foresp&#248;rsel til backend, som selv kan ha mer enn bare sp&#248;rring til database som programflyt.<\/p><p>I REST er det naturlig &#229; ha [url]/users for &#229; f&#229; tak i for eksempel id til alle brukere og [url]/users/11 for &#229; f&#229; tak i informasjonen til bruker med id lik 11.<\/p><p>For GraphQL er det vanlig &#229; kun ha ett endepunkt hvor man kan f&#229; tak p&#229; all informasjonen man m&#229;tte brukt mange endepunkter for &#229; f&#229; tak i med REST. En stor fordel med GraphQL er at det er lettere &#229; unng&#229; problemer med under- eller over-fetching, da det er lagt inn at man skal kunne be om akkurat informasjonen man trenger. GraphQL er p&#229; mange m&#229;ter litt mer fleksibelt enn REST &#242;g, ved at den som ber om data fra endepunktet definerer formatet de &#248;nsker &#229; f&#229; dataene p&#229; gjennom formatet p&#229; sp&#248;rringen til endepunktet.<\/p><p>For eksempel ville query{users{id name}} returnere en liste over alle brukere, vanligvis&#160;i JSON-format, med samme format som brukt; alts&#229; med id og navn i den rekkef&#248;lgen for hver bruker.<\/p><p>GraphQL bruker parameter for &#229; kunne f&#229; samme effekt som REST sin&#160;[url]/users/11, ved &#229; bruke query{users(id: 11){id name}}, og bruken av parametre med GraphQL kan gi all mulig funksjonalitet, s&#229; lenge det er implementert p&#229; endepunktets server/backend.<\/p><p>&#160;<\/p><p>REST er generelt mye mer statisk enn GraphQL, og man trenger mange flere foresp&#248;rsler for &#229; f&#229; all data man trenger dersom man har mye forskjellig data man &#248;nsker &#229; f&#229; tak p&#229;. GraphQL gir muligheten til &#229; sp&#248;rre om all data man trenger p&#229; &#232;n gang, som ogs&#229; gir backend mulighet til &#229; ha smartere l&#248;sninger for &#229; respondere raskere med data som er etterspurt, siden man kan ta for seg hele forsep&#248;rselen samtidig i stedet for &#229; gj&#248;re ting del for del.<\/p><p>&#160;<\/p><p>Fordelen med REST er at den er godt innarbeidet og veldig mange vet hvordan man skal interagere med endepunkter. Men det fine med GraphQL er at man ikke trenger &#229; fjerne REST for &#229; implementere det. Man kan starte med &#229; bruke det man har av REST API til &#229; bygge opp GraphQL-endepunktet umiddelbart, og s&#229; kan man optimalisere GraphQL-endepunktet etter hvert.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Hovedforskjeller mellom REST og Graphql<\/p><table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\t<thead>\t\t<tr>\t\t\t<th scope=\"col\">REST<\/th>\t\t\t<th scope=\"col\">GraphQL<\/th>\t\t<\/tr>\t<\/thead>\t<tbody>\t\t<tr>\t\t\t<td>Mange endepunkter<\/td>\t\t\t<td>Ett endepunkt<\/td>\t\t<\/tr>\t\t<tr>\t\t\t<td>Rigid &#34;return data&#34;<\/td>\t\t\t<td>\t\t\t<p>Fleksibel &#34;return data&#34;<\/p>\t\t\t<\/td>\t\t<\/tr>\t\t<tr>\t\t\t<td>Endepunkter som parameter<\/td>\t\t\t<td>Parameter som del av sp&#248;rring<\/td>\t\t<\/tr>\t\t<tr>\t\t\t<td>Vanskelig &#229; analysere hva slags data som trengs<\/td>\t\t\t<td>Lett &#229; analysere hva slags data som trengs, siden applikasjoner kan be om&#160;<strong>kun<\/strong>&#160;data de trenger<\/td>\t\t<\/tr>\t\t<tr>\t\t\t<td>Vanskelig &#229; finne ut av hva slags data man kan be om, m&#229; f&#229; en oversikt over alle endepunkter<\/td>\t\t\t<td>Lett &#229; finne ut av hva slags data man kan be om, ved &#229; be endepunktet om skjema over data man kan be om.<\/td>\t\t<\/tr>\t<\/tbody><\/table><p>&#160;<\/p><p>Det viktigste er &#229; tenke p&#229; at REST og GraphQL er ikke motsetninger, men to forskjellige m&#229;ter &#229; h&#229;ndtere det samme problemet. For noen prosjekter vil GraphQL v&#230;re enklest &#229; bruke (rapid prototyping er noe som virker logisk), mens for andre vil REST v&#230;re greiere.<\/p><p>&#160;<\/p><p>Personlig er jeg blitt glad i GraphQL, siden det er s&#229; fleksibelt og gir god oversikt over hva slags data man kan be om.<\/p><p><br />&#160;<\/p><p>kilder:<\/p><p>https://restfulapi.net/resource-naming/<\/p><p>https://graphql.org/learn/execution/<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://graphql.org/learn/introspection/<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540544,"ext_inspera_userAssessmentSetupId":7139945,"ext_inspera_userAssessmentId":4841171,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gunnarsli Haakon (10169)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45464518,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2136,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State<\/p><p>States brukes normalt sett for &#229; holde orden p&#229; property verdier som h&#248;rer til klassen du lager.<\/p><p>States deklareres i konstrukt&#248;ren til klassen som this.state = {}<\/p><p>Dersom noen av disse endres vil komponenten rendre p&#229; nytt.<\/p><p>States kan n&#229;s hvor som helst i koden og kan ogs&#229; skrives i render() metoden ved &#229; bruke this.state.<\/p><p>&#160;<\/p><p>Dataflyten<\/p><p>&#160;I react er dataflyten uten retning.<\/p><p>I react kan utvikleren jobbe direkte med komponenter og legge til nedadg&#229;ende data flyt slik at foreldre ikke blir p&#229;virket av barna. Dette gj&#248;r koden mer stabil.<\/p><p>&#160;<\/p><p>I faget har vi blant annet benyttet oss av &#229; sende tilstander som read-only propertys fra foreldrekomponenten til barn. Dette g&#229;r fint og barna vil f&#229; oppdaterte propertys s&#229; fort en av tilstandene endres.<\/p><p>&#160;<\/p><p>Dersom vi skal g&#229; fra barn til forelder m&#229; vi benytte callbacks fordi dataflyten er nedadg&#229;ende. Callback brukes som en notifikasjon p&#229; at det har skjedd en endring i en verdi.<\/p><p>&#160;<\/p><p>For &#229; sende mellom s&#248;skenkomponenter m&#229; man kombinere de to overnevnte. Det er her man eventuelt ogs&#229; kan bruke redux, mobx eller react context, alts&#229; global tilstandsh&#229;ndtering for &#229; forenkle prosessen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":75,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt bibliotek som tar tak i en del av de problemene man i dag har med context api i st&#248;rre applikasjoner.<\/p><p>Istedenfor &#229; ha en stor lagringsplass med alle globale states, s&#229; har man Atoms. Denne inneholder en n&#248;kkel og en verdi som kan bli lest og skrevet fra alle komponentene. Konseptet er alts&#229; at hver komponent kan velge hvilket atom de &#248;nsker &#229; observere. Fordelen med dette er at man slipper &#229; re-rendre alle komponenter hver gang et atom som verdi endrer seg. Det blir alts&#229; kun de komponentene som observerer variabelen som re-rendrer. B&#229;de context, mobx og redux st&#248;tter ogs&#229; denne typen funksjonalitet.<\/p><p>Man aksesserer verdien i atomet ved &#229; bruke useRecoilState sammen med en n&#248;kkel. Dersom denne endrer seg vil alle de andre komponentene som bruker denne variablen(observerer) oppdateres.<\/p><p>&#160;<\/p><p>Selector<\/p><p>Slik jeg ser det kan vi si at redux sin metode for &#229; ta inn en state og action, for &#229; deretter returnere en ny modifisert state er ganske likt selector. useRecoilState kan ogs&#229; ta inn en selector. Selektoren representerer et stykke avledet tilstand. Avledet tilstand tar utgangspunkt i passerende tilstand til en ren funksjon som modifiserer den gitte tilstanden p&#229; en eller annen m&#229;te.<\/p><p>&#160;<\/p><p>Diskusjon<\/p><p>N&#229;r man skal bed&#248;mme om man skal bruke et bibliotek/rammeverk eller ikke er det viktig &#229; gj&#248;re en analyse av hvilke alternativer som finnes der ute. Analysen b&#248;r inneb&#230;re en sjekk med venner, kollegaer og internett for &#229; hente inne erfaringer fra de forskjellige alternativene. Man m&#229; ogs&#229; f&#229; kartlagt hvor godt supportert teknologien er og om den dekke alle behovene du har i prosjektet ditt.<\/p><p>Resultatet av analysen er en beskrivelse av mulighetene, begrensingene, mengde jobb for &#229; bruke og risiko.<\/p><p>Recoil er laget av facebook og er veldig nytt. Et helt nytt bibliotek. Facebook er et godt tegn p&#229; at bibloteket kommer til &#229; bli vedlikeholdt. Et helt nytt bibliotek er dermed ikke n&#248;dvendigvis s&#229; bra fordi det utgj&#248;r en risiko for lite support og feil.<\/p><p>Det krevet relativt lite kode og er enkelt &#229; sette opp i forhold til redux.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilde er recoil.org<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1612,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQl<\/p><p>I grapql er m&#229;ten man henter data p&#229; basert p&#229; sp&#248;rringer. Dersom et objekt inneholder noen entiteter kan man bruke disse som parametere for hva man &#248;nsker &#229; hente. I sp&#248;rringen kan man ogs&#229; definere hva man &#248;nsker &#229; f&#229; tilbake.<\/p><p>&#160;<\/p><p>Dette f&#248;rer til at antall kall p&#229; server og mengden data som hentes reduseres til et minimum.<\/p><p>En av ulempene med graphql er at det ikke st&#248;tter implisitt cashing i http-laget.<\/p><p>Det er kun st&#248;tte for json-data.<\/p><p>&#160;<\/p><p>I det som kalles schema defineres hvilke kall som skal v&#230;re tilgjengelige for klienten. Dette schemaet kan blant annet inneholde logikk for validering.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>REST<\/p><p>Kjerneideen i REST applikasjoner er at man definer et eller flere endepunkter som brukes til &#229; skrive, lese og endre p&#229; entitetene ved bruk av http requests&#160;(GET, POST, PUT, DELETE) eller URI.<\/p><p>I rest st&#248;ttes cashing som default av alle nettlesere.<\/p><p>&#160;<\/p><p>En av ulempene ved rest er at dataen man mottar eller f&#229;r er mer kompleks og det kreves ofte flere kall for hente akkurat den dataen man er ute etter.<\/p><p>Undefetching er et eksempel p&#229; dette og betyr i at endepunktet ikke inneholder nok n&#248;dvendig informasjon slik at den m&#229; gj&#248;re flere kall for &#229; hente alle dataen.<\/p><p>Man kan ogs&#229; overfetche. Dette er mindre effektivt enn graphQl.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Eksamen h&#248;st 2019 hadde en oppgave om dette og f&#248;ler jeg m&#229; n&#248;dt til &#229; nevne at denne oppsumeringen er skrevet ned i notatene mine. Men jeg skj&#248;nner ogs&#229; hva som st&#229;r der!<\/p><p>&#160;<\/p><p>Grapgql er enklere, raskere og i mange tilfeller bedre. Rest er mer brukt og bedre supportert.<\/p><p>&#160;<\/p><p>Kilder:&#160;https://learn-eu-central-1-prod-fleet01-xythos.content.blackboardcdn.com/5def77a38a2f7/3411471?X-Blackboard-Expiration=1606824000000&#38;X-Blackboard-Signature=5y1Rp6ndVDddGD5Xbtxbd3lfD%2FUUthpHm7Auco33ydw%3D&#38;X-Blackboard-Client-Id=303508&#38;response-cache-control=private%2C%20max-age%3D21600&#38;response-content-disposition=inline%3B%20filename%2A%3DUTF-8%27%27LF%2520til%2520eksamen%2520i%2520IT2810%2520H19%25281%2529.pdf&#38;response-content-type=application%2Fpdf&#38;X-Amz-Algorithm=AWS4-HMAC-SHA256&#38;X-Amz-Date=20201201T060000Z&#38;X-Amz-SignedHeaders=host&#38;X-Amz-Expires=21600&#38;X-Amz-Credential=AKIAZH6WM4PL5M5HI5WH%2F20201201%2Feu-central-1%2Fs3%2Faws4_request&#38;X-Amz-Signature=6379bc7b4ed7b993d12dd571f272c2cc3075d939bd245865117817f64517d46a<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11541552,"ext_inspera_userAssessmentSetupId":7140109,"ext_inspera_userAssessmentId":4841347,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:00:15Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ueland Thea (10071)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34461339,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":4310,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I webutvikling generelt, som inkluderer React-applikasjoner, brukes programmeringsparadigmet funksjonell programmering. Funksjonell programmering er ett deklarativt paradigme, hvor applikasjonen har ulike tilstander og definerte funksjoner som kan endre tilstand. I React brukes funksjonelle komponenter til &#229; implementere dette, hvor en komponent kan v&#230;re&#160;funksjoner eller klasser med eller uten tilstand. F&#248;r introduksjonen av React hooks ble klasser brukt n&#229;r en komponent var med tilstand, med React hooks kan ogs&#229; funksjoner v&#230;re med tilstand.<\/p><p>&#160;<\/p><p>React komponenter kan ogs&#229; kommunisere tilstand med hverandre ved &#229; sende &#34;props&#34;. En komponent som endrer tilstand etter &#229; ha mottatt &#34;props&#34; fra en &#34;parent&#34;&#160;komponent vil &#34;rerender&#34;. En komponent kan ogs&#229; sende data til en &#34;parent&#34; komponent hvis den har mottatt en funksjon fra &#34;parent&#34; komponenten som &#34;props&#34;.<\/p><p>&#160;<\/p><p>Komponentene er strukturert i ett komponenthierarki, hvor det er en &#248;verste komponent som har en eller flere &#34;children&#34; komponenter, som igjen har en eller flere &#34;children&#34; komponenter. &#34;Render&#34; metoden som kalles n&#229;r en tilstand blir endret, oppdaterer kun det som er n&#248;dvendig ved &#229; sammenlikne komponenten og &#34;children&#34; komponenter med forrige tilstand, og oppdaterer komponentene til den nye tilstanden.<\/p><p>&#160;<\/p><p>Context apiet gj&#248;r det enklere &#229; dele data mellom komponenter, ved at en slipper &#229; sende &#34;props&#34; gjennom midlertidige komponenter. Bibliotex som Redux og mobX hjelper ogs&#229; med &#229; h&#229;ndtere tilstand, ved at tilstandene blir lagret i en kontainer&#160;som alle komponentene har tilgang til.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2099,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er ett bibliotek som kan brukes for &#229; h&#229;ndtere tilstand. Andre lignende bibliotek vil derfor v&#230;re Redux og MobX.<\/p><p>&#160;<\/p><p>Dokumentasjonen til Recoil sier at Recoil definerer en graf hvor tilstandsendringer flyter fra r&#248;ttene av denne grafen (som kalles for &#34;atoms&#34;) gjennom rene funksjoner (som kalles for &#34;selectors&#34;) og til komponenter.<\/p><p>&#160;<\/p><p>&#34;Atoms&#34; er enheter av tilstand. N&#229;r en &#34;atom&#34; oppdateres vil &#34;subscribed&#34; komponenter bli &#34;re-rendered&#34; med den nye verdien.<\/p><p>&#160;<\/p><p>En &#34;selector&#34; er en ren funksjon som aksepterer &#34;atoms&#34; eller andre &#34;selectors&#34; som input. N&#229;r disse blir oppdatert, vil &#34;selector&#34; funksjonen bli re-evaluert. Komponenter kan bli tilhengere av &#34;selectors&#34; akkurat som til &#34;atoms&#34;, og vil da bli &#34;re-rendered&#34; n&#229;r &#34;selectoren&#34; endres.<\/p><p>&#160;<\/p><p>Redux som ogs&#229; brukes for &#229; h&#229;ndtere tilstand, med ett felles bibliotek som alle komponenter har tilgang til. Det bruker &#34;events&#34; som kalles for &#34;actions&#34; for &#229; oppdatere tilstand.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":703,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL er ett &#34;query language&#34; som kan brukes til &#229; hente data fra en database. Det finnes flere bibliotek b&#229;de til frontend og backend som kan brukes til &#229; implementere GraphQL sp&#248;rringer.<\/p><p>&#160;<\/p><p>Rest, som st&#229;r for &#34;representational state transfer&#34;, kan ogs&#229; brukes til &#229; hente data fra en database. I dette backenden inneholde ulike &#34;resourses&#34; som kan hentes fra frontenden ved &#229; sende HTTP foresp&#248;rsler. En &#34;GET&#34; foresp&#248;rsel vil hente data, &#34;PUT&#34; vil oppdate en &#34;resource&#34;, &#34;POST&#34; foresp&#248;rsel vil sende data til backenden og en &#34;DELETE&#34; foresp&#248;rsel vil slette en &#34;resource&#34;.<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11541677,"ext_inspera_userAssessmentSetupId":7139935,"ext_inspera_userAssessmentId":4842161,"dateLastModified":"2020-12-01T10:31:21Z","ext_inspera_startTime":"2020-12-01T08:00:21Z","ext_inspera_endTime":"2020-12-01T10:31:21Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nyblom Stian Erikstad (10111)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":26376155,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3770,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Dataflyt: props<\/strong><\/p><p>I React er dataflyten mellom komponenter &#233;n-veis, hvor man kan sende props (kort for &#34;properties&#34;) nedover i komponenthierarkiet. Disse er immutable, dvs. at de ikke kan bli &#34;reassigned&#34;. Dette er fordi en komponent ikke skal administrere (eng: &#34;manage&#34;) sine egne props, da dette er noe som gj&#248;res av foreldrekomponenten som sender de.<\/p><p>&#160;<\/p><p><strong>Lokal state<\/strong><\/p><p>For lokal state (/tilstand), dvs. tilstand som kun er tilgjengelig lokalt i den spesifikke komponenten, kan man bruke den lokale tilstanden i en klassebasert komponent (gjennom this.state og this.setState()), eller React Hooks (gjennom useState()) i en funksjonsbasert&#160;komponent. Sistnevnte ble ikke introdusert til React f&#248;r versjon 16.8, s&#229; om man skulle ha lokal state f&#248;r dette, m&#229;tte man lage en klassebasert komponent, mens funksjonsbaserte komponenter kun var funksjonelle; de hadde ikke egen tilstand.<\/p><p>&#160;<\/p><p>Fordelen med &#229; bruke slik lokal state, framfor &#229; f.eks. kun lagre i vanlige variabler, er at komponenten blir automatisk rendret (eng: &#34;rendered&#34;)&#160;p&#229; nytt ved oppdateringer av tilstanden. For at dette skal skje med klassebaserte komponenter, er det viktig at man bruker this.setState() for &#229; endre tilstanden - ikke endre variablen direkte.<\/p><p>&#160;<\/p><p><strong>Global state<\/strong><\/p><p>Global state/tiltand er tilstand som man har tilgjengelig i &#34;alle&#34; (forenkling, ikke alltid tilfellet) komponenter. I praksis gj&#248;r dette at man kan sende data gjennom komponent-treet uten &#229; sende denne dataen inn som props til barnkomponenten p&#229; hvert niv&#229;, noe som forenkler dataflyten. Her har ogs&#229; React innebygd funksjonalitet i form av et Context API, men dette er ikke like enkelt og intuitivt som bruk av Hooks, slik at mange ofte bruker tredjepartsbiblioteker istedet. Eksempler p&#229; dette er Redux, Mobx og Recoil. Disse blir sammenlignet i neste oppgave.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3943,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et &#34;state management library&#34;, slik som bl.a. Redux og MobX, som brukes til h&#229;ndtering av global state.&#160;L&#230;ringsm&#229;let som passer til dette biblioteket er: &#34;Kunnskap og ferdigheter i state management (Context, Redux, MobX etc)&#34;.<\/p><p>&#160;<\/p><p>Dette er et eksperimentelt bibliotek fra Facebook (som lagde React), og har veldig mange likheter med eksisterende funksjonalitet i React for lokal state-h&#229;ndtering gjennom Hooks (med useState). Dette gj&#248;r at man kun kan bruke Recoil i funksjonsbaserte komponenter.<\/p><p>&#160;<\/p><p>Det er to hovedkonsepter for dette biblioteket; &#34;atoms&#34; og &#34;selectors&#34;:<\/p><ul>\t<li>Atoms er &#34;tilstandsenheter&#34; som holder p&#229;&#160;tilstanden, og er definert med navn og standardverdi. Man kan endre tilstanden i denne atomen, samt at flere komponenter kan&#160;&#34;abonnere&#34; (eng: subscribe) p&#229;&#160;den.&#160;Hvis man endrer tilstanden i &#233;n komponent, endres den tilsvarende tilstanden i de andre abonnerende komponentene ogs&#229;.&#160;&#160;<\/li>\t<li>Selectors er funksjoner som tar inn atomer eller andre selektorer. Man m&#229; definere en getter, som beskriver hva som skal skje n&#229;r man getter verdien av denne selektoren, men man kan ogs&#229; definere en setter, hvor man definerer hva som skal skje n&#229;r man skriver til selektoren. Disse kan brukes av komponenter p&#229; samme m&#229;te som atomer (useRecoilValue om man kun har en getter, mens man kan bruke useRecoilState slik som med Atoms om man har en setter i tillegg).<\/li><\/ul><p>Recoil lager en &#34;data-flow graph&#34; som holder oversikt over avhengigheter (hvilke komponenter/selektorer som subscriber til atoms/selektorer) slik at kun de p&#229;virkede komponentene/selektorene blir oppdatert ved en tilstandsendring.<\/p><p>&#160;<\/p><p><strong>Sammenligning av Recoil vs. Context, Redux og Mobx<\/strong><\/p><ul>\t<li>Context API: Med Context APIet wrapper man en ContextProvider rundt&#160;komponenter (foreldrenekomponentene; det vil automatisk bli tilgjengelig for barna til disse foreldrene)&#160;som skal bruke denne globale tilstanden. Dette APIet er egentlig ikke ment for &#229; oppdatere hyppig, men passer fint &#229; bruke til f.eks. fargetema osv. (https://github.com/facebook/react/issues/14110#issuecomment-448074060). Med Context rerendres alle komponenter i treet, ettersom komponent-tilstanden dyttes til en felles foreldre for alle som skal bruke tilstanden, noe som ikke skjer med de andre bibliotekene<\/li>\t<li>Redux: Med Redux har man kun &#233;n store (variabel for lagring av global tilstand) i form av key/value-lagring. Denne store-en fungerer som en &#34;single source of truth&#34;, som gj&#248;r det enklere &#229; ha oversikten over all global tilstand i applikasjonen, spesielt ved debugging, ettersom alt er p&#229; ett og samme sted. Om applikasjonen er veldig stor, kan det derimot fort bli litt for mye som lagres, ogs&#229; data som ikke h&#248;rer noe s&#230;rlig sammen.<\/li>\t<li>MobX: Kan ha flere stores, minst to. Er den raskeste av alle alternativene<\/li><\/ul><p>&#160;<\/p><p><strong>Fordeler<\/strong><\/p><p>- Likt som Reacts useState, b&#229;de i funksjonalitet og syntaks<\/p><p>- Enkelt &#229; bruke, mindre &#34;boilerplate&#34; som kreves enn de andre bibliotekene, spesielt Redux og Context<\/p><p>- Ikke den tregeste<\/p><p>&#160;<\/p><p><strong>Ulemper<\/strong><\/p><p>- Eksperimentell og relativt ny<\/p><p>&#160; - Dermed ogs&#229; lite dokumentasjon, men siden det er et s&#229;pass enkelt bibliotek kreves det nok ikke<\/p><p>- Ikke den raskeste<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1173,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST bruker HTTP-protokollen for API-kommunikasjonen, mens GraphQL har definert sin egen konvensjon for dette. Fordelen med &#229; bruke HTTP-protokollen er at data automatisk caches, noe som ikke skjer med GraphQL.<\/p><p>&#160;<\/p><p>Med GraphQL kan man sp&#248;rre om akkurat den dataen du trenger, til og med n&#248;stede relasjoner mellom dataene, mens man med REST&#160;m&#229; gj&#248;re ett API-kall per entitet. Dette gj&#248;r at man med REST risikerer b&#229;de underfetching og overfetching:<\/p><p>- Underfetching skjer om man trenger informasjon om en entitet, f.eks. en brukers innlegg, men ikke f&#229;r denne dataen n&#229;r man gj&#248;r et API-kall for den spesifikke brukeren. F.eks vil dette kallet returnere en liste over id-ene til innleggene, ogs&#229; m&#229; man gj&#248;re et nytt kall per innlegg for &#229; f&#229; mer informasjon om disse innleggene. Med GraphQL vil du kunne hente denne dataen i form av relasjoner, og n&#248;ste disse i sp&#248;rringen.<\/p><p>- Overfetching om man, fra f.eks. endepunktet /user/&#60;id&#62;, henter all informasjon om brukeren, selv om man kun &#248;nsker navnet. Med GraphQL slipper man overfetching, da man kun kan velge &#229; hente navnet.<\/p><p>Dersom det generelt ikke blir gjort veldig mange API-kall til serveren, eller st&#248;rrelsen p&#229; dataen ikke er s&#229; storm,&#160;har ikke dette mye &#229; si, men det kan v&#230;re hensiktsmessig &#229; bytte fra REST til GrapQL om dette er tilfellet.<\/p><p>&#160;<\/p><p>GraphQL er et nyere fenomen enn RESTful APIs, mens REST er mer moden. Det er derfor ofte mer dokumentasjon til REST, og blir mer brukt i industrien, men GraphQL har tatt&#160;store skritt mot dette i de siste &#229;rene.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11541806,"ext_inspera_userAssessmentSetupId":7139958,"ext_inspera_userAssessmentId":4842159,"dateLastModified":"2020-12-01T10:31:21Z","ext_inspera_startTime":"2020-12-01T08:00:32Z","ext_inspera_endTime":"2020-12-01T10:31:21Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Prietz Nikolai Kunewa (10132)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":27779634,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2498,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Note: some of the code might have some syntax-errors as acpital letter as word gave automatic capital letters. Some of the tabs might be not correct, but this is not the point of showing some simple code.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#34;Redux<\/p><p>-Single source of truth<\/p><p>-State is stored in one place - is called large (one store is one data structure, typically a tree)<\/p><p>-Store is read-only and can only be changed via actions (messages)<\/p><p>-Changes only via the dispatch method that takes in &#171;actions&#187;. In best-practive-Const are used for action types and are declared in a separate module. Functions should be used for creating actions. It is more readable and provides fewer lines of code.<\/p><p>-No other parts of the code can change the state<\/p><p>-Changes with pure functions (reduces)<\/p><p>&#160;-Uses react-redux to make large available for all sub-components<\/p><p>-connects the component to large with hooks: useSelector and useDispatch (equivalent to connect which is also used for this)<\/p><p>-For global state management like Redux, parts of the code are pure functions as simple<\/p><p>&#160;<\/p><p>ModX<\/p><p>-Global state management, but some differences<\/p><p>-Observable state<\/p><p>-MobX makes data structures observable and components can be made into observers<\/p><p>-Simple and scalable<\/p><p>-A library that to a lesser extent affects your code<\/p><p>Requires less boilerplate coding than Redux<\/p><p>-Great flexibility in design of state<\/p><p>&#160;<\/p><p>React has a built-in based on properties that are data condition is based on data to submit to a component when it is created. The state is a compontets condition data and can be changes. Further the designer also have the ability to send data upstream in the component hierarchy. This is done with call-back functions that allow children to change state in parents. For more complex applications (and some subjective thoughts and more informal notes will be discussed below) where typical data will be used again. To avoid redundant code and annoying imports and possibility of many errors. When sending throughout the hierarchy. A global state is better. All data is stored in one place and where one sets up automatic updating of affected components when data changes. Solutions used for this are, for example, Redux, Mobx - and Apollo also gives you the opportunity for global state of client data. When a more comprehensive state management is needed we often use libraries and external third party technologies. To avoid callbacks Redux and ModX can be called in as a helper.<\/p><p>&#160;<\/p><p>As an example, Redux can be used to store condition. This allows one to move states out of components, to a separate &#34;unit&#34;. Actions can be&#160;used to describe events that lead to a change, and reducers that describe how the states are changed by actions.&#160;<\/p><p>&#160;<\/p><p>A&#160;result of use is that makes&#160;applications more manageable and easier to test and log data changes. Wanting&#160;to implement a scalable website that can handle larger datasets, the decision should maybe&#160;Redux instead of Mobx. This is because Redux is more applicable for large applications.<\/p><p>&#160;<\/p><p>It is different from MobX since it has several stores for storing conditions. This can provide benefits such as being able to have one large for domain states, and one for UI states, and that one can then use elements in other applications.<\/p><p>&#160;<\/p><p>With react&#160;Axios can used to fetch the data from the API. The axios function that is imported and used with the *.get()* or *.post()*-function, that allows respectively to either read or overwrite. The response is then saved using redux. One key advantage with axios was that it provided automatic *JSON* serialization and parsing.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Hooks<\/p><p>After the React update (16.8 Hooks) it became possible to use *state* in functional components, and there its not necessarly a need to&#160;implement classes. React hooks allowes&#160;to reuse stateful logic without changing your component hierarchy and made it easy to share these Hooks among many components. This can be&#160;used to save search, filter and sort states before the user presses the &#8220;Show result&#8221; button etc.<br />-React mechanism that allows gives you functionality as a replacement for what you need class for and as mentioned below useState to handle state<br />-const [count, setCount] = useState (0);<br />-We can use useEffect as a replacement for lifecycle methods<\/p><p>&#160;<\/p><p>This was written as a more personal take on the different types that I am familiar with. It was included as to show extra experience over what is beeing informed through the slides, that I recon everyone else will prodive as an answer for this question Examples of code will also not be provided since it is not asked for, and can be found in t the lecture slides:<\/p><p>&#160;<\/p><p>In the average React App there are usually three types of state and the most common one is to just fetch data and store it from an API and commonly Redux is used for this. It is just a general state management library that has many ways to be implemented.<\/p><p>&#160;<\/p><p>En axample of use of Context was in this course used to keep track of pagers on the webpage. This was implementet with a GlobalProvider, where all&#160;logic was gathered in one provider, which is then wrapped around the App component. In this case it was usefull,&#160;as it was&#160;needed to send variables and functions across components that were not directly connected.<\/p><p>&#160;<\/p><p>Example: This example will only be brief since we know this from the projects and the course in general. &#160;Here we have a useEffect-hook that will run after the first render and just dispatch an action to load some data from the API. Once it is loaded it will be stored in redux and passed to this component.<\/p><p>&#160;<\/p><p>function App ({fetchUser, user}) {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; useEffect(() =&#62; {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fetchUser ();<\/p><p>}, [] );<\/p><p>Rerutn (<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#60;div&#62;<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Hello exam sensor {user ? user.name : &#8216;&#8217;}<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#60;div/&#62;<\/p><p>);<\/p><p>&#160;<\/p><p>This reminds me of making pasta from scratch if you are willing to use the time and the effort for creating home-made pasta the end results can be really good. If you are ok cook and surrounded by no help this might not be as good.<\/p><p>A recommendation is to use a pasta that is already done and really good. Buy it from the restaurant for example this analogy is compared with apollo or relay, for GraphQL and the store is known as react-query or SWR for REST. The point is that the result is really good and specifically designed for fetching and caching data from API and it is made by chefs with fresh ingredients.<\/p><p>&#160;<\/p><p>For an average react app using a data fetching library that is designed for this type of state compared to a general state management lib is going to spare you a lot of time and effort and is what is might be recommended.<\/p><p>&#160;<\/p><p>Local state is a &#8220;local state&#8221; that almost any client-side state that just one component or few close by components need access to. &#160;<\/p><p>&#160;<\/p><p><!--[if gte vml 1]><v:shape id=\"Bilde_x0020_2\" o:spid=\"_x0000_i1025\" type=\"#_x0000_t75\" alt=\"Et bilde som inneholder tekst&#10;&#10;Automatisk generert beskrivelse\" style='width:453pt;height:261pt;visibility:visible;mso-wrap-style:square'> <v:imagedata src=\"file:////Users/nikolaikunewaprietz/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png\"  o:title=\"Et bilde som inneholder tekst&#10;&#10;Automatisk generert beskrivelse\"/><\/v:shape><![endif]--><\/p><p>function app() {<\/p><p>const [checked, setChecket] = useState (false);<\/p><p>return (<\/p><p>&#60;div&#62;<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#60;input cheched = {checked}<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OnChange = {() =&#62; setChecked (!checked)}<\/p><p>&#62;&#160;<\/p><p>&#60;/input&#62;<\/p><p>{checked ? &#60;div&#62; apple &#60;div/&#62; : &#60;div&#62; orangr &#60;div/&#62; }<\/p><p>&#160;<\/p><p>&#60;div/&#62;<\/p><p>);<\/p><p>}<\/p><p>&#160;<\/p><p>Ex. Have a checkbox to hide and show something. For this a built-in state-hook can be used and if the complexity is increased a use reducer hook can be used.<\/p><p>Of course, as the components and app develop over time requirements change and components need access to this state and the component is lifted to the highest level and components that need the state close by its just to pass it down as the props. Otherwise it&#8217;s not as considered as a &#8220;local state&#8221;<\/p><p>&#160;<\/p><p>Next category is more of a &#8220;global state management&#8221; in parentheses because it is now used across the entire app but any state where it&#8217;s not desired to just pass props down or it gets too complicated to keep track of. Might be a sidebar that you want to hide sometimes and show sometimes and it&#8217;s a button in the header that decides this action. In this case you want to be able to control the sidebar from the header and they are pretty far apart in the structure and component tree. Here React context could be used or others like Zustand, due to not needed for wrapping the entire react app and providers. With a such approach the web designer don&#8217;t need to handle a lot of state at all with a state mgmt. lib or context and the majority of state is handled by useState and a data fetching library.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3454,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>After some research Recoil is minimal and reactish (as the website states) and looks like useState Hooks with some touches that makes it easy to understand how data is flowing through the application. It&#8217;s not necessarily a Facebook project. It is not an official state management library for react and neither is Redux.&#160;In addition to having atoms that you can subscribe to to retrieve the actual state, Recoil also has a built-in selector that allows components to subscribe to it for updates.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>My impression:<\/p><p>-Straightforward UI<\/p><p>-Like the idea of separating read-only + read-write APIs usage of the atom state into two different hooks<\/p><p>-Not too much overhead on top of normal hooks to use instead of using useState of Context. Simplified way to access all of this without being a &#8220;hooks-expert&#8221;<\/p><p>&#160;<\/p><p>Some advantages:<\/p><p>- Modular<\/p><p>- Requires modern architecture<\/p><p>- Testing<\/p><p>- Presistent states<\/p><p>-React compatible and uses some of the same terminologies and principles<\/p><p>-Supports concurrent mode<\/p><p>-Not much too learn if your a developer.&#160;<\/p><p>-Its simplier then MobX and Redux (see code)<\/p><p>-App-wide observation but not as mature as Redux.<\/p><p>- Brings state logic back into the components, if desired<\/p><p>- Very similar to api as the useState hook<\/p><p>- Selectors - make changes to the presentation of states without having to do this by component,-<\/p><p>- Less rerendering&#160;<\/p><p>- Boilerplate free<\/p><p>- Open source<\/p><p>&#160;<\/p><p>Some disadvantages (more discussion of this below):<\/p><p>-Needs&#160; well buil conventions states to treat different comps. This can create confusion in larg applicatoins<\/p><p>-Mentions presistent<\/p><p>&#160;<\/p><p>New react state management with two new items (states) and selectors (values derived from the state). They can be used as a substitute for react component State or shared between multiple components.<\/p><p>&#160;<\/p><p>Will use a quick example of how this works. Selector that allows you to create derived data from your state. For ex. Can create some value that will be updated when the state will be updated and it will be 2X so the value of the counter, x multiplied by 2.<\/p><p>&#160;<\/p><p>Selector needs to get unique key. And define a pure function so that for any given input it will return the same output and should now modify any global variables.<\/p><p>&#160;<\/p><p># Must first of course start a new app with:<\/p><p>Npm create-react-app exam2020<\/p><p># Add the react library:<\/p><p>Npm add recoil<\/p><p>&#160;<\/p><p>for ex In App.js:<\/p><p>&#160;<\/p><p>Import {atom, userecoildState, selector} from &#8220;recoil&#8221;;<\/p><p>const countState = atom ({<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Key: &#8220;countState&#8221;,<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Default:0<\/p><p>})<\/p><p>&#160;<\/p><p>const multi2select = selecotrt({<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; key : &#8220;CountState&#8221;,<\/p><p>get: ({get}) =&#62; {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const count = get (countState)<\/p><p>return count * 2;<\/p><p>}<\/p><p>})<\/p><p>&#160;<\/p><p>Function app() {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const [count, setCout] = useRecoildState(countState]<\/p><p>&#160;<\/p><p>#Bruker hook, som heter usercoild value.<\/p><p>const dobCount = useRecoilValue(multi2select)<\/p><p>&#160;<\/p><p>const larger = () =&#62; {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; serCount (count +1)<\/p><p>}<\/p><p>&#160;<\/p><p>const bigger = () =&#62; {<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; setCount (count-1)<\/p><p>}<\/p><p>&#160;<\/p><p>return (<\/p><p>&#60;div/&#62;<\/p><p>Count: {count}<\/p><p>dobCount: {count}<\/p><p>&#60;div/&#62;<\/p><p>);<\/p><p>&#160;<\/p><p>Further ir might not bgive its real power to majority of applications. It is created for face the afore-mentioned performance problems, but it can be used partially. The applications doesn&#8217;t need to depend on it and use it where the application can benfit from it. It also provides some cool features like time travel, persistent state. Some say that Recoil&#160;is not necessary for a basic and general application and that it is specifically design for a Facebook-like-problem.<\/p><p>&#160;<\/p><p>It brings native states to several components mainly. This method avoids the need of other methods that is the case for mobX, Redux and Context. This&#160; divides components state into smaller sub components and is the so called Atoms. It is wuick and ensures that alle components have subscribed to an atom will be updated to the latest.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>For the comparison part I dit not want to repeat too much, so the last part of Question 1 is meant for both questions as it fits for comparison.<\/p><p>&#160;<\/p><p>Examples of use:<\/p><p>https://blog.logrocket.com/simple-state-management-react-recoil/<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3012,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Communciation line:<\/p><p>Database&#160;&#60;---&#62; REST API/GraphQL &#60;---&#62; Application<\/p><p>&#160;<\/p><p>Some key points presentet in lecture slides and earlier exams:<\/p><p>Rest<\/p><p>-Representation state transfer&#160;- Transmission of condition<\/p><p>-URi<\/p><p>-HTTP-request (Put, Get, Post). Messages as communication<\/p><p>-Boilerplate code<\/p><p>-Uniform interface<\/p><p>-Caching for scalability<\/p><p>-Resources have addresses (unique URI for each resource)<\/p><p>-Multiple endpoints<\/p><p>-Establish solution and lots on the internet<\/p><p>-Information is fetched usully as JSON-format<br />-a mecahnism for&#160;using&#160;APIs. One makes a call to the API, as then<br />returns information (from the database) back.<\/p><p>-Provides status code for errors that point to where the error is located<\/p><p>&#160;<\/p><p>-Graph<\/p><p>-Only JSON for exchange of data<\/p><p>-Form<\/p><p>-Not caching<\/p><p>-Query for the API<\/p><p>-Server-side runtime<\/p><p>-Avoids overfetching<\/p><p>-Validation and documentation<\/p><p>-Very easy and understandable<\/p><p>&#160;<\/p><p>REST is an architecture or server communication method that focus on reading and writing resources. It uses principles like stateless communication, design that facilitates the use of browser caching, the use of URIs to identify resources, the use of HTTP requests GET, PUT, POST, DELETE to read, modify, create or delete resources. For REST endpoints are defined for the reading, writing and changers using URI and requests HTTP and its refined what data that the designer wants to return. It is also considered as easy to use and implement.<\/p><p>&#160;<\/p><p>An advantage is that caching is supported by almost all browsers. On the other hand, for complex endpoints, if there are many, it needs a lot of calls to get the data and might overfetch, get the same unneeded data more then necessary. This is not the case for GraphQL.<\/p><p>&#160;<\/p><p>GraphQL is an alternative to REST and other less structures APIs. It is considered as easy to use but might be more challenging is implementing from scratch. GraphQL is based on sending a request in terms of queries to a server, server-side runtime. It can be used in examples for showing what results to show in search to avoid overloading/overfetching data, since all data can be retrieved in one request. This type system makes it possible to document and validate the trade-off is that the link between the server and client might be closer. On the other hand, it might have a lack of implicit caching like REST have in HTTP storage and does not support JSON data. It also has plenty of tool such as Apollo + Neo4j / neo4j-graphql-js where a lot is already done for the implementor.<\/p><p>&#160;<\/p><p>Example of use:<\/p><p>Graph-QL can be used as a client which is a code that makes a POST request to a GraphQL server. In GraphQL, there are no API versions as there are for REST. The advantage is that the group avoids multiple versions of an API (eg Api.domain.com/v1/, api.domain.com/v2/), because the resources or structure of the resources can change over time. In GraphQL, it is possible to deprecate APIs at the field level. Thus, a client receives a depreciation warning when queries are made on an outdated field. An example of this is that when it is retrieved for example an author of a book, identified by an ID, and then retrieves all the books to this author (by search), by the author&#39;s id, then only one request is required. If the author&#39;s books will be retrieved without the authoring unit, then GraphQL allows this and overfetching is avoided, as REST does. This is a clear advantage of this method. Apollo Client can be used to communicate with a remote server using GraphQL. In projects, this can deal with local states with &#34;reactive variables&#34;. This allows local data to be handled globally. GraphQL provides the benefit of moving state management to the server side.<\/p><p>&#160;<\/p><p>const GET_ALL = gql`<\/p><p>&#160;&#160;&#160; query persons( $orderBy: String!, $pageNumber: Int!){<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; persons(orderBy: $orderBy, pageNumber: $pageNumber){<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; id<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; first_name<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; last_name<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; age<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; location<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; description<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<\/p><p>&#160;&#160;&#160; }<\/p><p>&#160;<\/p><p>// Define MovieSchema<\/p><p>const movieSchema = new Schema({<\/p><p>&#160; movie_title: {<\/p><p>&#160;&#160;&#160; type: String,<\/p><p>&#160;&#160;&#160; required: true<\/p><p>&#160; },<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11538557,"ext_inspera_userAssessmentSetupId":7140065,"ext_inspera_userAssessmentId":4841226,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Schrøder Marcus Anton (10180)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330701,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3524,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har vi diverse mekanismer og teknikker vi kan bruke til &#229; h&#229;ndtere tilstander og dataflyten. For &#229; lagre komponentens data bruker vi objektet state. <strong>State <\/strong>er mutable og kan endre med this.setState(). Hvis data endre vil setState gj&#248;re at det renderes slik at nye data blir brukt i komponentene. Dette er interne state, og hvis andre komponenter i prosjektet vil ha tlgnag til state m&#229; vi bruke en av mekanismene beskrevet under:<\/p><p>&#160;<\/p><p><strong>Props:<\/strong><\/p><p>Denne mekansimen blir brukt til &#229; sende data nedover til barnekomponenter i hierarkiet. For at vi skal kunne sende data oppover i komponenthierarkiet m&#229; vi sende noe som heter &#34;callback&#34; funksjoner fra parent til children komponent. noe som muligj&#248;r barnet til &#229; bruke funksjonen til &#229; sette state p&#229; foreldren. Props er immutable.<\/p><p>&#160;<\/p><p>For litt mer komplekse systemer med mange komponenter burde andre mekanismer brukes slik at man slipper &#229; sende data ned med props i komponentreet.<\/p><p>&#160;<\/p><p><strong>- Context&#160;<\/strong><\/p><p>Context l&#248;ser dette ved &#229; wrappe alle komponter som trenger den spesfike dataen med en provider. Da vil alle komponenter p&#229; alle niv&#229;er i komponentreet f&#229; tilgang til dataen s&#229; lenge en foreldre node x.antall niv&#229;er opp er wrappet i en Provider. Typisk blir dette brukt til Theme osv. Komponeter bruker Consumer for &#229; f&#229; tilgang til data fra de komponentene som er wrappet med Provider.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>- Redux:<\/strong><\/p><p>Ved bruk av Redux wrapper man komponentene med en Provider som har tilgan til en global &#34;store&#34;. Denne storen inneholder alle globale states i kompontetreet Provideren inneholder. I redux har vi actions, reducers og types. N&#229;r jeg f.eks skal trykke p&#229; en knapp som &#229;pner en modal. I Redux er det definert actions som OPEN_MODAL og CLOSE_MODAL. Den har og&#229;s den staten for om modalen er open eller ikke (true/false).&#160;N&#229;r knappen blir trykket blir f.eks open_modal trigget og sendt til reduceren som ut i fra hvilken action som blir sendt inn endrer staten i store med det tilsvarende. alts&#229; true i dette eksempelet.<\/p><p>&#160;<\/p><p><strong>- Mobex<\/strong><\/p><p>Mobex er relativt likt redux i motsetning til at det er mulig &#229; ha flere forkjellige stores.<\/p><p>Det er ogs&#229; mulig &#229; f&#229; automatisk oppdatert statene i komponentene.<\/p><p>&#160;<\/p><p><strong>- Hooks:<\/strong><\/p><p>Brukes for funksjonelle komponenter for den lokale staten til komponenten. For &#229; h&#229;ndtere staten brukes UseState(). Som en erstatning for lifecyclekomponentene som ComponentDidMount() osv, har Hooks useEffect som gj&#248;re det samme.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1747,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for tilstandsh&#229;ndtering og dataflyt. Ved bruk av Recoil lager man et overordnet dataflyt graf&#160;best&#229;ende av atoms og selektorer (selectors).<\/p><p><strong>Atomene<\/strong> er enheter av tilstand. Man kan oppdatere de og de er abonnerbare (subscribable). Noe som gj&#248;r at n&#229;r et atom er oppdatert me dny state, s&#229; vil alle komponenter som abonnerer til det atomet bli renderet p&#229; nytt med nye verdier.<\/p><p>&#160;<\/p><p><strong>Selektorer <\/strong>er funksjoner som tar inn atomer eller andre selektorer som input. N&#229;r atomene eller selektorene blir oppdatert vil selektor funsjonen revurdert. Likt som med atomene kan komponenter abonnere p&#229; selektorer, n&#229;r selektoren blir endret p&#229; vil komponenten re-rendere. Selektoren tar inn &#34;derived state&#34; og gj&#248;r den om p&#229; en eller annen m&#229;te.&#160;<\/p><p>&#160;<\/p><p><strong>Recoil vs Redux<\/strong><\/p><p>Recoil og Redux har begge global tilstandsh&#229;ndtering. Ved bruk av redux m&#229; en opprette en store som holder p&#229; p&#229; en state for hele komponentreet den har &#34;inni&#34; seg (inni Provider), mens i Recoill er det delt opp i atomer for hver enkelt state.&#160;<\/p><p>Recoill har egen st&#248;tte for asyncrone funksjoner. Noe Redux bare f&#229;r til med tredjepartkomponenter som Thunk.<\/p><p>Recoill bruker Hooks for state, noe en ikke kan bruke i klasse-komponenter.<\/p><p>I motsetning til Redux er ikke Recoil lagret globalt noen sted. tilsatnden er inkremental og distributert. Dette gj&#248;r kode-splitting oppn&#229;elig ut av boksen.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1857,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API baser seg p&#229; HTTP requester og URI som gjennom endepunkter i API&#39;et blir brukt til &#229; skrive, lese eller endre p&#229; entiteter. Man definerer hva slags data som skal returneres. Ved bruk av REST muligj&#248;r det bruk av av cachinng, noe som kan v&#230;re verdifullt til tider. Det kan av og til bli litt komplekst med mange endepunkter&#160;og en&#160;ulempe er at noen endepunkter kanskje ikke henter all dataen en &#248;nsker (underfetching), noe som gj&#248;r at man m&#229; gj&#248;re flere kall for &#229; hente riktig data. Ved flere kall kan det ogs&#229; resultere i at man ender opp med mer data enn en trenger (overfetching).<\/p><p>&#160;<\/p><p>&#160;<\/p><p>GraphQL baserer seg p&#229; sp&#248;rringer til serveren der man definerer b&#229;de s&#248;k og hva slags data som skal returneres. I motsetning til REST s&#229; kan GraphQL hente dataen med en request s&#229; man unng&#229;r overfetching. Dette kan v&#230;re alt fra mange objekter til spesifike felt innad i eniteter. En ulempe er at det kun st&#248;tter json. I GraphQL blir det definert struktur og typer, noe som gj&#248;r koblingen mellom klient og tjener enda tettere, noe som gj&#248;r det mulig med validering. En annen uempe er at det ikke st&#248;tter implisitt caching i HTTP-laget.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11539554,"ext_inspera_userAssessmentSetupId":7139950,"ext_inspera_userAssessmentId":4841328,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Matsen Erik Aunvåg (10124)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331202,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1934,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har innebygde mekanismer for state-h&#229;ndtering, som bruk av properties eller &#39;props&#39;, som er data som sendes mellom &#39;parent&#39; og &#39;child&#39;-komponenter, ved hjelp av &#39;props...&#39; og callback-funksjoner (for &#229; sende data oppover i komponenthierarkiet). Props brukes til &#229; sette initiell state i komponentene. I tillegg har React-komponenter til all tid en state. I klassekomponenter kan state n&#229;s&#160;med this.state, mens funksjonelle komponenter ikke har en innebygd state. Man kan derfor si at funksjonelle komponenter er &#39;stateless&#39;. Med bruken av hooks som useState kan man likevel oppn&#229; en local state i funksjonelle komponenter i praksis. Andre hooks, som useEffect gj&#248;r ogs&#229; at manipulering av denne staten kan gj&#248;res enkelt.<\/p><p>&#160;<\/p><p>Hvis man kun bruker props for dataflyt, kan ting fort bli komplisert hvis man skal sende data til en komponent som er &#39;langt unna i hierarkiet&#39;, som f. eks. en&#160;&#39;s&#248;skenbarn-komponent&#39;. Her kan man utnytte eksterne state h&#229;ndterings-verkt&#248;y for &#229; gj&#248;re jobben enklere, for eksempel React-Redux. Med Redux kan man ha en felles &#39;store&#39; som holder all informasjon, og kan oppdatere informasjonen i store med actions og reducers. Her er en reducer en funksjon som bestemmer hvordan state skal oppdateres. Reducers tar imot en action, som for eksempel &#39;Sort&#39;.&#160;Dette betyr at man enkelt kan sikre dataflyt mellom komponenter som er langt fra hverandre i hierarkiet, og unng&#229; mange un&#248;dvendige komplikasjoner, med verkt&#248;y som useSelector, som f&#248;lger med p&#229; en spesifik del av storen, og useDispatch, som endrer p&#229; staten. Andre verkt&#248;y enn Redux eksisterer for dette, som MobX. MobX skiller seg litt fra Redux i at den har flere stores for informasjon, i motsetning til Redux som bare har en. i MobX er tilstanden ogs&#229; &#39;impure&#39;, som betyr at staten til MobX kan endres, i motsetning til Redux sin state, som er immuterbar.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3182,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for stateh&#229;ndtering i React. Recoil definerer en form for graf&#160;knyttet til React sitt komponenttre, der tilstandsendringer kan flyte mellom s&#229;kalte &#39;atoms&#39;, som er l&#248;vnodene i denne grafen. Et &#39;atom&#39; er en enhet av tilstanden, som har en default tilstand og en default n&#248;kkel. Recoil tilbyr en del hooks for &#229; gj&#248;re aksess til disse enhetene av state enkel, ved bruk av f. eks. useRecoilValue. Tilstandsendringer i atomer kan flyte til komponentene ved hjelp av noe som heter Selectors. Selectors er rene funksjoner som kan hente tilstanden til atoms, eller andre selectors, og manipulere de. Disse selectorene blir oppdatert hver gang tilstanden endres. Komponenter som bruker selectors til &#229; hente informasjon fra atoms vil da re-rendere.&#160;<\/p><p>&#160;<\/p><p>Recoil kan her selvf&#248;lgelig sammenlignes med React-Redux eller MobX. Vi ser umiddelbart noen forskjeller mellom redux og recoil. i Redux m&#229; man subscribe til hele storen om man vil f&#248;lge med p&#229; tilstandsendringer, mens i Recoil er det enklere &#229; f&#248;lge med p&#229; spesifikke deler av tilstanden, som vil v&#230;re relevant for komponenten det er snakk om. I Recoil kan du&#160;unng&#229; un&#248;dvendige re-renders, da kun komponentene som subscriber til de enhetene vil re-rendere. I Redux vil alle komponentene som subscriber til store re-rendere. Man kan da se for seg at Recoil vil forenkle ting n&#229;r man jobber p&#229; store prosjekter, og bli mindre &#39;h&#229;rete&#39; enn det redux kan bli. I tillegg kan man unng&#229; mye gjenskriving av kode med Recoil sine selectors. Her drar man logikken som manipulerer state ut fra komponentene i egne selectors, som kan gjenbrukes mange steder. Det at Recoil splitter opp state s&#229;pass atomisk kan ogs&#229; gj&#248;re ting litt &#39;langstrakt&#39;, og skape mye skriving av kode.<\/p><p>&#160;<\/p><p>I tillegg kan det nevnes at Recoil&#160;er spesifikt for React, mens MobX og Redux kan brukes med andre bibliotek.&#160;<\/p><p>&#160;<\/p><p>noe informasjon hentet fra&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1479,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL har noen vesentlige forskjeller. REST API&#39;et har flere endpoints for informasjonen sin, dvs. at hvis man f. eks. vil hente favorittfilmene&#160;til bruker men navn John Smith, s&#229; m&#229; man bruke en egen URL for dette. Ressursene har alts&#229; sine egne adresser.&#160;Her er det knyttet visse ulemper. Hvis du har veldig mange endepunkter kan det hende at man m&#229; bruke mange kall for &#229; hente informasjonen. I REST er det ogs&#229; mulig &#229; &#39;overfetche&#39;, alts&#229; hente mer informasjon enn det som egentlig er n&#248;dvendig. Med REST kan man sende&#160;flere forskjellige HTTP-requests, som f. eks. GET eller DELETE for &#229; hente eller manipulere data. En fordel med REST er at man kan benytte seg av caching-mekanismen til browseren, som er viktig for effektivitet og skalerbarhet. Det kan ogs&#229; nevnes at siden REST har flere endpoints for ressurser, er innholdet i &#39;body-en&#39; valgfritt, det trengs f.eks. ikke om man bare skal hente data. Rest st&#248;tter i tillegg andre datatyper enn JSON, selv om det er JSON-data som brukes oftest i praksis.<\/p><p>&#160;<\/p><p>Hvis REST er URL-basert, er GraphQL query-basert. GraphQL har kun ett endpoint for informasjonen. Her vil da alle requests starte med POST/graphql og i body-en ha informasjon om hvilken query som skal utf&#248;res. Fordelene med dette er at all data kan hentes med en request, og man unng&#229;r lettere overfetching som kan oppst&#229; med REST. Ulemper med GraphQL er mangel p&#229; implisitt caching i browseren, og at det kun st&#248;ttet JSON-data.&#160;<\/p><p>&#160;<\/p><p>&#160;&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11539881,"ext_inspera_userAssessmentSetupId":7139926,"ext_inspera_userAssessmentId":4841330,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Borgen Haldis Kvalvåg (10130)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34583304,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1469,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Jeg kommer til &#229; ta for meg redux, mobX og context.&#160;<\/p><p>&#160;<\/p><p>Redux kan brukes for tilstandsh&#229;ndering i React. Redux har &#233;n redux store som holder hele staten til app. For &#229; endre staten i store m&#229; en action dispatches (&#34;settes i gang&#34;). Det skjer ved at man dispatcher en action creator. En acion creator returnerer en action. En action inneholder hva slags type action det er samt en payload (som feks kan v&#230;re en string med brukernavnet som skal logges inn). N&#229;r action creatoren dispatches vil man da dispatche en action (siden action creatoren returnerer en action). N&#229;r en action dispatches vil en reducer se hva slags type action det er og h&#229;ndrere dataen i henhold til hva slags type action det er. En reducer er en pure function som tar inn en state og en action , og returnerer en ny state. S&#229; ved at en action dispatches vil reduceren se p&#229; action typen, h&#229;ndterer dataen (ulik kode som kommer ann p&#229; hva som skal oppdateres og hva som trengs &#229; gj&#248;res) og returnere den oppdaterte staten i redux store. Ved at Redux store wrappes rundt hele App vil App og alle barna til App i komponent-treet ha tilgang til &#229; dispatche actions (endre staten i storen) samt hente ut staten i redux storen.&#160;<\/p><p>&#160;<\/p><p>MobX kan i motsetning til Redux ha flere stores. MobX tillater, i motsetning til Redux, at man lett kan oppdatere og overskrive states med nye verdier og kalles dermed &#34;inpure&#34;. Dette kan f&#248;re til at uforutsett output og storene (&#34;butikkene&#34;) i Mobx er dermed mindre forutsigmare en den &#233;ne man har ved bruk av Redux.&#160;&#197; utvikle kode kan dermed v&#230;re lettere enn med&#160;Redux samt gi mindre boilerplate (overhead) i koden, men gj&#248;re debugging og testing vanskeligere.&#160;<\/p><p>&#160;<\/p><p>Context brukes n&#229;r mange komponenter trenger tilgang p&#229; samme data. Ved bruk av en Provider rund en komponent vil alle barna ha tilgang til context dataen og man slipper &#229; sende den som props gjennom komponent hierkiet. Merk at context kan ogs&#229; sendes oppover i komponent hierkiet.&#160;Alle komponentene som da har tilgang p&#229;&#160;context verdien kan da endre denne. Et eksemepel p&#229; en context &#34;verdi&#34; er tema for en nettside, man kan enten ha tema natt eller dag. La oss si at alle komponentene som er barn av App trenger &#229; vite om tema er dag eller natt fordi de utifra dette skal endre designet sitt. Istedet for &#229; sende tema=dag som props til alle komponentene vil de ha direkte tilgang og vi slipper &#229; skrive un&#248;dvendig kode for at alle komponentene skal v&#230;re oppdatert p&#229; temaet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3201,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil baseres p&#229; to konsepter: atoms og selectors. Et atom er en enhet av staten som kan endres.En hvilken som helst komponent kan subscribe (f&#248;lge med p&#229;) atomet. Endres verdien til et atom vil alle komponentene som subscriber re-rendres. Alle komponentene som subscriber til et atom deler da samme state. Selectorer er en ren funksjon som mottar et atom eller en selector som input. Gitt inputen vil selectoren returnere en modifisert tilstand (state) hver gang upstream atomer eller selectorer oppdateres. Selectorer kan ogs&#229; subscribes som betyr at komponenter som subscriber vil re-rendres n&#229;r selectoren de f&#248;lger med p&#229; (subscriber) oppdateres<\/p><p>&#160;<\/p><p>Ved bruk av recoil kan man hindre un&#248;dvendig re-renders. Med redux f.eks s&#229; er hele staten i redux-store. Dette kan f&#248;re til at hele siden re-rendres selv om det kun er en liten del av staten som oppdateres, noe som i noen tilfeller kan v&#230;re problematisk. Recoil gj&#248;r det lettere &#229; kun re-rendre det som er n&#248;dvendig. Ved &#229; dele staten i induviduelle atomer vil kun komponentene som subscriber p&#229; atomet re-rendres og man hindrer un&#248;dvendig re-render.&#160;<\/p><p>&#160;<\/p><p>Recoil er et open source bibliotek for state management. MobX, men prim&#230;rt Redux krever mye oppsett (boilerplate kode) for&#160;statemanagement. Med redux m&#229; mye settes sammen&#160;f&#248;r selv en liten store vil fungere slik vi vil (f.eks som kun inneholder brukernavn). Man m&#229; sette opp actioncreators, spesifisere action typer, lage reducer samt redux store-en (redux butikken) og wrappe dette rundt App. Bruk av Recoil&#160;minker boiler plate, noe som hindrer un&#248;dvendig mye kode.<\/p><p>&#160;<\/p><p>Med bruk av redux er det vanlig &#229; bruke tredjepartskomponenter for ting som memorisering og selektor verdier. Utviklere av Recoil opplevde problemer med state sync mellom komponenter ved bruk av&#160;eksisterende state management. Med Recoil har man en delt state mellom komponentene i komponent treet som er mer effektivt og konsistent. Recoil kan ogs&#229; beregne ting med liten sannsynlighet for feil, alts&#229; at den nye staten endres effektiv og p&#229; en robust m&#229;te.&#160;<\/p><p>&#160;<\/p><p>S&#229; fordeler er blant annet at man har mindre boilerplate kode (kode for oppsett), kan g&#229; mer spesifikt inn p&#229; hva som skal re-rendres ved state endring, komponenter kan dele state. Man kan ogs&#229; loggf&#248;re alt som har skjedd med en komponent (logging) samt observere endringer og debugge. Dette er fordeler n&#229;r man utvikler store og kompliserte&#160;prosjekter. En ulempe for videre bruk av Recoil er at MobX og Redux allerede fungerer bra og det er mange utviklere som er vandt til det (spesielt Redux). Det krever dermed at man har en rekke engasjerte utviklere som virkelig ser fordelene ved bruk av Recoil. Det er heller ikke alltid n&#248;dvendig &#229; bruke Recoil, feks hvis man lager en nettside der det ikke er s&#229; farlig at flere komponenter und&#248;vendig re-rendres vil Recoil v&#230;re un&#248;dvendig.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p><p>https://www.telerik.com/blogs/recoil-in-react<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2459,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er et arkitekturisk konsept og st&#229;r for&#160;&#8220;Representational State Transfer&#8221;. REST spesifiserer et sett av regler for et API som bruker HTTP requester for &#229; f&#229; tilgang til samt bruke data. Dataen kan brukes til &#229; lese, oppdatere, slette og opprette (henholdsvis HTTP verbene:&#160; GET, PUT, DELETE, POST).P&#229; client siden spesifiseres dette kallet til API-et (som h&#229;ndterer dataen og sammenkobles til databasen). For &#229; spesifisere hvilke data som f.eks skal hentes m&#229; en path ogs&#229; spesifiseres. Skal du hente data om brukeren &#34;Ola&#34; vil HTTP requesten feks v&#230;re &#34;GET/users{name: &#34;Ola&#34;}. Vil du legge til en ny bruker vil httpverbet endres til POST og peke til et annet endepunkt i API-et. S&#229; ved bruk av REST API vil vi ha flere endepunkt.&#160;<\/p><p>&#160;<\/p><p>GraphQl er et query spr&#229;k for API-er. Med Graphql&#160; har man kun ett endepunkt i API-et med HTTP verbet POST. Typisk vil pathen kalles graphql. Den vesentlige forskjellen fra REST er at POST/graphql peker til det ene endepunktet i API-et og det er i bodyen vi spesifiserer hva som&#160;f.eks skal hentes.&#160;<\/p><p>&#160;<\/p><p>Med REST API har man flere endepunkt og selve dataqueryen til databasen skjer&#160;i body-en i HTTP requesten. Bodyen&#160;er strukturert p&#229; en bestemt m&#229;te som gj&#248;r at APIet kan skj&#248;nne hva som skal gj&#248;res. Dette&#160;krever&#160;at utviklere som arbeider med client-siden kanskje m&#229; sette seg mer inn i hvordan API-et er satt opp enn ved bruk av REST API. Dette er fordi man m&#229; vite hva som skal st&#229; i bodyen og det kan p&#229;st&#229;s at POST/GET og http verbene som brukes med REST er mer intuitiv og lettere for utviklere p&#229; klient siden.&#160;Med REST API kan det holde &#229; vite at GET/users vil hente alle brukere fra databasen og man trenger ikke n&#248;dvendigvis vite noe utenom hva endepunktet heter.&#160;<\/p><p>&#160;<\/p><p>Med GraphQL kan man hente ut mer spesifikk data og dermed hindre &#229; hente data man ikke trenger (over fetche). La oss si vi skal hente ut navn og alder til en bruker, da vil man spesifisere dette i data queryen og man f&#229;r tilbake kun navn og alder. Med REST API er det vanligere &#229; hente mer un&#248;dvendig data, som vil si at GET/user{name:&#34;Ola&#34;} vil gi navn, alder, men feks ogs&#229; ID, bosted og annen data lagret p&#229; brukeren. S&#229; n&#229;r man skal gj&#248;re mange kall til databasen vil GraphQl hindre mye un&#248;dvendig data &#229; bli sendt.&#160;<\/p><p>&#160;<\/p><p>API-et som jeg har henvist til her kan b&#229;de v&#230;re et API man har laget i backend (slik som i prosjekt 3) eller som poetryDB (prosjekt 2).&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://graphql.org/<\/p><p>https://restfulapi.net/<\/p><p>https://searchapparchitecture.techtarget.com/definition/RESTful-API<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11539918,"ext_inspera_userAssessmentSetupId":7140110,"ext_inspera_userAssessmentId":4841301,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:17Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Norvoll Mikal Bongo (10202)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34443895,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1487,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt i React referer hovedsakelig til bruken av state og props.<\/p><p>&#160;<\/p><p>Props brukes n&#229;r vi det skjer en hendelse eller endring i en foreldrekomponent og vi &#248;nsker og videref&#248;re denne endringen til et barnekomponent.<\/p><p>&#160;<\/p><p>State brukes n&#229;r vi har data som kun endres innad i en komponent, eller n&#229;r data trengs &#229; sendes lenger opp/ned treet en dirkete barn og foreldre. Til intern state brukes gjerne Reacts innebygde metoder, mens man ofte velger alternative bibliotek om man &#248;nsker global state management. Som en av utviklerne til React p&#229;peker, s&#229; er React Context designet for ufrekvente oppdateringer, og dermed trenger vi eksterne bibliotek om vi &#248;nsker &#229; ofte oppdatere data i state.<sup>1 <\/sup><\/p><p>&#160;<\/p><p>&#160;<\/p><p>1) https://github.com/facebook/react/issues/14110#issuecomment-448074060<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":5128,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som skal h&#229;ndere state i en applikasjon. Den er designet til &#229; v&#230;re lik state management fra React, men gi mulighet for &#229; lagre/endre flere verdier i state. Data lagres i <em>atoms<\/em>, som hver holder &#233;n verdi i state. Endring av atomer kan s&#229; sendes til <em>selectors<\/em>, funksjoner der output er basert p&#229; utregning av atomet som ble gitt.<\/p><p>&#160;<\/p><p>Fra pensum s&#229; konkurrerer dette biblioteket med ReduX og MobX, biblioteker som pr&#248;ver &#229; forbedre implementasjonen av global state i React. Recoil skiller seg fra disse ved bruk av atoms og selectors, da b&#229;de ReduX og MobX bruker stores til &#229; lagre data. Fordelen med dette er at Recoil tilsynelatende kj&#248;rer raskere enn bibliotek som Redux, da en oppdatering av et atom bare oppdaterer de komponentene som er avhengige av den, men ikke alle komponenter som i ReduX.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":449,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":1,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ett av hovedforskjellene mellom REST og GraphQL er hvordan requests h&#229;ndteres. I REST s&#229; m&#229; vi sende en ny request hver gang vi skal ha tilgang til forskjellige endepunkt, mens i GraphQL s&#229; h&#229;ndteres dette gjennom en Request med flere felt.<\/p>"}]}],"ext_inspera_totalScore":6,"score":6}},{"result":{"sourcedId":11539959,"ext_inspera_userAssessmentSetupId":7140088,"ext_inspera_userAssessmentId":4841208,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Halvorsen Phajsi Choque (10162)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22210291,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2604,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React sine mekaniskmer for h&#229;ndtering av tilstand og dataflyt i React applikasjoner er:<\/p><p>- UseState hooken i funksjonelle komponenter og setState() funksjonen i klasse komponenter.<\/p><p>-&#160;Context APIet til React<\/p><p>- props<\/p><p>&#160;<\/p><p>Hooken brukes til &#229;&#160;initialisere tilstanden ved &#229; ta den som en argument, og den returnerer et array med den aktuelle tilstanden og en funskjon for &#229; oppdatere tilstanden.<\/p><p>&#160;<\/p><p>Context APIet lar brukeren sende data &#34;nedover&#34; til komponentene ved &#229; opprette en Context objekt, og deretter bruke Context sin Provider metode for &#229; la komponenter abonnere p&#229; endringer i contexten.<\/p><p>&#160;<\/p><p>Props er data som kan sendes mellom komponenter, men de kan bare leses og den sendes i retningen fra&#160;foreleder til barn.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2862,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en tilstandsh&#229;ndtering bibliotek som l&#248;ser tilstandsh&#229;ndteringsproblemer som oppst&#229;r n&#229;r komponenter som er veldig lagt una i React treet m&#229; dele samme tilstand. De bruker noe de kaller for Atoms, tilstandsenheter som kan endres og abonneres, som ligger ortogonalt til React treet.&#160;<\/p><p>&#160;<\/p><p>Recoil kan sammenlignes med Context API, Redux og MobX.&#160;I ContextAPIet m&#229; brukeren sende tilstanden oppover i treet til en felles forelder komponent, for at barn-komponenter kan abonnere p&#229; tilstandsendringer.&#160;<br />Med Redux, er det mye &#34;boilerplate&#34; ved at m&#229; man implementere en kompleks&#160;tilstandsh&#229;ndteringsysten f&#248;r man kan starte &#229; bruke det. Men med Recoil&#160;kan man bytte useState hooken med Recoils eget useRecoilState() for &#229; abonnere til den samme atom-komponentet, som da kan brukes overalt i&#160;<br />komponent-treet.&#160;<\/p><p>&#160;<\/p><p>Fordelene med Recoil er at komponentene som trenger &#229; dele tilstand med komponenter som ligger langt unna i treet kan sette&#160;opp dette enkelt, med ingen &#34;boilerplate&#34; siden den bruke samme struktur som useState(). Jeg kan ikke se ulemper ved &#229; bruke det, siden man kan bare la v&#230;re &#229; bruke&#160;useRecoilState() n&#229;r det ikke er behov for det.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1624,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST definerer endepunkter til &#229; lese og skrive data fra og til en server, ved &#229; ha URI of HTTP requests. GraphQL p&#229; sin side sender sp&#248;rringer til en server hvor s&#248;ket er definert i en skjema&#160;som definerer strukturen og typer.&#160;<\/p><p>&#160;<\/p><p>REST kan bruke en mengde med dataformater, som JSON, XML, osv; mens&#160;GraphQL st&#248;tter bare JSON-data.&#160;<\/p><p>&#160;<\/p><p>Ved &#229; bruke REST kan man bruke weblesernes caching mekanismer, men med GraphQL er det ikke mulig &#229; bruke cache i HTTP niv&#229;et.<\/p><p>&#160;<\/p><p>Hvis man bruker REST til &#229; h&#229;ndtere mye og kompleks informasjon&#160;m&#229; man gj&#248;re mange kall for &#229; hente de data man trenger i tillegg til at man risikerer &#229; hente mer data en n&#248;dvendig. GraphQL derimot<br />derimot tillater spesifikke queries p&#229; klientsiden, som unng&#229;r fetching av mer data en n&#248;dvendig.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11540141,"ext_inspera_userAssessmentSetupId":7139983,"ext_inspera_userAssessmentId":4841263,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Butler Wang Fredrik Wilhelm (10176)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331005,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1521,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er en komponents tilstandsdata som kan endes underveis i kj&#248;retiden til komponenten. Ved &#229; bruke call-back funksjoner kan man sende data oppover i komponent-hierarkiet og med det la barn oppdatere state til foreldre. I en mer kompleks applikasjon kan det ofte bli sv&#230;rt komplisert og mye kode for &#229; sende data p&#229; tvers av hierarkiet. En l&#248;sning for dette er &#229; benytte seg av global state managment der man lagrer data som skal deles av flere kompoenter et felles sted, f.eks. en Redux Store. Da kan man sette opp automatisk oppdatering av komponentene som benytter seg av denne dataen n&#229;r dataen endres. MobX er et annet alternativ for &#229; f&#229; til dette.<\/p><p>I React finnes det ogs&#229; flere innebygde m&#229;ter &#229; h&#229;ndtere state p&#229;, b&#229;de Class og&#160;Hooks.<\/p><p>&#160;<\/p><p>I React er den innebygde dataflyten basert p&#229; properties (Props) som sendes inn i en komponent n&#229;r den opprettes, og brukes for &#229; sende data nedover i hierarkiet. Props er ogs&#229; &#34;read-only&#34; som vil si at man vil f&#229; error om man fors&#248;ker &#229; endre de.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/components-and-props.html&#160;<\/p><p>Forelesning om ResponsiveReact&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2179,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managment biblotek for React.<\/p><p>Bibloteket er, som de fleste stata managment biblotek er, ment til &#229; unng&#229; &#229; m&#229;tte sende state ned mange niv&#229;er av komponenter, ved &#229; introdusere global state management.<\/p><p>En annen ting bibloteket gj&#248;r er &#229; oppdatere komponenter ved endring av state, vanligvis ville man gjort dette med bruk av useEffekt som er innebygd i React. Recoil gj&#248;r dette automatisk ved bruk av en data-graf, som s&#248;rger for at en state&#160;kan &#34;lytte&#34; (subscribe) til en annen state og dermed oppdatere/beregne seg selv n&#229;r staten man &#34;lytter&#34; til endrer seg. Fordi alle state-endringer i hele appen er observerbare kan man ved slike state endringer ogs&#229; informere brukeren om at data&#39;en endrer seg og f.eks. rendre et laste-ikon eller liknende.<\/p><p>&#160;<\/p><p>Sammenliknet med en l&#248;sning blant l&#230;ringsm&#229;lene, s&#229; bruker blant annet Redux en global state, der endringer i state kan f&#248;re til at hele eller store deler av siden re-rendres. Dette kan i utgangspunktet g&#229; helt fint, men p&#229; sider der man har mange komponenter med states kan det v&#230;re dyrt &#229; m&#229;tte rendre hele applikasjonen. Recoil gir fordelen med &#229; kunne &#34;lytte&#34; til states, og dermed kun m&#229;tte re-rendre relaterte komponenter.<\/p><p>&#160;<\/p><p>Slik jeg ser det er det ingen &#229;penbare ulemper ved bruk av Recoil, annet en at det er relativt nytt og at ekspertisen og support-mulighetene er ganske minimale om man selv &#248;nsker &#229; ta det i bruk for f&#248;rste gang sammenliknet med alternativene som finnes.&#160;<\/p><p>At det ikke er noen &#229;penbare ulemper&#160;betyr heller ikke at man er n&#248;dt til &#229; ta i bruk Recoil, og det finnes allerede gode l&#248;sninger b&#229;de innebygd i React og andre bibloteker, men man kan heller vurdere &#229; ta det i bruk av deler av&#160;applikasjonen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3452,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere forskjeller mellom REST API og Graphql. Rent teknisk s&#229; er REST et&#160;arkitektur konsept for software som benyttes i web-tjenester. Graphql derimot er et definert sp&#248;rrespr&#229;k som opererer over et enkelt endepunkt. En annen teknisk forskjell er at Graphql ogs&#229; har typer som &#229;pner opp for validering, og det er JSON data som kan utveksles.<\/p><p>&#160;<\/p><p>Ved sp&#248;rringer er det flere forskjeller mellom de to. REST API kan ha flere endepunkter som benytter seg av URI og ulike HTTP request til &#229; blant annet lese, skrive eller endre data. REST har ogs&#229; p&#229; forh&#229;nd definert hva slags data som returneres for hver type sp&#248;rring, dvs en uri p&#229; &#34;brukere/&#60;id&#62;/venner&#34; kan f.feks gi deg en liste over alle vennene til en bruker med den id&#39;en.<\/p><p>I Graphql derimot er defineres det i sp&#248;rringen b&#229;de hva slags sp&#248;rring som gj&#248;res og hva slags data som skal returneres. S&#229; si vi skulle gj&#248;re en sp&#248;rring for en brukers venner igjen, men bare var ute etter de 3 f&#248;rste vennene i lista, s&#229; kunne dette v&#230;rt spesifisert i sp&#248;rringen, eller at hvert &#34;venne-objekt&#34; inneholder informasjon som h&#248;yde, interesser, alder, men vi kun er ute etter navnet kan dette ogs&#229; spesifiseres.<\/p><p>&#160;<\/p><p>Som et resultat av hvordan de to metodene er forskjellige er det slik at ved henting av st&#248;rre mengder informasjon, der man m&#229; benytte mange endepunkter, for REST resulterer det i at man kan hente mer data enn man trenger, noe som kalles overfetching. Fordi man i graphql spesfiserer retur-dataen kan dette unng&#229;s.<\/p><p>Motsatt, at man ikke f&#229;r nok data, og m&#229; gj&#248;re et nytt s&#248;k basert data&#39;en i det f&#248;rste s&#248;ket, kalles underfetching og kan ogs&#229; v&#230;re en utfordring med REST API&#39;er.<\/p><p>&#160;<\/p><p>REST drar nytte av caching&#160;(som er et av prinsippene for REST), som st&#248;ttes av weblesere, der data som er definert som &#34;cachable&#34; kan v&#230;re med p&#229; &#229; unng&#229; om m&#229;tte hente samme informasjon p&#229; nytt. Graphql har ikke denne funksjonen fra starten av, selv om det kan kan tilby liknende funksjoner, dog ikke i HTTP laget slik som REST gj&#248;r.<\/p><p>&#160;<\/p><p>Bruksmessig s&#229; kan man p&#229; et generelt niv&#229; si at REST er lettere &#229; benytte seg av, ihvertfall hvis man er ukjent med endepunkt(ene). Hvert endepunkt i REST har ganske tydelige instrukser p&#229; hva de tilbyr, mens Graphql kan virke litt mer utdydelig i starten, men kan gj&#248;re det lettere &#229; automatisere ting n&#229;r man f&#229;r en forst&#229;else for hvordan de ulike queries&#39;ene gj&#248;res. I forbindelse med s&#248;k som har hvert en sentralt i prosjektoppgavene s&#229; er Graphql i utganspunket mer optimalisert enn REST for dette nettop p&#229; grunn av m&#229;ten resultatet gis (kan unng&#229; over og under-fetching).<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>Forelsning om&#160;REST-Graphql-state<\/p><p>https://restfulapi.net/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11540815,"ext_inspera_userAssessmentSetupId":7140076,"ext_inspera_userAssessmentId":4841218,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:16Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Kongsvik Tobias Slettemoen (10112)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34124561,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2431,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React finnes det en god del forskjellige m&#229;ter &#229; h&#229;ndtere datafllyt p&#229;. De to &#34;orginale&#34; metodene man kan bruke er &#34;state&#34; og &#34;props&#34;.&#160; State kan man bruke i en komponent med hooken useState(funskjonelle komponenter) eller ved bruk av livssyklusfunkjsonnen i en klassebasert komponent. State i denne sammenhengen er lokal til komponenten og p&#229;virker ikke andre komponenter, den kan heller ikke endres av andre komponeneter. Man har ogs&#229; en hook useReducer som gj&#248;r mye av det samme, men den er litt mer kompleks. Med useReducer har du en mekanisme som likner litt mer p&#229; redux hvor du m&#229; dispatche actions og har en reducer som endrere en store basert p&#229; hvilke actions som blir dispatched.&#160;<\/p><p>&#160;<\/p><p>Med props kan man gj&#248;re mye som man ikke kan f&#229; til med bare state. Props er variabler som sendes inn i komponenter. N&#229;r en prop oppdateres oppdateres ogs&#229; verdien som blir sendt inn i komponenten og komponenten oppdateres. Dette gir oss en m&#229;te &#229; endre child komponenter&#160;p&#229;. Men hva om vi vil oppdatere en parent komponent? Vi kan bruke props til dette ogs&#229;. Det er mulig &#229; f&#229; til med s&#229;kalte callback funksjoner. Detter er funskjoner som man gir til en komponent via props. Man kan i funksjonen endre staten til parent komponent ogsp kan man kalle funksjonen i child komponenten. Man vil da ha informasjonsflyt oppover komponent treet, og ikke bare nedover.&#160;<\/p><p>&#160;<\/p><p>De to tingene jeg har nevnt s&#229; langt fungere veldig fint i mindre applikasjoner der tilstanden er relativt lokal, men hva gj&#248;r man dersom man vil tilstand over st&#248;rre avstander i applikasjonen. Man har et React alternativ i tillegg til en rekke forskjellige tredjeparts alternativer, de som er relevante for oss er Redux og MobX<\/p><p>&#160;<\/p><p>Reacts alternativ til global state heter Context. Context er bygget opp av det vi kaller providerss og comsumer. Disse er komponenter man settter inn i komponent treet. Alle comsumers som er etterkommere av providers&#160;i treet har tilgang p&#229; de veridene som blir satt av provideren.&#160;&#160;Det vil si at hvis providerens&#160;verdi oppdateres s&#229; oppdateres ogs&#229; alle consumers under denne provideren.&#160;<\/p><p>&#160;<\/p><p>Redux er en tilstandsbibliotek som er mue brukt i React. Det fungerer en god del som useReducer hooken beskrevet over. Den har en sentral &#34;store&#34; som inneholder hele tilstanden. Denne er immutable og kan bare oppdateres ved &#229; dispatche en action. N&#229;r man dispatcher en action ville denne plukkes opp av en reducer og reduceren kan s&#229; oppdatere&#160;tilstanden som befinner seg i storen. Denne teknikken har litt bratt l&#230;ringskurve, men den gir ogs&#229; mange fordeler. Den gj&#248;r det for eksempel veldig lett &#229; h&#229;ndtere logikk som m&#229; skje ved oppdatering av visse deler av tilstanden. Det er ogs&#229; lett &#229; ha en sentral immutable store som inneholder det som er sant. Da blir det ikke konflikter p&#229; kryss og tvers fordi forskjellige deler av applikasjonen har forskjellige sannheter. N&#229;r hver tilstandsendring er en action blir det ogs&#229; lett og se hvordan flyten g&#229;r ved &#229; for eksempel logge actions.&#160;<\/p><p>&#160;<\/p><p>Den siste relevante teknikken er MobX. MobX, som Redux, er et tredjepartsbibliotek for tilstandsh&#229;ndtering. I MobX har man ikke n&#248;dvendigvis bare en sentral store slik som i Redux, her kan man ha mange. MobX har som Redux actions for &#229; endre p&#229; state, men en veldig annen type action. I MobX er en action kode som kan endre p&#229; tilstand og ikke bare en &#34;opaque&#34; verdi slik som i Redux. Man har heller ikke noen reducers. Det man har i MobX som man ikke har i Redux er observable,&#160;&#160;computed og reactions. Observable og computed er bare m&#229;ter &#229; hente verdier fra tilsatanden enten direkte eller med modifikasjoner. Reactions er ting som skal skje n&#229;r tilstand er blitt endret og er veldig viktig for bruk av MobX med React.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/hooks-reference<\/p><p>https://mobx.js.org/observable-state.html<\/p><p>https://mobx.js.org/reactions.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1255,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en bibliotek for &#229; h&#229;ndtere tilstand. De tilsvarende bilbiotekene i l&#230;ringsm&#229;lene er Context,&#160;&#160;Redux og MobX som beskrevet i forrige oppgave. Recoil er bygget opp av Atoms og Selectors. Der atoms er objecter som inneholder tilstand. Selectors er verdier som kommer fra tilstand, men har v&#230;rt kj&#248;rt gjennom en funksjon f&#248;rst. Dette minner mye om computed i MobX.&#160;<\/p><p>&#160;<\/p><p>Recoil har ogs&#229; det eksperimentelle API&#39;et Atom Effects, som minner mye og MobX reactions. Dette er ting som skal skje n&#229;r atoms har blitt endret.&#160;<\/p><p>&#160;<\/p><p>Dette ser ut som et bibiotek som ikke er like komplekst og stort som for eksempel Redux. Det minner litt om simplisiteten til Context. Det ser ut til at man kan ha en rekke forskjellige atoms og ikke bare en. P&#229; den m&#229;ten minner det om b&#229;de MobX og Context.&#160;<\/p><p>&#160;<\/p><p>En ulempe med dette bibloteket er at det er mye nyere og mye mindre brukt en for eksempel Redux, noe&#160;som gj&#248;r det vanskelig &#229; finne hjelp online. Det var dog god dokumentasjone og Facebook er generelt sett gode p&#229; dokumentere bibliotekene sine.&#160;<\/p><p>&#160;<\/p><p>Jeg ser det at det er s&#229; simpelt som en store fordel, det ser ut som l&#230;ringskurven ikke er s&#229; bratt. Og utifra dokumentasjonen ser det ut som jeg kunnne startet &#229; ta ibruk dette relativt fort. Det var ogs&#229; lite boilerplate kode og et API som likner ganske mye p&#229; det man finner i React fra f&#248;r, noe som gir mening da begge er utviklet av Facebook.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":866,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De to st&#248;rste forskjellene mellom REST og GraphQL er formatet for sp&#248;rringer, og mengden data som returneres. I et REST api bruker man forskjellige HTTP metoder for &#229; indikere hva man har lyst til &#229; gj&#248;re, GET for &#229; hente ut data, POST for &#229; sette inn ny data, PUT for &#229; obdatere en entiet osv. Det gj&#248;r man ikke i GraphQL. I GraphQL bruker man POST for det som er, b&#229;de queries og mutations. For &#229; gj&#248;re sp&#248;rringer om spesifikk data i REST velger man f&#248;rst endepunktet man vil hente fra ogs&#229; velger man et sett med parameter som sendes i URLen(query parameters). Serveren vil da tolke dette og sende deg en hel enitet bassert p&#229; hvilket endepunkte og parametere du sendte. I GraphQL fungerer det p&#229; en litt annen m&#229;te. I GraphQL er det bare ett endepunkt. Her sender du en query i formatet GQL som er et sp&#248;rrespr&#229;k. Du definerer hvilken sp&#248;rring du gj&#248;re, eventuelle variabler og hvilke felter du har lyst til &#229; f&#229;. Serveren tolker dette og sender tilbake bare de feltene du spurte etter. Dette gj&#248;r API&#39;et mye mer nettverkseffektivt. Det gj&#248;r at du slipper &#229; sende hele entiten over et nettverk slik som du m&#229; med REST.&#160;<\/p><p>&#160;<\/p><p>Ogs&#229; det &#229; sette inn ny data er litt froskjellig mellom GraphQL og REST. I rest sender en POST med et JSON object i bodyen. Serveren vil da bassert p&#229; hvilket endepunkt du sendte til ta imot dataen og sette den inn der den skal. I GraphQL bruker vi ogs&#229; POST til dette, men i stedet for et JSON object sender vi en mutation i formattet GQL.&#160;<\/p><p>&#160;<\/p><p>GraphQL har ogs&#229; et annet konsept kalt subscriptions. Med subscriptions kan du opprettholde en forbindelse med serveren og f&#229; server data n&#229;r dataen endres. Dette gj&#248;r at du slipper &#229; konstant sp&#248;rre om data har blitt oppdatert. Jeg er ikke kjent med noen REST API&#39;er som har liknende funksjonalitet, selv om jeg vet at det er mulig &#229; f&#229; til.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://resthooks.org<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11541496,"ext_inspera_userAssessmentSetupId":7139998,"ext_inspera_userAssessmentId":4841175,"dateLastModified":"2020-12-01T10:01:25Z","ext_inspera_startTime":"2020-12-01T08:00:15Z","ext_inspera_endTime":"2020-12-01T10:01:25Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sæbøe-Larssen Vår Sørensen (10128)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34564374,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1816,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Props er en innebygd funksjon for dataflyt i React som fungerer slik at man sender inn visse props/data til en komponent n&#229;r den opprettes. Man kan ogs&#229; sende callback-funksjoner som props fra foreldre- til barnekomponenter, slik at barnekomponentene kan bruke funksjonen de f&#229;r til &#229; sette staten til foreldrekomponentene.<\/p><p>&#160;<\/p><p>Det &#229; kunne holde en global state i et programmeringsprosjekt er sv&#230;rt nyttig n&#229;r flere komponenter skal benytte seg av den samme staten. For &#229; s&#248;rge for en god state-h&#229;ndtering er det mulig &#229; innf&#248;re for eksempel Redux, MobEx eller Context. Context er en mekanisme som er innebygd i (f&#248;lger med) React og som passer godt for mindre applikasjoner med mindre dataflyt. Context kan s&#248;rge for at barnekomponenter kan arve/bruke og endre staten til foreldrekomponentene sine. I Context rendres alt hver gang man henter fra Context. Dette f&#248;rer til at hvis det anvendes i et stort prosjekt (spesielt med mange brukere) blir det veldig mye un&#248;dvendig datatrafikk, og veldig mange callback-funksjoner.<\/p><p>&#160;<\/p><p>For &#229; l&#248;se dette problemet kan det for store prosjekter v&#230;re sv&#230;rt nyttig &#229; bruke Redux. Redux er hovedsakelig et state-management bibliotek. Redux er veldig stabilt i forhold til Context (og MobEx) der man ikke vil f&#229; dette problemet med at barnekomponenter kan gj&#248;re endringer som man &#34;ikke vet hvor kommer fra&#34;. I Redux har man en store og reducers og actions som oppdaterer store, og en hvilken som helst komponent kan kalle p&#229; Redux ved &#229; gj&#248;re en action. P&#229; denne m&#229;ten ligger p&#229; en m&#229;te state &#34;utenfor&#34; komponentene, og alle komponenter kan hente &#34;inn&#34; det de trenger. Dette skiller seg fra Mobex og Context.<\/p><p>&#160;<\/p><p>MobEx er en annen mekaniske for state-management, som er noe mer fleksibel enn Redux. MobEx gj&#248;r det ogs&#229; mulig samle state p&#229; ett sted, og gj&#248;r det enkelt &#229; endre staten i de komponentene man &#248;nsker. Mens Redux f&#248;rer til mye kode i mange forskjellige filer, har MobEx fokus p&#229; at syntaksen skal v&#230;re enkel, og p&#229; denne m&#229;ten er ikke det som skjer like eksplisitt for programmereren. Dette gj&#248;r det enkelt &#229; vedlikeholde, men vanskeligere &#229; oppdage feil (uforusette endringer i state). MobEx har ogs&#229; actions som forandrer staten, men man kan forandre staten direkte (uten &#229; g&#229; gjennom en store). N&#229;r staten er oppdatert iverksetter det en reaksjon/oppdatering. Her kan man (i likhet med i Context) endre staten direkte, s&#229; man kan si at staten er lagert &#34;inne i&#34; prosjektet; den er mer &#34;tilgjengelig&#34; - men dette f&#248;rer ogs&#229; til at den er mindre stabil.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2829,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React (i likhet med Redux og MobEx). En viktig del av Recoil er &#34;shared state&#34;. Man bruker setRecoilState og useRecoilState for &#229; sette en state til en enkelt komponent (ikke global). Mens Redux har en global state som ligger utenfor komponentene, vil Recoil dytte staten ned til den individuelle komponenten. Dette gj&#248;r man for &#229; slippe &#229; rerendre hele prosjeket for &#229; oppdatere state for en komponent. S&#229;; vi &#248;nsker &#229; kunne oppdatere state for en enkelt komponent. Dette kunne man potensielt brukt Context til, men problemet da er at vi m&#229; ha en Provider for hver eneste komponent. Det er ikke et problem i seg selv &#229; ha mange Providers, men det er tungvint og kan f&#248;re til at det blir kluss n&#229;r man ikke lenger vet hvor mange man har. Med Recoil l&#248;ses det ved at hver state tilh&#248;rer en komponent, og at n&#229;r denne staten endres, re-rendres (render p&#229; nytt) kun den komponenten som staten h&#248;rer til. P&#229; denne m&#229;ten har man en lokal state som h&#248;rer til &#233;n komponent, men man kan dele state mellom komponenter slik at en endring ogs&#229; kan p&#229;virke flere komponenter.<\/p><p>&#160;<\/p><p>For &#229; gj&#248;r det slik at man kan rerendre kun de komponentene som bruker den staten som er endret, og for &#229; vite hvilke(n) komponent(er) som m&#229; oppdateres (rerendres), bruker Recoil en Selector. En Selector er en pure funksjon med informasjon om hvilken state den avhenger av, slik at n&#229;r den staten endres kan vi rerendre akkurat den komponenten som avhenger av den staten. P&#229; denne m&#229;ten rerendres kun de komponentene som m&#229; oppdateres (n&#229;r staten deres er endret), og man trenger ikke rerendre hele prosjektet.<\/p><p>&#160;<\/p><p>Recoil kan sies &#229; ha noen likheter med Context da state kan endres direkte fra kompontene. Forskjellen er at hver komponent (i Recoil) har sin egen state, og ikke kan endre noen global state (eller state h&#248;yere opp i hierarkiet). Sammenlignet med Redux er det mange forskjeller. Hovedpoenget med Redux (eller m&#229;ten man benytter det p&#229;) er &#229; ha globale states som kan aksesseres overalt i prosjektet (fra alle komponenter), mens poenget med Recoil er &#229; heller ha mange lokale states som tilh&#248;rer hver komponent. &#197; bruke Recoil vil trolig ikke passe seg i et prosjekt der man tar untytte av &#229; bruke global state; hvis komponentene uansett skal bruke og endre samme state vil det v&#230;re un&#248;dvendig &#229; bruke Recoil, og en l&#248;sning som Redux vil passe bedre. Hvis man derimot har komponenter med ulik state, kan det l&#248;nne seg &#229; bruke Recoil, for eksempel i et prosjekt med mye brukeraktivitet der mange brukere gj&#248;r sm&#229; endringer ofte. Hovedforskjellen fra Context her er at med Context rerendres alt hver gang en state endres, mens i Recoil kan man rerendre kun den enkelte komponenten; dette vil spare oss for mye datatrafikk!<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2529,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en arkitektur som skal s&#248;rge for kommunikasjon mellom klientsiden og serversiden. Man gj&#248;r dette med URI- eller HTTP-requests. Man sender en request om &#229; f&#229; data som ligger p&#229; en bestemt URI- eller HTTP-adresse. P&#229; denne m&#229;ten m&#229; man ha forskjellige endepunkter for de forskjellige sp&#248;rringene, og det kan derfor bli mange endepunkter. I mange tilfeller kan slike sp&#248;rringer ogs&#229; f&#248;re til at man f&#229;r mer data enn det man egentlig trenger, fordi man alltid henter ut hele datasettet som ligger i endepunktet. Prinsippet med REST er stateless kommunikasjon. Det betyr at server og kleint ikke trenger &#229; vite noe om hverandre (de er ikke tett koblet sammen). Dette gir litt mer frihet, men f&#248;rer til mindre validering av dataen og det kan dermed enklere oppst&#229; feil. Man bruker put, get, post og delete for &#229; lese, endre, opprette og slette data. REST er ikke s&#230;rlig fleksibelt, men kan v&#230;re enklere for programmereren &#229; forst&#229;.<\/p><p>&#160;<\/p><p>I tillegg til at man risikerer &#229; hente ut for mye data, er det ogs&#229; en risiko for at man ikke f&#229;r hentet ut all dataen man trenger i &#233;n sp&#248;rring, og m&#229; bruke flere sp&#248;rringer. Dette skjer n&#229;r endepunktet man henter fra ikke inneholder tilstrekkelig data. Problemene med overfetching og underfetching l&#248;ses med GraphQL.<\/p><p>&#160;<\/p><p>GraphQL fungerer p&#229; den m&#229;ten at man sender queries der dataen man &#248;nsker &#229; hente (eller endre/slette/legge til) er definert. Med GraphQL unng&#229;r man det at man kanske henter ut mer data enn det man trenger (siden man definerer dette selv i sp&#248;rringen). Det f&#248;rer dog til lengre sp&#248;rringer, og kan v&#230;re mer tungvint &#229; programmere. Man kan p&#229; en m&#229;te si at GraphQL er &#34;n&#230;rmere&#34; serversiden da de er mer koblet sammen. Dette f&#248;rer til mer validering av dataen og mindre risiko for feil.<\/p><p>Den st&#248;rste forskjellen fra REST er at GraphQL ikke jobber med dedikerte ressurser, men ting henger sammen som i en graf (ting er inter-connected). P&#229; denne m&#229;ten kan man v&#230;re mye mer spesifikk i sp&#248;rringene, og mye mer fleksibel. Man kan ogs&#229; kombinere flere entiteter i en og samme sp&#248;rring, og dette kan minimere antall sp&#248;rringer. For store prosjekter vil dette v&#230;re sv&#230;rt nyttig.<\/p><p>&#160;<\/p><p>Vi valgte dog i v&#229;rt prosjekt &#229; bruke REST fordi i et prosjekt av st&#248;rrelsen vi uvitklet var det mer enn tilstrekkelig nok. Det var ikke mye data som skulle hentes ut, og det var derfor ikke et problem at vi tidvis hentet inn mer data enn vi egentlig brukte. For en nettside med mye trafikk vil dog dette kunne v&#230;re problematisk.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11542102,"ext_inspera_userAssessmentSetupId":7140104,"ext_inspera_userAssessmentId":4841132,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:42Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Lam Jan Ming (10072)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45419164,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2408,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt i react applikasjoner f&#248;lger som enveisrettet retning. Det vil si at i en React applikasjon, f&#248;lger du en hierarki som en typisk parent-child relasjon. Naturligvis kan parent best&#229; av flere h&#248;yere ordens parents, og kan ha flere childs. Egenskapen her er at Parent sender kun snapshot av komponentene til child, og child ikke kan endre p&#229; dem (read only), for &#229; oppdatere i containeren sender child hva som skal bli oppdatert via callbacks(rerenderet) til parent, og parent foretar endringene. I react beskriver man som regel dette som en state management, i form av nested child, eller lokal state, ettersom denne childen bare gj&#248;re bare endringer lokalt.&#160;<\/p><p>&#160;<\/p><p>Det er mange m&#229;ter og h&#229;ndtere states p&#229;, dersom vi ser p&#229; React alene er React Hooks normalt &#229; bruke for &#229; h&#229;ndtere states (for klasse komponenter brukes det mount, componentOnUpdate osv.). Ved &#229; h&#229;ndtere states lar det oss representer visuelt endringer av komponentene, dette kalles ogs&#229; interaktiviteten mellom bruker og applikasjonen. I tillegg til Hooks, og Mount, har vi i dette faget tatt i bruk av state management verkt&#248;y i form av Context, Redux/MobX, hensikten her er at i st&#248;rre applikasjoner er det flere &#34;lokale states&#34; som vi gjerne vil gjenbruke, med den normale parent-child container har vi som en &#34;annen&#34; parent ikke tilgang til en annen parent-child. L&#248;sningen p&#229; dette er at vi definerer globale states f.eks. i Redux blir alle states definert i en store, og vi henter ut fra denne storen. For &#229; kunne gj&#248;re dette er det spesielle kall for &#229; endre disse, i MobX kan f.eks. observerer bli brukt for &#229; lytte til at endring skjer, mens i Redux kan vi bruke actions for &#229; endre p&#229; dem spesifikt.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2801,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Basert p&#229; dokumentasjonen observerer jeg at Recoil er en state h&#229;ndterings verkt&#248;y. Hvis jeg skal sammenligne dette med l&#230;ringsm&#229;l vil dette g&#229; under React, Ajax, og state management.&#160;<\/p><p>&#160;<\/p><p>En klar fordel er bruk av Atom, ved &#229; tillegg bryte ned States til Atom kan det by p&#229; store fleksibiliteter ved h&#229;ndtering av detaljer p&#229; States(derived State), ettersom et Atom er global unikt, kan vi h&#229;ndtere den p&#229; et niv&#229; vi normalt ikke kan ved vanlige state h&#229;ndtering. For &#229; gj&#248;re dette brukes Selector, den har ogs&#229; vanlige GET, SET egenskaper som vi er kjent med fra State, hovr de i tillegg kan ta i bruk av &#34;promise&#34;(hvor vi normalt m&#229; ha en spesial case hvis vi &#248;nsker dette). &#160;Et eks. hvor Atom kan ha bedre ytelse enn vanlig state h&#229;ndtering kan v&#230;re et tegneapplikasjon i flere layers (tenk photoshop), det er kostbart og rerendre hele layer hver gang, ved bruk av Atom kan vi bryte ned states til spesifikke piksler/strokes, ogs&#229; kun rerendre dem.&#160;<\/p><p>&#160;<\/p><p>Recoil ser ut til &#229; h&#229;ndtere b&#229;de sync, <em>og <\/em>async fetch funksjoner, dette gj&#248;r s&#229; vi kan bruke async funksjoner p&#229; komponenter som bare er lagt opp for sync funksjoner. Og det er muligheter for &#229; bruke de om hverandre, s&#229; selectorene kan ha en egen erroor handling.&#160;I tillegg ser det ut til at det ikke er s&#229; mye boilerplates i forhold til f.eks.Redux.<\/p><p>&#160;<\/p><p>Ved &#229; se p&#229; dokumentasjonen kan jeg se at testing kan v&#230;re problemer basert kun p&#229; dokumentasjonen, her nevnes det kun teste endring i states ved snapshot. Og det virker ikke hensiktmessige &#229; snapshotte mellom hver endring dersom vi &#248;nsker &#229; teste mange endringer etter hverandre for &#229; sjekke at hver state blir h&#229;ndtert riktig. Det viser seg heller ikke til &#229; v&#230;re mye dokumentasjon heller, og noe som kan by p&#229; problemer under utvikling dersom det er en issue som ikke er kjent fra f&#248;r av. Det er ogs&#229; personlig preferanse for en st&#248;rre diskutert communi<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1883,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er vesentlige forskjeller mellom rest api, og graphql, da vi tok v&#229;rt valg under prosjekt 3 var det hovedsaklige disse tingene vi s&#229; p&#229;:<\/p><p>&#160;<\/p><p>Hvordan REST API og GraphQL h&#229;ndterer HTTP kall. Rest api sine kall bruker blant annet plain text, JSON, og HTML, kontra GraphQL sine schema, hvorav det er kun JSON.&#160;<\/p><p>&#160;<\/p><p>GraphQL har ogs&#229; kun &#233;n endepunkt hvor dataen(ressurrssene) ligger, kontra restapi hvor du m&#229; lage unik URL for de ulike dataene(ressurssene).<\/p><p>&#160;<\/p><p>GraphQL returnerer alltid status kode 200, kontra rest api. I tillegg kan vi modifisere response kode dersom man &#248;nsker det ved rest api. Dette gj&#248;r s&#229; graphql kan by p&#229; noe vanskeligehter ved API observerasjoner.&#160;<\/p><p>&#160;<\/p><p>Rest api m&#229; som regel fetche flere ganger for spesifikke data(fare for overfetch), kontra graphql som kan hente alle p&#229; en gang.(hvorav rest api har fare for underfetch)&#160;Dette gj&#248;r s&#229; restapi fetcher mer enn n&#248;dvendig for spesifikke data, hvorav graphql trenger bare ett kall.<\/p><p>&#160;<\/p><p>Graphql har ikke st&#248;tte for automatisk caching, hvorav restapi m&#229; definere om det skal bli cached.<\/p><p>&#160;<\/p><p>Rest api er tilstandl&#248;s, enhvert kall er uavhengig av hverandre. Og det er klar skille over hva som er klient/server kontra graphql sin rolle.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11541757,"ext_inspera_userAssessmentSetupId":7140125,"ext_inspera_userAssessmentId":4841326,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:29Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Herstad Liv Elise (10210)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45405438,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2369,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Komponenter har en egen lokal state som kan benyttes. Den er det bare de selv som kan aksessere. Dersom en annen komponent ogs&#229; er avhengig av samme state som en annen kan det sendes opp gjennom treet. Dersom mange komponenter p&#229; ulike niv&#229;er bruker dette blir det fort veldig komplekst og kan f&#248;re til at mange komponenter m&#229; re-renderes un&#248;dvendig for &#229; sende verdiene gjennom treet ved oppdatering. Kan da ta i bruk alternative m&#229;ter for state management som Context APIet, redux eller mobx hvor man lagrer slike states som tas i bruk av mange komponenter p&#229; et separat sted slik at komponentene som trenger &#229; bruke tilstanden kan hente inn herfra heller enn &#229; sende det gjennom treet. I Context APIet lager man et context objekt for tilstanden man vil gj&#248;re tilgjengelig og s&#229; kan de komponentene som trenger det hente det inn derfra. I b&#229;de redux og mobx lager man en store hvor man kan hente data fra. Begge bruker ogs&#229; actions i appen som beskriver noe som skjer i appen. I Redux har man ogs&#229; reducers som tar inn tilstand og action for &#229; bestemme om tilstand trengs &#229; oppdateres. I Mobx vil action p&#229;virke tilstanden direkte.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2699,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Alternativ m&#229;te &#229; h&#229;ndtere state p&#229;. Lagrer state i atoms separat fra selve react treet slik at det skal bli lettere for ulike komponenter som skal bruke samme state. Bruker ogs&#229; selectors som funksjoner som tar inn en atom eller annen selector og gj&#248;r noen beregninger basert p&#229; dem. Komponenter kan &#34;subscribe&#34; til atoms og selectors og vil da oppdateres n&#229;r det skjer endringer.<\/p><p>&#160;<\/p><p>Tilsvarende l&#248;sninger fra listen over l&#230;ringsm&#229;l er vel context API, redux og mobx. Virker som mindre arbeid &#229; sette opp enn de andre l&#248;sningene dersom man g&#229;r inn for &#229; bruke det fra starten av. Selve bruken virker (fra min side iallefall) til &#229; v&#230;re mer intuitiv ogs&#229;. Som alle de andre tre l&#248;sningene setter ogs&#229; recoil opp en separat sted for state som komponenter kan hente fra. Mens redux og mobx bruker stores s&#229; bruker recoil atoms med selectors. I recoil vil bare de relaterte komponentene oppdateres under rerendering.<\/p><p>&#160;<\/p><p>En fordel er at det gj&#248;r det lettere &#229; dele state mellom flere komponenter og at man bare re-rendrer de komponentene som p&#229;virkes ved endring i tilstand. Virker ogs&#229; intuitivt &#229; sette seg inn i og bruke.&#160;<\/p><p>En ulempe i seg selv er vel at det kan gj&#248;re appen mer kompleks enn &#229; bare bruke innebygd state, men &#229; bare bruke innebygd state kan ogs&#229; gj&#248;re en app veldig kompleks n&#229;r man m&#229; sende state gjennom flere niv&#229; av komponenter. Dersom komponentene i stor grad har separate verdier i state og ikke noe s&#230;rlig felles s&#229; vil fordelene ved &#229; bruke recoil forsvinne samtidig som man gj&#248;r det mer komplekst ved &#229; lagre state separat fra hvor det brukes.<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1922,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I Graphql henter man akkurat det man trenger, mens det med REST API er mye vanskeligere &#229; gj&#248;re da man ofte vil hente ut mer informasjon man trenger (over-fetching) eller ikke f&#229;r alt man trenger ved et kall (under-fetching) slik at man m&#229; gj&#248;re flere. Over-fetchingen skjer gjerne n&#229;r man skal hente ut et objekt, men bare trenger noe av informasjonen det inneholder. Med REST-API kan man rett og slett ikke bare hente ut deler av objektet slik som i Graphql, men m&#229; n&#248;ye seg med &#229; hente ut data som definert i serveren. I Graphgl har man ogs&#229; muligheten til &#229; hente ut flere objekter med samme kall, i motsetning til med REST-API hvor man m&#229; bruke separate kall for &#229; hente ut separate objekter. I GRaphql defineres hva som skal hentes i frontend<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11542127,"ext_inspera_userAssessmentSetupId":7140062,"ext_inspera_userAssessmentId":4841154,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:43Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rosager Jørgen (10212)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35302450,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2005,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstand i React-applikasjoner blir behandlet ved &#229; bruke for eksempel this.state (for klassekomponenter) eller useState-hook (for funksjonelle komponenter). Endringer av tilstand vil typisk f&#248;re til rerendering av komponenten.&#160;For klassekomponenter er hovedideen at du har all tilstand for applikasjonen din i this.state og at du har en funksjon for &#229; endre tilstanden til komponenten med this.setState(newState). For funksjonelle komponenter bruker man useState-hooken for &#229; f&#229; tilstand, denne sender tilbake en array med f&#248;rst tilstandsverdien og s&#229; en funksjon for &#229; endre tilstandsverdien. Vanligvis vil man bruk useState flere ganger i komponenten i motsetning til klassekomponenter hvor alt ligger i et object (this.state). Andre mekanismer som p&#229;virker state (eller man vil som regel at de skal p&#229;virke state) er lifecycle-metoder. For klassekomponenter vil disse metodene for eksempel v&#230;re &#34;componentDidUpdate&#34; eller &#34;componentDidMount&#34;, det er veldig vanlig &#229; kj&#248;re API-kall som vil endre tilstanden til komponenten i sistnevnte. Disse lifecycle-metodene blir erstattet av useEffect-hooken i funksjonelle komponenter (de gj&#248;r ikke helt det samme, men man kan f&#229; tiln&#230;rmet lik funksjonalitet).&#160;<\/p><p>&#160;<\/p><p>Dataflyt i React kjennetegnes av props, callback-funksjoner og global/semi-global&#160;statemanagement. Props (properties) er immutable dataverdier/funksjoner som sendes fra parent-komponent til children-komponent, disse kan da alts&#229; ikke endres av child direkte. Det andre kjennetegnet for dataflyt i React-applikasjoner er derfor callback-funksjoner, dette er funksjoner du sender ned gjennom props, som n&#229;r kalt inni child-komponent med en verdi satt der nede vil endre tilstanden lenger opp i treet til der den funksjonen kom fra. Det er for eksempel veldig vanlig &#229; sende endringsfunksjonen fra useState-hooken nedover i komponent-treet.&#160;<\/p><p>&#160;<\/p><p>Det er lett &#229; se at dette kan bli veldig komplekst og uoversiktlig i lengden om man m&#229; sende data/funksjoner gjennom flere lag for at de skal komme til riktig sted. Derfor er det veldig vanlig &#229; bruke global/semi-global&#160;statemanagement med for eksempel Context (fra React), Redux, MobX eller Recoil. Ideen her er at du har en global state som er tilgjengelig for (n&#230;rmest, sp&#248;rs hvor du definerer at den skal v&#230;re tilgjengelig) hele applikasjonen som har sine egne funksjoner som kan brukes til &#229; endre den globale staten. N&#229;r slike endringer&#160;blir gjort vil alle komponenter som bruker den globale staten bli rerenderet. Dette gj&#248;r koden mer oversiktlig og gj&#248;r koden inni komponentene mye enklere, p&#229; en annen side m&#229; dette ogs&#229; balanseres opp mot behovet for en global state. Man skal ikke plassere noe i den globale staten med mindre det er absolutt n&#248;dvendig og den dataen blir faktisk brukt mange steder i applikasjonen for &#229; slippe un&#248;dvendige rerendering eller un&#248;dvendig lagring av data.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3826,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et statemanagement bibliotek laget for React. Biblioteket lar oss splitte v&#229;r globale tilstand til flere &#34;atoms&#34;, disse kan oppdateres og bli subscribet p&#229; av komponenter som vil rerendres n&#229;r atomet endrer seg. Atomene kan bli subscribet p&#229; enkelt ved &#229; bruke useRecoilState(state) (en hook). Recoil har ogs&#229; &#34;selectors&#34;, disse brukes til &#229; kalkulere avledende data fra den minimale tilstanden larget i atomene. Disse kan subscribes p&#229; i likhet med atomer. P&#229; denne m&#229;ten f&#229;r man en effektiv statemanagement uten &#229; lagre un&#248;dvendig data og man henter hele tiden ut bare det man trenger.&#160;&#160;<\/p><p>&#160;<\/p><p>Biblioteket oppfyller mange av de samme funksjonene som for eksempel Context og Redux, men det er fortsatt en del forskjeller. Recoil har veldig bra performance i alle tilfeller der det er riktig &#229; bruke global statemanagement. Fordelen med Recoil er at bare de komponentene som subscriber til en atom/selector vil rerendres n&#229;r atom/selector (alts&#229; de atoms som blir brukt i selector) blir oppdatert, dette f&#248;rer til en sv&#230;rt effektiv l&#248;sning hvor man gj&#248;r sv&#230;rt lite un&#248;dvendige kalkulasjoner/oppdateringer. Dette er i motsetning til b&#229;de Redux og Context.<\/p><p>&#160;<\/p><p>I Redux vil man som regel f&#229; veldig god performance, spesielt ved &#229; bruke selectors riktig. Ulempen er derimot at selv om man har bra selectors s&#229; vil Redux m&#229;tte kalkulere om hvert component p&#229; rerendres, dette slipper man i Recoil fordi har bare oppdaterer de relevante atoms. Dette gj&#248;r at Recoil blir O(1) mens Redux er&#160;O(n). (https://news.ycombinator.com/item?id=23183177, Dave McCabe, skaper av Recoil).<\/p><p>P&#229; komplekse applikasjoner kan denne performancen ha mye &#229; si og v&#230;re en grunn til &#229; velge Recoil. En annen forskjell i forhold til Redux er kompleksiteten i koden. Redux har veldig mye boilerplate kode som m&#229; skrives bare for &#229; komme igang, mens Recoil har ingen. Dette gj&#248;r Recoil ogs&#229; til et bedre valg en Redux for sm&#229; applikasjoner hvor man bare vil komme raskt i gang.&#160;<\/p><p>&#160;<\/p><p>Sammenlignet med Context er det ogs&#229; mange fordeler. If&#248;lge Sebastian Markbage fra React Team s&#229; er Context laget for lav frekvens oppdateringer (som for eksempel theme) og ikke h&#248;yfrekvens oppdateringer som man ofte kan f&#229; i applikasjoner. (https://github.com/facebook/react/issues/14110#issuecomment-448074060,&#160;Sebastian Markbage, React Team). Dette kan ha blitt fikset siden 2018, men jeg fant dessverre ikke mer om det. Context har ogs&#229; mer boilerplate enn Recoil. En stor ulempe med Context er ogs&#229; at hver Context bare kan lagre en enkelt data og ikke en uendelig mengde av verdier som hver har sine egne consumers. Dette vil si at at for &#229; f&#229; en effektiv applikasjon med Context m&#229; du lage flere Context med sine egne providers. Dette gj&#248;r at Recoil er mye mer skalerbart, hvor man enkelt bare kan legge til nye atomer n&#229;r det trengs uten noe boilerplate kode.&#160;<\/p><p>&#160;<\/p><p>Hovedulempen for Recoil sammenlignet med disse er at som et nytt rammeverk s&#229; er det mangel p&#229; guides for alle brukstilfeller og at det kan v&#230;re mindre bugs som ikke har blitt luket ut enda. Redux som har eksistert og dominert statemanagement i lang tid har for eksempel veldig mye dokumentasjon og guides tilgjengelig i tillegg til veldig bra debugging-verkt&#248;y. Allikevel vil nok Recoil&#160;med tiden vokse og ta over rollen til Redux over tid.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1304,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST kan returnere forskjellige typer data (JSON, YAML), GraphQL kan bare returnere JSON. Dette er ikke en stor ulempe for GraphQL da JSON blir brukt i de fleste moderne nettsider, men om man beh&#248;ver annen data kan man m&#229;tte bruke en REST-api.&#160;En fordel REST har er at den kan&#160;implisitt cache i HTTP-laget, dette kan ikke GraphQL hvor man har caching p&#229; klient-siden. Dette krever derimot mye meta-data, noe som gj&#248;r at utviklere m&#229; sette opp caching selv for &#229; f&#229; den mest mulig effektiv.&#160;<\/p><p>&#160;<\/p><p>I REST-api definerer man flere endepunkter og hva de returnerer, for eksempel /users/&#60;id&#62; og /users/&#60;id&#62;/friends, i GraphQL sender man bare et query til GraphQL-serveren som returnerer det queryet spurte om. I REST kan dette f&#248;re til at man m&#229; gj&#248;re flere kall for &#229; f&#229; dataen man vil ha (underfetching)&#160;og man kan f&#229; en del redundant data (overfetching), mens dette blir unng&#229;tt i GraphQL hvor man bare f&#229;r det man har spurt etter.&#160;<\/p><p>&#160;<\/p><p>I&#160;GraphQL er det mulig &#229; definere skjemaer som definerer struktur og typer p&#229; begge sider av klient/server. Disse skjemaene er skrevet i SDL og deles mellom klient og server, dette gj&#248;r det enkelt for klienten &#229; vite hva slags data den kan f&#229; fra serveren og muliggj&#248;r validering. I REST m&#229; utvikler&#160;som regel passe p&#229; at begge sider av applikasjonen bruker den samme dataen. Dette gj&#248;r derimot ogs&#229; at GraphQL har en del h&#248;yere oppstartskostnad en REST, man m&#229; definere skjemaene f&#248;r man kan begynne. I lengden vil derimot dette v&#230;re en fordel fordi du har definert hvordan data kan se ut og oppf&#248;re seg, s&#229; man kan ikke gj&#248;re feil med typer som i REST.&#160;<\/p><p>&#160;<\/p><p>I REST s&#229; m&#229; man ofte tilpasse endepunktene til hvilke krav klienten har (alts&#229; frontend), dette kan f&#248;re til mye arbeid i utvikling. I GraphQL slipper man dette fordi man lar klienten utforme queries selv som sendes til et generelt endepunkt, alts&#229; slipper man &#229; endre for mye i backenden. Dette gj&#248;r GraphQL mer skalerbart enn REST-apier.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://jelvix.com/blog/graphql-vs-rest<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11542934,"ext_inspera_userAssessmentSetupId":7139915,"ext_inspera_userAssessmentId":4841380,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:01:53Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Holst Johan Ludvig (10213)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":43519249,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1994,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React applikasjoner er state management et viktig tema. Det finnes flere biblioteker som assisterer i bruk av state management, som Redux eller Mobx, men React selv har endret seg i l&#248;pet av &#229;rene siden det ble lansert, og introduksjonen hooks &#229;pner enklere flyt av logikk mellom komponenter.&#160;<\/p><p>&#160;<\/p><p>React har en innebygget m&#229;te &#229; utveksle tilstand i form av props. Dette tillater komponeter &#229; endre state i kj&#248;retid, samt &#229; f&#248;re tilstanden oppover i komponenthierkiet. Callback funksjoner hos foreldre tillater dermed at barn tilf&#248;yer state hos foreldre, og at dette kan fortsette oppover nodenettverket dersom det er flere komponenter under hverandre.&#160;<\/p><p>&#160;<\/p><p>State management bibliotek som&#160;Mobex benytter markeringene&#160;<em>observable<\/em> og <em>computed<\/em>&#160;av properties et objekt. Ved &#229; markere&#160;en prop observable, vet Mobx at disse verdiene kan endre seg over tid, og de blir dermed overv&#229;ket for tilstandsendringer. Computable kan s&#229; brukes for &#229; lage funksjoner som automatisk bruker dataen fra tilstanden som endres for s&#229; &#229; cashe datan.&#160;Dette er en av de store fordelene ved &#229; bruke state management, fordi da er det kun behov for &#229; endre dataen, tilstandsbibliotkektt tar defra &#229; oppdaterer dataen via de aktuelle kanalene fram til brukergrensesnittet.&#160;I Mobx&#160;er det ogs&#229; mulig &#229; utnytte en observer wrapper for &#229; f&#229; full utnyttelse av automatisert state managemnet som oppdateres automatisk selv i applikasjoner med store mengder data.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2390,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Utifra dokumentasjonen er det tydelig at biblioteket er designet for &#229; ha sterk tilh&#248;righet med React, og at det skal f&#248;les naturlig &#229; bruke biblioteket. Det er ogs&#229; klart at det er stor fokus p&#229; performance og at det skal v&#230;re enkelt &#229; designe for effektiv ressursbruk.<\/p><p>Recoil bruker Atoms som typedefinisjon for tilstand (som ogs&#229; mobx gj&#248;r), f.eks en samling arrays eller strings, men det er mulig &#229; gjenbruke disse noe som ikke g&#229;r i Mobx.<\/p><p>En eller flere komponent kan&#160;abonere p&#229; p&#229; et Atom, og ved endring av atomet vil ogs&#229; komponenten re-rendre dataen assosiert med det atomet. Det er ogs&#229; mulig &#229; tilf&#248;ye tilstand p&#229; alle niv&#229;er.&#160;<\/p><p>Det virker som at det er enklere &#229; bruke atoms i Recoil en Mobx, etter som atoms i Mobx blir abstrhert som objekter, mappings og arrays.&#160;<\/p><p>&#160;<\/p><p>Det utnytter hooks p&#229; en gjennkjennelig m&#229;te, blant annet s&#229; er useState byttet om med useRecoilState.&#160;<\/p><p>Recoil tilbyr ogs&#229; mange kjente konsepter, som observable.box, computed. use observer akuratt som i mobx.&#160;<\/p><p>&#160;<\/p><p>I forhold til mobx er det virker det som Recoil integrerer mer naturlig inn med react, men er derfor ogs&#229; avhengig av &#229; brukes med react. Dette kan b&#229;de v&#230;re en fordel fordi det krever mindre &#229; komme i gang. En trenger for eksempel&#160;ikke gj&#248;re masse arbeid for &#229; sette i gang &#229; bruke applikasjonstilstand. Dersom man liker de funksjonelle aspektene av react tror jeg Recoil kan passe veldig bra. Utifra dokumentasjonen og changelog virker det som det fortsatt er et ganske ungt bibliotek, kun nylig med integrasjon for typescript og mulighet for snapshot tester. Dersom en vurderer &#229; bruke Recol i et prosjekt kan dette v&#230;re verdt &#229; ta med i avgj&#248;relsesn.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2253,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest API&#160;og GraphQL er begge m&#229;ter &#229; sende data over http.&#160;Rest er et concept for en arkitektor, mens Graphql er et sp&#248;rringsspr&#229;k og verkt&#248;y for &#229; operere p&#229; data mellom to noder.<\/p><p>&#160;<\/p><p>Rest er ganske enkelt, i forhold til GraphQL sv&#230;rt lite fleksibelt. Ved en sp&#248;rring med Rest f&#229;r man alltid det komplette dataset, og dersom en &#248;nsker &#229; gj&#248;re logiske koblinger mellom flere datakolloner m&#229; det gj&#248;res manuelt enten av restserveren eller av klienten. Med graphql derimot, er det mulig &#229; gj&#248;re dynamiske sp&#248;rringer ved &#229; definere dataen som skal returneres. P&#229; denne m&#229;ten vil graphql gj&#248;re interagering med langring for &#229; returnere kun dataen som er etterspurt.<\/p><p>&#160;<\/p><p>En av de store fordelene med bruk av GraphQL er at det er mye enklere &#229; vedlikeholde, samt &#229; s&#248;rge for at nye versjoner eller implementasjoner av tjenester&#160;ikke &#248;delegger tidligere utgaver. Dette ettersom dataformatet alltid er tilpasset behovet til sp&#248;rreren. F.eks gitt introduksjon av nye tabeller i en database, s&#229; vil ikke dette v&#230;re en del av responsen i en GraphQL sp&#248;rring med mindre det var definert som et &#248;nske fra klienten. Med REST ville de nye feltene blitt inkludert og poteniselt &#248;delagt vesentlig logikk.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; en fordel at un&#248;dveldig data ikke blir overf&#248;rt, da en i Rest ofte utvikler apier som sender mer data en n&#248;dvendig for &#229; minimere antall sp&#248;rringer og redusere kompeksitet i APIer. Ved bruk av graphql er dette ikke et problem ettersom sp&#248;rringsspr&#229;ket er en del av graphql. Det vil si at un&#248;dvendig trafikk ikke opptar nettverket eller dataressurser (over-fetching eller under-fetching). Dette kan ha store fordeler f. eks for mobilbrukere eller brukere med redusert nettverkstilgang.<\/p><p>&#160;<\/p><p>Det er noen fordeler REST har, men sp&#248;r du meg er dette ikke fundamentale teknologifordeler men ligger heller&#160;i modenhet og utbredelse. Rest tilbyr st&#248;tte utover JSON, blant annet HTML,&#160;noe GraphQL ikke gj&#248;r, men jeg ser ikke at det er et behov som er utbredt. Rest har ogs&#229; automatisk cashing som kan v&#230;re en stor fordel ift ytelse. Rest gir ogs&#229; mer brukbare HTML feilkoder noe som kan gj&#248;re debugging enklere, GraphQL returnerer samme feil uanset hva som har skjedd. Jeg mener ogs&#229; det er en stor forenkling &#229; kun ha et endepunkt med GraphQL, hvor en derimot har mange forskjellige endepunkt ved bruk av Rest.&#160;<\/p><p>&#160;<\/p><p>GraphQL krever bruk av en graphql server, f.eks Apollo server, og det finnes ogs&#229; gode graphql klienter som passer godt med popul&#230;re frontend rammeverk. Kompleksiteten her er st&#248;rre en det som kreves for &#229; sette opp en rest-api, men mesteparten av arbeidet er gjort p&#229; forh&#229;nd av bibliotektene noe som gj&#248;r denne ulempen minimal.&#160;<\/p><p>&#160;<\/p><p>Alt i alt er graphql et&#160;moderne konspet for informasjonsutveksling over http og selv om det ikke l&#248;ser alle problemene med Rest er det en stor forbedring.&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11532843,"ext_inspera_userAssessmentSetupId":7139931,"ext_inspera_userAssessmentId":4841124,"dateLastModified":"2020-12-01T10:01:21Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:21Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aspaas Odd Gunnar (10166)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22039513,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2347,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er et komponentbasert bibliotek for Javascript. I komponentbaserte biblioteker har hver komponent en egen tilstand, og rotkomponenten inneholder vanligvis tilstanden til hele applikasjonen. Barna til rotkomponenten kan snakke med og endre tilstandsdata f&#248;r den blir sendt til serveren. I React skjer dette vanligvis med &#229; sende properties til barn og callbacks til foreldre.&#160;<\/p><p>&#160;<\/p><p>Hvis applikasjonen blir stor og kompleksiteten &#248;ker, blir det fort et behov for &#229; ha en mer kontrollerbar og forutsigbar tilstand, gjerne med hjelp av en <em>state management system<\/em>. Her kommer Redux og MobX (for v&#229;rt kurs) inn i bildet. De tar tilstanden ut av komponentene som en <em>stand-alone<\/em> enhet og tilbyr mekanismer for &#229; synkronisere applikasjonen p&#229; tvers av komponenter.&#160;<\/p><p>&#160;<\/p><p>B&#229;de Redux og MobX bruker enveis dataflyt. Dette betyr at man oppdaterer tilstanden til en applikasjon ved &#229; sende <em>dispatches<\/em>. Dispatches eller sendinger, m&#229; tolkes av en <em>reducer <\/em>i React, som finner ut hvordan sendingen skal tolkes. I MobX er ikke dette tilfellet da den ikke bruker reducers.&#160;<\/p><p><br />Redux og MobX passer flott inn i <em>Model-View-Controller<\/em> designm&#248;nsteret. Dette er et popul&#230;rt m&#248;nster brukt i programvareutvikling for &#229; skille data og brukergrensesnitt med hjelp av en megler. I de nevnte systemene, har de en datastore som inneholder tilstandsdata,&#160; la oss kalle denne Model. Videre har vi actions som brukes i dispatches nevnt tidligere. Disse definerer hva og hvordan vi vil oppdatere modellen v&#229;r. La oss kalle actions for controllers. Til slutt har vi view. Dette er det som vises frem i appen, da alts&#229; frontend av applikasjonen. Her kan brukere interagere og manipulere tilstanden til appen via bruker input. Det er verdt &#229; merke at mange MVC modellen ble f&#248;rst introdusert p&#229; 1970-tallet og nye modeller har kommet fra denne. De har lignende arkitektur og en popul&#230;r variant kalt&#160;<em>Model-View-Viewmodel<\/em> (MVVM) har blitt mye brukt i dette omr&#229;det. MobX skriver blant annet p&#229; sin offisielle side at den er inspirert av MVVM. [1]<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>[1] - (https://mobx.js.org/README.html#credits)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2761,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er facebook sitt svar p&#229; Redux og MobX. Recoil baserer systemet sitt p&#229; <em>atoms <\/em>(atomer) og <em>selectors <\/em>(velgere). Atomer er den sm&#229; enheter som inneholder tilstand. Tankegangen her er at komponenter kan lytte til atomene, noe likt en <em>publish-subscribe<\/em> m&#248;nster. Atomene kan oppdateres, og sender da ut informasjonen til de komponentene den har lyttende til seg. I Recoil er det ment at atomene tar over rollen til de lokale tilstandene som React komponentene har, og siden hvilken som helst komponent kan lytte til et atom, blir de lokale tilstandene delt globalt. Velgere er svaret p&#229; actions, som nevnt i oppgave 1. Forskjellen her er at velgere kan ta inn b&#229;de atomer og andre velgere. Velgere kan ogs&#229; oppdateres p&#229; lik linje som atomer, og lyttes til av komponenter. Man bruker ogs&#229; velgere til &#229; transformere data til en avledet tilstand.&#160;<\/p><p>&#160;<\/p><p>Recoil er laget av Facebook (forfatterne av React) og laget spesifikt til React. Redux kan benyttes i mange forskjellige rammeverk, dette gj&#248;r indirekte at Recoil er raskere enn Redux. Videre er Recoil tett koblet til react-hooks. Likevel er Recoil kun 7 m&#229;neder gammel og ikke like testet som Redux. Dette betyr at man ikke burde starte et stort kommersielt prosjekt med Recoil med det f&#248;rste. Videre kan har Redux en ganske stor boilerplate som kan v&#230;re vanskelig &#229; forst&#229; seg p&#229; av nye utviklere, mens Recoil har ingen boilerplate.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>(https://recoiljs.org)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2021,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REpresentional State Transfer (REST) og Graph Query Language (GraphQL) er to m&#229;ter &#229; sende data over HTTP. En REST-basert l&#248;sning er den tradisjonelle m&#229;ten &#229; sende data og har f&#229;tt en h&#248;y f&#248;lgerskare over &#229;rene.&#160;GraphQL ble open source i 2015 og er ofte presentert som en revolusjonerende ny m&#229;te &#229; tenke p&#229; API&#8217;er. Grunnen til dette er at GraphQL h&#229;ndterer mange av manglene til REST arkitekturen.&#160;&#160;<\/p><p>&#160;<\/p><p>REST er en API design arkitektur brukt for &#229; implementere nettside-tjenester. Dette gj&#248;r blant annet at en nettside kan be om tilgang og manipulere tekstbaserte ressurser p&#229; nettet ved &#229; bruke predefinerte og tilstandsl&#248;se operasjoner. Tilstandsl&#248;shet i denne sammenheng betyr at hver eneste HTTP request er isolert. N&#229;r klientsiden (frontend) ber om noe fra serveren, inkluderer det all informasjon som er n&#248;dvendig for at serveren skal kunne svare korrekt. Dermed kan man anta at serveren aldri trenger informasjon fra tidligere sendinger.<\/p><p>&#160;<\/p><p>Da REST ble introdusert i 2000 sammen med HTTP 1.1, var det et veldig annerledes internett enn det&#160;vi har i dag. N&#229; i dag, har smarttelefoner, stadig st&#248;rre IoT, og datadreven kultur f&#248;rt til stor ettersp&#248;rsel av store datamengder&#160;som kombinerer forskjellige ressurser. Med REST-baserte API&#8217;er betyr dette mange turer frem og tilbake fra serveren for &#229; hente alt man trenger. For eksempel, la oss si at <em>Instagram<\/em> har en relasjonsdatabase med brukere, bilder, <em>likes<\/em>, og kommentarer, samt bruker REST-API. For &#229; se p&#229; et innlegg p&#229; Instagram m&#229; man ha 4 rundturer&#160;til serveren. Hvis man scroller raskt nedover feeden, ville dette v&#230;rt sv&#230;rt kostbart.&#160;<\/p><p>&#160;<\/p><p>En annen mangel er n&#229;r REST-tjenester over- eller under-fetcher.&#160; Dette skjer n&#229;r man itererer eller skalerer en applikasjon, og man ikke lengre kan ha spesifikke endepunkter til alle entitetene i databasen. Hvis man da tar en l&#248;sning som for eksempel <strong>...com/users/ <\/strong>som returnerer alle brukerne gj&#248;r man en over-fetching.&#160;Under-fetching er det motsatte og f&#248;rer til at du m&#229; gj&#248;re flere kall, f.eks kalle alle brukere med <strong>:id<\/strong> i stedet for &#229; ha en <strong>/users<\/strong> endpoint.&#160;&#160;&#160;<\/p><p>&#160;<\/p><p>GraphQL er ett sp&#248;rrespr&#229;k for API&#39;er bruker sp&#248;rringer, ikke endepunkter til &#229; sende informasjon. Dette gj&#248;r at man kan definere spesifikt hva man sp&#248;rom og hvilke attributter man &#248;nsker.&#160;GraphQL har ogs&#229; st&#248;tte for typevalidering med hjelp av&#160;<em>schemas&#160;<\/em>i backend, alts&#229; f&#248;r det blir sendt til frontend. Dette sikrer konsis og sikker dataflyt.&#160;<\/p><p>&#160;<\/p><p>Hovedforskjellen mellom GraphQL og REST er at GraphQL ikke bryr seg om dedikerte ressurser. Med dette menes at alle entiteter behandles som noder og er knyttet sammen i en graf, derav navnet. Dette betyr ogs&#229; at man kan endre sp&#248;rringer til &#229; gi akkurat det man vil ha.<\/p><p>&#160;<\/p><p>B&#229;de REST og GraphQL er API design arkitekturer som kan bli brukt til &#229; bygge nettside-tjenester for data-drevne applikasjoner. GraphQL er mer fleksibel en REST ved at man kan endre sp&#248;rringer til &#229; hente n&#248;yaktig det man vil ha, der REST m&#229; definere endepunkter. REST benytter seg av caching-mekanismen som er innebygd i alle weblesere, mens GraphQL gj&#248;r ikke det. Dog REST sine mangler, har det overlevd i utrolig mange &#229;r, og har tatt plassen som industri standard. Dette har gjort at det finnes mye bedre verkt&#248;y for REST enn GraphQL den dag i dag, da spesielt med tanke p&#229; analyseverkt&#248;y.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>(https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis)<\/p><p>(https://en.wikipedia.org/wiki/Representational_state_transfer)<\/p><p>(https://graphql.org/)<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11533105,"ext_inspera_userAssessmentSetupId":7139914,"ext_inspera_userAssessmentId":4841128,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Morholmen Pål Andreas (10154)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34664995,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2090,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Props<\/strong> er en m&#229;te &#229; gi applikasjonen dataflyt. S&#229;nn som det meste i React f&#248;lger props hierarkiet i React-applikasjonen: Alts&#229; parent-elements&#160;kan sende props ned til child-elements. Props skrives inn i &#34;taggen&#34; til elementet i koden. Dette gj&#248;r at elementer av samme type kan variere ut ifra hvordan de er implementert forskjellige steder i applikasjonen. Mest brukt for lokale verdier.<\/p><p>&#160;<\/p><p><strong>Hooks<\/strong> er en m&#229;te &#229; gi en funksjonelle komponenter state (og andre funksjoner). Originalt kunne bare klasse-komponenter ha state, men med useState() hooken kan funksjonelle komponenter ogs&#229; f&#229; en state. Mest brukt for lokale verdier.<\/p><p>&#160;<\/p><p><strong>Context API<\/strong> er en m&#229;te &#229; innf&#248;re state management i en React-applikasjon. Den tillater komponenter &#229; sende informasjon gjennom hierarkiet uten &#229; m&#229;tte sende med props p&#229; hvert niv&#229;. S&#229; lenge Context Provideren ligger &#248;verst i hierarkiet, kan alle komponenter i applikasjonen n&#229; informasjonen som ligger der. En ulempe med dette er at de fort kan bli uoversiktlig i en st&#248;rre applikasjon. En fordel er at det er innebygd i React og man trenger ikke noen tredjepartsbiblioteker for &#229; f&#229; det til &#229; fungere.&#160;Mest brukt for globale verdier.<\/p><p>&#160;<\/p><p><strong>Redux<\/strong> er en m&#229;te &#229; innf&#248;re state management i en Javascript applikasjon. Sammen med biblioteket &#34;react-redux&#34; fungerer det str&#229;lende med React. Redux har ogs&#229; en Provider som gir tilgang til &#34;Storen&#34; (som det heter i Redux) til alle child-components. Redux introduserer ogs&#229; Actions og Reducers. Actions er det eneste som kan p&#229;virke staten og reducere har ansvar for &#229; gi tilbake den nye staten etter en action har blitt utf&#248;rt. Dette gj&#248;r at Redux state management blir &#34;predictable&#34; og sentralisert. Sammen med &#34;redux-thunk&#34; kan redux ogs&#229; ha asynkrone actions som API-kall f.eks. Redux kan ogs&#229; deles inn i deler med flere reducers sammensatt til en rootReducer for bedre oversikt. Redux brukes for globale verdier og brukes som oftest i litt st&#248;rre applikasjoner der state management med Context kan bli uoversiktlig og vanskelig &#229; opprettholde.<\/p><p>&#160;<\/p><p><strong>MobX<\/strong> er ogs&#229; en m&#229;te &#229; innf&#248;re state management i en Javascript applikasjon. Denne fungerer ogs&#229; med React. I motsetning til Redux som har en &#34;Store&#34; for staten, kan MobX ha flere &#34;Stores&#34; som er logisk separert. MobX bruker ogs&#229; observerbar data der Redux bruker vanlige JS objekter. Dette gir MobX fordelen med at informasjonen om staten&#160;blir automatisk oppdatert i komponentene. MobX brukes ogs&#229; for globale verdier og funksjoner og har som m&#229;l &#229; v&#230;re en skalerbar l&#248;sning for state management.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3479,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek laget&#160;spesifikt for&#160;state management i React. Kjerneid&#233;ene i Recoil omhandler Atoms og Selectors. Komponenter kan &#34;abonnere&#34; til b&#229;de atoms og selectors.<\/p><p>&#160;<\/p><p><strong>Atoms<\/strong> er sm&#229; enheter for &#229; holde state til en komponent eller state som deles mellom komponenter. Det er viktig at atoms har en globalt unik n&#248;kkel for identifisering i hele applikasjonen.&#160;En komponent kan f&#229; tilgang til staten ved hjelp av hooken useRecoilState(atom). N&#229;r den verdien blir endret i en komponent, blir den ogs&#229; oppdatert i alle andre komponenter som bruker den staten.&#160;<\/p><p>&#160;<\/p><p><strong>Selectors<\/strong> er funksjoner som tar inn atoms eller andre selectors. Disse er laget for &#229; kalkulere data basert p&#229; staten. Disse har blitt implementert for &#229; minimere totale staten. N&#229;r staten som en selector er avhengig av oppdateres, oppdateres ogs&#229; selectoren. En komponent f&#229;r tilgang til det selectoren returnerer ved &#229; bruke hooken useRecoilValue(selector). Disse kan ogs&#229; endres i komponenter og da vil de oppdatere alle andre komponenter som ogs&#229; bruker den selectoren.<\/p><p>&#160;<\/p><p>I motsetning til <strong>Redux,<\/strong> som har en store som holder hele staten for hele applikasjonen, bruker alts&#229; Recoil flere Atoms og Selectors til &#229; holde mindre biter av staten. Recoil har integrert st&#248;tte for asynkrone endringer. Redux kan gj&#248;re dette ved bruk av &#34;redux-thunk&#34; biblioteket. Recoil bruker hooks for &#229; f&#229; tilgang til staten, som betyr at det kun fungerer i funksjonelle komponenter. Redux har st&#248;tte for state management i klasse-komponenter. Recoil er ogs&#229; laget med React spesifikt i tankene som kan gj&#248;re det mer optimalisert. Redux er laget for generelle Javascript applikasjoner.<\/p><p>&#160;<\/p><p>I forhold til <strong>MobX<\/strong>, ser vi mange av de samme forskjellene som med Redux. Noe de har til felles er at staten kan deles inn i mindre logiske separerte enheter. B&#229;de MobX og Recoil har integrert st&#248;tte for asynkrone endringer. MobX har st&#248;tte for b&#229;de klassekomponenter og funksjonelle komponenter, Recoil brukes bare i funksjonelle komponenter.<\/p><p>&#160;<\/p><p>Til syvende og sist ser det ut til at Recoil sin st&#248;rste fordel er den tette integrasjonen med React (naturligvis n&#229;r det utvikles av samme firma). Redux og MobX er laget for alle typer JS applikasjoner, mens Recoil &#34;spesialiserer&#34; seg p&#229; React. I en applikasjon som har mange klassekomponenter kan det v&#230;re vanskelig &#229; innf&#248;re Recoil, siden alt m&#229; gj&#248;res om til funksjonelle komponenter. Her passer Redux eller MobX bedre. Recoil har heller ikke offisiell st&#248;tte for React Native eller Server-side rendering, noe b&#229;de Redux og MobX har. Dette er nok pga. Recoil er s&#229; nytt og blir sikkert implementert etterhvert.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1405,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I <strong>REST API<\/strong>&#39;er&#160;definerer man hvert eneste endepunkt som applikasjonen skal bruke. Det vil si at man m&#229; skrive spesifikke metoder for &#229; hente/lage/oppdatere ressurser som ligger i databasen. Disse metodene blir hardkodet og hvis frontend skal legge til eller endre funksjonalitet, er det h&#248;y sannsynlighet for at API&#39;et ogs&#229; m&#229; oppdateres. Dette er en ulempe fordi det krever ekstra tid i utviklingsprosessen. En annen ulempe er at n&#229;r applikasjonene blir st&#248;rre og man &#248;nsker mer informasjon fra flere ressurser, m&#229; man gj&#248;re flere API kall. Da er det mulig at man henter mer informasjon enn det man egentlig trenger. Spesielt p&#229; mobiler kan dette v&#230;re en ulempe fordi mer informasjon blir mer prosessering som blir mer str&#248;mforbruk. Fordelen med REST er at det er industri standarden for&#160;&#229; lage API&#39;er. Det betyr at det finnes mer dokumentasjon og mer modne metoder for &#229; implementere REST API&#39;er p&#229;. En annen fordel med REST API&#39;er er at de kan dra fordel av caching-mekanismer i weblesere.<\/p><p>&#160;<\/p><p><strong>GraphQL<\/strong> er et &#34;query language&#34; som baserer seg p&#229; &#229; sende sp&#248;rringer til serveren om akkurat den informasjon man trenger. Det betyr at i motsetning til REST API&#39;er med flere endepunkter, har GraphQL API&#39;er kun ett endepunkt&#160;som dekker funksjonaliteten til alt applikasjonen trenger.&#160;Fordelen med dette er at man ikke henter for mye informasjon (spesielt bra for mobiler). En annen fordel er at n&#229;r backend funksjonalitetene er implementert, kan frontend fortl&#248;pende introdusere nye funksjonalitet uten at backend m&#229; gj&#248;re st&#248;rre endringer.&#160;Ulemper med GraphQL er at det ikke kan ta nytte av caching-mekanismene i weblesere som REST API&#39;er kan. GraphQL st&#248;tter ogs&#229; kun JSON, mens REST kan legge tilrette for mange flere typer informasjon.<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11533692,"ext_inspera_userAssessmentSetupId":7139902,"ext_inspera_userAssessmentId":4841241,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aa Eirik Olav (10055)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35123771,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1915,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har men to ulike komponenter, Klassekomponenter og funksjonskomponenter. Klassekomponentene tilbyr mer funksjonalitet, da de extender Component fra React-biblioteket. Funksjonskomponenter er egentlig bare javascript funksjoner, og har ikke de samme React funksjonalitetene. Men fra React 16.8 ble det ogs&#229; mulig &#229; f&#229; state i funksjonskomponenter. Dette gj&#248;res ved &#229; ta i bruk useState-hooken. Hooks er funksjoner som lar deg bruke React-egenskaper i funksjonskomponenter. State er et javascript objekt som holder styr p&#229; den informasjonen som p&#229;virker outputen til komponenten. State er privat og det er kun den tilh&#248;rende komponenten som har tilgang til og kan endre&#160;denne informasjonen. Kan sammenlignes med hvordan en variabler som er deklarert inne i funksjoner. Hver gang state endres, oppdateres state-objektet, og komponenten re-rendres. Dette gjelder b&#229;de for klassekomponenter og funksjonskomponenter.&#160;<\/p><p>&#160;<\/p><p>For at komponenter kan snakke sammen tas det i bruk props. Props er ogs&#229; et javascript-objekt og har ogs&#229; oppgaven om &#229; holde p&#229; informasjon som p&#229;virker outputen til komponenter.&#160;Men props er ikke privat. Props kan passes fra foreldre-komponenter til barnekomponenter, alts&#229; dataflyten beveger seg nedover i komponent-treet. Dette gj&#248;res ved &#229; definere et barn i returnen, og bestemme hvilke props som skal sendes, og hva disse skal inneholde. Alle komponenter er pure functions mtp props. Det betyr at de alltid gir lik output for lik input. Props blir tatt inn hos komponenter litt p&#229; samme m&#229;te som parametere i en funksjon. Props er ikke mulig &#229; endre, s&#229; om det er informasjon som m&#229; endres inne i komponenten, s&#229; m&#229; man bruke state.&#160;<\/p><p>&#160;<\/p><p>Dersom man &#248;nsker &#229; dele informasjon mellom komponenter som ikke er foreldre og barn, kan man ta i bruk global-state. Det g&#229;r ut p&#229; &#229; lagre informasjon globalt, og s&#229; gi de komponentene som trenger det den informasjonen de trenger.&#160;Finnes flere ulike teknikker for dette, de vi har sett p&#229; i pensum er Context API, Redux og MobX. ContextAPI sender data gjennom treet, uten &#229; manuelt m&#229;tte passe props nedover i treet. Brukes ofte til globale data, som skal leses av mange komponenter. Redux lagrer alt av global state lagres i en store, og komponenter kan f&#229; tilgang til denne staten ved &#229; v&#230;re wrappet i en provider. Redux er read only og kan kun endres via actions. Har ogs&#229; sett p&#229; MobX. Dette fungerer som en observarberbar state, der hvor komponentene er observat&#248;rer p&#229; staten.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3834,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state-management bibliotek. Det tilbyr en data-flyts-graf som g&#229;r fr atomer, til selectorer og ned til komponentene. Et atom er en form for state, som kan forandres og abonneres p&#229;. En komponent kan abonnere p&#229; et atom, og hver gang atomet endrer seg, s&#229; vil alle komponentene som abonnerer p&#229; atomet re-rendre. Alle komponentene som abonnerer p&#229; et atom deler derfor state. En selector er en pure function som tar inn et atom eller en annen selektor som input. Gitt inputen, s&#229; returnerer selektoren en modifisert state hver gang upstream atomene eller selektoren endres. En selector kan ogs&#229; abonneres p&#229;, og likt som for atomer, s&#229; re-rendres alle abonnentene n&#229;r selectoren oppdateres.&#160;Recoil tilbyr oss p&#229; samme som Redux, Context API og MobX en m&#229;te &#229; h&#229;ndtere global state p&#229;.<\/p><p>&#160;<\/p><p>Context lager global-state for et tre av react-komponentet. Recoil pr&#248;ver &#229; gj&#248;re dette enda mer fleksibelt for komplekse aplikasjoner. Recoil &#248;nsker &#229; tilby en l&#248;sning for de som ikke f&#248;ler de trenger et fullt state-management system (som Redux og MobX), men ogs&#229; f&#248;ler seg litt for begrenset av Context.&#160;<\/p><p>&#160;<\/p><p>Problemene Recoil l&#248;ser med Context. Context kan kun dele state ved &#229; sende det opp til den fellese forfederen i treet, noe som f&#248;rer til en re-rendering av hele treet. Med Recoil vil kun de komponentene som abonnerer p&#229; akkurat det atomet re-renderes n&#229;r det endres. I tillegg s&#229; kan Context kun lagre en enkel verdi, mens Recoil kan lagre flere.<\/p><p>&#160;<\/p><p>Redux kan ogs&#229; ha mye un&#248;dvendige re-renders om man har flyttet mye av staten opp til store, vil man f&#229; mange re-renders av komponent-treet. Dette l&#248;ser Recoil p&#229; samme m&#229;te som sammenlignet med Context.&#160;<\/p><p>&#160;<\/p><p>En annen fordel i forhold til Redux er at det er mye mindre boiler-plates som skal til for at det skal fungere. Bruken av det vil minne mye om local state, men enkle gettere og settere. Det vil ikke v&#230;re et behov for en egen store for &#229; lagre alt state. Trenger heller egne actions, da komponenter rendres n&#229;r staten oppdateres.&#160;Recoil tilbyr ogs&#229; at utledet data kan flyte asynkront eller synkront uten &#229; modifisere komponentene som bruker det.&#160;<\/p><p>&#160;<\/p><p>I tillegg er Recoil ganske mye lettere &#229; l&#230;re virker det som, da det er mindre &#229; sette seg inn i. Og mange skirver at de f&#248;ler det f&#248;les mer som react og bruken av hooks enn det MobX og Reduc gj&#248;r.&#160;<\/p><p>&#160;<\/p><p>Recoil er enda ganske nytt, og det er vanskelig &#229; si om det er en fullverdig erstatter for annen state management. Det er ogs&#229; mer dokumentasjon om Redux, MobX og Context, som kan gj&#248;re det lettere &#229; tilpasse det din app.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1393,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av de st&#248;rste forskjellene mellom REST API og GraphQL er m&#229;ten data hentes ut p&#229;. I GraphQL opprettes det et skjema, og man kan sende sp&#248;rringer basert p&#229; dette skjemaet. Dette gj&#248;r at man kan hente definere tydligere hva slags data man skal hente fra databasen. Med REST f&#229;r man ikke begrenset hvilket felter man &#248;nsker &#229; hente ut, og man vil alltid f&#229; et komplett datasett fra en sp&#248;rring. Dette kan f&#248;re til &#34;overfetching&#34;, da man ofte henter ut mer informasjon enn det man trenger. L&#248;singen til GraphQL kan, om den implementeres godt, spare mye prosesseringskrefter ved at den ikke trenger &#229; hente like store datasett.<\/p><p>&#160;<\/p><p>En annen forskjell er at med REST API kan man ha flere endepunkter for &#229; lese, skrive eller manipulere data p&#229;. Da vil gjerne hvert endepunkt ha hver sin oppgave. F.eks det ene endepunktet er knyttet opp mot forfattere i databasen, mens et annet er knyttet til b&#248;ker. Med GraphQL er det vanlig alt g&#229; gjennom det samme endepunktet. Fordelen med flere endepunkter er at det kan v&#230;re litt mer oversiktlig, da du vet hvor du kan hente hvilken data. Et problem med flere endepunkter er at man m&#229; gj&#248;re mange kall for &#229; hente ut den informasjonen man trenger, og det kan igjen f&#248;re til &#34;overfetching&#34;.&#160;<\/p><p>&#160;<\/p><p>En ulempe med GraphQL er at det kun st&#248;tter JSON-data, mens REST API st&#248;tter mange data leselige formater (selv om JSON er det foretrukne formatet). GraphQL har heller ikke muligheten for implisitt caching av data, noe som er default st&#248;ttet av alle weblesere med REST API.&#160;Men GraphQL har mulighet for validering gjennom dens typesystem.&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533743,"ext_inspera_userAssessmentSetupId":7139974,"ext_inspera_userAssessmentId":4841304,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rankin Thomas Everleigh (10181)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331115,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2217,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React er den overordnede strukturen satt opp slik at data flyter fra parent til child. Det g&#229;r alts&#229; ovenifra og ned i hierarkiet. For &#229; endre dette m&#229; man benytte seg av tredjepartsbiblioteker som Redux, mobX osv, noe jeg ikke vil g&#229; inn p&#229; her.<\/p><p>&#160;<\/p><p>Props (properties) brukes for &#229; gi komponenter forskjellige verdier som input. Props er immutable som vil si at de ikke kan endres. Props er en god m&#229;te &#229; initialisere komponenter med forskjellige verdier, som for eksempel &#229; gi et komponent en unik tittel og beskrivelse.<\/p><p>&#160;<\/p><p>State brukes for &#229; endre tilstanden til komponenter p&#229; innsiden av komponentet, alts&#229; for &#229; oppdatere og re-rendre komponenter ved for eksempel brukerinteraksjon.<\/p><p>&#160;<\/p><p>En god m&#229;te &#229; endre states i React er hooks. Det mest vanlige hooket &#229; bruke er useState(), hvor man f&#229;r returnert en array med to verdier. Den f&#248;rste verdien i denne arrayen er tilstanden komponentet er i n&#229;. Den andre verdien er en funksjon hvor man bestemmer hva det er som skal gj&#248;res med tilstanden som er akkurat n&#229;, og p&#229; hvilken m&#229;te dette gj&#248;res.<\/p><p>&#160;<\/p><p>Ellers kan man ogs&#229; bruke en klasseversjon av state, hvor man setter lokale tilstander inne i klasser.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2189,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. Det ligner i bruk p&#229; hooks i React rammeverket, men har egne m&#229;ter &#229; h&#229;ndtere flyten av data i applikasjonen og tilstander. F&#248;rst og fremst er Recoil godt &#229; bruke om man har applikasjoner med mye dynamisk interaksjon hvor flere deler av applikasjonen endrer seg utifra brukerinteraksjon. Dette l&#248;ser Recoil bedre enn for eksempel Redux ved &#229; fokusere mer p&#229; state h&#229;ndteringens fleksibilitet og p&#229;virkning p&#229; applikasjonens ytelse. Recoil gir i tillegg en god oversikt over appens tilstander, som igjen gir bedre muligheter for debugging osv.<\/p><p>&#160;<\/p><p>Redux p&#229; sin side er ogs&#229; et state management bibliotek, men er mer omfattende i bruk enn Recoil. Redux l&#248;nner seg som regel kun for st&#248;rre, mer komplekse systemer, ettersom det er litt mer &#229; sette seg inn i enn n&#229;r det kommer til Mobx, Recoil, eller innebygget React state.<\/p><p>&#160;<\/p><p>Det kan v&#230;re b&#229;de en fordel og en ulempe at Recoil er s&#229;pass simpelt som det er. Dersom applikasjonen er et stort prosjekt med mange spesifikke bruksomr&#229;der med forskjellige behov vil kanskje ikke Recoil kunne tilfredstille alle disse behovene like godt som f.eks Redux. Men dersom applikasjonen trenger en simpel og oversiktlig m&#229;te &#229; h&#229;ndtere appens states vil Recoil v&#230;re et godt alternativ.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2760,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL er l&#248;sninger for klient-server kommunikasjon for web applikasjoner.<br /><br />REST API er en arkitektur som benytter seg av ett eller flere endepunkter i form av HTTP requests og URI for &#229; lese, skrive og endre ressurser. P&#229; den andre siden har vi GraphQL, som kun benytter seg av ett enkelt endepunkt som alltid n&#229;s med et POST request.<\/p><p>&#160;<\/p><p>REST API er lagt opp med en HTTP request, en URI/path og evt. noe data som skal hentes ut fra serveren, hvor HTTP requesten og URIen/pathen og dataen som skrives inn er frivillig:<\/p><p>&#160;<\/p><p>GET/movies{title: movietitle}<\/p><p>&#160;<\/p><p>med GraphQL vil derimot HTTP requesten alltid v&#230;re satt til POST, og URIen/pathen vil alltid v&#230;re den samme. I delen hvor man i eksempelet over har spesifisert dataen som {tilte: movietitle} vil man i graphQL ha en sp&#248;rring istedet:<\/p><p>&#160;<\/p><p>POST/graphql{sp&#248;rring}<\/p><p>&#160;<\/p><p>I REST defineres alts&#229; hva som skal returneres utifra hvilken kombinasjon av HTTP request, URI og data som sp&#248;rres etter, mens med GraphQL sender man sp&#248;rringer hvor man kan definere hva som skal hentes/manipuleres osv. fra/p&#229; serveren.<\/p><p>&#160;<\/p><p>En ulempe ved REST er at det kan bli un&#248;dvendig mange kall ved mer kompleks informasjon, fordi man da ender opp med mange og omfattende endepunkter. I tilleg kan det ved st&#248;rre og mer kompliserte applikasjoner som benytter seg av mye og kompleks data v&#230;re en fare for at man henter mer data enn man faktisk trenger.<\/p><p>&#160;<\/p><p>Dette problemet har man ikke med GraphQL. Ettersom man kan hente ut all data man trenger fra &#233;n request vil man alts&#229; unng&#229; &#229; hente ut data man ikke har bruk for.<br /><br />P&#229; den andre siden har man med REST API muligheten til &#229; lagre kopier av data som ofte hentes i et caching system. Dette er st&#248;ttet av alle nettleserene, og vil kunne gj&#248;re applikasjoner som gj&#248;r mange ensartede kall mer effektive. Dette st&#248;ttes ikke av GraphQL.<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11533802,"ext_inspera_userAssessmentSetupId":7140114,"ext_inspera_userAssessmentId":4841288,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Steen-Johnsen Odd Ferdinand (10090)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35241744,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2505,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Oppsummering:<\/strong><\/p><ul>\t<li>Statemetoder i de to klassetypene<\/li>\t<li>Callback-funksjoner&#160;<\/li>\t<li>Properties og propdrilling<\/li>\t<li>State managemenent<\/li><\/ul><p><br />For de to typene komponenter har de hver sine tilsvarende metoder for &#229; p&#229;virke state. I klassekomponenter har man feks&#160;setState(), imens en funksjonell komponent med hooks ville brukt useState() i kombinasjon med en variabeldeklarasjon.<\/p><p>&#160;<\/p><p>For b&#229;de &#229; sette&#160;state og &#229; sende data oppover i hierarkiet&#160;kan man bruke <strong>callback<\/strong> funksjoner. Dette er en mekanisme der man kan sette state til en komponent h&#248;yt opp i komponentreet fra en komponent som er lavere nede. Man gj&#248;r dette ved &#229; sende med en setState funksjon som en prop og drille det nedover s&#229; langt som trengs til den komponenten som skal bestemme hvilken informasjon som skal lagres i runtime.<\/p><p>&#160;<\/p><p><strong>Properties<\/strong> er data som en komponent blir deklarert med av forelderkomponenten.&#160;Som nevnt over er prop-drilling en teknikk for &#229; sende b&#229;de data og/eller funksjoner&#160;som en property n&#229;r en komponent blir deklarert.&#160;<\/p><p>&#160;<\/p><p>Alt over dekker dataflyten i en reactapplikasjon mellom forelder/barne noder. Hvis appen er mer komplisert med flere komponenter og mer informasjon som skal deles p&#229; tvers av noder er det lurt med en<strong> state manager<\/strong>. En state manager l&#248;fter staten ut av en enkelt komponent og gj&#248;r den tilgjengelig for en st&#248;rre del av applikasjonen. Dette gj&#248;r at koden er enklere &#229; forst&#229; i tillegg til at det minimerer muligheten for bugs.<\/p><p>&#160;<\/p><p><em>(Videre kommer en dr&#248;fting av state managers som ikke er like relevant som informasjonen over, men &#248;nsket &#229; vise min kompetanse p&#229; omr&#229;det. I tillegg&#160;underbygger det forkunnskapene mine for oppgave 2.)<\/em><br /><br />Riktig valg av state manager kommer an p&#229; omstendighetene rundt prosjektet du skal utf&#248;re.<\/p><p>&#160;<\/p><p>Jeg vil si at det kommer an p&#229; disse faktorene:<\/p><ul>\t<li>St&#248;rrelse p&#229; prosjektet<\/li>\t<li>Hvor mange som skal samarbeide<\/li>\t<li>Hva du/dere kan fra f&#248;r av<\/li><\/ul><p>Hvis du skal arbeide alene p&#229; et lite prosjekt er det ikke sikkert at du trenger en state manager i det hele tatt, men det kan v&#230;re verdt det &#229; ta en titt p&#229; <strong>Context<\/strong> for en ryddigere opplevelse.<\/p><p>&#160;<\/p><p>Hvis man er kjent med objektorientert programmering fra f&#248;r av og skal drive med et litt st&#248;rre prosjekt med flere medlemmer (eller alene) kan det l&#248;nne seg &#229; bruke <strong>MobX<\/strong>. Da kan man understreke hvordan man &#248;nsker &#229; implentere mobX l&#248;sningen sammen f&#248;r man begynner p&#229; prosjektet slik at alle er underforst&#229;tt med hvordan man &#248;nsker &#229; programmere state management l&#248;sningen. Da kan man benytte seg av observable funksjonene i tillegg til at det er minimalt med boilerplate for &#229; komme i gang. MobX er enkelt og intuitivt med en slak l&#230;ringskurve.<\/p><p>&#160;<\/p><p>Dersom man skal jobbe p&#229; et stort prosjekt med mange bidragsytere er <strong>Redux<\/strong> en god l&#248;sning. Redux har mye boilerplate og en bratt l&#230;ringskurve s&#229; her kan det l&#248;nne seg &#229; enten ha erfaring med det p&#229; forh&#229;nd eller sette av mye tid til &#229; faktisk l&#230;re seg det. N&#229;r man skal organisere mye data i runtime er redux et godt alternativ fordi det bringer en streng metodikk som m&#229; f&#248;lges for at alt skal fungere. Dette medf&#248;rer at det er enklere &#229; samarbeide p&#229; prosjekter med Redux fordi det er lite valgfrihet rundt implementasjonen av denne state managern. Derfor er redux mye brukt i store selskaper med mange bidragsytere p&#229; grunn av nettop frodelen med skalerbarhet.<\/p><p>&#8203;&#8203;&#8203;&#8203;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3145,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Hva er Recoil?<\/strong><\/p><p>Recoil er et state manager bibliotek laget til React av Facebook. Kort forklart s&#229; er systemet delt inn i atoms og selectors.&#160;Atom kan sees p&#229; som en del av state som er tilgjengelig for&#160;hele&#160;applikasjonen. Selectors er rene funksjoner som oppdaterer dem eller gj&#248;r kalkulasjoner p&#229; informasjon som finnes i state.<\/p><p>&#160;<\/p><p><strong>Sammenligning med andre state managers:<\/strong><\/p><p>Atoms og selectors&#160;er subscribeable i likhet med MobX som bruker observables. Komponenter rendres p&#229; nytt hver gang det skjer en endring i en Atom eller en Selector som de lytter til slik som en obervable komponent ville gjort i MobX.&#160;Redux Proovider, Context Provider&#160;er ganske lik som&#160;RecoilRoot som wrappes rundt den &#248;verste komponenten i appen. I likhet med MobX kan man manipulere state, med recoil s&#229; endres atoms, mye mer direkte endring av state&#160;enn man kan i Redux. I tillegg s&#229; er mengden boilerplate mye mindre enn Redux og mye n&#230;rmere det man kan forvente seg av en MobX eller Context state management implementasjon.<\/p><p>&#160;<\/p><p><strong>Fordeler:<\/strong><\/p><ul>\t<li>Trenger ikke lage en separert Store<\/li>\t<li>Opprett en State lettere med atoms, manipulere state direkte med Hooks-syntaks<\/li>\t<li>Slipper &#229; re-rendre hele appen hver gang state oppdateres. Data-flow g&#229;r direkte fra hver atom&#160;gjennom selectors og inn i komponentene. Dette gj&#248;r at hele applikasjonen er mer effektiv enn alternativer som Redux.<\/li>\t<li>Mye mindre boilerplate og du&#160;slipper &#229; omstrukturere appen n&#229;r man tar beslutningen om &#229; legge til Recoil. Gj&#248;r Recoil alternativet&#160;mer fleksibelt og skalerbart.<\/li>\t<li>Recoil syntaks er mye n&#230;rmere React og ligner p&#229; hvordan man er vant med &#229; bruke Hooks. Dette tror jeg vil gi en mindre bratt l&#230;ringskurve for de som allerede kan React litt fra f&#248;r av. (I motsetning til Redux)<\/li><\/ul><p>&#160;<\/p><p><strong>Ulemper:<\/strong><\/p><ul>\t<li>Recoil er basert p&#229; Hooks og kan bare brukes med funksjonelle komponenter. Siden det er basert p&#229; Hooks vil det ikke fungere med tradisjonelle react-klassekomponenter. Dette kan medf&#248;re omskrivning av eldre react apper f&#248;r man eventuellt implementerer Recoil.<\/li>\t<li>Nytt og eksperimentellt: Bl.a st&#248;rre risiko for bugs enn med mer etablerte l&#248;sninger<\/li><\/ul><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><ul>\t<li>Artikkel fra Medium skrevet av bruker&#160;<em>Chandu:<\/em><em>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/em><\/li>\t<li>https://recoiljs.org<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1422,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Backend API alternativene er vesentlig&#160;forskjellige p&#229; disse omr&#229;dene:<\/p><ul>\t<li>Endepunkter<\/li>\t<li>Caching<\/li>\t<li>Overfetching<\/li>\t<li>Validering<\/li>\t<li>St&#248;ttede data formater<\/li><\/ul><p><strong>Endepunkter:<\/strong><\/p><p>REST API bruker som regel flere endepunkter for &#229; hente ut informasjon. Man definerer flere endepunkter som gir forskjellig informasjon slik at man slipper &#229; hente ut all informasjonen fra databasen samtidig. En ulempe med dette er at man noen ganger m&#229; kombinere fler endepunkter for &#229; f&#229; informasjonen man trenger, dermed gj&#248;res det flere kall mellom Backend og database.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker et og bare et endepunkt. N&#229;r man bruker en l&#248;sning som implementerer GraphQL som spr&#229;k sender man med et schema som sp&#248;r etter informasjonen som trengs. Skjema blir sendt til dette ene endepunktet og evaluert derfra f&#248;r den henter den m&#229;lrettede informasjonen som ble etterspurt.<\/p><p>&#160;<\/p><p><strong>Caching:&#160;<\/strong><\/p><p>REST henter som regel ut mye mer informasjon p&#229; hvert kall enn det GraphQL gj&#248;r. Dermed er det ogs&#229; en mye st&#248;rre mulighet for &#229; kunne lagre denne informasjonen i &#160;nettleserens cache. Dermed kan man si at dersom informasjon som allerede har blitt hentet ut av REST cachen til nettleseres vil en REST som backend API v&#230;re traskere enn GraphQL som bare henter ut den informasjonen den trenger p&#229; hvert kall.&#160;<\/p><p>&#160;<\/p><p>S&#229; hvis REST har hentet ut overfl&#248;dig informason p&#229; et tidligere kall vil denne informasjonen senere v&#230;re mye raskere &#229; hente opp igjen fordi den er lagret lokalt i nettleseren. GraphQL vil derimot bruke ca. like mye tid p&#229; hvert kall med mindre den skal hente opp informasjon som har blitt hentet fra f&#248;r av.<\/p><p>&#160;<\/p><p><strong>Overfetching:<\/strong><\/p><p>GraphQL henter bare den informasjonen den trenger fordi et schema blir medsendt i kallet til databasen. REST henter et helt endepunkt og har dermed mye h&#248;yere risiko for &#229; f&#229; med mye mer informasjon enn det man egentlig trenger.<\/p><p>&#160;<\/p><p><strong>Validering:<\/strong><\/p><p>GraphQL har et innebygd typesystem for validering. REST har ikke dette.<\/p><p>&#160;<\/p><p><strong>Data-formater:<\/strong><\/p><p>GraphQL st&#248;tter kun JSON-data. REST st&#248;tter JSON og mange fler.&#160;<\/p>"}]}],"ext_inspera_totalScore":14,"score":14}},{"result":{"sourcedId":11534302,"ext_inspera_userAssessmentSetupId":7140034,"ext_inspera_userAssessmentId":4841182,"dateLastModified":"2020-12-01T10:01:25Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:25Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sjøborg Edvard Dønvold (10012)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34696882,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1727,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt i React g&#229;r normalt kun en vei hvor man kan sende props til komponenter. Komponenter har ogs&#229; sin egen state de kan endre p&#229; internt og sende nedover i hierarkiet. Det er ikke normalt sett lagt opp til &#229; sende data oppover i komponent hierarkiet, men det er mulighet for callback funksjoner som kan gj&#248;re noe i komponentene over. Denne enveis dataflyten gir bedre ytelse og er lettere &#229; debugge. Men det kan ofte bli vanskelig &#229; h&#229;ndtere en state som brukes mange steder i appen.<\/p><p>React sitt context api muliggj&#248;r globale verdier og data, men det er lagt opp til at endringene skjer sjeldent. Endringer som bruker autentisering eller valg av stil er typiske bruk for context apiet. Det er fult mulig &#229; implementere global state management som redux for h&#229;ndtering av hyppigere endringer. <span>&#160;<\/span><\/p><p>I dag er det &#34;hot&#34; &#229; utvikle funksjon komponenter som bruker hooks til &#229; h&#229;ndtere staten sin. Hooks kommer i mange forskjellige varianter, men useState og useEffect er de vanligste. Disse gir funksjons komponenter mulighet til &#229; oppf&#248;re seg i stor grad likt som klasse komponenter. Det er lagt til at man skal lage egne hooks i appen etter behov. Mange gode tredjeparts biblioteker inneholder sine egne hooks som gj&#248;r det enklere &#229; implementere biblioteket. Hvis en komponents state endrer seg vil dette som oftest rerendre komponenten.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3051,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en global state management l&#248;sning gir alle komponenter tilgang til atoms eller selectors. Atoms representerer rene verdier i appens tilstand. Ved endring av et atom rerendres alle komponenter som subrscriber til atomet. Selectors er en slags endring/transformasjon av en annen state eller verdi. Selectors kan endres ikke p&#229; samme m&#229;te som atoms gj&#248;r. Man kan p&#229; lik linje subscribe til selectors og lese verdene deres. Man m&#229; inkludere et RecoilRoot element som gir alle komponenter under i hierarkiet tilgang til Recoil staten.<\/p><p>Tilsvarende eksisterende l&#248;sninger er Redux, mobX og Context som ble gjennomg&#229;tt i faget. Den skiller seg fra Context APIet siden det er lagt opp til mange og hyppige endringer i staten. Det kan ogs&#229; hentes verdier asynkront. I forhold til Redux er det mye mindre oppsett med Recoil samt en mye enklere l&#230;ringskurve. Derimot er ikke Recoil kompatibel med klasse komponenter p&#229; samme m&#229;te som redux er. Jeg lite erfaring med mobX, men det virker som Recoil rerendrer alle komponenter som subscriber til et atom ved endring og mobX l&#248;ser dette p&#229; en bedre m&#229;te.<\/p><p>Helhetlig virker Recoil som en god l&#248;sning til global state management, men det er tydelig at det ikke er ferdig utviklet. Biblioteket virker som den l&#248;ser de fleste frustrasjonene jeg hadde med redux i prosjekt 3. Blant annet asynkron oppf&#248;rsel virker lettere med Recoil.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2392,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er teknikker brukt for h&#229;ndteringen av nett baserte ressurser. REST er noen design prinsipper som ble introdusert i 2000 og har v&#230;rt industri standard i lang tid. GraphQL er en nyere teknologi som fors&#248;ker &#229; l&#248;se mange av problemene med REST, men har ogs&#229; sine egne ulemper. Men i bunn og grunn baserer begge seg p&#229; &#229; gj&#248;re http foresp&#248;rsler etter data p&#229; en ekstern server.<\/p><p>I et REST API defineres ulike ende punkter hvor man kan hente en ressurs og disse endepunktene skal kun tilby denne ene ressursen. Dette forekommer i URLen til foresp&#248;rselen. Dette er egentlig et godt prinsipp ettersom det alltid vil bli gitt et fullkommet svar fra backenden. Hvis man &#248;nsker &#229; spesialisere svaret legges dette ogs&#229; i URLen. Men det er problemer med overfetching eller underfetching i et REST api. Overfetching henter clienten un&#248;dvendig data, mens underfetching menes det at man gjerne m&#229; sp&#248;rre flere endepunkter for &#229; l&#248;se en oppgave.<\/p><p>GraphQL l&#248;ser dette p&#229; en annen m&#229;te. Alle foresp&#248;rsler g&#229;r til samme URL, men man kan spesifisere hvilke data man &#248;nsker &#229; hente i et schema. Dette l&#248;ser problemet i REST med overfetching og underfetching. GraphQL sikrer at man kun f&#229;r den dataen man &#248;nsker.<\/p><p>Caching er ogs&#229; forskjellig mellom REST og GraphQL. Det er mye lettere &#229; chache med REST siden alle svarene med samme URL vil gi samme svar eller likt utseende p&#229; svaret. Med GraphQL er svaret fra serveren tilpasset foresp&#248;rselen s&#229; det blir vanskelig &#229; cache dataen godt i nettverkslaget. Dette vil f&#248;re til mer stress p&#229; en GraphQL server enn en REST.<\/p><p>En GraphQL server kan v&#230;re vanskelig og tidkrevende &#229; sette opp for mindre prosjekter i forhold til REST. Det er mye mere setup med &#229; definere querisene, typer og resolvers enn det er &#229; sette opp et endepunkt i REST.<\/p><p>I GraphQL vil svaret alltid v&#230;re et json objekt, mens med et REST API er det mulighet for mange forskjellige typer svar. Dette er veldig begrensende p&#229; mulige bruk av backenden.<\/p><p><span>Jeg tror det vil v&#230;re mye vanskeligere &#229; overv&#229;ke <\/span> nettverksbruken og ressusene i et GraphQL API. Med REST kan man helt tydelig se hvilke ressuser som blir brukt og hentet oftest p&#229; URLen, men jeg er usikker p&#229; om GraphQL har en solid l&#248;sning. Jeg har ingen erfaring med GraphQ<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534666,"ext_inspera_userAssessmentSetupId":7140113,"ext_inspera_userAssessmentId":4841258,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Lia-Rognli Emilie (10067)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330921,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2468,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har komponentene ulike state og props. State er den internte&#160;tilstanden til selve komponenten, og kan endres ved &#229; bruke setState(). Med hooks kan man ogs&#229; endre state til en komponent ved bruk av useState(). N&#229;r staten endres, s&#229; re-rendrer komponenten seg. Props st&#229;r for properties og er input som gies til komponenten fra andre komponenter. Man bruker props til &#229; sende data fra en komponent til en annen. Props er ogs&#229; read-only, det vil si at det ikke kan endres p&#229;. I props flyter data fra en parent-komponent til en child-komponent.<\/p><p>&#160;<\/p><p>N&#229;r applikasjonen din blir st&#248;rre, med flere komponenter og flere ulike tilstander man skal holde rede p&#229;, s&#229; kan det fort bli veldig vanskelig og uoversiktlig ved at man skal sende data p&#229; tvers av hierarkiet og til ulike komponenter. Om det er flere komponenter som skal bruke samme data, s&#229; kan man bruke noe som heter global state management. Her lagres all data, og til dette kan man bruke Context, Redux eller MobX.&#160;<\/p><p>&#160;<\/p><p>Context fungerer p&#229; den m&#229;ten at man wrapper hele appen rundt en ContextProvider, slik at alle komponenter under kan bruke contexten hvis de vil det. Det eneste man trenger &#229; gj&#248;re da er &#229; definere at man vil bruke context med&#160;React.useContext(Context) i selve komponenten. Context kan man endre p&#229; og manipulere slik man vil. Context brukes for det meste om man vil sette et tema for hele siden (feks. darkmode/lightmode), brukerautentisering eller foretrukker spr&#229;k p&#229; siden.&#160;<\/p><p>&#160;<\/p><p>Redux og MobX&#160;er to sider av samme sak, og lar deg samle data p&#229; en plass slik at du kan bruke det hvor som helst i komponenthierarkiet. I Redux har man &#233;n store der all dataen ligger, mens i mobx kan man ha flere (dette gj&#248;r at man kan splitte opp dataen p&#229; en mer hensiktsmessig m&#229;te). I redux benytter man seg av reducers og actions. Actions kan man se p&#229; som events&#160;handlers som dispatcher en action - det vil si det er her vi sier hvilken action vi skal gj&#248;re.&#160;Reducers forandrer staten i storen basert p&#229; action som skal gj&#248;res, og oppdaterer staten som er i store. For &#229; hente noe som ligger i store, kan man bruke useSelector(), og for &#229; dispatche en action, kan man si dispatch(action). Redux state er bare read-only (immutable), hvor man m&#229; bruke reducers og actions for &#229; endre p&#229; staten.<\/p><p>&#160;<\/p><p>MobX er ogs&#229; global state management. I MobX gj&#248;r man datastrukturene observerbare, og komponenter kan gj&#248;res til observat&#248;rer. N&#229;r man endrer en state her, vil de komponentene som ogs&#229; bruker denne staten, f&#229; oppdatert den. MobX er mutable, det vil si at man kan lese og skrive til storen. MobX kan alts&#229; bli opdatert uten &#229; trigge en action som i Redux.<\/p><p>&#160;<\/p><p>Dataflyt i react kan alts&#229; skje p&#229; flere m&#229;ter. Vi kan sende data ved hjelp av props, fra en parent til en child. Hvis en applikasjon skal bruke samme data flere plasser, l&#248;nner deg seg &#229; bruke global state management, som redux og mobx for &#229; samle all data p&#229; en plass (som skal brukes av flere komponenter). Context brukes ogs&#229; om man vil at flere komponenter skal bruke det samme - for eksempel darkmode.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://codeburst.io/mobx-vs-redux-with-react-a-noobs-comparison-and-questions-382ba340be09<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3051,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er state management som er innebygget i React fra f&#248;r i stedet for ekstern global state som vi har brukt (Redux, MobX, Context). Recoil skal forenkle det ved &#229; sende states/data p&#229; tvers av komponentene, og skal ligne p&#229; Redux, MobX og Context. Recoil er alts&#229; en ny type state management som er bygget inn i React, og som ikke trenger like mye konfigurasjon som feks Redux. I redux m&#229; man sette opp ganske mye p&#229; forh&#229;nd f&#248;r man kan h&#229;ndtere global state, og det skal man slippe i Recoil.<\/p><p>&#160;<\/p><p>I Recoil er det to hovedkonspeter: atoms og selectors.<\/p><p>&#160;<\/p><p>Atoms er enheter av state. Man kan tenke p&#229; de som lokale React state (alts&#229; i stedet for bruk av state), som alle andre komponenter kan subscribe til - de er globale, men ligger lokalt i komponenten sin. Vi bruker useRecoilState() i stedet for useState() som i &#34;vanlig&#34; react. Atoms kan oppdateres og brukes av andre, og n&#229;r en atom forandrer seg, s&#229; vil de andre komponentene som subscriber til atomet, re-rendere slik at de f&#229;r den nye verdien. Dette minner veldig om konseptet&#160;store&#160;i Redux og Mobx, bare at states ikke er samlet i &#233;n store, men spredt over flere komponenter som atoms. Dette betyr alts&#229; at de som subscriber til samme atom, deler samme state.&#160;<\/p><p>&#160;<\/p><p>Selectors er rene funksjoner som tar inn et atom eller andre selectors som input. Komponenter&#160;ogs&#229; subscribe&#160;seg til ulike selectors, slik som atoms. Selectors returnerer en ny state n&#229;r inputen deres ogs&#229; endrer seg. De komponentene som subsciber p&#229; en selector, vil ogs&#229; endre seg n&#229;r selectoren endrer seg. Selectors minner om actions og reducers i Redux, hvor man tar en state (atom), gj&#248;r noe med den, og oppdaterer staten. I redux tar man ogs&#229; en state, gj&#248;r noe med den, og f&#229;r en ny oppdatert state i store. Det at man kan subscibe seg til atoms og selectors minner om m&#229;ten MobX&#160;bruker observer-observat&#248;r teknikken for &#229; &#34;lytte&#34; til endringer, og selv re-rendere seg selv om en endring har skjedd.<\/p><p>&#160;<\/p><p>Recoil lar deg lage en dataflyt-graf som flyter atomer gjennom selectors og ned i komponentene dine.&#160;<\/p><p>I Recoil skal man klare &#229; dele states p&#229; tvers av komponenter, avledet data p&#229; en god m&#229;te n&#229;r det skjer endringer og i tillegg skal man kunne observere alt som skjer i appen fra en komponent (app-wide state observation).&#160;<\/p><p>&#160;<\/p><p>En fordel med Recoil er at man slipper &#229; konfiguere og sette opp veldig mye p&#229; forh&#229;nd f&#248;r man kan bruke global state mangament som i Redux.&#160;En annen fordel er at de ulike statene, atoms, ligger i den komponenten som de &#34;h&#248;rer hjemme til&#34; - det vil si der de i utgangspunktet blir hentet/endret, i stedet for at de ligger i en store med mange andre states. La oss ta s&#248;kefelt som et eksempel. Dette vil man kanskje bruke flere plasser i en app, s&#229; i stedet for &#229; legge searchterm som en global state i en store, s&#229; lager man den som en atom i den komponenten hvor searchterm faktisk blir hentet (la oss si et input-felt). Dette kan ogs&#229; sees p&#229; som en ulempe, da vi ikke har like god oversikt over alle globale state, atoms, som vi har i Redux hvor alt ligger i en store (eller flere i MobX). En annen fordel med Recoil er at man kun re-renderer de komponentene som har f&#229;tt en atom forandret. I Redux s&#229; kan det hende at hele appen re-renderer seg selv om man har alt samlet under en stor container, og det vil man gjerne unng&#229; om man kan - noe Recoil gj&#248;r.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.telerik.com/blogs/recoil-in-react<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1500,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQLer to m&#229;ter &#229; hente ut data fra endepunkter p&#229;. Det er flere forskjeller som skiller disse to.&#160;<\/p><p>&#160;<\/p><p>I REST&#160;bruker man ett eller flere endepunkter for &#229; lese, skrive eller endre p&#229; entiteter/ressurser ved &#229; bruke URI og HTTP request. I rest kan man bruke HTTP requests som PUT, GET, DELETE og POST for &#229; oppdatere, hente, slette og legge til data. N&#229;r man bruker rest, s&#229; vil man alltid f&#229; ut et helt datasett. Om du vil f&#229; ut feks data om en brukers favorittb&#248;ker, og data om brukerens favorittfilmer, m&#229; man gj&#248;re to forskjellige requests. Dette f&#248;rer ofte til overfetching, da vi kanskje f&#229;r mer data enn det vi har lyst p&#229;. Det er en ulempe med REST. N&#229;r informasjonen vi vil ha er mer kompleks, og endepunktene er mange, vil det f&#248;re til overfetching. En fordel med Rest, som vi ikke finner i GraphQl er muligheten for &#229; benytte caching - det vil si data som er hyppig brukt ligger i en cache. Vi vil alts&#229; klare &#229; hente ut dataen raskere.<\/p><p>&#160;<\/p><p>GraphQL kan oppfattes som mer intuitivt og enklere &#229; bruke enn REST. Det er basert p&#229; at du sender en sp&#248;rring til databasen hvor du definerer hva du vil hente ut. I GraphQL har man bare et singel endepunkt. Fordelen med GraphQL er at man ikke trenger flere endepunkter for &#229; hente ut de dataene du trenger, slik som i REST, men du spesifiserer alt i en sp&#248;rring. Om man vil hente ut en brukers topp 3 favorittfilmer, og topp 3 favorittb&#248;ker, kan dette gj&#248;res i sp&#248;rringen, og man vil f&#229; akkurat 6 JSON-objekter i retur. Vi har alts&#229; ingen overfetching i GraphQL. GraphQL har ogs&#229; et typesystem som gj&#248;r det mulig &#229; validere (alts&#229; definerer hvordan API ser ut som). Ulempe med GraphQL er at det ikke st&#248;tter caching og at det kun st&#248;tter JSON-formatterte data.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11536972,"ext_inspera_userAssessmentSetupId":7139909,"ext_inspera_userAssessmentId":4841324,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Torjusen Hanna (10102)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37363968,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2531,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I denne teksten bruker jeg det engelske ordet state for tilstand da det er dette ordet jeg har benyttet ved arbeid av prosjektene, ref. til oppgaveteksten som nevner tilstand.<\/p><p>&#160;<\/p><p>Prosjekter som benytter javascript biblioteket React, er strukturert med et hierarki av komponenter som kalles nedover i&#160;DOM-treet. Disse komponentene kan brukes om igjen i treet. For at dataflyten skal fungere mellom alle komponentene i treet kan man med React bruke ulike metoder.<\/p><p>&#160;<\/p><p>Komponenter over/under hverandre i treet kalles henholdsvis parent- og child-komponenter. En childkomponent kan arve/f&#229; nedsendt data fra parentkomponentene over. Ved React sendes disse som props som kan benyttes videre nedover i treet. Children kan ikke sende informasjon oppover i hierarkiet, og dersom et barn skal endre p&#229; en variabel i en forelder, m&#229; dette gj&#248;res ved at forelderen sender ned en callbac-funskjon som barnet benytter. Hvis man kun benytter denne metoden og ikke statemanaget(en m&#229;te &#229; holde styr p&#229; og endre tilstandene en applikasjon har)&#160;der det er hensiktsmessid kan det i noen tilfeller f&#248;re til problemer med consistency og redundans i webapplikasjonen. Dette skjer ved at variabler som skal oppdateres ikke alltid vil oppdateres, eller at noen variabler lagres flere ganger. I tillegg vil det ofte f&#248;re til at variabler vil lagres p&#229; unaturlige steder i hierarkiet for &#229; s&#248;rge for at alle childkomponentene som trenger variabelen f&#229;r tilgang til dataen via props.<\/p><p>&#160;<\/p><p>Statemanagementet Context er en m&#229;te &#229; f&#229; tilgang til dataen slik som diskutert i avsnittet over, men man slipper &#229; manuelt sende dataen som props gjennom alle komponentene i hierarkiet. Slik dagens Context benyttes i prosjekter&#160;brukes det sammen med hooks. Denne metoden &#229; h&#229;ndtere dataflyt er egnet godt for globale states, men den er ikke like effektiv for states som endres ofte. En av grunnene til dette er at Context utl&#248;ser en rerendring av siden n&#229;r staten oppdaterer seg.&#160;Eksempler p&#229; states som ikke endres s&#229; ofte, og context er godt egnet til, er tema p&#229; nettsider(f.eks dark/light mode), brukerinnstillinger elller brukerautentisering. Context er innebygd i React biblioteket, og man trenger dermed ikke &#229; laste ned noe tredjeparts-komponent for &#229; bruke Context. Context er alts&#229; en rask og enkel m&#229;te &#229; innf&#248;re statemanagement, ved at man ikke trenger &#229; sette opp en egen fil etc. for dette.<\/p><p>&#160;<\/p><p>For &#229; h&#229;ndtere et st&#248;rre sett av states, kan man innf&#248;re&#160;en annen form for statemanagment slik som Redux. Redux er et tredjeparts-komponent og kan installeres via. eksempelvis npm. De ulike statesene lagres utenom selve komponentene i hierarkiet, men heller i en store med tilh&#248;rende reducers og actions. Denne storen er en global tilstand og kan deles inn i flere filer dersom det er hensiktsmessig, men m&#229; ha sine egne reducers og actions. Reducerene er&#160;funskjoner som bestemmer endringene til staten, og reduceren bruker den actionen den mottar for &#229; bestemme nevnte endring. Dataen/statsene lagres alts&#229; i storen, som er read-only, men kan endres via disse actionsene/reducerne. Statsene endres ikke direkte, men man erstatter den gamle staten med den nye staten. Det betyr at men&#160;eskempelvis ikke kan appende en array direkte i staten, man m&#229; heller tilegne staten hele den nye arrayen. For &#229; f&#229; tilgang til actionsene i komponenthierarkiet bruker man dispatch, og for &#229; f&#229; tilgang til variablene bruker man useSelector. I motsettning til slik som nevnt om Context, fungerer Redux&#160;veldig bra til ting som opdateres ofte. Dette kan eksempelvis v&#230;re informasjon som lagres i en s&#248;kekatalog hvor filtrene lagres i en state. For utviklingsprosessen har Redux devtools. Dette er et verkt&#248;y som enkelt lar utvikleren tracke staten applikasjonen har og hva som endres n&#229;r, dette har ikke Context.<\/p><p>&#160;<\/p><p>En annen statemanagement er bibilioteket MobX. Mobx har stor flexibilitet,&#160;er enkelt og skalerbart og p&#229;virker i mindre grad koden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2238,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil, lansert av facebook, er et statemanagement bibliotek for React. Recoil er dermed laget for &#229; l&#248;se en del av begrensningene man har uten en statemanagment, som nevnt i oppgave 1. Recoil er laget for &#229; slippe &#229; m&#229;tte lagre states oppe i en felles forelderkomponent, og i tillegg l&#248;se begrensningen context har med &#229; kun lagre en enkelt verdi. Begge disse faktorene gj&#248;r det vanskelig &#229; splitte opp koden som ligger h&#248;yest i hierarkiet fra komponentene lenger nede. Dette skal Recoil l&#248;se, men ved &#229; fortsatt beholde API og semantikken, og oppf&#248;rselen mest mulig lik som React.<\/p><p>&#160;<\/p><p>Recoil best&#229;r av atoms og&#160;selectors. M&#229;ten komponenter f&#229;r tak i atoms og selectors er ved &#229; subscribe p&#229; disse, litt slik som n&#229;r man bruker usedispatch og useselector for &#229; benytte actions og states i Redux.&#160;Atoms er enheter av tilstanden/Staten. N&#229;r et atom oppdateres vil&#160; komponenter som benytter atomet re-rendres. Dette kan sammenlignes litt med hvordan man i react kan sette conditions i en useEffect i komponenter slik at n&#229;r&#160;tilstandene som ligger som conditions oppdateres vil useEffecten s&#248;rge for at komponenten de befinner seg i vil re-rendres. Ved redux ville disse tilstandene v&#230;rt lagret i store, men en slik separat store trengs ikke i Recoil. Selectors er funskjoner som kan endre p&#229; atomene, litt slik som actions i Redux. Selectors fungerer b&#229;de synkront og asynkront, til forskjell fra Redux som ikke er asynkront.<\/p><p>&#160;<\/p><p>For &#229; hente og sette atomene i Recoil kan man enkelt benytte useRecoilState, litt p&#229; samme m&#229;te som med komponenters state som benytter setState. Dette er forskjellig fra Redux som har to ulike metoder &#229; hente og sette satesene(useSelector og usesispatch slik som nevnt tidligere).<\/p><p>&#160;<\/p><p>M&#229;ten Recoil fungerer p&#229; er at det defineres en ortogonal grad knyttet til react treet. Her flyter staten gjennom funksjoner(selektorene) og ned til komponentene.<\/p><p>&#160;<\/p><p>Recoil har en &#34;tidsreise&#34;-funksjon som gj&#248;r at du kan lagre en gammel state fra en snapshot test. Dette er nyttig funksjonalitet for &#229; g&#229; tilbake &#229; gjennopprette tidligerere globale tilstander.<\/p><p>&#160;<\/p><p>Til forskjell fra Context har b&#229;de Redux og Recoil dev tools som gj&#248;r at man under utvikling enkelt kan f&#248;lge med p&#229; hvordan tilstandene endres.<\/p><p>&#160;<\/p><p>Ulemper med Recoil, over eksempelvis Redux, er at det er nyere og dermed mindre dokumentasjon tilgjengelig. Eksempelvis var noen&#160;punkter, slik som APIet Atom Effects, under Recoils offisielle dokumentasjon hvor det sto at funksjoner fortsatt er under utvikling.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee#:~:text=In%20redux%2C%20actions%20are%20fired,shared%20atom%20state%20using%20selectors.<\/p><p>https://medium.com/better-programming/recoil-js-the-new-better-state-management-library-for-react-1095947b5191<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2386,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST og GraphQL er backend APIer. REST er et velbrukt API med masse dokumentasjon tilgjengelig slik at det er enkelt &#229; finne informasjon for &#229; implementere og bruke dette. REST har lenge v&#230;rt best practice ved design av API-er for web. GraphQL er en nyere metode som er ment for &#229; l&#248;se noen av ugunstighetene REST har. GraphQL er laget for &#229; v&#230;re enkelt &#229; bruke og enkelt &#229; konfigurere. Allikevel er det i noen tilfeller vanskeligere &#229; implementere fra bunnen av, fordi det er nyere og dermed med mindre dokumentasjon og har blitt mindre utpr&#248;vd.&#160;Det er dog mer informasjon som trengs for &#229; sette seg inn i REST i forhold til GraphQL, slik at inngangsbarrieren ikke er like stor for GraphQL. Det er ogs&#229; mindre feilmargin med&#160; GrapghQL.<\/p><p>&#160;<\/p><p>REST overf&#248;rer tilstand, men er tilstandsl&#248;s. Her har vi operasjoner som GET, POST og PUT. REST er ikke avhengig av tidligere informasjon for &#229; svare p&#229; en foresp&#248;rsel. Dette kan f&#248;re til utfordringer ved eksempelvis h&#229;ndtering av s&#248;kefunksjoner(sortering, filtrering, paging, s&#248;keinput), og l&#248;sningen p&#229; dette er at man m&#229; gj&#248;re et nytt s&#248;k. Har man eksempelvis en s&#248;keside p&#229; verdens land, og man f&#248;rst huker av kontinentet Asia for &#229; s&#248;ke p&#229; dette, for deretter &#229; legge til ett nytt kontigent vil ikke REST APIet huske alle landene som tilh&#248;rer Asia. Derfor vil man finne alle disse landene p&#229; nytt i tillegg til de nye landene. Rest legger opp til bruk av browserens caching.<\/p><p>&#160;<\/p><p>GraphQL er et query language(sp&#248;rrespr&#229;k) hvor man skreddersyr hva man henter av informasjon. Det brukes server-side runtime for &#229; utf&#248;re sp&#248;rringer. Objektene i GraphQL er representert av noder, definert av GraphQL skjemaet, og forholdet mellom nodene er kantene i grafen.<\/p><p>&#160;<\/p><p>N&#229;r man bruker REST skriver man kall til endepunkter, og man kan lage flere endepunkter. Man skriver inn parametse som hentes inn alt ettersom hvilket endepunkt man gj&#248;r kall til. I GraphQL derimot er det kun ett endepunkt.<\/p><p>&#160;<\/p><p>N&#229;r man gj&#248;r et kall med REST f&#229;r man alltid returnert et helt datasett. Dette kan f&#248;re til over fetching, at man f&#229;r mye mer data en man har behov for. Som nevnt er GraphQL et query language, og man kan derfor sp&#248;rre spesifikt etter akkurat den informasjonen man trenger slik at man&#160;unng&#229;r over fetching&#160;og limiterer dermed prosesseringen som kreves. I tillegg er det med GraphQL mulig &#229; hente informasjon fra flere objekter i et kall utifra en slik sp&#248;rring, men med REST m&#229; man gj&#248;re x antall kall til x ulike endepunkter n&#229;r man skal ha informasjon om x antall objekter. Dette er s&#229;kalt under fetching, som vi alts&#229; ogs&#229; unng&#229;r med GraphQL.<\/p><p>&#160;<\/p><p>GraphQL har ikke implisitt caching i HTTP-laget. Det er kun JSON for utveksling av data, men med REST er det flere formater. En annen ulempe med GraphQL er at applikasjonen ikke kj&#248;res fra serveren, fordi det er kobling mellom server og klient.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilde:<\/p><p>https://goodapi.co/blog/rest-vs-graphql (link anbefalt fra forelesning)<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11537042,"ext_inspera_userAssessmentSetupId":7140050,"ext_inspera_userAssessmentId":4841197,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Funnemark Elin Schanke (10041)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303713,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2236,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt inneb&#230;rer &#229; sende data mellom komponenter. I react brukes props som en m&#229;te &#229; sende argumenter mellom kompoenentder. Ved bruk av props kan en kompoennet motta data fra sin foreldre kompoenent. For &#229; h&#229;ndtere tilstand brukes state. State er et objekt som lagrer verdier som tilh&#248;rer kompoenenten, og state blir direkte initialisert. State kan bli initialisert av props. State kan alts&#229; lagre data sendt til kompoenenten som props. For &#229; endre et state objekt brukes setState(). N&#229;r en endring i state skjer vil kompoenenten re-rendres.&#160;<\/p><p>&#160;<\/p><p>Det &#229; h&#229;ndtere state er et viktig konsept i react, og en vanlig&#160;m&#229;te&#160;&#229; gj&#248;re dette p&#229; er ved &#229; nruke props som sendes nedover kompoenenten. Denne m&#229;ten er derimot ikke skalerbar til st&#248;rre applikasjoner. Eksempelvis er det tungvidt &#229; sende props nedover mange ledd dersom hierrkiet er sotr. For &#229; h&#229;ndtere state p&#229; tvers av dette kompoenent hierarkiet kan man da implementere global state. Det finnes flere m&#229;te &#229; h&#229;ndtere state globalt p&#229; og dermed f&#229; en bedre dataflyt i en&#160;st&#248;rre react applikasjonen. Eksempler p&#229; dette er ved &#229; bruke Context, Redux eller MobX. Disse tre vil n&#229; forklares.&#160;<\/p><p>&#160;<\/p><p>Context er en m&#229;te &#229; h&#229;ndter state globalt p&#229; og gj&#248;r slik at man kan hente state over alt i koden. Dette betyr at en ikke trenger &#229; sende props manuelt nevoder treet p&#229; hvert niv&#229;. For &#229; bruke context lager man en egen context klasse som wrappes i en provider slika t den er tilgjengelig for alle komponenter. Context er en mekanisme som lagrer data og varser burere n&#229;r dataen har forandret seg. Det er ikke regler om &#229; fortelle provider klassen i seg selv n&#229;r forandringer skjer, men heller en mekanisme som forteller consumers at en forandring har skjedd. Context inkluderer creat context, provicde context og cosume contect. En lager vanligvis en ny context for hver unike data som skal v&#230;re tilgjengelig i kompoennt treet. Provider lar en deklarerer data som trengs i kompoenenttreet. Consumer lar alle kompoenenter som trener data &#34;abonomere&#34; p&#229; denne dataen.&#160;En kan ogs&#229; i kompoenentene, endre daten i context. Alt detet gj&#248;r at man f&#229;r en global state h&#229;ndtering.&#160;Context brukes hovedsakelig&#160;n&#229;r data m&#229; v&#230;re tilgjengleig for mange kompoenenter p&#229; ulike niv&#229;er av kompoent treet.<\/p><p>&#160;<\/p><p>Neste m&#229;te man kan h&#229;ndtere global state p&#229; er ved &#229; bruke Redux. Redux lager en reducer, som har en handling, som oppdaterer store. Dette metoden krever alts&#229;; actions, reducers og store. For &#229; enkelt forklare hva dette er kan en si at actions er eneste kilde for informasjon til stor. Actions har all informasjon som sender data fra applikasjoneen til store. Reduceers er ansvarlig for hvordan applikajsonene forandres som resons av en handling gjort an en end-user. Stor kobler alt sammen og gj&#248;r at applikasjonene funer. For &#229; gj&#248;re store tilgjengelig i appen og dens komponeneter m&#229; app wrappes i en &#60;Provider&#62; kompoenent. For &#229; hente ut state i en kompoenent brukes useSelector() og for &#229; endre state brukes useDispatch(). En enkel forklaring p&#229; hvordan redux funker er som f&#248;lger:<\/p><p>1. et event skjer i systemet, som dispatcher en action til store<\/p><p>2. store mottar action og oppdaterer store gjennom state reduction<\/p><p>3. n&#229;r state er oppdatert informeres alle lyttere til storen og at dataen har forandret seg og kompoenenten oppdateres<\/p><p>&#160;<\/p><p>Siste m&#229;te jeg skal nevne for &#229; h&#229;ndtere ste er MobX. MobX er et bibliotek som har observerbare datastruktur for &#229; automatisk oppdage endringer gjennom &#34;abonomenter&#34; MobX har f&#248;lgende konsepter: state, derivations og actions. En kan forklare MobX slik: mobX har en action som oppdaterer en &#34;observable&#34;. denne &#34;observable&#34; forusaker en reaksjon alle sted hvor dette observerbare objektet er brukt. Dette betyr at applikasjonene kun oppdaterer noen objekter, og disse vet MobX akkuratt hvor er. I forhold til Redux s&#229; har MobX mye mindre boilerplate koding.<\/p><p>&#160;<\/p><p>For &#229; besvare denne oppgaven er det brukt forelseningslide og medium.com sine sider om de ulike metodene<\/p><p>-&#160;https://medium.com/leanjs/introduction-to-redux-redux-explained-with-very-simple-examples-b39d7967ceb8<\/p><p>-&#160;https://medium.com/@chamikakasun/react-context-api-whats-it-all-about-75a8a4bf62fa<\/p><p>-&#160;https://medium.com/better-programming/react-and-mobx-lessons-learned-427a8e223c93<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3037,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som brukes for state management. Recoil skal gi en rask og fleksibled shared state. Recoil lar deg lage data-flow fra atomer, gjennom selectors og ned til react kompoenentene. Her er atomer den delte saten som&#160;er oppdaterbare og en kan abonomere p&#229; disse. N&#229;r et atom oppdaterer seg vil kompoenentene som abonomerer varsles&#160;og re-rendres. Selectors er rene funksjoner som tar atomer eller andre selectorer som input. En selector representerer en bit av derived state. Derived state kan ses p&#229; som output fra &#229; gj&#248;re state om til rene funskjoner som modifiserer staten p&#229; en m&#229;te. Derived state er et bra konsept fordi det lar en bygge dynamisk data som avhenger av hverandre.&#160; En fordel med recoil er alts&#229; at det<\/p><p>&#160;<\/p><p>En kan sammenlikne dette med eksmepelvis Context. I dokumentasjonen nevnes det blant annet at en av motivasjonene til &#229; lage dette bibliotektet var fordi et problem med context er at context kun kan lagre en enkelt&#160;verdi, ikke et ubegerenset sett med verdier med sine egnene consumers. Dette gj&#248;r det vanskelig &#229; dele koden mellom toppen av treet, hvor sate &#34;bor&#34; og lengere ned i treet hvor state &#34;brukes.&#34;. En fordel med recoil er alts&#229; at dne lar deg gj&#248;re dette.&#160;<\/p><p>&#160;<\/p><p>En kan ogs&#229; sammelikne Recoil med redux, som er det mest popul&#230;re biblioteket for &#229; h&#229;ndtere state. I Redux&#160;lages applikasjonenes state ved &#229; bruke reducers, i Recoil er det &#229; dele state en &#34;straight forward approach using atoms&#34;. Hvert atom kan ses p&#229; som en en enekelt del delt data. For &#229; gj&#248;re en action i redux brukes distpatch metoden, mens en i recoil brukes selector for &#229; modifisere eksisterende delte atom state. For &#229; koble den delte stateen med kompenenentene brukes useSelector og useDispatch i redux. I&#160;Recoil brukes useRecoilValue og useRecoulsState som kan brukes i kompoenentene p&#229; samme m&#229;te som setState.TIl slutt, i Redux, brukes Provider for &#229; wrappe app klassen. I recoil brukes RecoilRoot. En av fordelene med recoil, som er grunnen til at en i fremtiden kanskje vil bruke dette i steden for Redux er at Recoil lar det lage en dataflyt fra atomer (delt state) gjennom selectors ( rene funskjoner) og ned i react kompoenentene uten &#229; m&#229;tte h&#229;ndtere store creations og re-rendre hele app kompoenent treet n&#229;r state oppdateres. Dette er alts&#229; en fordel med recoil.&#160;<\/p><p>&#160;<\/p><p>Recoil er et nytt bibliotek, noe som gj&#248;r at det ike liggere like mye dokumentasjon ute om dettte per n&#229;. Dette kan v&#230;re en ulempe som utvikler og gj&#248;re det vanskelig dersom man st&#248;ter p&#229; problemer. En annen ulmpe med recoil er at det per n&#229; ikke ikke har &#34;concurrent mode&#34; st&#248;tte. Derimot er det planlagt at det skal lages. Concurrent mode er et nytt sett med features som hjelpe react apper &#229; ha et responsivt design og tilpasse seg brukeres enhetets evner og nettverkshastighet. Dette er derimot fortsatt en&#160;eksprimentelt feature. Denne ulempen representerer godt bruken av nye biblioteker under utvikling. Fordelen med eldre biliotekter som Context og redux er at de har hatt lengere tid til &#229; videreutivkli,&#160;&#160;finne feil og dokumentere bibliotketet. Likevel er det spennede og fordelsaktig &#229; bruke nye biblitoeker da de vanligvis er laget p&#229; bakgrunn av mangler i tidligere. Det var ikke mangler p&#229; global stte h&#229;ndteringsbiblioteker f&#248;r recoil kom, men recoil er laget som en respons av utvikling og lengere bruk av tidligere biblioteker som gir samme funskjonalitet. Ved &#229; bruke recoil kan en v&#230;re med &#229; videreutvikle det til et bedre bibliotek og se mangler ved tidligere bibliote. Selv om det vil v&#230;re nye ting &#229; sette seg inn i for en som allerede kan eksempelvis redux.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>For &#229; besvare denne oppgaven har jeg brukt kilden oppgitt:&#160;https://recoiljs.org og<\/p><p>-&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>-&#160;https://reactjs.org/docs/concurrent-mode-intro.html<\/p><p>- https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1736,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST st&#229;r for Represetntational State Transfer og er API som bruker HTTP protokollen. GraphQL er et query langugae for API. Jeg skal n&#229; nevne og diskutere noen av forskjellenne mellom de to.&#160;<\/p><p>&#160;<\/p><p>N&#229;r man sender en foresp&#248;rsel i REST sendes en HTTP foresp&#248;rsle og f&#229;r et komplett datasett i retur. Dersom man eksemplevis &#248;nsker data fra tre objekter m&#229; man bruke tre REST API&#160; foresp&#248;rseler for &#229; hente informasjonene. Fordelen med dette er at REST er enkelt &#229; forst&#229;. Du har x antall endepunkt og f&#229;r x mengde data.&#160;I graphQL kan en tilpasse forsp&#248;rselene sine til n&#248;yaktige krav og&#160;kombinere ulike enheter til en sp&#248;rring.<\/p><p>&#160;<\/p><p>Data henting med REST API kan f&#248;re til over- og underfetching problemer. Ettersom en klient kun kan forsp&#248;rre data ved endepunkter som returnerer bestemete datastrukturere kan man ikke hente n&#248;yaktig hva man trenger. Dette kan f&#248;re til at man laster ned mer data enn n&#248;dvendig. En kan ogs&#229; risikere at endepunktet ikke gir alt informasjon som trengs, slik at klienten m&#229; sende flere foresp&#248;rsleenr for &#229; f&#229; alt. Dette kalles underfetching. Problemet med over- og under-fetching eksisterer ikke i GraphQL ettersom man kan tilpasses sp&#248;rringen til &#229; hente n&#248;yaktig den dataen man trenger. Utbiler kan med GraphQL f&#229; n&#248;yaktig innsikt i dataen som er forespurt p&#229; baceknd og hvordan denne datan brukes ved at klienten spesifiserer n&#248;yaktiug hva som trengs.&#160;<\/p><p>&#160;<\/p><p>En annen forskjell er at endepunktet som kalles i RESTY er objektets identittet, mens objektets identittet ikke har noe med hvordan vi fetcvher det i GraphQL. I rest definerer alts&#229; objektet p&#229; bakcend, mens det i grapQL defineres p&#229; fornt end. Med&#160;rest defineres ogs&#229; server st&#248;rrelse og form p&#229; ressursene. MEd graphAL deklarerer&#160;serveren kun tilgjengelige ressureser, og klienten kan selv sp&#248;rre om n&#248;yaktig hva som trenges.&#160;<\/p><p>&#160;<\/p><p>REST bruker automatisk caching, men dette har ikke graphQL. Caching er evenen til &#229; lagre data som ofte sp&#248;rres etter slik at det er enklere &#229; hente ut i senere tid.&#160;&#160;I tillegg er feilh&#229;ndtering lettere i REST, da graphQL ofte gir den en 200ok kode.&#160;<\/p><p>&#160;<\/p><p>For &#229; si det kort kan en si at en i REST er begrenset til &#229; h&#229;ndtere rn enkelt ressurs. Hvis du trenger data fra flere m&#229; man g&#229; flere rundtyrer. Rest returnerer ogs&#229; alltid fulle datasett. GrapQL er mye mer fleksibel og du kan spesifisere n&#248;yaktig hvilken data som skal hentes. En kan ogs&#229; bruke grafen og koble entitetter sammen innen en sp&#248;rring, som gj&#248;r at en ikke trenger flere sp&#248;rringer<\/p><p>&#160;<\/p><p>Den st&#248;rste forskjellen mellom REST og GrapQL er hvor mye du kan tilpasse en foresp&#248;rsel. I GraphQL h&#229;ndterer en ikke dedikerte ressuerste, men istedet ser man p&#229; alt fom en graf og alt er dermed koblet sammen.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11537227,"ext_inspera_userAssessmentSetupId":7140021,"ext_inspera_userAssessmentId":4841236,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Michaelsen Vidar (10186)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35198377,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2179,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React kan komponenter ha state som kan aksesseres med this.state og endres med this.setState. Disse verdiene kan brukes internt i komponenten eller displayes til brukeren. Helt grunnleggende kan man definere props i komponenter og `passe` det ned til barnekomponentene, men man kan ikke gj&#248;re dette den andre veien. For &#229; tillate barn &#229; kommunisere med foreldre m&#229; foreldrene passe ned funksjoner som forventer input til barna. Disse funksjonene kalles `callback props`. Det funker fint n&#229;r man vil at to komponenter skal kunne dele data, men det skalerer d&#229;rlig n&#229;r flere komponenter er avhengige av flere andre. I slike tilfeller m&#229; man enten skrive veldig mye kode eller bruke ferdiglagde biblioteker som for eksempel Redux, eller Context.<\/p><p>&#160;<\/p><p>De fleste biblioteker som skal h&#229;ndtere state opererer p&#229; samme grunnleggende m&#229;te. De samler all state p&#229; ett sted, og bruker predefinerte funksjoner for &#229; tillate alle komponenter &#229; referere til state om n&#248;dvendig. I Redux definerer man actions (ofte med payloads) inni en reducer (state-h&#229;ndterende funksjon). For eksempel kan et array med gj&#248;rem&#229;l `todos` ha denne eksempel-actionen: {type: `todos/todoAdded`, payload: todoText }. N&#229;r man har actionen kan man lage koden som for caset der denne actionen blir kj&#248;rt. I Context har man en context provider og en eller flere consumers. I provider defineres variabler, og disse kan hentes og endres i consumers med useContext.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2739,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek hvis form&#229;l er &#229; gj&#248;re `state` i React mer h&#229;ndterbart. Dette gj&#248;res ved &#229; splitte state opp i `atoms` som er &#34;subscribeable&#34;, som vil si at komponenter kan si at de bruker en verdi i et atom, og da vil komponenten renderes p&#229; ny hver gang atomet oppdateres. Man har ogs&#229; `selectors`, som blir beskrevet som &#34;derived state&#34;. De brukes for &#229; returnere en modifisert versjon av state. For eksempel kan et atom inneholde en liste, mens en selector kan inneholde en funksjon som returnerer en versjon av listen som inneholder alle listeelement med verdien `x`. Blir atomet oppdatert, vil selectoren ogs&#229; oppdateres siden den subscriber til atomet. Atomene er `source of truth`, selectorene er funksjoner p&#229; dem. Recoil er nytt og eksperimentelt, s&#229; ukjente bugs og manglende st&#248;tte kan v&#230;re ulemper med biblioteket. En potensiell ulempe med Recoil er at det baserer seg p&#229; hooks og kan kun brukes i funksjonelle komponenter.<\/p><p>&#160;<\/p><p>Redux gir mange av de samme fordelene som Recoil. Man har `slices` med state som kombineres til et `store`, som er all state. I Redux bruker man `reducers` for &#229; endre p&#229; state. Om man vil displaye en modifisert versjon av innholdet i en slice m&#229; man putte &#34;business logic&#34; p&#229; alle steder man vil vise det eller lagre den modifiserte versjonen som en egen slice (og skrive kode for &#229; automatisk oppdatere den n&#229;r originalen blir oppdatert). Her har Recoil en klar fordel med sine selectors som er intuitive og selvoppdaterende (siden de subscriber til atomet de er basert p&#229;).<\/p><p>&#160;<\/p><p>Kilder: https://redux.js.org/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2224,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er definert som en `software architectural style` som beskriver 6 `guiding constraints` som m&#229; bli fulgt for &#229; kunne definere sin interface som RESTful. I REST web services har man endepunkter der man kan bruke GET, POST, PUT og DELETE, for &#229; hente ut eller p&#229;virke ressurser som ligger p&#229; endepunktene. Man kan ikke velge &#229; hente ut kun en del av et endepunkt, og om man vil hente ut fra flere endepunkter m&#229; man gj&#248;re flere kall.<\/p><p>&#160;<\/p><p>GraphQL brukes for &#229; sende sp&#248;rringer til en server der man kan hente ut eller oppdatere n&#248;yaktig de datafeltene man &#248;nsker med en sp&#248;rring. I bakgrunnen gj&#248;res dette av GraphQL med HTTP via ett endpoint. Det blir vanligvis brukt med JSON, og har ogs&#229; st&#248;tte for typer i sp&#248;rringene, slik at man vet hva man f&#229;r tilbake og kan kj&#248;re funksjoner p&#229; resultatsettet uten tr&#248;bbel.<\/p><p>&#160;<\/p><p>Kilder: https://restfulapi.net/, https://graphql.org/<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11542691,"ext_inspera_userAssessmentSetupId":7140036,"ext_inspera_userAssessmentId":4842165,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:01:23Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Finhammer Thale Marie April (10173)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34562622,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3266,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Dataflyt (props):<\/strong><\/p><p>Dataflyt handler om hvordan man sender data mellom komponenter i React, alts&#229; hvordan komponentene &#34;snakker sammen&#34; dvs. props. State og props oppdateres asynkront, og burde derfor eksempelvis ikke brukes til &#229; kalkulere neste state igjen. Props st&#229;r for properties og er navngitte, immutable dataverdier. Disse gis som input n&#229;r en komponent kalles eller opprettes. Her flyter dataen fra en forelderkomponent til barnekomponenter; i return i en parent legge man inn children og definerer i tilleggg hvilke props som skal sendes videre nedover i komponenthierarkiet og innholdet deres. Disse kan s&#229; hentes ut i barnekomponentene ved &#229; eksempelvis skrive this.props.value. Blant annet fordi props ikke endrer seg (immutable) har vi state ogs&#229;.<\/p><p>&#160;<\/p><p>En viktig regel i React er at alle komponenter m&#229; v&#230;re s&#229;kalte &#34;pure functions&#34; med tanke p&#229; props. Dette inneb&#230;rer at for samme input, skal en funksjon alltid returnere lik input. Inputen skal heller ikke endres p&#229; noen m&#229;te i selve handlingen.<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; implementere dataflyt oppover i komponenthierarkiet. Dette gj&#248;res gjennom &#229; sende s&#229;kalte callback-funksjoner som props fra foreldre og ned til barnekomponentene. Dette gj&#248;r det mulig for barnekomponentene &#229; bruke funksjonene de mottar til &#229; endre staten p&#229; foreldrekomponenten.<\/p><p>&#160;<\/p><p><strong>Tilstand (state):<\/strong><\/p><p>State er interne variabler i en komponenten som kan oppdatere. Komponenter kan ha state; statefull, eller ikke; stateless. &#197; sette state gj&#248;res gjennom setState(). Ofte vil en slik endring av staten f&#248;re til at komponenten, og eventuelle barn av denne, rendres p&#229; nytt igjen. State opprettes i konstrukt&#248;ren med this.state = {staten: value}. Dersom man da kaller p&#229; this.state.staten returneres value.&#160;Hooks brukes p&#229; funksjonelle komponenter for &#229; gi de samme funksjonalitet med tanke p&#229; state-h&#229;ndtering som klassekomponenter har.<\/p><p>&#160;<\/p><p>En av de store fordelene med React er faktisk nettopp det at states gj&#248;r det enkelt &#229; deale med blant annet state og historikk. N&#229;r det er sagt, blir det gjerne vanskelig &#229; h&#229;ndtere og vedlikeholde litt st&#248;rre og mer omfattende applikasjoner som tar i bruk state. Her kan det eksempelvis oppst&#229; problemer med vedlikehold, at man har for mange callbacks, at state flyttes oppover til felles foreldrekomponenter og havner steder der det kanskje ikke gir helt mening &#229; ha den med mer.&#160;<\/p><p>&#160;<\/p><p>Vi har derfor noe som kalles state management. Dette er en slags teknikk som gj&#248;r det mulig for en programmerer &#229; samle all data om state p&#229;&#160;ett sted, og man legger i tillegg til rette for automatisk oppdatering av ber&#248;rte komponenter n&#229;r data endres..State management gir i tillegg mekanismer for &#229; endre p&#229;, og lese staten der man trenger det i komponenthierarkiet.&#160;&#160;<\/p><p>&#160;<\/p><p>Redux er et eksempel p&#229; et JavaScript-bibliotek som kan brukes til nettopp dette. Mobx er ogs&#229; et godt alternativ. Der Redux har et best-practice-design som gj&#248;r det enkelt &#229; implementere, krever det ganske mye kode. Mobx har et st&#248;rre fokus p&#229; enkel syntaks og skjuler derfor mye av det som faktisk skjer.&#160;<\/p><p>&#160;<\/p><p>Gruppen min benyttet seg av Context til stateh&#229;ndtering p&#229; prosjekt 2, og i all hovedsak av Redux i prosjekt 3. Apollo gir forresten ogs&#229; mulighet for global state av klient-data, dette benyttet vi oss ogs&#229; av i prosjekt 3. Redux kan v&#230;re ganske vanskelig &#229; forst&#229; seg p&#229; i starten, i hvert fall etter min mening. Det er i hvert fall en m&#229;te &#229; h&#229;ndtere state p&#229; for JS der man har global state fremfor at hver komponent har sin egen state. Dette er spesielt nyttig dersom eksempelvis flere komponenter skal aksessere den samme tilstanden, men at de ikke har et naturlig foreldre-barn-forhold.&#160;<\/p><p>&#160;<\/p><p>Det deles ogs&#229; inn i smarte og dumme komponenter i Redux, der det er de smarte komponentene som er i kontakt med den globale staten. Staten endres ikke direkte, men man erstatter den med en ny en.<\/p><p>&#160;<\/p><p>M&#229;ten man strukturerer koden p&#229; her blir ca. slik:&#160;<\/p><p>&#160;<\/p><p>// STORE -&#62; GLOBALIZED STATE<\/p><p>Der store typisk inneholder en samling av all data og states for applikasjonenen. Et slags tre. Gj&#248;r blant annet debugging og persistens henting av state enklere. Opprettes ved const store = createStore(reducer);<\/p><p>&#160;<\/p><p>// ACTION<\/p><p>Beskriver hva vi skal gj&#248;re eksempelvis dersom vi har en counter, kan en action v&#230;re INCREMENT. Brukes alts&#229; for &#229; faktisk endre staten; beskriver den og hva som skjer. Kommuniserer med reducer om &#229; endre staten. Best&#229;r av et type-felt og data. Er herfra man sender data fra React-applikasjonen til Redux Store. Blir kalt p&#229; gjennom store.dispatch(). Dataen kommer fra brukerinteraksjoner eller API-kall.<\/p><p>&#160;<\/p><p>// REDUCER<\/p><p>Beskriver hvordan handlinger transformerer en state til neste state. Sjekker hvilken action som gjennomf&#248;res, og basert p&#229; dette modifiserer den storen.<\/p><p>&#160;<\/p><p>// DISPATCH<\/p><p>Det er her vi faktisk executer actionen. Typisk handlingsforl&#248;p: dispatch this action to the reducer =&#62; send it to the reducer =&#62; reducer checks what to do =&#62; the store gets updated<\/p><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><p>Tidligere eksamener i IT2810<\/p><p>https://firebasestorage.googleapis.com/v0/b/playground-eirikdahlen.appspot.com/o/compendiums%2FIT2810.pdf?alt=media&#38;token=54e26bc1-e614-4748-86f1-ea51cde65dbc<\/p><p>Egne tidligere prosjekter i IT2810<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2917,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt JavaScript state management bibliotek, men det er i en slags experimental fase for &#248;yeblikket. Dette h&#229;ndterer mange av problemene som st&#248;rre applikasjoner som benytter seg av Context API-et, s&#229; vel som Redux, m&#248;ter p&#229;.<\/p><p>&#160;<\/p><p>Recoil best&#229;r i all hovedsak av to ting: Atoms og Selectors, der atoms er der den falles staten er og selectors er pure functions. Atomsene kan oppdateres og kan subscribes til; dersom en komponent har subscribet til et gitt atom og det blir oppdatert, blir den komponent rerendret med den nye verdien. Og dette kan gj&#248;res i kj&#248;retid. Problemet med Redux her er at den m&#229; sp&#248;rre hver enkelt komponent koblet til seg om den trenger &#229; bli rerendret, og dette kan ogs&#229; ha noen konsekvenser for performancen. Dette kan riktignok bli bedre ved hjelp av Selectors, men det krever fortsatt ekstra kalkuleringer dersom noe i staten endres sammenlignet med Recoil.&#160;I Context vil alle endringer i state f&#248;re til at komponentene som bruker den staten blir rerendret. Mobx har nok hakket bedre performance enn Recoil.<\/p><p>&#160;<\/p><p>En av de st&#248;rre fordelene med Recoil, kanskje spesielt sammenlignet med Redux er at Redux har en del boilerplate-kode, der Recoil ikke har det. Recoil mulliggj&#248;r dataflyt fra atoms (som er felles state) gjennom selectors (pure functions) og til React-komponentene. Men i motsetning til Redux, gj&#248;res dette uten bruken av store creations eller &#229; m&#229;tte rerendre hele App-komponent-treet.<\/p><p>&#160;<\/p><p>B&#229;de med Redux og med Recoil m&#229; man wrappe hele appen i en provider. I Redux m&#229; man definere selectoren sin i tillegg til &#229; lage en store&#160;osv, og kan m&#229; ogs&#229; benytte seg av useDispatch()- og useSelector()-hooksene. I Recoil f&#229;r man disse tingene automatisk n&#229;r man initialiserer storen ved hjelp av atom(). Dette igjen viser ogs&#229; at Redux krever en del ekstra boilerplatekode.&#160;Det nok derfor ogs&#229; betrakterlig enklere &#229; l&#230;re seg Recoil enn Redux.<\/p><p>&#160;<\/p><p>N&#229;r det er sagt, er recoil i&#160;startfasen, imens Redux og Mobx allerede er established biblioteker. Det at de er&#160;det har sine fordeler eks. at de&#160;er anerkjent og mange vet hvordan det brukes, det finnes massevis av tutorials p&#229; nett og mye kode brukt i eksisterende systemer benytter seg av det. Dette er i all hovedsak&#160;en fordel.<\/p><p>&#160;<\/p><p>Dersom man allerede har en ferdig React-app med hooks f.eks. er Recoil enkelt &#229; implementere. Dersom man derimot allerede har implementert eksemepelvis Mobx eller Redux allerede, er det&#160;muligens ikke nok argumenter enn&#229; for &#229; endre p&#229; alt for &#229; g&#229; over til Recoil, da performance-forskjellene gjerne er minimale og Recoil er i et s&#229;pass tidlig stadie fortsatt. Men det er uansett noe det kan l&#248;nne seg &#229; l&#230;re seg, da det ser ut som at det kommer til &#229; bli et godt alternativ som muligens til og med delvis erstatter l&#248;sninger som redux.<\/p><p>&#160;<\/p><p><strong>Kilder:&#160;<\/strong><\/p><p>https://recoiljs.org<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>https://www.emgoto.com/redux-vs-recoil/<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p><p>https://blog.logrocket.com/simple-state-management-react-recoil/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2679,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST-API-et og GraphQL er begge l&#248;sninger for klient-server-kommunikasjonen i webapplikasjoner.<\/p><p>&#160;<\/p><p>REST er en overordnet arkitektur for webbasert og stateless&#160;klient-server-kommunikasjon med fokus p&#229; lesing og skriving av ressurser. Det st&#229;r for Representation State Transfer og er alts&#229; en m&#229;te &#229; benytte seg av API-er p&#229; der man gj&#248;r et API-kall og f&#229;r informasjonen returnert fra databasen. Kallene til API-et st&#248;res gjennom &#229; skrive URI-en til endepunktetet i tillegg til hvilken HTTP-request man &#248;nsker &#229; gjennomf&#248;re (GET - lese ressurser, PUT - endre ressurser, POST - opprette ressurser, DELETE - slette ressurser). Informasjon hentes som regel ut p&#229; JSON-format, slik som i GraphQL (som kun gj&#248;r det).&#160;<\/p><p>&#160;<\/p><p>En av de st&#248;rre forskjellene mellom REST og GraphQL er at REST baserer seg p&#229; bruken av flere &#34;dumme&#34; endepunkter, imens GraphQL kun har ett &#34;smart&#34; endepunkt. Dette utgj&#248;r en vesentlig forskjell ettersom dataen man mottar fra et endpoint er derfor basert p&#229; queryen man sender til endepunktet i GraphQL, i stedet for &#229; v&#230;re basert p&#229; hvilket endepunkt man sender&#160;dataen til slik som i REST.<\/p><p>&#160;<\/p><p>I REST defineres ett eller flere slike endepunkter for &#229; lese og&#160;skrive til, eller endre p&#229; entiteter/ ressurser. Dette gj&#248;res igjen ved hjelp av URI og HTTP-requests. Dette kan dog v&#230;re en ulempe dersom man har mange endepunkter, ettersom det dermed m&#229; gjennomf&#248;res mange kall for &#229; hente n&#248;dvendig data. Og man kan ofte ogs&#229; overfetche det vil si hente mer data enn man egentlig trenger. F.eks. dersom jeg &#248;nsker &#229; hente ut informasjon om b&#248;ker i en database, og kun &#248;nsker navnet p&#229; forfatteren og boken, f.eks. dersom jeg vil hente topp fem b&#248;ker av Erling Loe. Da kan det gjerne hende at jeg m&#229; sende minst fem API-kall, alts&#229; for &#229; hente informasjon om hver enkelt bok. Og for hver av disse hentes navnet hans, navnet p&#229; boken s&#229; vel som mye annen, un&#248;dvendig informasjon ut. Dette st&#229;r i kontrast til GraphQL der man i mye st&#248;rre grad kan spesifisere hva man &#248;nsker &#229; hente ut, gjennom queries. Dette gj&#248;r den mye raskere, ettersom man b&#229;de kan hente info og nested info i ett kall. Og det gj&#248;r p&#229; mange m&#229;ter GraphQL ogs&#229; enklere &#229; h&#229;ndtere.<\/p><p>&#160;<\/p><p>En fordel med REST er at man har tilgang til en caching-mekanisme som by default st&#248;ttes av alle weblesere.&#160;<\/p><p>&#160;<\/p><p>GraphQL baserer seg p&#229; at man sender en sp&#248;rring til en server. Her defineres b&#229;de s&#248;k og oppdateringer eller hvilke data som skal returnerers. Dette er gunstig ettersom alle data dermed kan hentes ved hjelp av&#160;&#233;n enkelt request, i hvert fall i mange tilfeller. Ettersom man i st&#248;rre grad spesifiserer hva man &#248;nsker, unng&#229;r man ogs&#229; innlasting av un&#248;dvendig mye data. Koblingen mellom tjeneren og klienten blir ogs&#229; noe tettere i GraphQL enn hva den er i REST. Dette er fordi man benytter seg av et skjema som definerer b&#229;de struktur og typer. Fordelen med det er at det muliggj&#248;r validering av dataen, men en slik tett kobling er ikke n&#248;dvendigvis bare bra. En annen ulempe med GraphQL er at man ikke har implisitt caching i HTTP-laget slik som i REST. N&#229;r det er sagt benyttet for eksempel jeg meg av Apollo Client i prosjekt 3 nettopp p&#229; grunn av det, ettersom det har en god innebygget cache-funksjon.&#160;GraphQL st&#248;tter i tillegg kun JSON-data, noe som er en ulempe.&#160;<\/p><p>&#160;<\/p><p><strong>Slik gjorde vi det:<\/strong><\/p><p>Da vi i prosjekt 3 skulle velge mellom GraphQL eller REST, ble GraphQL valgt fremfor REST p&#229; grunn av de datastrukturerte queriesene dine og hvordan disse ville integreres godt med code-generation for TypeScript og statisk typing. Og b&#229;de requests og responses fikk derfor benyttet seg av full type support med out of the box type validation fra apollo-serveren.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><p>https://www.youtube.com/watch?v=ZQL7tL2S0oQ&#38;ab_channel=WebDevSimplified<\/p><p>Tidligere eksamener i IT2810<\/p><p>https://firebasestorage.googleapis.com/v0/b/playground-eirikdahlen.appspot.com/o/compendiums%2FIT2810.pdf?alt=media&#38;token=54e26bc1-e614-4748-86f1-ea51cde65dbc<\/p><p>Egne tidligere prosjekter i IT2810<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11542750,"ext_inspera_userAssessmentSetupId":7140070,"ext_inspera_userAssessmentId":4841223,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:01:30Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Madsen-Malmo Fredrik August (10193)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34579635,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3243,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I will start by discussing the different state management techniques embedded in React, including elaborating on the additional benefits from using a third-party solution such as Redux (and mobX etc., but the focus will remain on Redux). After this, I will touch on data flow in a React application, also shedding light on what Redux does and why it&#39;s a well-known, solid&#160;solution to this problem.<\/p><p>&#160;<\/p><p>Firstly, let us discuss the most primitive form of state management, namely state. I will here discuss both the functional and class oriented implementations, i.e. &#34;React.Component.setState&#34;&#160;and &#34;React.useState&#34;.<\/p><p>&#160;<\/p><p>These both work in&#160;<em>mostly<\/em>&#160;the same way. They are initialised at the top of the component, either by setting the &#34;state&#34; property, or by creating a getter and setter with &#34;React.useState&#34;. Later, you may update the value with either the &#34;setState&#34; method, or with the associated setter from the functional alternative. An important note here is that the type of the value is permanent (not enforced by React, but by using TypeScript you may &#8211; and should &#8211;&#160;enforce this), such that the type of the value does not change.[1] With the class component alternative, you may only have&#160;<em>one<\/em>&#160;such state, whereas with the functional approach you may have an arbitrary amount of them. Of course, the class component may use an object to encompass an arbitary amount of values, but this might not always be desirable. This is due to the way JavaScript handles equality checks between objects. As it turns out, they employ a shallow comparison, which in the case of objects only checks to see whether or not the memory addresses of the objects are the same &#8211; which they will never be when you use a setState, as you assign a&#160;<strong>new<\/strong>&#160;value to the state.[2] This stems from the functional reactive nature of React (thus why React is referred to as FRP &#8211; Functional Reactive Programming). State changes are &#34;one-way&#34; and deterministic. One-way meaning that the state changes do not themselves modify the view, rather the view reflects the state, and deterministic meaning that given the same arguments to a function will always net the same result. This can result in unwanted rerenders of your child components that depend on values from the current state.<\/p><p>&#160;<\/p><p>As the complexity of your data model increases, you might want more granular control of your state, as well as being able to express only your intent and what values are required to achieve said intent, without having to include the business logic in the view. This sparked the creation of the store/reducer/action-model, or as it&#39;s more commonly referred to, the actor model.[3] These work in the following way; you have four&#160;main components that you interact with:<\/p><p>&#160;<\/p><p>0) State &#8211; how does your data look?<\/p><p>1) Actions &#8211; stating what you wish to do with the state. For example { type: &#39;SIGN_IN&#39;, payload: { username: &#39;Administator Hansson&#39; } }.<\/p><p>2) Reducers &#8211; given the current state, and an action, how can we derive a&#160;<strong>new<\/strong>&#160;state (recall the deterministic and functional aspects).<\/p><p>3) mapDispatchToProps/mapStateToProps and useDispatch/useSelector&#160;&#8211; we use these connector parameters (former) or hooks (latter) to retrieve the dispatch function you use to send actions to the reducers (which are in turn composed into a store), and to retrieve the parts you care about from the state.<\/p><p>&#160;<\/p><p>The immediate benefit from this is that you may isolate the business logic associated with state alterations in the recucers, and remove it from the views.<\/p><p>&#160;<\/p><p>For both of these alternatives, there&#39;s the discussion regarding data flow. In react, you may only pass state downwards in the hierarchy, in one of two ways;<\/p><p>&#160;<\/p><p>1) Props &#8211; can be provided to a child by its parent with e.g. &#60;Child value1={2} /&#62;. Recursively passing props from your parent to your children is called &#34;prop drilling&#34;, and can be mitigated by &#8211;&#8211;<\/p><p>2) Context &#8211; is inserted into the hierarchy at a given point with a context provider, allowing all children (and children of children (of children ...)) to retrieve the value passed down by the context provider (using a context consumer).<\/p><p>&#160;<\/p><p>Props are very useful if you want to pass set of values from a parent down to a child, such as e.g. the value of a text field (in React, all attributes on standard HTML elements &#8211; e.g. value, onClick etc. &#8211;&#160;are in fact props!). Context on the other hand, is useful when several different elements beneath the context provider want to retrieve said value.<\/p><p>&#160;<\/p><p>Redux, for example, uses the context API to send its store (composition of reducers) and dispatch functions down to all interested components. This is particularly interesting if you have the application state in the Redux store, thus being able to pick out any part of the state and update it (with the dispatch) further down the tree.<\/p><p>&#160;<\/p><p>Redux is a&#160;&#34;batteries included&#34; solution to state management in React, but you may also implement it rather easily yourself with React.useReducer and the Context API. Using the library simply saves you from some manual labour, as well as implementing some performance enhancements and debug functionality that might be difficult to implement yourself.<\/p><p>&#160;<\/p><p>------<\/p><p>[1] Type is a broad term, and can be a union type such as &#34;number | string&#34; to allow several primitive types to be used as the value for the state.<\/p><p>[2] This is why in JavaScript, {a: 2} != {a: 2} evaluates to <em>true<\/em>.<\/p><p>[3] Technically speaking, Redux and reducers aren&#39;t complete actor models, as they lack inter-model communication, but they carry a lot of the important characteristics.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2447,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Firstly, I will be comparing Recoil to Redux and not mobX as most of the arguments&#160;<em>for<\/em>&#160;recoil affect redux and mobx as they both use a global&#160;application state.<\/p><p>&#160;<\/p><p>One of the great benefits of Recoil is that it allows you to split the application state into several &#34;atoms&#34;, essentially creating a decentralised application state. This allows code splitting, which allows for quite substantial performance improvements. It allows you to only compile (or transfer&#160;if you&#39;re using server side rendering)&#160;the necessary parts of your applications, and defer the rest until it&#39;s required (if it even is). Consider the example where you have an admin page as part of your application. Without code splitting, all non-admin users have to compile this, and waste precious CPU cycles, but with, they won&#39;t have to as they never visit this page.<\/p><p>&#160;<\/p><p>It also provides a tighter integration with React&#39;s own state management system. It&#39;s built on hooks (which has the caveat of only working with funcional components) which provides a familiar syntax for react devs, as opposed to e.g. the map(State/Dispatch)ToProps from Redux (although they have also introduced hooks for this).&#160;<\/p><p>&#160;<\/p><p>The main difference from default React is that the atoms (the single sources of truth &#8211; akin to regular useStates in this fashion) are defined externally, meaning that you can import them in any file and use their values. This is probably due to the component &#34;RecoilRoot&#34; which is recommended to put at the root of the tree. We can verify this with a quick dive into the source code, confirming that this is indeed due to the use of a context[0]. This bears similarities to Redux&#39;s similar behaviour, where you may retrieve a section of the state and the dispatch function at any time. The main difference is that instead of retrieving a subset of the global application state, you retrieve a single small state, which helps them achieve decoupling of state &#8211; again providing the possibility of code splitting.<\/p><p>&#160;<\/p><p>One drawback compared to Redux may be that you have to write the state modification in the view when you call the setValue function, similar to how you would do it with React hooks. In Redux, this is abstracted away by actions, which define your intentions, and thus have a slightly more &#34;new to the project&#34;-friendly API. By this I mean that it might be&#160;easier for a new developer to your project to use actions provided that they have descriptive names compared to a setValue function where you have to modify the state yourself. This is of course possible to circumvent by abstracting away the state modification functions, but this is not implicit in the recoil library.<\/p><p>&#160;<\/p><p>Conversely, the recoiljs library gives you the possibility of defining a custom getter in the selectors, which allows you to retrieve a (e.g.) formatted time string from the state, even though the raw value stored is a date object. This is&#160;<em>not<\/em>&#160;present in Redux, where you have to retrieve the state in e.g. a mapStateToProps or useSelector (from @reduxjs/toolkit) and then format it before assigning it to a prop or returning from the hook.<\/p><p>&#160;<\/p><p>[0]&#160;https://github.com/facebookexperimental/Recoil/blob/master/src/core/Recoil_RecoilRoot.react.js#L95<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1403,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL was created long after the introduction of REST APIs, and wanted to solve a couple of pain points of classical REST APIs;&#160;<\/p><p>&#160;<\/p><p>1) Data redundancy<\/p><p>&#160;<\/p><p>In REST APIs, you submit a request to an endpoint, and you&#39;re returned a predetermined set of values (which you do not know beforehand, unless you&#39;ve read their OpenAPI spec or other documentation). There&#39;s no guarantee that you need all this data &#8211; thus potentially leading to wasting network resources fetching data you don&#39;t need. As an illustration, consider the case where you want to get the username of the currently authenticated user. In a REST API, you would have to GET /user/ and retrieve the username field from the potentially massive JSON object[0] you&#39;re handed. You&#160;<em>could<\/em>&#160;of course set up one endpoint for each field in the user object, such as /user/displayName, /user/age, etc., but that would result in high levels of&#160;redundancy in the backend, and a bloated code base.&#160;<\/p><p>&#160;<\/p><p>GraphQL provides a neat solution to this by using a schema based request, where you specify exactly what you want. As an example, observe the following query:<\/p><p>&#160;<\/p><p>query {<\/p><p>&#160; user {<\/p><p>&#160; &#160; name {<\/p><p>&#160; &#160; &#160; first_name<\/p><p>&#160; &#160; }<\/p><p>&#160; &#160; age<\/p><p>&#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>This would&#160;<em>only<\/em>&#160;give you the first name and age of the user, and nothing else &#8211; no resource waste! You also know exactly&#160;how the response will look, as it will match the request. No more delving into obscure and/or ancient API docs to reverse engineer the API!<\/p><p>&#160;<\/p><p>2) No more route naming inconsistencies<\/p><p>&#160;<\/p><p>Although there are (unofficial) standards to follow for REST API structuring there are still inconsistencies to be found; most use<\/p><p>&#160;<\/p><p>POST /user/<\/p><p>&#160;<\/p><p>and some use<\/p><p>&#160;<\/p><p>POST /user/create<\/p><p>&#160;<\/p><p>to create a new user, and without looking at the API spec, it&#39;s hard to tell which one to use. With GraphQL, this is mitigated by having the developer create a mutation (specifying that the following action will mutate a backend resource &#8211; i.e. delete/update/create). Given access to the auto-generated GraphQL documentation[1] (which most often is readily available), you can simply look for a function called &#34;createUser&#34; and note its parameters. A lot of developers will also expose their playground &#8211; allowing external developers to experiment with their API with integrated documentation and auto-completion for their API! This is a great way for developers of public APIs to encourage use of their API.<\/p><p>&#160;<\/p><p>3) Statically typed responses<\/p><p>&#160;<\/p><p>A thing that&#39;s rarely documented in REST API docs (unless they use a solution like OpenAPI) is the types of the response fields (i.e. string/int/float/etc.). This is not possible to omit in GraphQL docs, as they are an integral part of the schemas &#8211; being carried into the documentation automatically. This allows you &#8211; as a developer &#8211; to skip wondering whether the telephone number will be returned as a string or number.<\/p><p>&#160;<\/p><p>---------<\/p><p>[0] For this comparison, we will consider the case where they both return JSON objects, as that is the most common in modern APIs, and the de-facto standard for GraphQL.<\/p><p>[1] I argue that you can skip looking at REST API documentation by looking at the GraphQL documentation instead, which might seem counter-intuitive, but the reasoning is that GraphQL documentation is derived from the schemas you define, and developers are incentivised to publish them to a larger degree with GraphQL &#8211; largely due to the simplicity of deploying the docs.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533278,"ext_inspera_userAssessmentSetupId":7139997,"ext_inspera_userAssessmentId":4841135,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rynning-Tønnesen Sverre (10137)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330849,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2673,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React baserer seg p&#229; komponenter og en &#248;nsker da at disse komponentene skal kunne snakke sammen. Vi har b&#229;de props og state. Props (proporties) er data som du sender inn til en komponent n&#229;r den opprettes og state som er komponentens tilstandsdata som kan endres under kj&#248;ring. Alts&#229; vil staten til en komponent kunne bli props til en child component. Data som kommer fra en parent kalles props (en kan sende b&#229;de funksjoner og variabler). Dette funker for b&#229;de class og hooks (funksjonelle og klassekomponenter). Props er immutable og en komponent vil ta i mot props litt p&#229; samme m&#229;te som en funskjon vil ta imot variabler. Kan ogs&#229; nevne at klasser er litt mer forst&#229;elig mtp state og livssyklus enn funksjonelle komponenter (Ihvertfall n&#229;r en startert &#229; programere i React for f&#248;rste gang). En komponent som f&#229;r inn props kan ikke endre disse propsene direkte (ettersom de er immutable). For &#229; endre props i en child component kan en bruke child events og parent callbacks. Child komponenten kan kalle f.eks onNameChanged, parent vil da reagere p&#229; eventet med &#229; sende en callback handler og oppdatere staten til parent noe som da oppdaterer propsen.<\/p><p>Ettersom props ikke kan endre seg har vi ogs&#229; bruk for state (dette er ikke 100% presist). State kan ligge i de ulike komponentene b&#229;de klassebaserte og funksjonelle komponenter (gjennom setState()). State lagrer alts&#229; dataen siden din trenger. Ettersom en vil kunne trenge &#229; bruke samme variabler i komponenter som ikke er direkte underkomponenter&#160;av hverandre kan vi ogs&#229; bruke state management.<\/p><p>Global state management gir mulighet for &#229; ha en global state som brukes av mange komponenter og endringer i ulike komponenter som endrer state vil da ogs&#229; endre/oppdatere de andre komponentene som bruker denne staten. Best practice skal sies &#229; bruke global state management n&#229;r det er n&#248;dvendig, alts&#229; m&#229; en passe p&#229; &#229; ikke overbruke det (noe som det virker som er vanlig &#229; gj&#248;re).<\/p><p>Innenfor state management er det vanlig (og er de vi har sett p&#229; i dette faget) &#229; bruke b&#229;de React Context (Innebygd i React), Redux og MobX. Forskjell p&#229; disse kommer i neste oppgave da det passer bedre inn der.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2244,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management library. Det lar deg lage en data-flow graph som flyter gjennom atoms og selectors (rene funksjoner) og ned til React komponentene. Atoms er &#34;units of state&#34; som kan bli fulgt individuelt i motsetning til f.eks Redux. Det hjelper deg med &#229; eliminere de un&#248;dvendige re-rendersene som kommer med &#229; bruke&#160;React Context API-et og&#160;Redux. Et eksempel er et scenario hvor en applikasjon bruker Redux. N&#229;r en er i en komponent og kaller en dispatch funskjon som endrer staten i context s&#229; vil alle komponentene re-renders. Med Recoil vil en l&#248;se dette gjennom Atoms, en individuell state, og det er kun komponentene som er koblet til atoms som m&#229; re-rendre.<\/p><p>Her er noen av fordelen hentet direkte fra Recoil sin egen nettside (https://recoiljs.org/docs/introduction/motivation):&#160;<\/p><ul>\t<li>We get a boilerplate-free API where shared state has the same simple get/set interface as React local state (yet can be encapsulated with reducers etc. if needed).<\/li>\t<li>We have the possibility of compatibility with Concurrent Mode and other new React features as they become available.<\/li>\t<li>The state definition is incremental and distributed, making code-splitting possible.<\/li>\t<li>State can be replaced with derived data without modifying the components that use it.<\/li>\t<li>Derived data can move between being synchronous and asynchronous without modifying the components that use it.<\/li>\t<li>We can treat navigation as a first-class concept, even encoding state transitions in links.<\/li>\t<li>It&#39;s easy to persist the entire application state in a way that is backwards-compatible, so persisted states can survive application changes.<\/li><\/ul><p>De global state mangamentene vi har g&#229;tt gjennom i faget er React Context, redux og mobX.&#160;<\/p><p>&#160;<\/p><p>Context er typisk brukt for applikasjoner hvor endringene i state ikke er alt for store/mange. Det er lett &#229; bruke og enkelt/raskt &#229; l&#230;re. Det kreves mindre kode enn de to andre og en trenger ikke importere ekstra bibloteker ettersom det er innebygd i React. En av problemene med Context er at det ikke er noen innebygd m&#229;te for reducer state &#229; bli delt p&#229; tvers&#160;av container components.&#160;<\/p><p>&#160;<\/p><p>Redux er nok det som er mest brukt i dag og det er derfor mye god hjelp og dokumentasjon som ligger tilgjengelig. Redux har en enkelt store som kan splittes opp i mange reducere. Staten i store er immutable, kan ikke endre store uten &#229; g&#229; gjennom the dispatcher and its actions. Dette er bra for &#229; ikke f&#229; noen utilsiktede feil. Redux kan sees p&#229; som mindre skalerbar enn de andre. I tillegg er det litt komplisert &#229; l&#230;re seg. Redux kommer i forhold til de andre med en del boiler plate code.&#160;<\/p><p>&#160;<\/p><p>MobX har en action som oppdaterer en og den observable-en &#34;skaper en reaksjon&#34; alle steder hvor den observable-en er brukt. Alts&#229; oppdateres bare de komponentene som bruker de propertisene som blir oppdatert. Dette er tilsvarende som Recoil skryter av at de kan tilby.&#160;Det er mer fleksibelt enn redux. Lar deg ha flere stores og bestemme hvordan de ulike skal brukes. Du kan endre store slik du &#248;nsker. Du kan endre variabler i store gjennom b&#229;de komponentene, actions, functions eller gjennom debugging tools. Disse endringene skaper automatisk re-rendering i applikasjonen. Vil ogs&#229; nevne at Apollo som mange brukte i prosjekt 3 ogs&#229; gir deg mulighet for global state av klient data. MobX er mye diskutert, men en del mener det er best performance.&#160;<\/p><p>&#160;<\/p><p>Overordnet kan en si at Recoil virker som et godt kompromi mellom enkelhet og ytelse. Det er noks&#229; enkelt &#229; implementere, men er verken best eller d&#229;rligst p&#229; ytelse.&#160;&#160;<\/p><p>&#160;<\/p><p>Brukte kilder:<\/p><p>https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>https://medium.com/@mwanahamuntu/redux-vs-mobx-vs-react-context-api-4febfe1bad0<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2238,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er to ulike l&#248;sninger p&#229; kommunikasjon mellom frontend og backend (server / klient) i en web applikasjon.&#160;<\/p><p>Med et REST API vil du typisk samle data gjennom &#229; akksessere flere endpoints. Disse endepunktene kan endre p&#229; etiteter gjennom URI og HTTPS foresp&#248;rsler. REST definerer hvilke type data som skal returneres for en ressurs og hver ressurs har en egen URI adresse. Et&#160;typisk endpoint kan v&#230;re /worker/&#60;id&#62;. Dette vil da gi informasjon om en worker. S&#229; kan en ha worker/&#60;id&#62;/jobs som returnerer alle jobbene. Og s&#229;nn kan det fortsette, med &#229; ha flere endpoints. REST vil ogs&#229; gi deg muligheten til &#229; f&#229; hjelp av cachingen som er i nettleserne by default. Caching p&#229; klienten er viktig for effektivitet/skalerbarhet. Responsen en f&#229;r m&#229; ogs&#229; eksplisitt eller implisitt defineres som cachable. REST er ogs&#229; mer utbredt =&#62; mer dokumentasjon.&#160;<\/p><p>Ulemper med REST er blant annet at du ikke kan begrense dataen/feltene en vil f&#229; fra et endepunkt, en vil alltid f&#229; all dataen selv om man ikke trenger alt (overfetching). En mulig ulempe er ogs&#229; det at mange ulike endepunkter kan bli kaotisk og du m&#229; kanskje gj&#248;re mange kall for &#229; kunne hente den dataen du trenger.<\/p><p>&#160;<\/p><p>GraphQL bruker i motsetning til REST bare et endepunkt. Du sender en enkelt sp&#248;rring (et JSON objekt) til GraphQL serveren som inkluderer de konkrete dataene du &#248;nsker &#229; f&#229; tilbake. Serveren vil s&#229; svare med &#229; sende tilbake et JSON objekt som inneholder alle resultatene som oppflyte sp&#248;rringen. Alts&#229; kan du unng&#229; over/underfetching med &#229; skrive presise sp&#248;rringer og vil gjennom dette ogs&#229; &#248;ke ytelsen p&#229; applikasjonen. Ettersom det er samme format p&#229; sp&#248;rringene en skriver og svaret en f&#229;r returnert blir det ogs&#229; veldig enkelt &#229; programmere og &#229; henge med p&#229; hva som blir sendt og retunert. Det er i tillegg et innebygd typesystem som gj&#248;r det mulig &#229; validere de resultatene en f&#229;r og det blir da enkelere &#229; oppdage potensielle feil.&#160;<\/p><p>Ulemper er blant annet at det kun st&#248;tter JSON data samt at det er mangel p&#229; implisitt caching i HTTP-laget.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; mange likheter som at begge har ideen om en ressurs og kan spesifisere ID for de ressursene. Begge kan bli fetchet gjennom en HTTP GET requset med en URL og begge kan returnere JSON data. Begge har ogs&#229; mulighet for &#229; si ifra om en API request er ment for &#229; lese eller sende data.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533414,"ext_inspera_userAssessmentSetupId":7139918,"ext_inspera_userAssessmentId":4841332,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Schefte Inger-Ane Sætra (10238)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35242408,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2371,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En m&#229;te &#229; h&#229;ndtere dataflyt p&#229; er &#34;unidirectional&#34; dataflyt som g&#229;r ut p&#229; at states kan sendes nedover i komponenttreet fra parent til child, evt. oppover i treet ved hjelp av call-back funksjoner.&#160;Dersom man &#248;nsker &#229; sende states mellom to komponenter&#160;med denne teknikken, m&#229; man f&#248;rst sende staten til deres felles forelder og s&#229; sende staten nedover til child komponentene derfra. Ulempen med denne metoden er at det fort kan bli komplisert og vanskelig &#229; holde styr p&#229; n&#229;r applikasjonen blir st&#248;rre.&#160;<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; h&#229;ndere state og dataflyt p&#229; er med verkt&#248;y som Context, Redux og MobX som gj&#248;r det mulig &#229; &#34;sende&#34; states mellom komponenter uten &#229; sende states manuelt gjennom&#160;hvert niv&#229;. Med Context wrapper man en provider rundt en parentkomponenten, og alle children av denne komponenten vil da f&#229; tilgang til en felles variabel. Dersom man endrer p&#229; noe i contex uansett hvor man er i hierarkiet (m&#229; v&#230;re innenfor provideren), s&#229; vil koden rerenderes og oppdateres.<\/p><p>&#160;<\/p><p>Redux er en annen metode som kan brukes til state management. Redux krever en del boilerplate kode med action creators, actions og reducere, men er enkelt &#229; bruke n&#229;r denne koden er p&#229; plass. Redux kan dermed sies &#229; v&#230;re &#34;overkill&#34; i mindre prosjekter, men ved &#229; bruke Redux legger du til rette for at applikasjonen enkelt&#160;kan utvides med flere komponenter og states. En annen fordel med Redux er at det&#160;er lett &#229; debugge koden og at redux er mer forutsigbar enn f.eks. MobX.<\/p><p>&#160;<\/p><p>MobX er ogs&#229; en metode som kan brukes for &#229; h&#229;ndtere states. I MobX skjer h&#229;ndteringen av states mer automatisk, og MobX krever dermed&#160;mindre boilerplate kode enn redux. MobX kan dermed blant annet v&#230;re nyttig i mindre prosjekter. Ulemper med MobX at det er mindre forutsigbart enn Redux (siden mye skjer automatisk) og at det dermed kan v&#230;re vanskelig &#229; teste at h&#229;ndteringen av state oppf&#248;rer seg som det skal.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>One Way Data Flow - React Training (gitbook.io)&#160;(&#60;- kilde, blir limt inn s&#229;nn her selvom jeg kopierer urlen)<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2331,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management i React. Recoil bruker konseptene Atoms og&#160;Selectors. Atoms er deler av state som kan oppdateres og som som andre komponenter kan &#34;subscribe&#34; p&#229;. Komponenter som bruker samme atom deler state. Selectors kan endre disse statesene synkront eller asynkront. Selectors er funksjoner som tar atoms og andre selctors som input. N&#229;r disse inputverdiene oppdateres vil selector funksjonen bli reevaluert og og s&#229; vil komponentene som har subscribet til denne selectoren bli re-rendret og endre seg. (Core Concepts | Recoil (recoiljs.org)).<\/p><p>&#160;<\/p><p>Recoil gj&#248;r p&#229; mange m&#229;ter det samme som andre state management verkt&#248;y som Redux, MobX og Context. Recoil bruker Context APIet og hooks til &#229; h&#229;ndtere state, men i&#160;motsetning til Context som kun kan ha en verdi i sin store, kan Recoil lagre s&#229; mange set med verdier man &#248;nsker. Dette gj&#248;r at det kan v&#230;re en fordel &#229; bruke Recoil i stedenfor Context i st&#248;rre applikasjoner. I stedenfor &#229; lage action creators, actions, reducers og evt. kombinere disse i en egen fil, holder det med atoms og selectors n&#229;r man bruker recoil. I redux m&#229; man bruke dispatch metoiden for &#229; &#34;fire&#34; en action, mens man i recoil firer actions ved &#229; modifiserer en action med selectorene. I motsetning til Redux som krever mye boilerplatekode sies Recoil &#229; v&#230;re mer minimalistisk med mindre boilerplatekode. Bruk av Recoil sies ogs&#229; &#229; v&#230;re mer likt React enn redux.<\/p><p>En ulempe med Recoil er at det er relativt nytt, og det kan dermed v&#230;re tryggere &#229; bruke et statemanagement verkt&#248;y man er bedre kjent med.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;Introducing Recoil: Simplified state management for React - LogRocket Blog<\/p><p>-&#160;Redux vs Recoil: which should you use? &#183; Emma Goto (emgoto.com)<\/p><p>-&#160;Recoil: A New State Management Library Moving Beyond Redux and the Context API | by Jennifer Fu | Better Programming | Medium<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1951,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er et &#34;architectural concept&#34; for nettbasert sofware, mens GraphQL er et sp&#248;rrespr&#229;k. (Rubrik | GraphQL vs REST: What You Need to Know)&#160;<\/p><p>&#160;<\/p><p>N&#229;r man bruker REST f&#229;r man et komplett datasett i retur, noe som gj&#248;r at REST ofte &#34;over fetcher&#34;. Med GraphQL kan du i motsetning til i REST begrense sp&#248;rringen s&#229;n at du henter ut akkurat den dataen du trenger.<\/p><p>&#160;<\/p><p>REST har flere endepunkter, mens GraphQL bare trenger ett endepunkt. Dersom du &#248;nsker &#229; hente ut/endre informasjon om ulike objekter med REST m&#229; du&#160;gj&#248;re flere sp&#248;rringer/requests siden en sp&#248;rring i REST kun kan hente ut in formasjon om ett objekt. Her opererer GraphQL annerledes, og med GraphQL kan man lage requesten slik at den returnerer akkurat det man &#248;nsker, ogs&#229; hvis man &#248;nsker data&#160;om ulike objekter. Dermed kan man hente ut/endre informasjon om ulike objekter i samme sp&#248;rring. I REST har man dermed x endepunkter for x antall data, mens man i GraphQL gjerne kun har ett endepunkt (kan ogs&#229; ha flere).<\/p><p>&#160;<\/p><p>En fordel med REST er at hvert endepunkt har en oppgave/&#34;sp&#248;rring&#34; knyttet til seg, og det er dermed enkelt &#229; forst&#229; og endre koden og forst&#229; hva som vil bli returnert fra en sp&#248;rring. I tillegg er REST en del av MERN stacken og er mye brukt av utviklere.&#160;<\/p><p>&#160;<\/p><p>Fordeler med GraphQL er at man kun henter ut dataen man &#248;nsker og dermed ikke &#34;over fetcher&#34;. Ulemper med GraphQL er at den legger til kompleksitet p&#229; serversiden av et prosjekt og gj&#248;r det mer komplekst &#229; fetche data effektivt.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-Rubrik | GraphQL vs REST: What You Need to Know<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533420,"ext_inspera_userAssessmentSetupId":7140041,"ext_inspera_userAssessmentId":4841253,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Melkild Live Pettersdatter (10107)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35241951,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2738,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er en &#34;one-way data flow&#34; nedover i component hirarkiet.&#160;<br />Stateh&#229;ndering er en viktig del av react. For &#229; kunne oppdatere staten til siden n&#229;r en action skjer, kan vi bruke ulike hjelpemidler. Om vi ikke har et state management kan vi sjekke staten til appliksjonen ved &#229; sjekke DOM elementene.<\/p><p>&#160;<\/p><p>Vi kan bruke Redux, Mobx og Context til stateh&#229;ndtering. Disse tre har vi gjort research p&#229; til prosjektene. Alle er bra&#160;teknologier, men n&#229;r man setter opp et ReactJS prosjekt b&#248;r man tenke over hvilken som er best til situasjonen.&#160;<\/p><p>&#160;<\/p><p>Stateh&#229;ndtering med Redux var det mange som brukte til prosjekt 3, min gruppe inkludert, selv om det kanskje ikke var det som var mest effektivt. Redux har mye boilerplate ettersom det er mye setup kode som m&#229; implementeres. Prosjektet 3 var et realtivt lite prosjekt og mye tid og plass gikk til &#229; skrive redux kode. Men redux er det mest popul&#230;re stateh&#229;ndeting managementet, s&#229; natruligvis er det mange fordeler ved redux. <strong>Det er lettere &#229; debugge redux og redux er sv&#230;rt nyttig i store prosjekter hvor man trenger mye state h&#229;ndtering(og dermed nyttig &#229; l&#230;re seg)<\/strong><\/p><p>Redux har en store som kan deles inn i flere reducers. M&#229;ten appliksojonen kan interact med store-en er gjennom action. Vi bruker dispatch til dette. Reduceren spesifiserer hvordan app staten endrer seg i forhold til responsen til &#34;dispated actions&#34;. Reduceren f&#229;r inn sate og action som argumenter og returnerer den neste staten for appliksonene. (previous, action) =&#62; newState<\/p><p>&#160;<\/p><p>I prosjekt 3 fikk vi alternativet mellom &#229; bruke Mobx eller Redux. Som sagt valgte de fleste &#229; bruke Redux, men jeg tenkte p&#229; i etterkant at det hadde v&#230;rt smartere for oss &#229; bruke Mobx. Mobx er et state management som gir mindre boiler plate enn redux og l&#248;nner seg mer til mindre prosjekter. Det er enklere &#229; l&#230;re seg (etter kilder fra nettet) og er mindre set up. Med Mobx kan man lage flere stores for &#229; store tilstanden til appliksonenen. Det vil v&#230;re lettere &#229; oppdatere staten med nye verdier ettersom staten er foranderlig.&#160;<\/p><p>&#160;<\/p><p>I prosjekt 2 brukte vi context. Context er et smart valg om man &#248;nsker &#229; aksessere data som er lengre &#34;nede i komponent-treet&#34; uten &#229; m&#229;tte sende det gjennom props manuelt i hvert niv&#229;. Man trenger en provider som gj&#248;r staten tilgjengelig for alle &#34;child&#34; komponentene og en consumer som s&#248;rger for at hvilken som helst kompoent i komponenttreet kan hente ut dataen. Context er mindre komplekst, men egner seg derfor ikke til komplekse applikasjoner ettersom det er vanskeligere &#229; vedlikeholde. Context er heller ikke et bra valg om det skal skje flere fortl&#248;pende endringer, da er det bedre &#229; bruke redux eller Mobx. Men i prosjekt 2 fikk vi testet ut &#229; bruke context til noen endringer som ikke n&#248;dvedigvis skulle skje s&#229; ofte eller endret mellom s&#229; mye forksjellig.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3232,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state manement bibliotek for react, som kan sammenlignes med de andre state managementene som jeg skrev om i oppgave 1. Recoil baserer seg p&#229; Atoms og selcetors som gj&#248;r recoil til et unik state management siden det vil v&#230;re enklere og&#160;raskere &#229; gj&#248;re visse operasjoner<\/p><p>&#160;<\/p><p>Context vs Recoil.<\/p><p>Om vi har to elementer som &#248;nsker &#229; endre state samtidig ettersom det &#34;henger sammen&#34; p&#229; en m&#229;te, men de er lagt i fra hverandre i komponenttreeet, kan man bruke context, men det er ikke det optimale. Det vil bli mye overflod av providers som skal &#34;conecter&#34; elementene. Komponetstrukturen blir for kompleks for context.<\/p><p>Dette problement l&#248;ser recoil ettersom den bruker en tenikk som de kaller flexible shared state. Det oppretter et&#160;atom som er en enhet som innholder state. Staten til et atom kan endre seg og der er mulig &#229; knytte en komponetnen til atom-et. S&#229; i steden for at hver komponent har dens egne state, som blir mange separate stater, s&#229; deler heller komponteter tilstander. Hver ID blir knyttet opp mot ett atom, dermed om en state blir endret ett sted, vil det ogs&#229; bli endret et annet sted om de deler tilstand.&#160;<\/p><p>&#160;<\/p><p>Recoil vil ogs&#229; gi mindre sjanse for bugs ettersom den ikke alltid gir en egen state til vise deler av applikasjonen. Om vi har en del av applikasjonen som avhneger av andres state n&#229;r den oppdateres, blir det mye oppdatering av stater med f.eks bruk av redux. Recoil tar heller &#229; samler statene ved hjelp av en funksjon. selector tar &#229; henter id-en til det som har blitt valgt og derretter tar &#229; henter de atomene som er knyttet til den id-en, dette samles i operasjonen som &#248;nsker &#229; bli gjort. Men det bra som rcoil gj&#248;r er at den ikkebregener funsjonen p&#229; nytt selv om et atom er byttet ut.&#160;<\/p><p>&#160;<\/p><p>Fikk ikke mer tid til &#229; skrive, men h&#229;per det ble forst&#229;rlig. Pr&#248;vde &#229; forst&#229; s&#229; mye som mulig p&#229; kort tid.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1221,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Begge teknologiene omhanlder &#229; sendte en HHTP request og motta et resultat.&#160;<\/p><p>&#160;<\/p><p>Den vesentlig forskjellen&#160;mellom RestAPI og GrapthGL er&#160;at RestAPI har flere endepunkt enn GrapthQL. I rest APi har vi GET,POST,DELETE PUT osv, mens i GrapthGl har vi POST. Siden vi har mange endepunkter med Rest API kan det bli mye overf&#248;ldig data. I GrapthGL har vi spesefike sp&#248;rringer som reulterer i at vi bare f&#229;r ut dataen vi &#248;nsker --&#62; mindre overf&#248;dig data. Arkitetureren vil da bli renere og det vil bli en mer konsis kode.&#160;<\/p><p>&#160;<\/p><p>Fordeler med grapthGL er at det er under eller over fetching, siden man kan spesifisere feltene som man &#248;nsker seg. Feil vil enklere bli fanget opp. En bra fordel er at frontend og backend kan jobbe uavgening av hverandre<\/p><p>&#160;<\/p><p>Fordelen med RestAPI er at det er mer vanlig enn grapthGL og vil derfor v&#230;re mer dokumentasjon&#160;p&#229; det, og andre programmerere vil v&#230;re mer kjent med teknologien. Om man &#248;nsker mye informasjon, er det smart med RESTApi. Jeg mener at Restapi var det beste &#229; bruke i prosjekt 3, ettersom vi &#248;nsket mye data om hvert element.&#160;<\/p><p>&#160;<\/p><p>Ulempen med restAPI er at det er mange endepunkter og mye oppdatering, som blir mye overfetching. Om man ikke &#248;snker dette er grapth GL et mye bedre alternativ. Men i Grapth GL er det mer komplisert &#229; fetche data effektivt.&#160;&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533445,"ext_inspera_userAssessmentSetupId":7139928,"ext_inspera_userAssessmentId":4841306,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Lazreg Lotfi Amin (10046)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331336,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1708,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React komponenter har en lifecycle hvor du har en intern state og hvis det skjer endringer p&#229; denne staten vil komponentet rerendre. I utgangspunktet deler komponenter ingen state og er uavhengige av hverandre p&#229; denne m&#229;ten. Hvis man &#248;nsker at et underkomponent skal se staten til en parent kan man passe den ned via props. Underkomponent vil ikke ha mulighet til &#229; endre p&#229; staten, men kan se staten og blir rerendret n&#229;r staten endrer seg.<\/p><p>&#160;<\/p><p>Man kan sende en funksjon, definert i parent&#160;til underkomponentet som endrer p&#229; state og dermed gj&#248;r det mulig &#229; endre state i underkomponentet Problemet som oppst&#229;r blir at hvis man skal sende state ned flere steg vil man til slutt ende opp med en stor kjede av dependencies og rerenders og det vil bli veldig kostbart. Man kan ogs&#229; passe&#160;ned state til flere forskjellige underkomponenter fra samme parent, men samme problem vil oppst&#229;. Et annet stort problem er at man kan gj&#248;re endringer p&#229; state som f&#248;rer til uforutsigbarhet hvis flere komponenter endrer p&#229; samme state.&#160;&#160;<\/p><p>&#160;<\/p><p>Disse to problemene kan l&#248;ses til forskjellige grader via bruk av andre teknikker og tredje-parts bibloteker som Recoil, Redux, mobx,react-context og hooks.<\/p><p>&#160;<\/p><p>Hooks kan kun brukes i funksjonelle komponenter og kan brukes til &#229; gj&#248;re funksjonene stateful ved &#229; implementere useState. useState fungerer mer eller mindre likt som class components sin state, men gj&#248;r det enklere &#229; dele logikk mellom komponenter.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3881,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et biblotek for &#229; dele state mellom komponenter i en React-applikasjon. De to hovedkonseptene i Recoil er Atoms og Selectors. Atoms er deler av state som komponenter kan subscribe til og dermed rerenderes n&#229;r denne atomen oppdateres. Atoms fungerer p&#229; samme m&#229;te som React sin lokale komponent state og kan brukes istedenfor denne, forskjellen er at denne staten kan deles mellom komponenter uten bruk av props.&#160; Selectors er funksjoner som regner ut derived state som tar inn enten atoms eller andre selectors som input og gj&#248;r utregninger basert p&#229; det. Et eksempel kunne v&#230;rt getLastName(fullname) ha en Atom p&#229; person som har et felt fullname som man regner ut last name p&#229;. Komponenter som subscriber til denne selector vil kun rerendres&#160;n&#229;r lastName endres.&#160;<\/p><p>&#160;<\/p><p>React-context api bruker mange av de samme teknikkene. Man subscriber til et context ved &#229; importere useContext fra dette context og n&#229;r det skjer endringer i dette contextet vil alle komponenter som subscriber rerendres. Man kan ogs&#229; implementere selectors, dog p&#229; en litt annen m&#229;te enn Recoil.&#160; Med React-context APi kan man kun subscribe til ett context i motsetning til Recoil.<\/p><p>Alle komponenter som subscriber til et context vil rerendres n&#229;r dette context endres selvom endringer skjer p&#229; en annen del av state enn det man er interessert i. Dette f&#248;rer til uforutsigbare rerendres og det kan bli veldig kostbart &#229; gj&#248;re endringer p&#229; state som f&#248;rer til en mangel p&#229; skalerbarhet. Recoil l&#248;ser dette ved at man kan ha flere Atoms man kan subscribe til og lytte til forskjellige deler av states.Hvis man kun er interessert i &#229; endre state, og ikke lytte, kan man ogs&#229; gj&#248;re det.<\/p><p>&#160;<\/p><p>Mobx har samme funksjonen ved at man kan subscribe til variabler, men mobx tillater at state blir lett modifisert og overskrevet av nye verdier. Dette gj&#248;r det lett &#229; implementere mobx og komme kjapt i gang, men &#229; maintaine og skalere opp blir vanskeligere i m&#248;te med uforutsigbart output.&#160;<\/p><p>&#160;<\/p><p>Redux har en single source of truth ved &#229; ha en enkelt store som kombinerer de andre storene man eventuelt har. State kan kun endres gjennom reducers og actions som gj&#248;r at state er forutsigbar. Redux krever veldig mye boilerplate code og det er mye &#229; sette seg inn i.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1551,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er overordnet arkitektur / design. Bruker POST/GET/PUT/DELETE og&#160; URI for &#229; treffe ressursene.&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k hvor du spesifiserer i query hva du vil hente.<\/p><p>&#160;<\/p><p>Hvis du har en bok-database vil kallene kunne se slik ut.&#160;<\/p><p>&#160;<\/p><p>graphql: query = {book(id:$id) {title author}, get(localhost:4000/query={query})<\/p><p>REST: get ( uri: (localhost:4000/book/$id)&#160;<\/p><p>&#160;<\/p><p>Ved &#229; utf&#248;re get requets med Rest vil man f&#229; alt som returneres i denne pathen. Med GraphQL har du mulighet til &#229; f&#229; akkurat de feltene du &#248;nsker og ikke noe mer.&#160;&#160;Dette har en effekt p&#229; nettsidens ytelse og forbruker mindre data for brukeren.&#160;<\/p><p>&#160;<\/p><p>Denne m&#229;ten &#229; sette opp queries hvor du ber om data via json gj&#248;r at du kan erstatte <strong>mange <\/strong>REST, GET requests men<strong> &#233;n<\/strong>&#160;graphql GET<\/p><p>Hvis du skal initialisere siden med info fra et API m&#229; du gjerne med REST gj&#248;re flere api kall for &#229; f&#229; all data<\/p><p>Hvis du har en bok blogg side og du vil vise innlegg og b&#248;ker p&#229; hovedsiden. M&#229; du gj&#248;re 2 api kall med REST, ett for innlegg og ett for b&#248;ker. Med graphql kunne du ha gjort {{blogs(query) {title content} }{books(query){title author}} }<\/p><p>&#160;<\/p><p>S&#229; essensen er: Man kan f&#229; kun dataen man er ute etter og gj&#248;re f&#230;rre api-kall med GraphQL.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11533488,"ext_inspera_userAssessmentSetupId":7140012,"ext_inspera_userAssessmentId":4841199,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hjelle Emil Wiersdalen (10134)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331226,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2017,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React kan man ha&#160;tilstander som tilh&#248;rer en spesifikk komponent, eller bruke global state management (eller en kombinasjon). Tilstander kan bli sendt som props ned i komponent hiarkiet. Dette gj&#248;r det mulig for komponenete &#229; bruke tilstanden til foreldrene, men ikke endre den. Hvis det er tilstander som ikke er spesifikke for en komponent, er det lurt &#229; bruke global state management. Det gj&#248;r det miulig &#229; for flere komponenter &#229; f&#229; tilgang til state fra forskjellige deler av komponent treet. Noen vanlige bibliotek man bruker for global state management er:<\/p><p>&#160;<\/p><p>Context - Context er godt egnet for &#229; gi tilgang de ulike komponente tillgang til state, men er ikke like effektiv n&#229;r man endrer state ofte. Her har man consumer og provider for &#229; for &#229; spesifisere hvor man skal ha tilgang p&#229; den globale state&#39;en.<\/p><p>&#160;<\/p><p>Redux - Redux er egnet for&#160;komplekse apper som endres ofte. Dete er delt inn i store, actions og reducers. State blir lagret i store og er read-only. Komponente&#160;endrer p&#229; state med&#160;dispatch-metoden og en action. Reducers tar inn state og action for &#229; sette en ny state.<\/p><p>&#160;<\/p><p>MobX - MobX skal v&#230;re minimalistisk og enkelt &#229; bruke.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://mobx.js.org/README.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3234,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek. N&#229;r man bruker det&#160;i komponentene s&#229; minner en veldig om den klassiske m&#229;ten &#229; bruke local state p&#229;. Man kan bruke &#34;state&#34; og &#34;setState&#34; p&#229; samme m&#229;te bare at man bruker useRecilValue() i steden for useState().&#160;<\/p><p>&#160;<\/p><p>Recoil virker som et enklere bibliotek &#229; bruke sammenlignet med redux. Noe av motivasjonen bak Recoil er at man &#248;nsker &#229; forbedre state management, uten &#229; endree p&#229; den klassiske semantikken og oppf&#248;rselen til react. Jeg synes ogs&#229; det virker enklere &#229; forholdes seg til atoms og selectors i steden for &#229; m&#229;tte forholde seg til store, actions og reducers.&#160;<\/p><p>&#160;<\/p><p>En begrensing med Context som Recoil &#248;nsker &#229; fikse, er at man kun kan lagre en verdi. Recoil gj&#248;r det ogs&#229; mulig &#229; ha en state som kan v&#230;re tilgjengelig i flere komponenter uten at mman trenger &#229; rerendre store tr&#230;r.&#160;&#160;&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1703,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL er primert et sp&#248;rrespr&#229;k hvor man kun bruker json objekter til &#229; spesifisere hva man &#248;nsker &#229; hente eller endre.&#160;<\/p><p>&#160;<\/p><p>REST API&#160;bruker&#160;HTTP foresp&#248;rslene GET, PUT, POST, DELETE for &#229; lese, endre, opprette eller slette ressurser.&#160;<\/p><p>&#160;<\/p><p>REST&#160;legger til rette for caching, mens GraphQL ikke har noe implistt caching i HTTP-laget. Caching medf&#248;rer at man har hurtig tilgang p&#229;&#160;dataen man har lagret, og man slipper &#229; un&#248;vendige foresp&#248;rsler.&#160;<\/p><p>&#160;<\/p><p>REST vil alltid gi et komplett datasett. Dette kan f&#248;re til &#34;over fatching&#34;. I GraphQL er det mulig &#229; begrense s&#248;ket slik at man kun f&#229;r det man trenger. Dette gj&#248;r det lett &#229; h&#229;ndtere dataen i klienten, ettersom at mye av filteringen og sorteringen kan gj&#248;res i GraphQL. I GraphQL kan hente n&#248;vendig data med 1 forsp&#248;rsel.&#160;<\/p><p>&#160;<\/p><p>I graphQL definerer man typer for validering, og at det skal v&#230;re enklere for andre &#229; forst&#229; koden.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11533933,"ext_inspera_userAssessmentSetupId":7140023,"ext_inspera_userAssessmentId":4841240,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gibson Molly Prestholdt (10199)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331172,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1984,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Hovedm&#229;ten som brukes for &#229; h&#229;ndtere tilstand og dataflyt i React-applikasjoner er state og props. State er den interne tilstanden i en komponent som den selv kan endre p&#229;, og/eller sende nedover til sine &#34;barn&#34;.<\/p><p>&#160;<\/p><p>Props er informasjon som kommer fra et komponent h&#248;yere opp i komponenthierariket som gis til komponentet n&#229;r det kalles. En komponent skal ikke endre p&#229; informasjon fra props, dette er bare noe komponentet f&#229;r fra h&#248;yere opp. Et viktig aspekt med dataflyt i en React applikasjon er at data kan bare sendes nedover i komponentene, og ikke &#34;sidelengs&#34; eller oppover. Fordi man ikke alltid vil sende informasjon som skal brukes av mange komponenter globalt gjennom alle lag i komponent hierarkiet, har ogs&#229; React biblioteker som kan implementerer&#160;global state.<\/p><p>&#160;<\/p><p>Det vi har sett mest p&#229; i dette faget er redux, context og mobx. I prinsippet er&#160;alle disse&#160;relativt like, man &#248;nsker &#229; lagre noen ting i en state, som komponenter i hele hierarkiet lett kan f&#229; tak i og komponentet rerendres n&#229;r state endres p&#229;.&#160;Fordelen med f.eks Redux&#160;i forhold til de andre er at&#160;Redux er immutable og man f&#229; &#34;en kilde til sannhet&#34; n&#229;r du blant annet tester, ulempen er at det er en del overhead og &#34;boiler plate&#34; kode som du m&#229; ha for &#229; f&#229; det til &#229; fungere. P&#229; grunn av dette er det absolutt en l&#248;sning for st&#248;rre og mer kompliserte applikasjoner eller nettsider. context og mobx&#160;er ikke like &#34;tunge&#34; l&#248;sninger som ogs&#229; implementerer tilgang til en global state, men hvor staten er mutable som fort kan bli en utfordring i store applikasjoner hvor staten oppdateres fra mange steder.<\/p><p>&#160;<\/p><p>M&#229;ten global state h&#229;ndteres av disse er at de har en logikk som ligger i egne komponenter, f.eks reducers og actions som man har i Redux eller bare et rent&#160;context komponent, ogs&#229; wrappes ett toppniv&#229; komponent i en context provider, store etc. p&#229; index/app niv&#229; for &#229; gi tilgang nedover i komponent hierarkiet. Komponenter &#34;subscriber&#34; til state og rerenderes n&#229;r state endres av ett komponent for &#229; holde siden oppdatert. Det er forskjell mellom de tre om alt rerendres ved change av state, eller om man subscriber og rerenderer spesifikke komponenter.&#160;<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://hackernoon.com/data-flow-in-reactjs-c682edc95106&#160;<\/p><p>https://reactjs.org/docs/thinking-in-react.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2910,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er ett helt nytt bibliotek fra facebook, de samme som lagde react, for &#229; implementere global state mangement.<\/p><p>&#160;<\/p><p>M&#229;ten dette gj&#248;re p&#229; er at du lager atoms som hver har&#160;en bit av state, og disse atomsene kan da brukes istedenfor state i komponentene dine eller som global state i tillegg til state i komponenter.&#160;Hver&#160;atom har en unik n&#248;kkel&#160;og m&#229;ten alle kompontene har tilgang til atoms, er at du har en recoilRoot som er wrapper&#160;alle komponenten,&#160;p&#229; samme m&#229;te som context/redux fungerer.<\/p><p>&#160;<\/p><p>Du lager ogs&#229; selectors som b&#229;de kan gi deg en bit med &#34;derived state&#34;, alts&#229; sate som endres p&#229; av en funksjon, f.eks setters som gir deg muligheten til &#229; endre p&#229; staten til et atom. Recoil&#160;er laget for funksjonelle komponenter og erstatter useState med useRecoilState blant annet og useRecoilValue gir deg tilgang til en state sin tilstand. selectors subscriber ogs&#229; p&#229; state og rerenderes hvis en state endrer p&#229; seg, men hvis man endrer en state om ikke har noe med et komponent &#229; gj&#248;re vil den ikke rerendre<\/p><p>&#160;<\/p><p>Tilsvarende l&#248;sninger som vi har p&#229; l&#230;ringsm&#229;lene og som Recoil ville erstattet er Redux, MobX og Context. Fordelene med Recoil er at det kan erstatte all state h&#229;ndtering, istedenfor &#229; bare implementere en globalstate i tillegg til state i et komponent&#160;som v&#229;re l&#248;sninger i st&#248;rre grad gj&#248;r. Det virker&#160;ogs&#229; som det er&#160;mindre &#34;boilerplate&#34; kode som for eksemple Redux har mye av, og siden det virker veldig lett &#229; sette opp s&#229; er det ogs&#229; skalerbart til store og sm&#229; applikasjoner. Dette er definitvt klare fordeler med Recoil.&#160;<\/p><p>&#160;<\/p><p>En annen positiv&#160;ting med recoil er at det h&#229;ndterer asynkrone fetches p&#229; en veldig lett m&#229;te rett i selectors, istedenfor &#229; m&#229;tte bruke thunk middelware som man m&#229; gj&#248;re i f.eks. Redux. Det har ogs&#229; noe som heter suspense som gir deg muligheten til &#229; lett ha f.eks &#34;loading icon&#34; n&#229;r du gj&#248;r asynkrone fetches. Recoil er ogs&#229; som nevnt over, utvikelt av de samme som har laget React. Dette gj&#248;r at strukturen og m&#229;ten man bruker&#160;Recoil p&#229; er veldig lik som m&#229;ten React tenker p&#229;, og det er derfor veldig lett &#229; sette seg inn i og begynne &#229; bruke uten &#229; m&#229;tte sette seg inn i noe som fungerer helt annerledes enn resten av applikasjonen man utvikler.&#160;<\/p><p>&#160;<\/p><p>En av de viktigtste tingene mot &#229; bruke Recoil er at det er helt nytt av 2020, s&#229; det er nok ikke s&#229; lurt &#229; bruke i noen store prosjekter f&#248;r det har blitt uvitklet mer, men ser veldig lovende ut for n&#229;r det begynner &#229; bli&#160;stabilt. Det er ogs&#229; viktig med community support n&#229;r man utvikler, s&#229; hvis man m&#248;ter p&#229; problemer s&#229; finnes det andre som jobber med det og forum man kan sp&#248;rre i, i tillegg til &#229; ha mye dokumentasjon tilgjengelig. Dette finnes ikke for Recoil enda, da det som sagt er veldig nytt.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://medium.com/better-programming/recoil-js-the-new-better-state-management-library-for-react-1095947b5191<\/p><p>https://recoiljs.org/docs/introduction/installation<\/p><p>https://medium.com/@narendersaini32/recoil-a-new-state-management-library-from-facebook-for-react-cd159c081ed9<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2199,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST har v&#230;rt m&#229;ten &#229; l&#248;se backend p&#229; lenge, men blir i st&#248;rre grad tatt over av Graphql, en av hovedgrunnene til dette er behovet for en mye mer fleksibel l&#248;sning enn det REST er. Dette er fordi Rest fungerer veldig godt n&#229;r man har en frontend og UI&#160;som passer med REST og som samsvarer med dataene som ligger sammen i backend.&#160;<\/p><p>&#160;<\/p><p>Problemet ligger i n&#229;r du har laget en ett sett med GET requests, men s&#229; endrer du UIen p&#229; frontend og vil plutselig hente litt andre dataer sammen, eller mindre data av gangen. Da f&#229;r du problemet med overfetching/underfetching i Rest, fordi du forholder deg til endpoints, og m&#229; plutselig hente fra flere endpoints og ender opp med for mye data eller for lite og m&#229; hente flere ganger.<\/p><p>&#160;<\/p><p>I&#160;graphQL sender du bare en query med ett sett med krav til hva slags data du vil ha og serveren svarer med ett json&#160;objekt. Istedenfor &#229; ha laget GETbok f.eks, som returnerer en bok og en forfatter s&#229; vil man ha definert typene bok og forfatter og sp&#248;rre etter de typene i graphQL hvis man skal ha de sammen. Dette er en veldig viktig forskjell mellom REST og graphql, hva slag type data du har og hvordan denne dataen hentes er ikke koblet sammen i graphql, men det er den i REST. En fordel med graphql er at n&#229;r alle disse typene er satt kan backend og frontend utviklere jobbe samtidig, fordi de er blitt enige om alle typene og frontend/backend kan utvikles samtidig uten konflikt mellom struktur i backend og endringer i UI.&#160;<\/p><p>&#160;<\/p><p>Graphql kan se p&#229; som en m&#229;te &#229; multiplekse REST, fordi du kan bygge opp n&#248;stede queries for &#229; f&#229; spurt om flere og spesifikke ting fra databasen samtidig.&#160;<\/p><p>&#160;<\/p><p>Det skal sier at en annen forskjell p&#229; REST og graphql er at REST er ett eldre og mer etablert API, noe som gj&#248;r at det er bedre dokumentert og har ett veldig stort og aktivt community som jobber med det fortsatt. Dette er en viktig fordel n&#229;r man skal jobbe med ett rammeverk, at det fortsatt har mye st&#248;tte og det er mye god dokumentasjon p&#229; hvordan det b&#248;r brukes.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534648,"ext_inspera_userAssessmentSetupId":7139995,"ext_inspera_userAssessmentId":4841163,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hanesand Magnus (10232)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331266,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1923,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstand i React er i utgangspunktet forbeholdt klasser. Det er variabler som tilh&#248;rer en enkelt komponent og styres i komponenten. I&#160;funksjonelle komponenter har derimot ikke komponentene tilstand p&#229; samme m&#229;te som f&#248;r. Dette h&#229;ndteres med React Hooks. Tilstanden til en komponent er tilgjengelig kun internt i komponenten, s&#229; om informasjon skal flyttes mellom komponentene m&#229; det sendes nedover i komponenttreet. Dette vil si at en komponent kan sende informasjon i form av &#34;props&#34; til en komponent den rendrer (gitt at komponenten under er definert til &#229; ta imot props). Det er ikke mulig &#229; sende informasjon direkte oppover i komponenthierarkiet, men man kan simulere det ved &#229; sende en s&#229;kalt callback-funksjon fra mottakeren til senderen av informasjonen. Alts&#229; kan en komponent ettersp&#248;rre informasjon fra en komponent lavere i treet, som s&#229; p&#229; sin side kan svare med informasjonen den &#248;nsker &#229; sende opp.<\/p><p>&#160;<\/p><p>For noen typer tilstander er det enormt upraktisk &#229; m&#229;tte sende informasjon som props. Hvis tilstanden skal brukes i mange komponenter er det veldig mye som m&#229; sendes opp og ned i komponenthierarkiet. For &#229; l&#248;se dette finnes det APIer og biblioteker som lar oss i praksis lage en global tilstand. Eksempler p&#229; dette er Context, Redux, Recoil og MobX. Fellestrekkene for disse er at de alle lagrer tilstand ett sted, men sender tilgang til tilstanden rekursivt nedover i komponenthierarkiet. Dette vil si at hvis du for eksempel har en Provider i komponenten helt &#248;verst i treet ditt, vil samtlige komponenter i appen ha tilgang til tilstanden. Komponentene kan s&#229; abonnere p&#229; tilstandsendringer eller trigge en tilstandsendring selv.&#160;<\/p><p>&#160;<\/p><p>Redux er et av de mest popul&#230;re bibliotekene for tilstandsh&#229;ndtering. Redux benytter seg av &#233;n sannhetskilde for tilstand, &#34;store&#34;. I store finner man logikken for &#229; endre selve tilstanden, for tilstanden kan kun leses ellers i appen. Endring av tilstand skjer derfor gjennom en lenke med handlinger som best&#229;r av dispatching, actioner og reducere. N&#229;r tilstanden til slutt endres i store, vil komponenter som abonnerer p&#229; store rendres p&#229; nytt. Dette er generelt en egenskap med tilstander: Komponenter rendres p&#229; nytt n&#229;r tilstanden oppdaterer seg.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3909,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et relativt nytt bibliotek for tilstandsh&#229;ndtering i React. Biblioteket er atter en l&#248;sning p&#229; problemet med &#34;globale tilstander&#34; &#224; la Context og Redux som beskrevet i oppgave 1. Recoil benytter seg av en RecoilRoot, helst h&#248;yt oppe i komponenttreet, som rekursivt gir tilgang til en global&#160;tilstand til komponentene under seg. Tilstanden i seg selv er definert i s&#229;kalte &#34;atomer&#34;. Atomer er objekter med en unik n&#248;kkel for hver tilstand, samt verdien til selve tilstanden. Med Selectorer kan transformerte varianter av atomene&#160;v&#230;re egne tilstander. Tilgang til tilstandene og verdiene til tilstandene l&#248;ses helt og holdent med React Hooks.&#160;<\/p><p>&#160;<\/p><p>Den mest umiddelbare fordelen med Recoil er nok hvor enkelt det virker. I forhold til spesielt Redux har biblioteket i praksis ingen boilerplate, og funksjonaliteten virker veldig intuitiv&#160;for noen som allerede kan React godt. Der Redux krever actions, dispatchere, reducere og store benytter Recoil seg av Hooks-logikk for &#229; endre og bruke tilstander. For en vanlig lytter-klasse vil den globale tilstanden v&#230;re akkurat lik en lokal tilstand, med unntak av hvilken hook man bruker i deklarasjonen av variabelen. En ulempe med dette er dog at det er en mye st&#248;rre feilkilde. I Redux finnes det kun &#233;n sannhetskilde, alts&#229; er det i realiteten kun ett sted tilstand har logikk. Recoil har derimot en sannhetskilde i hvert atom. S&#229;nn sett er Redux b&#229;de mer innkapslet og forutsigbart enn Recoil.&#160;I likhet med b&#229;de Context og MobX oppdateres heller ikke tilstand i Recoil immutably.&#160;<\/p><p>&#160;<\/p><p>Context og Recoil stiller ganske likt n&#229;r det kommer til enkelhet (selv om Recoil har hakket mindre boilerplate). Det finnes dog andre omr&#229;der der Recoil har fordeler. &#201;n context har for eksempel ett objekt, mens Recoil har mange&#160;atomer som alle kan aksesseres uavhengig av hverandre [1].<\/p><p>&#160;<\/p><p>En stor forel&#248;pig ulempe med Recoil er hvor nytt det er. Siden det f&#248;rst kom ut i v&#229;r, er det et relativt tynt dokumentert bibliotek. Om Recoil blir popul&#230;rt er dette naturligvis et midlertidig problem, men for &#248;yeblikket stiller de andre bibliotekene betraktelig sterkere p&#229; denne fronten. Hvor nytt det er gj&#248;r ogs&#229; at all funksjonalitet ikke er helt stabil eller ferdig implementert.&#160;<\/p><p>&#160;<\/p><h2>Kilder:<\/h2><p>[1]: https://medium.com/swlh/intro-to-recoil-d689a77c5f04<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1325,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er grunnleggende forskjellige teknologier. GraphQL er et sp&#248;rrespr&#229;k (query language) som brukes for kommunikasjon mellom to parter. REST API bruker HTTP-protokollen til &#229; sende meldinger mellom partene. Dette medf&#248;rer naturligvis sine fordeler og ulemper.<\/p><p>&#160;<\/p><p>Den st&#248;rste ulempen til REST API-er er hvor vanskelige de kan v&#230;re &#229; lage&#160;<em>ordentlig<\/em>&#160;[1]. GraphQL er mye enklere &#229; bruke om du &#248;nsker &#229; benytte deg av alle fordelene teknologien kan tilby. Dette kan v&#230;re fordeler som at man ikke trenger &#229; laste inn mer data enn n&#248;dvendig, men kan hente inn akkurat den dataen man trenger med &#233;n sp&#248;rring. Et REST API vil kun tilby det den selv &#248;nsker &#229; tilby gjennom et gitt endepunkt.&#160;<\/p><p>&#160;<\/p><p>REST har derimot fordelen at den implisitt cacher sp&#248;rringene til klienten. Dette er en fordel med&#160;HTTP, som GraphQL jo ikke bruker, s&#229; caching m&#229; implementeres av utvikleren selv. REST er derimot ikke helt feilfritt n&#229;r det kommer til lagring, for det er tilstandsl&#248;st. Det vil si at en sp&#248;rring ikke huskes av en tjener, s&#229; neste sp&#248;rring vil ikke kunne bygges p&#229; forrige sp&#248;rring.&#160;<\/p><p>&#160;<\/p><p>GraphQL benytter seg kun av JSON i sp&#248;rringene sine.&#160;<\/p><p>&#160;<\/p><h2>Kilder:<\/h2><p>[1] https://goodapi.co/blog/rest-vs-graphql<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11534691,"ext_inspera_userAssessmentSetupId":7140019,"ext_inspera_userAssessmentId":4841202,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nedregård Hildegunn Elin Olaussen (10011)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330606,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2418,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>State:<\/p><p>Data i en komponent i&#160;react lagres i states.&#160;Ved funksjonelle komponenter bruker man hooks til &#229; holde styr p&#229; state.&#160;<\/p><p>&#160;<\/p><p>Props:<\/p><p>State kan kun aksesseres i den komponenten den er initialisert i. Dette vil si at om du vil hente ut eller legge til data i en state er dette i utgangspunktet&#160;ikke mulig. For &#229; sende data mellom ulike komponenter i react er man derfor n&#248;dt til &#229; sende via props som er&#160;argumenter som sendes til et&#160;komponent&#160;gjennom en&#160;HTML attributt. &#197; bruke props fungerer veldig greit om du f.eks. vil sende verdien i et input felt til &#233;n annen komponent som s&#229; viser teksten i en popup, men props har ogs&#229; mange begrensninger. Om man f.eks vil sende verdien i inut-feltet til mange komponenter kan dette fort bli litt kaos. I tillegg kan props ogs&#229; bare sendes nedover fra et foreldrekomponent (parent) til et barn (child). Det er ikke mulig &#229; sende data oppover fra child til parent. Om du da vil sende f.eks. verdien til inputfeltet langt den i komponent-hiarkiet m&#229; du da sende verdien gjennom mange ulike komponenter (ofte kalt prop drilling)&#160;Om dette m&#229; gj&#248;res med mange verdier kan det fort bli litt tungvindt.&#160;<\/p><p>&#160;<\/p><p>Context api:<\/p><p>Om du har data som brukes mange steder i applikasjonen din, kan det fort bli slitsomt &#229; sende rundt ved hjelp av props.&#160;Context API er bygget inn i react og en m&#229;te &#229; gj&#248;re data tilgjengelig fra hvor som helst i applikasjonen.Context har imidlertid noen ulemper, f.eks. er det ikke ment for hyppige oppdaternger av data.&#160;<\/p><p>&#160;<\/p><p>Biblioteker for stateh&#229;ndtering:<\/p><p>For mer avansert h&#229;ndtering av data kan man er det utvikklet ulike bibliotek.&#160;Disse bibliotekene samlee alle komponentenes stater&#160;og lagre dem i en sentral lokasjon. P&#229; denne m&#229;ten blir&#160;daten da mulig &#229; hente ut fra alle komponenter uten &#229; m&#229;tte lene seg p&#229; &#229; sende dataen gjennom&#160;parent/ child. To biblioteker for dette som vi har brukt i prosjektene er MobX og ReduX. Begge lagrer dataen i en sentral komponent som kalles store.&#160;<\/p><p>&#160;<\/p><p>MobX og Redux l&#248;ser begge samme problem, men p&#229; litt ulike m&#229;te. Det finnes ogs&#229; andre biblioteker (slik som recoil i neste oppgave)<\/p><p>&#160;<\/p><p>Noen forskjeller p&#229; mobX og Redux:<\/p><p>&#160;<\/p><p>MobX<\/p><p>- automatisk oppdaterer<\/p><p>- flere stores<\/p><p>- states kan skrives over<\/p><p>&#160;<\/p><p>Redux<\/p><p>- enkelt store&#160;<\/p><p>- oppdateres manuellt<\/p><p>- read only states<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2317,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for global stateh&#229;ndtering. I prosjektene har vi brukt biliotekene&#160;mobX og Redux for&#160;&#229; h&#229;ndtere dette.<\/p><p>&#160;<\/p><p>Fordeler/ ulemper med recoil vs MobX&#160;og Redux:<\/p><p>&#160;<\/p><p>fungerer veldig bra med hooks. Funksjonelle komponenter og bruk av hooks er veldig i vinden for tiden ( i motsettning til klassekomponenter som var mer popul&#230;rt f&#248;r) og mulighet for &#229; enkelt implementere stateh&#229;ndtering med hooks er derfor en fordel. I stedet for &#229; bruke useState slik som ved&#160;hooks, kan man ved recoil bruke UseRecoilState.<\/p><p>&#160;<\/p><p>Ved mobX kan man kun hente data (consume)&#160;og oppdatere data p&#229; det &#248;verste laget, mens man ved recoil kan gj&#248;re det fra alle lag.&#160;<\/p><p>&#160;<\/p><p>Recoil bruker atom&#160;som kan sammenlignes med en vanlig react state for &#229; lagre data og&#160;selectors tar dataen i et atom,&#160;gj&#248;r en opperasjon p&#229; dette og returenerer en ny state som man kan bruke. En selector kan sammenlignes litt med Redux Thunk som utf&#248;rer opperasjone p&#229; dataen f&#248;r den oppdaterer staten.&#160;<\/p><p>&#160;<\/p><p>En selector kan ogs&#229; gj&#248;re staten synkron eller ansynkron. At den er synkron betyr at komponenter lastes p&#229; nytt (re-render) n&#229;r en selector oppdaterer seg.&#160;Synkrone stater er ogs&#229; mulig i MobX, men ikke i Redux.&#160;<\/p><p>&#160;<\/p><p>Redux har tradisjonelt f&#229;tt en del kritikk for at det krever at man m&#229; sette opp en del ulike ting f&#248;r man kan begynne &#229; bruke det, noe som gj&#248;r dette litt tungvindt &#229; bruke. Det &#229; sette opp en enkel stor kan f.eks. kreve en del arbeid.&#160;<\/p><p>&#160;<\/p><p>MobX og Redux har eksistert i mange &#229;r. Dette f&#248;rer til at det finnes mye god dokumentasjon og mange gode tutorials p&#229; hvordan disse skal brukes. Recoil er et ganske nytt bibliotek s&#229; om man her st&#248;ter p&#229; problemer kan det v&#230;re vanskeligere &#229; finne en god kilde p&#229; nett som kan v&#230;re til hjelp. Dette er noe man burde tenke p&#229; spesielt om man er &#34;nybegyner&#34; p&#229; react og global stateh&#229;ndtering.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2433,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>REST API:<\/p><p>Rest er en overordnet arkitektur&#160;for web&#160;baserte klient/tjener.&#160;Rest bruker HTTP metoder for &#229; foreta opperasjoner p&#229; URI. Dette er&#160;create,read, update og delete opperasjoner ( ofte referert til som CRUD). Rest API legger til rette for browser caching og&#160;<\/p><p>&#160;<\/p><p>GraphQL:<\/p><p>GraphQL er f&#248;rst og fremst et sp&#248;rrespr&#229;k for API&#160;og runtime for &#229; oppfylle queries med eksisterende data.&#160;<\/p><p>&#160;<\/p><p>Uthenting av data:<\/p><p>Ved rest API henter du data gjennom ulike endepunkt. Endepunkt er spesifisert kode som sender henter ut spesifikk data.&#160;For &#229; hente alle&#160;brukerene m&#229; man da hente ut fra et&#160;endepunktene /users. Dette kan f&#248;re til overfetching og underfetching. Overfetching er n&#229;r clienten henter ut mer informasjon enn det som det er behov for, f.eks. at /users gir veldig mye informasjon om brukeren n&#229;r man egentlig bare trengte nav og adresse.&#160;Underfetching er motsatt problem n&#229;r et spesifikkt endepunkt ikke gir nok informasjon. Ved GraphQL kan man enkelt hente ut akkuratt den dataen man trenger ved &#229; sende en sp&#248;rring til graphQL serveren som spesifiserer n&#248;yaktig hvilke data som skal hentes ut. Man endrer alts&#229; bare p&#229; ulike n&#248;kkelord i sp&#248;rringen for &#229; f&#229; den dataen man vil ha.&#160;Serveren responderer da men et JSON objekt men denne dataen.&#160;<\/p><p>&#160;<\/p><p>eks p&#229; forskjell om man vil hente ut en bruker sitt telefonnnummer og navn&#160;<\/p><p>&#160;<\/p><p>REST:&#160;<\/p><p>trenger endepunktene:<\/p><p>/users/&#60;id&#62;/name<\/p><p>/users/&#60;id&#62;/phonnr<\/p><p>&#160;<\/p><p>GraphQL:<\/p><p>query {<\/p><p>User(id: &#34;1234&#34;) {<\/p><p>&#160; &#160;name<\/p><p>&#160; &#160;phonenr<\/p><p>&#160; &#160;}<\/p><p>}<\/p><p>&#160;<\/p><p>GraphQl tillater klienten til &#229; sp&#248;rre etter flere ressurser i en request. Dette sparer mange &#34;turer&#34; og tillater klienten &#229; filtrere ned til den dataen&#160;de trenger. Ved REST m&#229; man hente flere ganger (f.eks. f&#248;rst bruker id for s&#229; &#229; hente navn)<\/p><p>&#160;<\/p><p>Rest gj&#248;r cahcing automatisk, men det gj&#248;r ikke&#160;GraphQL. Caching er viktig fordi det akan redusere mengden trafikk til en server ved &#229; samle data som ofte brukes og gj&#248;re dette lett tilgjengelig.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534706,"ext_inspera_userAssessmentSetupId":7140004,"ext_inspera_userAssessmentId":4841363,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hasund Anne Marie Skaar (10116)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45084722,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2080,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyten i React-applikasjonar baserar seg i hovedsak p&#229; at foreldrekomponentar (parents)&#160;sender data til sine barn (children) ved hjelp av props. Til d&#248;mes, kan det&#160;for barnet sj&#229; slik ut,<\/p><p>&#160;<\/p><p>function Child (props) {<\/p><p>&#160; &#160; return &#60;p&#62;My name is {props.name}&#60;/p&#62;<\/p><p>}<\/p><p>&#160;<\/p><p>der props.name er definert i forelderen,<\/p><p>&#160;<\/p><p>function Parent () {<\/p><p>&#160; &#160;&#160;return &#60;Child name={Kari} /&#62;<\/p><p>}<\/p><p>&#160;<\/p><p>Dersom barnet er ein classkomponent kan det i tillegg til props, ha ein state som kan holde p&#229; data. Der initialiserast data som skal vere likt for alle objekta av denne typen, og dei kan seinare endrast inne i komponenten ved hjelp av setState()-funksjonen.<\/p><p>&#160;<\/p><p>class Child extends React.Component {<\/p><p>&#160; &#160;&#160;constructor(props) {<\/p><p>&#160; &#160; super(props);<\/p><p>&#160; &#160; this.state = {<\/p><p>&#160; &#160; &#160; &#160; age = 0,<\/p><p>&#160; &#160; &#160; &#160; };<\/p><p>&#160; &#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>For at eit barn skal kunne oppdatere state i sin forelder, kan ein bruke funksjonar i props. D&#229; sender forelderen med ein funksjon i props, som barnet kan aktivere, til d&#248;mes ved eit knappetrykk. Funksjonen, som ligg i forelderen, vil d&#229; kallast p&#229;, og denne kan oppdatere til d&#248;mes state.<\/p><p>&#160;<\/p><p>React kom i fjor med ei ny oppdatering som inneheld Hooks. Dette gir ein mellom anna moglegheit til &#229; bruke state ogs&#229; utanfor classkomponentar ved hjelp av hooken useState. Tilsvarande kode vil d&#229; vere<\/p><p>&#160;<\/p><p>function Child (props) {<\/p><p>&#160; &#160;&#160;const [age, setAge] = useState(0);<\/p><p>}<\/p><p>&#160;<\/p><p>og ein kan her endre alderen ved &#229; bruke setAge().<\/p><p>&#160;<\/p><p>Dersom ein vil utveksle data mellom andre komponentar enn parent/child, m&#229; ein bruke andre teknikkar. D&#229; kan ein til d&#248;mes bruke Redux/Mobx store. Denne funksjonaliteten gjer at ein kan lagre og endre data i storen og denne dataen kan hentast fr&#229; alle komponentar i applikasjonen.<\/p><p>&#160;<\/p><p>Ein annan funksjonalitet for tilgang p&#229; data mellom filer er Context, der ein wrappar ein Provider rundt komponentane som skal ha tilgang til dataen. Dette brukast blant anna ofte til light/dark options i applikasjonar.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3153,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er eit bibliotek for dataflyt i Reactapplikasjonar. Det baserar seg p&#229; atoms som kan delast med alle komponentar i applikasjonen som abonnerar p&#229; dei. Atoms er state som kan endrast ved hjelp av selectors-funksjonar, b&#229;de synkront og asynkront.<\/p><p>&#160;<\/p><p>Som diskutert i forrige oppg&#229;ve, er det mange ulike m&#229;tar &#229; handtere data i Reactapplikasjonar. Eg vel &#229; samanlikne Recoil med Hooks, Redux og Context. Ein kan sj&#248;lvsagt ogs&#229; samanlikne med den innebygde statehandteringa i React, der ein m&#229; sende state som props mellom barn og foreldre, som nemd i forrige oppg&#229;ve.<\/p><p>&#160;<\/p><p>Linja<\/p><p>&#160; &#160;&#160;const [fontSize, setFontSize] = useRecoilState(fontSizeState);<\/p><p>liknar veldig p&#229; bruken av useState i Hooks. Forskjellen er at der Hooks initialiserar staten direkte, brukar Recoil atoms for &#229; b&#229;de initialisere og holde p&#229; staten, her i fontSizeState. For eit s&#229; enkelt eksempel kan ein argumentere for at bruken av Recoil er overfl&#248;dig, ettersom fontSize berre skal halde p&#229; eit tal. Fordelen er at atoms kontrollerar bedre og det er lettare &#229; debugge p&#229; key (som er eit krav i atoms).<\/p><p>&#160;<\/p><p>Selectors i Recoil minnar om actions i Redux. Ein stor ulempe med Redux er at det er vanskelig &#229; sette seg inn i, d&#229;&#160;det liknar lite p&#229; React ellers. Det ser ut som at Recoil har klart &#229; redusere&#160;dette gapet vesentleg. Til d&#248;mes treng ein ikkje i Recoil &#229; initialisere ein store f&#248;r ein startar, og ein slepp &#229; lage reducers, d&#229; dette skjer i atoms for Recoil. Det er ogs&#229; i Redux veldig mange forbindelsar mellom dei ulike delane, medan det i Recoil berre er atoms og selectors, som gjer det meir oversiktleg. Ein ser ogs&#229; at i&#160;komponentane der storen skal brukast, er det mykje enklare &#229; sette opp med Recoil enn Redux. Med Redux m&#229; ein bruke mange hjelpefunksjonar, medan det for Recoil berre er &#229; importere atoms og selectors og bruke dei.<\/p><p>&#160;<\/p><p>For &#229; samanlikne med Context API, s&#229; kan det seiast at Context berre kan lagre &#232;in verdi per Provider. Dersom ein skal store mykje data, vil det d&#229; vere veldig upraktisk &#229; bruke, samanlikna med Recoil.<\/p><p>&#160;<\/p><p>Ein annan fordel med Recoil er at ein har ein lesefunksjon for atoms, der ein ikkje kan endre state, nemlig useRecoilValue. Det gjer at ein kan begrense skrivetilgangen p&#229; storen, som kan vere bra om fleire komponentar brukar same atoms.<\/p><p>&#160;<\/p><p>Ei ulempe med Recoil er at det er eit ganske nytt bibliotek. Dette inneber at det kan vere ein del bugs som ikkje er oppdaga, samt funksjonalitet som ikkje er p&#229; plass. Det vil heller ikkje vere like enkelt &#229;&#160;utveksle kunnskap med&#160;andre utviklarar, verken i eit arbeidsmilj&#248; eller p&#229; til d&#248;mes stackoverflow, d&#229; det er veldig f&#229; som er blitt gode p&#229; bruk av biblioteket.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>- https://recoiljs.org/docs<\/p><p>- https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1765,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST og GraphQL&#160;er brukt til&#160;klient-server-kommunikasjon i applikasjonar.<\/p><p>&#160;<\/p><p>REST baserar seg p&#229; HTTP- og URI-requests for &#229; skrive til og lese fr&#229; endepunkt. Ein m&#229; d&#229; spesifisere kva for eit endepunkt ein skal hente informasjon fr&#229;, og for &#229; hente fr&#229; fleire endepunkt m&#229; requesten gjentakast.<\/p><p>&#160;<\/p><p>For GraphQL er requestsa erstatta med ei sp&#248;rring (graf), der ein kan definere b&#229;de kva ein skal s&#248;ke p&#229; og kva for data som skal returnerast.<\/p><p>&#160;<\/p><p>Den fyrste forskjellen ein ser er sj&#248;lve m&#229;ten &#229; formulere kallet p&#229; data, der REST kallar direkte p&#229; eit endepunkt, medan GraphQL kallar med ein graf der alt er kopla saman. Fordelar med REST her er at kallet er veldig oversiktlig og det er lett &#229; sj&#229; kvar ein hentar/skriver data, medan ulempene er at ein m&#229; gjenta kallet for kvar einaste operasjon. For GraphQL er fordelane at ein kan f&#229; fleire sett med data fr&#229; samme kall, slik at ein slepp &#229; gjenta. Ulempa kan vere at ein m&#229; l&#230;re &#229; spesifisere kalla riktig slik at ein f&#229;r berre den dataen ein ynskjer.<\/p><p>&#160;<\/p><p>Overfetching er eit fenomen ein ser ved REST, der kallet hentar mykje meir data enn det ein treng. Dette er fordi REST alltid vil returnere eit heilt datasett, sj&#248;lv om ein ikkje treng all denne informasjonen. For GraphQL vil ein her kunne spesifisere kva for data ein ynskjer returnert, og unng&#229;r dermed dette problemet.<\/p><p>&#160;<\/p><p>For GraphQL fins det typesystem, litt likt som det i TypeScript,&#160;som kontrollerar og validerar kalla og dataen, for &#229; unng&#229; error.<\/p><p>&#160;<\/p><p>Ein fordel med REST og GraphQL er at dette er den mest utbredte. Det gjer at fleire nettlesarar har tilrettelagt for REST. Dette gjer at cachinga (data lagrast i nettlesaren for raskare henting) er mykje bedre for bruk av REST enn GraphQL.<\/p><p>&#160;<\/p><p>Ein annan fordel med REST er at denne er mykje bedre for henting av data som ikkje er tekst, som til d&#248;mes bilete. GraphQL st&#248;ttar kun henting av JSON-filer.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>- LF eksamen haust19<\/p><p>-&#160;https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534976,"ext_inspera_userAssessmentSetupId":7139957,"ext_inspera_userAssessmentId":4841297,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Kanstad Sondre Molnes (10109)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34829330,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":749,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React sender data mellom komponenter ved bruk av props. Props er dataverdier som er komponentenes input. Disse kan ogs&#229; sendes tilbake til foreldrekomponenter ved callback funksjoner. Props er immutable og kan derfor ikke endres, derimot kan man bruke state og endre state ved setState() metoden. N&#229;r staten blir endret vil komponenten/komponentene som har en kobling mot staten rendres p&#229; nytt. N&#229;r man har mange komponenter og kompleks trestruktur hvor data skal deles p&#229; tvers av treet&#160;kan state managment v&#230;re vanskelig og f&#248;re til mange callback funksjoner.&#160;Dette kan l&#248;ses ved bruk av Context, Redux eller MobX. Det disse gj&#248;r er &#229; lage en global state som kan sendes til alle komponenetene som er inni en provider. Det gj&#248;r det lettere &#229; sette en state som skal brukes i flere komponenter og ofte p&#229; forskjellige steder i komponenttreet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3214,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managment bibliotek som skal forenkle reacts dataflow. Det brukes til &#229; sende data til komponenter ved bruk av Atoms. Atoms er en state som kan endres p&#229; lik m&#229;te som setState() ved funksjonen useRecoilState(). Deretter kan de brukes som en global state og sendes til andre komponenter i komponenttreet.<\/p><p>&#160;<\/p><p>Dette minner om de andre globale state managment bibliotekene. Redux og Recoil har en del likt som for eksempel der Redux har actions som kj&#248;res ved dispatch funksjonen, kj&#248;rer&#160;Recoil actions ved bruk av noe som heter selectors. Selectorene kan ta inn atoms eller andre selectors og oppdaterer disse selektorene. N&#229;r de har blitt oppdatert vil de tilsvarende komponentene bli re-rendret. Dette kan sammenlignes med reducers fra Redux.&#160;<\/p><p>&#160;<\/p><p>Context er en forenklet state managment&#160;som tillatter en global state og data blir sendt nedover treet. Derimot er Context laget for globale states som ikke endrer seg for ofte, som tema eller spr&#229;kvalg. Derfor er Context syntaksen enkel, men den kan bare ha en state som gj&#248;r den mindre praktisk n&#229;r man skal ha flere states.&#160;<\/p><p>&#160;<\/p><p>MobX er en mer brukervennlig syntaks&#160;og forenklet state managment i forhold til Redux, dette er et bedre valg for mindre applikasjoner med mindre komplisert data flow.&#160;<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper:&#160;<\/strong><\/p><p>Fokuset til Recoil var &#229; lage en state managment med enkel syntaks og baserte seg p&#229; Reacts logikk samtidig som det hadde mer funksjonalitet og performance i forhold til Context.&#160;<\/p><p>&#160;<\/p><p>En av fordelene til Recoil er at selectors kan endre state b&#229;de synkront og asynkront med en getter og en setter funksjon. Deretter m&#229; alle atoms ha en unik key, fordelen med dette er at man f&#229;r kontroll over de forskjellige atomene og det skaper persistens. I Redux m&#229; man lage en &#34;<em>store<\/em>&#34; dette slipper man i Recoil, men komponentene m&#229; fortsatt wrappes i en provider.<\/p><p>&#160;<\/p><p>En av ulempene m&#229; v&#230;re at siden Recoil bruker useRecoilState() og setRecoilState() kan dette fortsatt bli relativt komplisert &#229; sende til komponenter veldig dypt nede i komponenttreet da det vil v&#230;re lettere &#229; bruke f.eks. Redux hvor man separerer state helt fra UI&#39;et s&#229; det er mye enklere &#229; sende data akkurat hvor du vil. Kompromisset er da at Redux er mer kode enn recoil, men Redux viser seg bedre n&#229;r komponentreet blir komplekst og man har fokus p&#229; performance. Recoil har vist seg &#229; v&#230;re brukervennlig og krever mindre kode enn Redux, men har igjen mer funksjonalitet enn Context.<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>&#160;<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2141,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en kobling mellom webklienter og webservere og bruker URI for &#229; hente ut ressurser. REST er ogs&#229; stateless som betyr at foresp&#248;rselen er isolert og server trenger ingen ekstra informasjon annet enn det foresp&#248;rselen gir. Rest&#160;bruker HTTP foresp&#248;rslene GET, PUT, POST og DELETE for &#229; hente, endre, lage og slette data. GraphQL er et sp&#248;rrespr&#229;k for API&#160;og serverside runtime som kj&#248;rer sp&#248;rringer. Graphql ble&#160;utviklet av Facebook og sender forsep&#248;rsler med Queries og Mutations for &#229; hente og endre/legge til/slette&#160;data. Dataen som blir hentet er som oftest JSON, men i f&#248;lge docsen s&#229; krever de ikke en spesifik &#34;serialization format&#34;.&#160;<\/p><p>&#160;<\/p><p>En av hovedfordelene til GraphQL er at man kan sende inn argumenter for hvert objekt i sp&#248;rringen i motsettning til REST hvor man bare kan sende inn et sett med argumenter i en URL request. Det vil si at hvis REST skal hente noe fra forskjellige endepunkter m&#229; man ha flere sp&#248;rringer og henter kanskje for mye data enn man trenger. Mens GraphQL enkelt kan neste sp&#248;rringer og hente ut de feltene med data man vil ha. Dette betyr at man for det f&#248;rste kan gj&#248;re f&#230;rre sp&#248;rringer, men i tillegg bare hente ut n&#248;dvendig data s&#229; man slipper overfetching.<\/p><p>&#160;<\/p><p>Et av hovedproblemene til GraphQL er at de ikke har innebygd caching, dette m&#229; l&#248;ses ved manuell implementasjon eller ved &#229; bruke en annen tjeneste sitt caching system. Mens i REST er det innebygd caching som st&#248;ttes av alle nettlesere. En mindre fordel ved GraphQL er at de har typedeklarasjon som kan gj&#248;re validering av koden enklere og kan raskt gi tilbakemelding til utvikleren n&#229;r sp&#248;rringen ikke er valid.<\/p><p>&#160;<\/p><p>http://spec.graphql.org/draft/#sec-Serialization-Format<\/p><p>https://graphql.org/learn/<\/p><p>https://restfulapi.net/<\/p><p>https://restfulapi.net/statelessness/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535003,"ext_inspera_userAssessmentSetupId":7140058,"ext_inspera_userAssessmentId":4841138,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Morstøl Hallvard Molin (10209)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330868,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2488,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har to typer komponenter klasse komponenter og funksjonelle komponenter. De behandler states litt forskjellig. Funksjonelle komponenter bruker usestate hooket det ser slik ut&#160;<\/p><p>&#160;<\/p><p>export&#160;default&#160;function&#160;DummyFunc(props:&#160;{ Dummy: string })&#160;{<\/p><p>&#160;const&#160;[state,&#160;setState]&#160;= useState(&#34;Hei&#34;);<\/p><p>return ( &#60;p&#62; {state} &#60;p&#62; )<\/p><p>}<\/p><p>her er state tilstanden, useState er en funksjon der man kan sette ny verdi for state og &#34;hei&#34; er&#160;startverdien. Start verdien kan ogs&#229; v&#230;re noe annet.&#160;<\/p><p>&#160;<\/p><p>En klasse komponent med state kan se slik ut<\/p><p>&#160;<\/p><p>class DummyClass extends component {<\/p><p>constructor (props){<\/p><p>super(props);<\/p><p>this.state = &#34;Hello&#34;;<br />}<\/p><p>render () {<\/p><p>return ( &#60;p&#62; {this.state} &#60;p&#62;)<\/p><p>}<\/p><p>&#160;<\/p><p>Her ser vi at man m&#229; bruke this for &#229; refere til staten til klassen og her kan state endres med this.setState().&#160;<\/p><p>State kan endres internt i komponenten i motsetning til props som er immutable. Props (properties) er immutable (ikke mulig &#229; endres) fordi en komponent skal kun kunne endre sine egne tilstander. Props sendes fra foreldre komponenten ned til barne komponenten. Hvis man &#248;nsker at barne komponenten skal kunne endre&#160;foreldre komponentens sine tilstander m&#229; foreldre komponenten sende en funksjon (f.eks setState fra DummyFunc) ned til barne komponenten. En slik funksjon kalles da en callback funksjon siden den tillater et tilbakekall til foreldre komponenten for &#229; endre tilstand.&#160;<\/p><p>&#160;<\/p><p>Et problem er at det fort kan bli rotete hvis man m&#229; sende mange props og callback funksjoner gjennom komponent hierarkiet. Hvis man m&#229; sende en prop gjennom en komponent som ikke bruker den kalles dette propdrilling. Propdrilling er som regel greit gjennom et par komponenter, men hvis man m&#229; sende den gjennom 5 eller mer komponenter blir det fort veldig vanskelig &#229; f&#248;lge dataflyten i applikasjonen.&#160;<br />For &#229; hindre at det blir for mye rot med sending av props og callback funksjoner kan man bruke global state managment. Det finnes tre l&#248;sninger for global state managment som vi har g&#229;tt gjennom i faget. Det er Context api som er React sin egen l&#248;sning, det er Redux og Mobx.<br /><br />Context api brukes ved at du lager en context fil slik som dette:<br />&#160;<\/p><p>const&#160;StorageKeysContext&#160;=&#160;React.createContext([&#34;favoritArt&#34;,&#160;&#34;speedOfRotation&#34;]);<\/p><p>&#160;<\/p><p>export&#160;default&#160;StorageKeysContext;<br /><br />og s&#229; wrapper du&#160;komponentene der de skal f&#229; context staten fra i en provider<br /><br />&#60;StorageKeysContext.Provider&#62;&#160; &#60;component/&#62; &#60;/StorageKeysContext.Provider&#62;<\/p><p>&#160;<\/p><p>og der de skal bruke staten i&#160;en consumer&#160;<br /><br />&#60;StorageKeysContext.Consumer&#62;&#160;&#60;component/&#62;&#160;&#60;/StorageKeysContext.Consumer&#62;<\/p><p>&#160;<\/p><p>Redux og mobx er to tredjeparts l&#248;sninger som ogs&#229; st&#248;tter global state managment. De er ikke avhengig av rammeverket s&#229; de kan brukes i forskjellige applikasjoner ikke bare React applikasjoner. De baserer seg p&#229; at de har store (Redux har en, MobX kan ha flere) med states og bruker litt forskjellige l&#248;sninger for hvordan disse statesene sendes og endres. Redux bruker reducers og slicers samt useSelector for &#229; h&#229;ndtere states, mens MobX bruker litt andre l&#248;sninger som makeAutoObservable, observer,&#160; .&#160;En siste l&#248;sning som ofte kan v&#230;re god er &#229; lage komponenter som bruker component composition. Dette vil si at man lager komponenter der man definerer hvordan children skal v&#230;re p&#229; den m&#229;ten kan du legge alle komponentene inn i den komponenten som egentlig skal sende states.<br /><br />function App() {<br />const content = &#34;Who needs me?&#34;;<br />return (<br />&#60;div className=&#34;App&#34;&#62;<br />&#60;FirstComponent&#62;<br />&#60;SecondComponent&#62;<br />&#60;ThirdComponent&#62;<br />&#60;ComponentNeedingProps content={content} /&#62;<br />&#60;ThirdComponent&#62;<br />&#60;/SecondComponent&#62;<br />&#60;/FirstComponent&#62;<br />&#60;/div&#62;<br />);<br /><br />Her er app den som sender verdi(content). First, Second, og Third trenger ikke content, men componentNeedingProps trenger content. Her slipper man &#229; bruke Context Api, Redux eller MobX uten at det krever propdrilling.<\/p><p>&#160;<\/p><p>Component Composition:&#160;https://medium.com/javascript-in-plain-english/how-to-avoid-prop-drilling-in-react-using-component-composition-c42adfcdde1b&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2458,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managment library for React. Det er en del av FacebookExperimental og blir en annen l&#248;sning for state managment fremfor &#229; bruke Context API, Redux eller MobX. Recoil bruker Atoms for &#229; lagre tilstander. I Recoil bruker man&#160;useRecoilState(nameOfAtom) for &#229; hente verdien til et Atom og lage en setter for den&#160;atomen.<br /><br />const [tempF, setTempF] = useRecoilState(tempFahrenheit);<\/p><p>L&#248;sninger er veldig lik useState hooket som allerde finnes i React.<br />Hvis man bare &#248;nsker verdi kan man ogs&#229; bruke useRecoilValue.&#160;<br /><br />const names = useRecoilValue(namesState);<br /><br /><br />Selector() brukes for &#229; hente utregnet verdi til en atom. Man m&#229; fortsatt wrappe rot-komponenten i&#160;&#60;RecoilRoot&#62; &#60;Component/&#62;&#60;/RecoilRoot&#62; slik som man m&#229; wrappe i consumer og provider i Redux.&#160;<br /><br />Fordeler med &#229; bruker Recoil er:<\/p><p>- Det er laget av Facebook som er stort og derfor skal det nok litt til at prosjektet blir droppet uten videre.<\/p><p>- Facebook lager ogs&#229; React s&#229; det kan hende Recoil l&#248;sningen blir implementert i React. Og det kan hende at det blir en veldig effektiv og optimalisert l&#248;sning for state managment i React.<\/p><p>- Recoil ser ut som det trenger mindre kode (boilerplate) for &#229; h&#229;ndtere state managment fremfor Redux.<\/p><p>- Siden det er simpelt er det enkelt &#229; komme i gang med som igjen gj&#248;r det lett &#229; bruke og at flere pr&#248;ver &#229; bruke det.<\/p><p>- Det har nylig blitt oppdatert s&#229; det er ikke foreldtet (deprecated).<\/p><p>- Det bruker MIT license s&#229; det er gratis &#229; bruke for&#160;kommersiell bruk.<\/p><p>- Det har 10.8 tusen stjerner p&#229; Github s&#229; det er bra rangert.<\/p><p>- Det oppf&#248;rer seg ganske likt som React og bruker mye av den samme terminologien.<\/p><p>- Siden det er Facebook som lager det kan det hende at det blir inkludert i nyere versjonener av React, MEN det blir spekulasjoner.&#160;<\/p><p>- Enkelt &#229; sette opp &#34;npm install recoil --save&#34;<\/p><p>- Det er st&#248;tte for testing<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>- Det er mange issues (108 n&#229;r jeg skriver dette)<\/p><p>- Dokumentasjonen er ikke like utfyllende som for Redux og MobX. Dette kan man ogs&#229; se da en del av issuesene har lable som er &#34;question&#34; eller &#34;documentation&#34;.<\/p><p>- Det er ekseprimentelt derfor kan man ikke belage seg p&#229; at det er stabilt<\/p><p>- Det er React spesifikt s&#229; vil nok ikke st&#248;tte andre rammeverk<\/p><p>- De gj&#248;r det veldig tydelig at APIet er under endring s&#229; det vil v&#230;re muligheter for breaking changes.<\/p><p>&#160;<\/p><p>N&#229;r det skal sies er Recoil s&#229; nytt at jeg neppe ville inkludert det i ny applikasjoner hvis det er et krav om at den applikasjonen skal v&#230;re stabil, men det er en l&#248;sning fra Facebook som godt kan hende at blir mer vanlig og bruke fremover. Spesielt hvis den blir inkludert i standard React.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2164,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest API og Graphql er to l&#248;sninger for sending og mottak av data over nett. Rest API er et konspet, mens GraphQl er et sp&#248;rre spr&#229;k (Querry language). GraphQl opperer over et endepunkt og fokuset har v&#230;rt p&#229; &#229; optimalisere og gj&#248;re det mer effektivt, mens Rest API kan operere over flere endepunkt og kan ogs&#229; brukes for &#229; lage nye APIer.<\/p><p>&#160;<\/p><p>REST (Representational State Transfer) bruker GET, POST, PUT og DELETE for &#229; skille mellom kall. Get brukes for &#229; hente data. Post brukers for &#229; oppdatere data eller for &#229; gj&#248;re spesifikke sp&#248;rringer. Put brukes for &#229; oppdatere data eller lage ny data. En av forskjellen mellom Post og Put er at hvis man kaller Post vil man lage ny data hver gang, men hvis man kaller Put s&#229; vil det man &#248;nsker &#229; lage kun bli laget en gang (Post tillater kopier).<br /><br />GraphQl opperer med kun et endepunkt og dataen anses som en graf der all dataen er koblet sammen. Dette gj&#248;r at man kan gj&#248;re sp&#248;rringer som er mer spesifikke og p&#229; den m&#229;ten hente kun den dataen man trenger.<\/p><p>&#160;<\/p><p>query HeroNameAndFriends($episode: Episode = JEDI) {<\/p><p>&#160; hero(episode: $episode) {<\/p><p>&#160; &#160; &#160;name<\/p><p>&#160; &#160; &#160; friends {<\/p><p>&#160; &#160; &#160; &#160; name<\/p><p>&#160; &#160; &#160; }<\/p><p>&#160; &#160;}<\/p><p>&#160;}<\/p><p>&#160;<\/p><p>I eksempelet over som er hentet fra (https://graphql.org/learn/queries/) s&#229; ser vi at graphQL tillater &#229; sp&#248;rre om kun &#34;name&#34; for friends. Dette gj&#248;r at hvis friends inneholder mer data enn det man trenger s&#229; vil ikke dette bli sendt med. Her ser man ogs&#229; at det vil gj&#248;re en sp&#248;rring for alle venene til personen uten at man trenger &#229; gj&#248;re denne sp&#248;rringen for hver enkelt venn.&#160;<\/p><p>&#160;<\/p><p>Siden Rest har flere endepunkter vil man kunne f&#229; problemer med overfetching og/eller underfetching. Overfetching er der hvor man henter for mye data. Dette kan for eksempel v&#230;re at man kun trenger navn men APIet kun tilbyr &#229; hente en bruker da m&#229; man hente hele objektet som kan se slik ut og da blir &#34;age&#34; og &#34;isMale&#34; overfetched.<br /><br />{<\/p><p>name: &#34;Ola Nordman&#34;,<\/p><p>age: 12,<\/p><p>isMale: true,<\/p><p>}<\/p><p>&#160;<\/p><p>Et annet problem med REST API er underfetching. Dette gjelder hvis man ikke f&#229;r nok data fra endepunktet man kaller. Hvis man trenger age fra bruker, men ogs&#229; trenger sporten personen driver med m&#229; man kalle et nytt ende punkt. Dette vil ogs&#229; kunne skape n+1 problemet. Der man kanskje m&#229; hente alle brukere (1 sp&#248;rring)&#160;fra et endepunkt og s&#229; m&#229; gj&#248;rre sp&#248;rringer for alle n brukerne med fra den&#160;f&#248;rste sp&#248;rringen.&#160;<\/p><p>&#160;<\/p><p>En annen forskjell mellom GraphQL og Rest er at siden GraphQL kun tilbyr&#160;et endepunkt blir det vanskeligere &#229; tilby delvis &#229;pne APIer. Instagram tilbyr foreksempel &#229;pne APIer for &#229; hente noe data, men hvis de hadde brukt graphQl som tilbyr alle dataen kan det hende at de ikke ville tillat &#229; gj&#248;re dette tilgjengelig p&#229; samme m&#229;te.<\/p><p>&#160;<\/p><p>REST brukes i dag mer en GraphQL s&#229; det er flere som er vant med &#229; bruke det og det finnes nok mer dokumentasjon om REST enn for GraphQL. N&#229;r man skal velge mellom GraphQL eller REST s&#229; man man vurdere om man skal sikte seg inn mot ytelse hvor GraphQL er best eller om man skal sikte seg inn p&#229; tilpasning hvor REST fortsatt tillater flere forskjellige l&#248;sninger.&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535012,"ext_inspera_userAssessmentSetupId":7140123,"ext_inspera_userAssessmentId":4841179,"dateLastModified":"2020-12-01T10:01:25Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:25Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ommundsen Erlend Marius (10153)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330853,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2337,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tistandsflyten i React har mange sider ved seg. Dersom man kun ser p&#229; det som er innebygd, m&#229; man f&#248;rst se p&#229; Klassekomponenter og funksjonelle komponenter. I klassekomponenter, som ikke er like popul&#230;re n&#229; som de brukte &#229; v&#230;re f&#248;r hooks ble lagt til, lager man et state objekt. Noe &#225; la: &#34;state = { cart: [], total: 0 }&#34;. Deretter kan man benytte seg av &#34;this.state&#34; for &#229; vise den. Som man kan se basert p&#229; disse korte kodesnuttene, minner&#160;klassekomponentene om objektorientert programmering.<\/p><p>I funksjonelle klasser har det nylig blitt introdusert hooks. Hooks gj&#248;r at man kan lagre state ved bruk av funksjonen useState(). Et eksempel p&#229; dette er: &#34;const&#160;[movies,&#160;setMovies]&#160;=&#160;useState&#60;Array&#60;Movie&#62;&#62;([]);&#34;. &#34;setMovies&#34; kan en kalle i koden for &#229; oppdatere state til movies. Kodelinjer slik som eksemplet viser, kan en ha flere av. Etter at man f.eks. har hentet data fra en server, kan man benytte seg av setMovies til &#229; endre den n&#229;v&#230;rende lista av filmer, til en annen.&#160;<\/p><p>Et annet sp&#248;rsm&#229;l er n&#229;r state skal oppdateres, og hvordan det kan gj&#248;res. I React har man forskjellige funksjoner som kan hjelpe med dette. I Komponentlivssyklusen til React-komponenter har man eksempelvis constructor(), getDerivedStateFromProps(), render(), componentDidMount() og componentDidUpdate(). Alle disse har passende bruksomr&#229;der. Constructor blir kalt f&#248;rst og her er det naturlig &#229; sette opp den opprinnelige start-staten til komponenten, i tillegg til &#229; sende inn props. I neste metode getDerivedStateFromProps() vil man sette staten basert p&#229; de props komponenten har f&#229;tt. I render vil komponenten bli outputted p&#229; den faktiske nettsiden. Den er n&#229; i DOM. ComponentDidMount() blir kalt rett etter dette er gjennomf&#248;rt. Deretter har man componentDidUpdate() som kalles n&#229;r komponenten f&#229;r en forandring eller oppdatering i state eller props. Noen av disse metodene, for eksempel constructor(),&#160;gjelder i st&#248;rst&#160;grad for klassekomponter. Funksjonelle komponenter har igjen hooks som gj&#248;r at componentDidUpdate ikke lenger er like relevant.&#160;<\/p><p>I tillegg til livssyklusmetoder, har man ogs&#229; selvf&#248;lgelig andre hendelser som kan brukes til &#229; oppdatere state og props. Det finnes brukerrelaterte hendelser som komponenter kan lytte p&#229;. Dette kan v&#230;re onClick(), eller onPress() i React Native. Denne vil kalles n&#229;r et objekt blir trykket p&#229; av brukeren. I denne funksjonen, kan man bruke en hook til &#229; endre state til en komponent. Et eksempel p&#229; dette kan v&#230;re en knapp for nattmodus. Trykker man p&#229; den, kan&#160;en verdi i state bli endret til &#34;night&#34; og sidens fargepalett&#160;blir endret.&#160;<\/p><p>En annen funksjonalitet som brukes til &#229; flytte p&#229; data gjennom komponenthierarkiet, er callbackfunksjoner. Disse brukes til &#229; sende data oppover i hierarkiet, fra en komponent til en annen. Da vil en funksjon kalles&#160;som sender med seg en verdi fra den ene komponenten, og&#160;opp til den andre. Slik kan den andre komponenten f&#229; informasjon fra den f&#248;rste.&#160;<\/p><p>State managers er en annen sv&#230;rt popul&#230;r m&#229;te &#229; lagre state p&#229;. Det finnes mange eksempler p&#229; slike, og to av dem er Redux og MobX. Disse ville jeg g&#229;tt mer inn p&#229; hadde jeg hatt mer tid.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2502,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>RecoilJS-biblioteket er et state management-bibliotek for React. Ved &#229; plassere en RecoilRoot-rundt en komponent, kan alle komponenter inni denne komponenten benytte seg av Recoil-staten. Dersom man plasserer denne wrapperen p&#229; utsiden av applikasjonens rotkomponent, kan alle komponenter i applikasjonen bruke Recoil-staten.&#160;<\/p><p>En atom i Recoil er en del av state. Dersom vi plasserte wrapperen p&#229; utsiden av rotkomponenten har, som sagt, alle komponenter tilgang p&#229; dette atomet. Alle komponenter som viser en verdi fra dette atomet, er en av atomets abonnenter. Det vil si at komponentene vil rendres p&#229; nytt hvis atomet endrer seg, alts&#229; state endres. Komponenter som skal lese fra og til atomer burde bruke &#34;useRecoilState()&#34;. Denne funksjonen er lik &#34;useState()&#34;,&#160;som jeg nevnte i oppgave 1. Den virker ogs&#229; p&#229; samme m&#229;te.&#160;<\/p><p>Et annet konsept i Recoil er selectorer. Det vil si et&#160;datapunkt&#160;som er derivert fra state. Dette er likt konseptet &#34;derviations&#34; som brukes i state management-verkt&#248;yet MobX. En derivert state vil si en state som f&#229;r en verdi endret, eller supplert, basert p&#229; den n&#229;v&#230;rende staten. Dersom man har en state som inneholder todos, kan en selector bli brukt til &#229; automatisk hente ut antallet som er uferdige. Dette vil da v&#230;re basert p&#229; de todos som ligger i state. En annen likhet med MobX er wrapperen som blir brukt. I MobX har man en observer-wrapper som gj&#248;r at endringer&#160;p&#229; innholdets dens blir lyttet p&#229;. Men det blir mer spesifikt i Recoil med atom-konseptet.&#160;&#160;<\/p><p>Det er enkelt&#160;&#229; se fordeler med Recoil. En fordel vil v&#230;re at utvikleren kan bestemme hvilke komponenter som skal ha tilgang til state ved plassering av RecoilRoot. En annen er det enkle oppsettet og minimale mengden kode for &#229; f&#229; det i gang. P&#229; den andre siden av skalen har man Redux som har mer arbeid med oppsett og mengde kode som er likt for alle applikasjoner. Dersom man har benyttet seg av funksjonelle komponenter i React, vil useState() og hooks hjelpe veldig med &#229; kjapt forst&#229; konseptene i Recoil. Det er alts&#229; usannsynlig at det tar lang tid &#229; l&#230;re seg hvordan Recoil skal brukes.&#160;<\/p><p>Ulemper kan ogs&#229; fange &#248;ye n&#229;r man gj&#248;r research p&#229; Recoil. RecoilRoot kan, i st&#248;rre applikasjoner ende opp med &#229; bli brukt flere ganger. Dette vil si at man f&#229;r mange forskjellige states som er eksklusive for bare noen komponenter. Med for mange slike, vil det medf&#248;lge en &#248;kende grad av uoversiktlighet og uryddighet. En annen ulempe kan v&#230;re at man f&#229;r mange oppdateringer som ikke er n&#248;dvendige, og heller gj&#248;r applikasjonen mer krevende &#229; kj&#248;re.&#160;&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/getting-started<\/p><p>https://medium.com/better-programming/recoiljs-the-future-of-react-state-management-ffb1345833b6&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2329,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":1,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Graphql er den fremadstormende nykommeren, mens REST har gjort seg til industriens &#34;best practise&#34;. REST API, som st&#229;r for representational state transfer application programming interface, henter ressurser fra en server. Disse resursene blir hentet ved bruk av URI-er gjennom HTTP-requests. Ved hjelp av en URI-en &#34;GET /movies&#34; kan man hente ut en liste over filmene som ligger p&#229; serveren man kommuniserer med. I GraphQL vil man hente ut objekter med noder som kan bli spesifisert og typedefinert av utvikleren i en schema-fil i backend. I tillegg er det ogs&#229; en resolver som aksesserer serverens data.&#160;Deretter m&#229; man definere et query som blir brukt til &#229; hente ut objektene. Siden det er grundigere definering av hva som skal hentes i Graphql vil disse sp&#248;rringene v&#230;re mye mer leselige enn de tilsvarende sp&#248;rringene gjort med&#160;REST.&#160;<\/p><p>En annen vesentlig forskjell er RESTs endepunkter. Endepunktet X vil gi ut X data. Her vil en ikke kunne begrense fields, og det kan ofte f&#248;re til overfertching. I GraphQL vil klienten kunne spesifisere hva den trenger p&#229; det tidspunktet den skal hente data.&#160;<\/p><p>Bruker man REST,&#160;kan man spesifisere hvordan responsen fra serveren skal se ut. Dette er ikke tilfellet i med et Graphql. GraphQL vil returnere noe som skal matche formen til sp&#248;rringen som er sendt.<\/p><p>I REST vil en request kalle en spesifikk route handler. I GraphQL, p&#229; den andre siden, vil en sp&#248;rring kunne kalle flere resolvers og deretter lage en response som er n&#248;stet.<\/p><p>I Graphql har man resolvers. Her spesifiseres hvordan hva som skal bli returnert for alle de individuelle sp&#248;rringene som ogs&#229; utvikleren har definert.&#160;<\/p><p>Graphql kan gi mer overhead enn n&#248;dvendig i mindre applikasjoner. Her kan et REST API passe bedre.&#160;<\/p><p>Det finnes flere muligheter for &#229; gj&#248;re dataanalyse dersom man velger &#229; benytte et REST API. Grunnen til dette er at det finnes langt flere verkt&#248;y til dette, enn det gj&#248;r for GraphQL.&#160;<\/p><p>Det som gj&#248;r Graphql til ett godt alternativ for mange er den h&#248;ye graden av fleksibilitet. B&#229;de frontendutviklere og backendutviklere vil oppleve at det er lett &#229; tilpasse Graphql til n&#248;yaktig deres bruk gjennom spesifisering av queries, resolvers og schema. Her vil man kunne bruke b&#229;de synkrone og asynkrone interaskjoner mellom klient og server. Objektene kan hentes slik at de er lettere &#229; h&#229;ndtere&#160;<\/p><p>REST API krever mindre oppstartstid for &#229; komme i gang, enn det GraphQL gj&#248;r.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":7,"score":7}},{"result":{"sourcedId":11535089,"ext_inspera_userAssessmentSetupId":7140001,"ext_inspera_userAssessmentId":4841167,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Swensson Birgitte Berg (10014)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33642304,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1273,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Props:&#160;<\/strong><\/p><p>Props tillater komponenter &#229; kommunisere med hverandre, hvor en komponenet sender props ned hierarkiet og tillater dataflyt.&#160;Tilstander som fins i en komponenet kan derfor sendes ned til barn-komponentene, slik at de kan kommuisere med hverandre.&#160;Dette er dog en-retnings dataflyt; nedover fra foreldre-komponent til barn.&#160;<\/p><p>&#160;<\/p><p><strong>Redux/MobX<\/strong><\/p><p>N&#229;r applikasjonen n&#229;r en viss st&#248;rrelse og ikke lenger best&#229;r av kun enkel funksjonalitet, har man behov for &#229; bruke state management, i stedenfor this. state og this.setState bla. B&#229;de Redux og MobX&#160;h&#229;ndterer states i applikasjonen, men hvor Redux har en enkelt store, og der dataen er uforanderlig, mens MobX kan ha flere stores og states kan uthentes/oppdateres direkte uten reducers/actions ( slik som i Redux ). Dette er en type dataflyt som tillater kommunikasjon ikke bare nedover i komponenthierarkiet, men p&#229; tvers av alle komponenter.<\/p><p>&#160;<\/p><p><strong>Context<\/strong> er ogs&#229; en mekanikk for &#229; sende data gjennom komponenttreet uten &#229; m&#229;tte sende props ned de underliggende niv&#229;ene i hierarkiet. Dette skjer ved bruk av providers og consumers.&#160;&#160;Eksempler p&#229; verdier som kan v&#230;re greit &#229; ha i en context er bruker-informasjon&#160;eller andre globale verdier som er nyttig for hele komponenttreet.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3368,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil funksjonalitet og sammenligning med Redux, MobX og Context:<\/strong><\/p><p>&#160;<\/p><p>Recoil er en&#160;state management mekanikk som tillater dataflyt p&#229; lik linje med Redux og Context. Den lokale staten i en komponent kan erstattes med atoms, som er en tilstandsenhet (unit of state).&#160;<\/p><p>&#160;<\/p><p>Nedlastet data fra API, eller annen data som er essensiell for flere komponenter, kan gj&#248;res tilgjengelig for flere komponenter ved &#229; lagre det i en atom. De komponentene som &#248;nsker &#229; f&#229; tilgang til tilstanden i en atom, kan subscribe til den - noe som gir dem en delt tilstand. Dersom tilstandene i et atom oppdateres, vil alle subscriber-komponentene rendres automatisk. Dette er noe av det samme vi finner i redux. Ogs&#229; her har komponentene en form for global state i stedenfor at hver komponent har sin egen.&#160;<\/p><p>&#160;<\/p><p>For &#229; endre tilstanden i en atom, har man selectors; funksjoner som transformerer en atom-tilstand enten asynkront eller synkront. Slik som med atoms kan&#160;kompnentene ogs&#229; subscribe til selectors.<\/p><p>&#160;<\/p><p>Slik som i Context, kan man i Recoil bli varslet n&#229;r state endrer seg for den lagrede dataen man abonnerer&#160;p&#229; - dette ved bruk av&#160;subscriber og consumer.&#160;P&#229; en m&#229;te er ogs&#229; Reacts <em>useState<\/em>-hook lik subskriber-funksjonen til Recoil, da komponenten&#160;f&#229;r beskjed om &#229; re-rendres dersom den gitte&#160;dataen endrer seg.<\/p><p>&#160;<\/p><p>Redux og Context har store, mens recoil har ikke store. I tillegg har man med redux tilgang til all data i storen fra komponentene, mens med context og recoil kan komponenten selv velge hva slags state den vil abonnere p&#229;.&#160;<\/p><p>&#160;<\/p><p>Ved &#229; sammenligne med MobX kan man se at komponenter oppdateres n&#229;r de bruker en observable, og slik Recoil har Atoms og selectors, har MobX&#160;actions og observables. N&#229;r den subscribede storen oppdateres, vil komponent-abonnentene re-rendres.&#160;<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper:&#160;<\/strong><\/p><p>&#160;<\/p><p>I store applikasjoner l&#248;ser Recoil flere av problemene man m&#248;tes p&#229; med Context, bare mer effektivt.<\/p><p>I motsetning til Context, har Recoil muligheten til &#229; lagre st&#248;rre oppdatering-frekvens, da Context i utgangspunktet ble laget til &#229; lagre og oppdatere enkle data, slik som for eksempel fargetema og bruker-data.<\/p><p>I tillegg tillater Recoil lagring av uendelige verdier, og ikke bare enkeltverdier, slik som i Context.&#160;<\/p><p>&#160;<\/p><p>Problemer som kan oppst&#229; ved bruk av Recoil, er at det er s&#229;pas ny teknologi, noe som kan gi d&#229;rlig dokumentasjon og kan gj&#248;re det mindre troverdig.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2442,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er begge metoder for &#229; uthente/sende data over HTTP for &#229; sette opp et API i frontend. Begge vil typisk returnere JSON-data i requesten.&#160;<\/p><p>&#160;<\/p><p>REST&#160;API&#160;uthenter hele datasettet, uavhengig av om alt er n&#248;dvendig eller ikke. Her er det serveren som avgj&#248;r st&#248;rrelsen p&#229; dataen man heter ut, mens i GraphQL er det klienten som bestemmer&#160;man henter ut til enhver tid.&#160;I tillegg har REST flere endepunt (v&#160;DELETE, PUT, GET, POST), og dette krever ofte mer round trips for &#229; hente alt, sammenlignet med GraphQL. Ogs&#229; over fetching er en negativ effekt av REST API.<\/p><p>REST er derimot mer etablert og kjent&#160;enn GraphQl, noe som gir bedre dokumentasjon, og RESTAPI er mer skalerbart, siden du kan gj&#248;re flere kall.&#160;<\/p><p>&#160;<\/p><p>GraphQL uthenter den dataen man sp&#248;r etter, og har kun ett endepunkt; POST. Den sender denne POST-foresp&#248;rselen til serveren, og etter at serveren har tolket foresp&#248;rselen, blir &#248;nsket data sendt tilbake.&#160;Dette gir mer fleksibilitet og effektivitet enn over-fetchingen som kan oppst&#229; ved REST. I tillegg har GraphQl et type-system for &#229; beskrive data i APIet. Ved &#229; hente ut eksakt den dataen man &#248;nsker i en request, vil GraphQL ha h&#248;yere ytelse; ingen over- og under-fetching.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535204,"ext_inspera_userAssessmentSetupId":7139907,"ext_inspera_userAssessmentId":4841374,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aarhus Karen Dahl (10224)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":23368156,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2953,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er sv&#230;rt mange mekanismer og teknikker for h&#229;ndtering av tilstand og dataflyt i React-applikasjoner. I utgangspunktet er &#34;state&#34;&#160;et JavaScript objekt som avgj&#248;r hvordan en komponent&#160;skal oppf&#248;re seg. Tilstand kan endres og oppdateres ved &#229; sende komponenten forskjellige forskjellige &#34;props&#34;. N&#229;r staten endres, re-rendres komponenten med den oppdaterte tilstanden.<br /><br />Utfordringen&#160;med &#229; bruke state p&#229; denne m&#229;ten er at tilstanden er lokal, og blir lagret og endret i hver enkelt komponent. Dette kan fort bli vanskelig&#160;&#229; holde styr p&#229; i st&#248;rre applikasjoner som &#248;nsker &#229; ta i bruk en tilstand p&#229; tvers av komponenter. For &#229; l&#248;se disse utfordringene er det utviklet flere tilstandsh&#229;ndterings systemer som heller tar i bruk en global tilstand for hele applikasjonen.&#160;<\/p><p>&#160;<\/p><p>Context APIet er Reacts svar p&#229; utfordringene knyttet til &#229; sende props rundt i en applikasjon, og gj&#248;r det isteden mulig &#229; lagre globale data for hele komponent-treet.&#160;Det er nyttig &#229; bruke n&#229;r man har data som b&#248;r v&#230;re tilgjengelig for flere komponenter p&#229; forskjellige&#160;niv&#229;er, og kan for eksempel brukes for &#229;&#160;holde styr p&#229; en innlogget bruker, valgt spr&#229;k eller tema p&#229; en nettisde. Bruk av Context gj&#248;r det mulig &#229; sende data gjennom komponenttreet uten &#229; m&#229;tte sende props manuelt gjennom hvert niv&#229;, dette gj&#248;r fortsatt at alle&#160;komponenter re-rendres om det gj&#248;res en endring selv om de ikke selv blir p&#229;virket av tilstandsendringen.&#160;<\/p><p>&#160;<\/p><p>React Hooks er en ny form for tilstandsh&#229;ndtering i React som lar deg bruke tilstand uten &#229; skrive en klasse. Hooks brukes ved &#229; ta i bruk funksjoner som useState, setState etc.<\/p><p>&#160;<\/p><p>Redux er er annet svar p&#229; tilstandsh&#229;ndtering som i motsetning til Context kun oppdaterer de komponentene som er p&#229;virket av en tilstandsendring. I Redux har du en global &#34;store&#34; som holder p&#229; applikasjonens tilstand.&#160;For &#229; ta i bruk redux er det flere ting som trengs: store, actions, types og reducers. Kort forklart lar Redux deg lagre tilstanden i en store, og bruker actions til &#229; kalle&#160;reducers som s&#229; endrer&#160;staten slik du &#248;nsker den. Men tilstandene i redux er &#34;immutabale&#34;, alts&#229; uforanderlige, s&#229; staten oppdateres ved at reduceren returnerer en ny tilstand hver gang.&#160;<\/p><p>En av ulempene ved bruk av Redux er at det inneb&#230;rer sv&#230;rt mye kode, uavhengig av hvor stor applikasjonen er. Denne &#34;boilerplate&#34; koden kan virke un&#248;dvendig men gj&#248;r ogs&#229; at Redux er sv&#230;rt lett &#229; f&#248;lge. Redux er ogs&#229; skalerbar i st&#248;rre grad enn for eksempel MobX.&#160;<\/p><p>&#160;<\/p><p>MobX er et tredje svar p&#229;&#160;tilstandsh&#229;ndtering som i steden for mange funksjoner og kode heller best&#229;r av en observerbar liste. Der Redux lagrer data i et JavaScript objekt eller liste tar MobX heller et eksisterende JavaScript-objekt og gj&#248;r det mulig &#229; observere det. Tilstandene i MobX er &#34;mutable&#34;, alts&#229; mulig &#229; endre. N&#229;r det skjer endringer i tilstanden kalles &#34;actions&#34; som kun oppdaterer komponentene det gjelder.&#160;MobX krever alts&#229; mindre kode, og holder automatisk oversikt over alt som er observerbart.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2085,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tilstands-h&#229;ndterings bibliotek som i f&#248;lge dokumentasjonen &#248;nsker &#229; l&#248;se noen av problemstillingene og begrensningene ved&#160;Reacts innebyggede tilstandsh&#229;ndtering.<\/p><p>Biblioteket presenterer to hovedelementer: atoms og selectors. Atoms er deler av en tilstand, og selectors er funksjoner som tar atoms&#160;eller andre selectors som input for &#229; endre eller oppdatere tilstanden. En selector holder oversikt over hvilke komponenter som trenger den og&#160;hvilke tilstander de er avhengig av.&#160;N&#229;r et atom eller en selector oppdateres vil den evalueres p&#229; nytt og&#160;alle komponentene som er avhengige av den vil re-rendres.&#160;Man kan se p&#229; atomer i recoil som en helt vanlig tilstand, men som hvilken som helst komponent kan &#34;abonnere&#34; p&#229;.&#160;&#160;<\/p><p>&#160;<\/p><p>Fordelen ved &#229; bruke Recoil i utvikling er at det tilbyr flere funksjonaliteter som er nyttige for h&#229;ndtering av state. For eksempel er det sammenlignet med Redux mye mindre boilerplate kode, og biblioteket gj&#248;r det mulig &#229; lagre flere deler med informasjon i en tilstand. Det l&#248;ser problemstillingen knyttet til bruk av Context APIet som kan v&#230;re vanskelig &#229; implementere i st&#248;rre applikasjoner der man &#248;nsker &#229; dele tilstand med mange komponenter.&#160;<\/p><p>Ulempene knyttet til &#229; ta i bruk Recoil er at det er sv&#230;rt nytt, og man har dermed som utvikler lite dokumentasjon og f&#229; ressursser &#229; lene seg p&#229; om det skulle oppst&#229; sp&#248;rsm&#229;l eller problemer.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;https://recoiljs.org,&#160;https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2139,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API st&#229;r for&#160;Representational State Transfer API og best&#229;r av et sett med regler for utvikling og design av web api. Ved bruk av REST henter man data med sp&#248;rringer til ulike&#160;endepunkter. Disse sp&#248;rringene gir mye data, og en utfordring ved REST er at det fetches mer enn det som trengs.&#160;<\/p><p>I motsetning til Graphql er det i REST et tydelig skille mellom hva som er klient og server sitt ansvar. I tillegg bruker REST et universelt utformet grensesnitt med globalt konsistent bruk av HTTP operasjoner som GET, POST og PUT. REST APIet er ogs&#229; tilstandsl&#248;st, noe som inneb&#230;rer at serveren ikke husker klientens foresp&#248;rsler.&#160;REST er &#229; regne som standaren n&#229;r det kommer til bruk av apier og i regnes i mange tilfeller som &#34;best practice&#34;.&#160;<\/p><p>&#160;<\/p><p>Grapql er hovedsakelig et sp&#248;rrespr&#229;k, og returnerer resultater i JSON-format.&#160;Det er ogs&#229; enkelt &#229; bruke og &#229; konfigurere, og blir presentert til et alternativ til REST som i st&#248;rre grad lar utvikleren tilpasse s&#248;kene til egne &#248;nsker.&#160;Graphql unng&#229;r et av de st&#248;rste utfordringene ved REST, nemlig fetching av for mye data. Ved bruk&#160;av graphql sp&#248;rringer f&#229;r man all n&#248;dvendig data med &#233;n foresp&#248;rsel. Graphql tilbyr ogs&#229; et type-valideringssystem.<\/p><p>&#160;<\/p><p>Kilde: hovedsakelig forelesningsnotater.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533294,"ext_inspera_userAssessmentSetupId":7139939,"ext_inspera_userAssessmentId":4841242,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Smines Vegard Rognstad (10053)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35109193,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2083,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State i React er et verkt&#248;y som brukes for &#229; gj&#248;re applikasjonen dynamisk og interaktiv. State kan brukes for &#229; bestemme hvordan et komponent renderer og oppf&#248;rer seg. Render blir aktivert for et komponent n&#229;r state endrer seg.<\/p><p>&#160;<\/p><p><strong>State i Class component og functional component:<\/strong><\/p><p>Class components definerer state i constructor og bruker setState for &#229; endre state.<\/p><p>Functional components, i motsetning til Class components, er egentlig stateless, men vi kan bruke Hooks for &#229; gi samme funksjonalitet.<\/p><p>&#160;<\/p><p><strong>Props:<\/strong><\/p><p>Props i React brukes for &#229; sende data fra et parent component til sine child components. Det g&#229;r ogs&#229; an &#229; bruke props til &#229; sende data motsatt vei med en callback funksjon, men i prinsippet g&#229;r all informasjonsflyten i React nedover.<\/p><p>&#160;<\/p><p><strong>State management tools:<\/strong><\/p><p>Props er stort sett en effektiv m&#229;te &#229; sende data, men i noen tilfeller, s&#230;rlig i st&#248;rre applikasjoner med komplekst hierarki m&#248;ter man ofte p&#229; problemer med at props m&#229; sendes gjennom veldig mange &#34;lag&#34; og man f&#229;r mye s&#229;kalt prop drilling. I disse situasjonene kan det v&#230;re hensiktsmessig &#229; benytte state management tools der man ikke m&#229; &#34;kode seg gjennom&#34; hele hierarkiet.<\/p><p>&#160;<\/p><p>Redux:<\/p><p>Redux er et state management tool man wrapper rundt prosjektet ogs&#229; bruker man &#233;n sentralisert store som alle komponenter har tilgang p&#229;. P&#229; denne m&#229;ten kan informasjonsflyten med props erstattes av helt eller delvis erstattes av Redux. Ofte brukt for st&#248;rre prosjekter siden det kan v&#230;re mer tidkrevende &#229; implementere enn det er verdt<\/p><p>&#160;<\/p><p>MobX:<\/p><p>MobX fungerer mye p&#229; samme m&#229;te som redux, men er blant annet regnet for &#229; v&#230;re litt lettere &#229; implementere og den bruker flere stores. Ofte brukt for mindre prosjekter enn Redux.<\/p><p>&#160;<\/p><p>Context:<\/p><p>Context er et relativt nytt state management tool&#160;innebygd i React. En viktig forskjell mellom Context og de to verkt&#248;yene over er at Context rerenderer hele applikasjonen noe som kan f&#248;re til problemer om man oppdaterer informasjonen i Context veldig ofte.<\/p><p>&#160;<\/p><p>Det finnes ogs&#229; mange andre verkt&#248;y for state management, blant annet som nevnt i neste oppgave.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3413,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek som s&#248;ker &#229; forbedre mange av problemene til mer etablerte bibliotek som redux. Det er to kjerne konsepter som er kritiske for Recoil:<\/p><p>&#160;<\/p><p>Atoms: atoms er globale state som enkelte komponenter kan velge &#229; &#34;subscribe&#34; til.&#160;Bruken av atoms gir Recoil en fordel over verkt&#248;y som redux og context med at bare de komponentene som er subscribed til et atom rerenderer. Det gj&#248;r Recoil langt mer kostnadseffektivt, s&#230;rlig i applikasjoner med hyppige state updates for states som bare brukes av noen komponenter.<\/p><p>&#160;<\/p><p>Selectors:<\/p><p>Selectors gir en s&#229;kalt &#34;derived state&#34;, som i praksis betyr at den tar inn data fra state i et atom og kj&#248;rer den gjennom en funksjon (verdt &#229; nevne at det er en pure funksjon, som alts&#229; alltid gir samme output for samme input og ikke har noen andre avhengigheter)&#160;og gir data som er basert p&#229; verdien i staten i atom.<\/p><p>&#160;<\/p><p>Recoil vs redux:<\/p><p>Recoil er boilerplate-free og har krever mindre kode for &#229; implementeres, noe som potensielt gj&#248;r det bedre egnet for mindre applikasjoner.&#160;<\/p><p>Flere stores (atoms) som kan gi shared state mellom spesifikke komponenter i stedet for shared state for hele applikasjonen gir bedre performance, s&#230;rlig der noen f&#229; komponenter deler en state som skal endres veldig hyppig.<\/p><p>Redux virker lettere &#229; maintaine for store prosjekter siden den har en enkelt store og ikke masse atoms spredd rundt i forskjellige komponenter. Dette kan potensielt ogs&#229; gj&#248;re det lettere &#229; debugge.<\/p><p>En enkelt store gir single source of truth noe som gj&#248;r det lettere &#229; ha en konsistent applikasjon.<\/p><p>&#160;<\/p><p>Recoil vs Context:<\/p><p>Samme fordel som mot redux med mer effektiv rerendering.<\/p><p>Context har fordelen av &#229; v&#230;re innebygd i react.<\/p><p>Selv om context er lettere &#229; implementere enn redux er ogs&#229; her recoil enda litt mer effektiv.<\/p><p>&#160;<\/p><p>Recoil vs MobX:<\/p><p>MobX er regnet for &#229; ha&#160;enda litt bedre performance enn Recoil.<\/p><p>Recoil er mer effektivt &#229; implementere.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1592,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Graphql er i utgangspunktet mer effektiv siden man kan gj&#248;re mer spesifikke queries og bare hente akkurat den dataen man trenger. Dette eliminerer over og underfetching som er et kjent problem i REST. Dersom man fetcher fra et endepunkt i REST f&#229;r man all dataen fra det endepunktet (ogs&#229; un&#248;dvendig data), man kan ikke filtrere p&#229; samme m&#229;te som i graphql. Underfetching kan skje i REST ved at endepunktet man henter fra ikke har all informasjonen man trenger noe som gj&#248;r at man m&#229; fetche flere ganger.<\/p><p>&#160;<\/p><p>Support: Det er vanskeligere &#229; finne st&#248;tte og dokumentasjon dersom man bruker Graphql ettersom den er nyere og mindre utspredt.&#160;<\/p><p>&#160;<\/p><p>Graphql bruker post til alle operasjoner, inkludert &#229; hente data.<\/p><p>&#160;<\/p><p>Graphql trenger bare et endpoint, REST bruker vanligvis mange (for &#229; ikke fetche absolutt all data samtidig).<\/p><p>&#160;<\/p><p>I motsetning til REST cacher ikke graphql automatisk, dette m&#229; implementeres i tillegg dersom man &#248;nsker &#229; bruke det.<\/p><p>&#160;<\/p><p>Graphql er strongly typed noe som gj&#248;r det mindre utsatt for errors, men potensielt litt vanskeligere eller&#160;mer tidkrevende &#229; implementere.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533334,"ext_inspera_userAssessmentSetupId":7140101,"ext_inspera_userAssessmentId":4841183,"dateLastModified":"2020-12-01T10:01:25Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:25Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Brobak Eskild (10063)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22042894,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":918,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Props<\/strong><\/p><p>Props i react er et navn for properties og brukes n&#229;r du vil sende informasjon mellom funksjoner og klasser, brukt n&#229;r du vil sende data fra parent til child klasser/funksjoner.&#160;Det som er viktig n&#229;r det gjelder props er at de ikke kan endres og er dermed immutable.&#160;<\/p><p>&#160;<\/p><p><strong>State<\/strong><\/p><p>State er selve tilstanden til interne variabler.&#160;Denne kan endres ved &#229; bruke setState() og en slik endring vil&#160;ogs&#229; rendre p&#229; nye komponenter, og da ogs&#229; n&#248;dvendigvis deres barn.<\/p><p>&#160;<\/p><p><strong>Callback funksjoner<\/strong><\/p><p>Callback funksjoner brukes n&#229;r du vil sende props fra child til parent.<\/p><p>&#160;<\/p><p><strong>Global state management<\/strong><\/p><p>Har du et veldig komplisert og vanskelig system hvor det er vanskelig &#229; h&#229;ndtere state, s&#229; kan det v&#230;re lurt &#229; samle all h&#229;ndteringen av dette p&#229; et sted. Her kan man da benytte seg av biblioteker som for eksempel Redux.&#160;<\/p><p>&#160;<\/p><p><strong>Testing av dataflyt<\/strong><\/p><p>Det er mulig &#229; teste dataflyten ogs&#229; som ved &#229; legge til end to end testing. Her tester man da rett og slett hvordan dataflyten er i applikasjonen. Sett opp noen aktuelle scenariorer og lag tester for disse. Her finnes det ogs&#229; gode biblioteker for dette, som f.eks. Cypress.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2181,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil<\/strong> er et open source bibliotek for React for&#160;global state management. Som forklart i oppgave 1 s&#229; er global state management noe du gjerne vil ha i din react applikasjon hvis du har mye state behandlig og gjerne komplisert i tillegg. Da er det lurt &#229; samle alt p&#229; et sted. I listen over l&#230;ringsm&#229;l har vi hovedsakelig sett p&#229; redux og mobx for global state management.<\/p><p>&#160;<\/p><p>Recoil bruker atoms og selectors ved behandling av state, hvor atoms i recoil er en mini versjon av state&#160;og kan endres. Selectorene som kan ta et atom som input, og&#160;brukes hovedsakelig ved mer komplisert behandling av data.&#160;<\/p><p>&#160;<\/p><p>Sammenlignet med <strong>Redux<\/strong> s&#229; er dette veldig forskjellig hvor Redux har actions, store og reducers. Actions er der selve funskjonene og behandlingen av data skjer. I store blir selve staten lagret og reducer tar inn en action og store&#160;som input og behandler disse med hensyn til hverandre. En umiddelbar fordel er at Redux er veldig mye brukt og har dermed veldig mye gode ressurser knyttet til seg, hvor Recoil ble laget i &#229;r og er dermed veldig mye mindre brukt.&#160;<\/p><p>&#160;<\/p><p><strong>MobX&#160;<\/strong>er en annen m&#229;te &#229; h&#229;ndtere global state management p&#229;. For hvert &#34;event&#34; ved bruk av mobx, s&#229; benyttes actions som igjen oppdaterer state. Det som er greia med mobx er at utvikleren ikke n&#248;dvendigvis trenger &#229; vite hva som skjer &#34;behind the scenes&#34; i motsetning til Redux.&#160;<\/p><p>&#160;<\/p><p>Min umiddelbare tanke mellom disse tre bibliotekene for global state management er at Recoil kanskje kan v&#230;re en litt mindre krevende versjon av Redux, men igjen litt mer krevende enn MobX, s&#229; mer et mellomledd mellom disse.&#160;<\/p><p>&#160;<\/p><p>En umiddelbar fordel med Recoil (Inspirasjon hentet fra &#34;https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10&#34;)<\/p><p>&#160;er at ved bruk av Recoil trenger du ikke n&#248;dvendigvis &#229; rendre ALLE komponenter og deres barn hvis man vil gj&#248;re endring p&#229; state til en av de. Sammenlignet med Redux hvor alle barn m&#229; re-rendres fordi de har en &#34;shared global state&#34;. Det som da kan v&#230;re bra er om applikasjonen din gj&#248;r mye computations og sliter med kraft s&#229; kan recoil v&#230;re en bra ting.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1548,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>REST<\/strong> er et design for web-basert klient tjener som hovedsakelig fokuserer p&#229; lesing og skriving, hvor dette da skjer via URI og HTTP requests. Ved disse requestene s&#229; fokuserer du mest p&#229; dataen og kan da velge mellom forskjellige kommandoer for &#229; h&#229;ndtere denne dataen. Her kommer begrepene POST, PUT, GET og DELETE som henholdsvis betyr oppretting, endring, lesing og sletting av data. Det som kan v&#230;re ulempen med REST er at hvis du skal hente komplisert data eller gj&#248;re en komplisert request s&#229; kan det hende det gj&#248;res veldig mange kall til serveren som da kan gj&#248;re det tregt. Jo mere kall du gj&#248;r, jo st&#248;rre risiko er det ogs&#229; at du kan hente mer data enn det du egentlig trenger, noe som s&#229; fint kalles for overfetching.&#160;<\/p><p>&#160;<\/p><p><strong>GraphQL<\/strong> er hovedsakelig et sp&#248;rrespr&#229;k og opperer ved runtime. Helt enkelt s&#229; sender du en sp&#248;rring til serveren og sp&#248;r etter hvilken data du vil ha og f&#229;r da det tilbake (gitt at sp&#248;rringen er riktig i forhold til det du skal ha da). Den &#229;penbare fordelen med GraphQL er at det er veldig enkelt og du f&#229;r det du sp&#248;r etter. En annen fordel med graphQL er at det unng&#229;r overfetching, siden du henter all data med en request. I GraphQL er brukes keyword i query og kan lett endres.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533590,"ext_inspera_userAssessmentSetupId":7140024,"ext_inspera_userAssessmentId":4841232,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Huso Gunvor (10076)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330483,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2038,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er lokale variablar som h&#248;yrer til ein komponent. Ved &#229; endre state vil komponenten rendre p&#229; nytt.<\/p><p>Props er eigenskapar som vert gitt som input n&#229;r ein komponent vert oppretta eller kalla. Verdiane komponenten mottar kan ikkje endrast sidan props er immutable.<\/p><p>&#160;<\/p><p>Ein komponent med state kan sende staten sin nedover som props til barnekomponentane sine. Data flyt nedover fr&#229; foreldrekomponen til barnekomponent. For &#229; implementere dataflyt oppover i eit komponenthierarki i React m&#229; ein nytte callback-funksjonar som gjer at barnekomponenten kan endre staten i foreldrekomponenten.<\/p><p>&#160;<\/p><p>I ein kompleks applikasjon med mange komponentar der ein til d&#248;mes skal nytte same data fleire stader eller ein treng &#229; sende data p&#229; tvers av komponenthierarkiet, vert dette for veldig komplisert. Her kan det difor vere lurt &#229; nytte Global State Management. D&#229; kan ein lagre alle data p&#229; ein stad og implementere automatisk oppdatering av tilh&#248;yrande komponentar n&#229;r data vert endra. Her kan ein til d&#248;mes nytte Redux og Mobx. Ein enklare metode implementert i React er Context APIet. Dette tillet applikasjonen &#229; dele state i heile komponenthierarkiet, utan props-drilling.<\/p><p>&#160;<\/p><p>https://medium.com/@thejasonfile/callback-functions-in-react-e822ebede766<\/p><p>https://www.loginradius.com/blog/async/react-context-api/<\/p><p>https://www.javatpoint.com/react-state-vs-props<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2511,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er eit state management-bibliotek for React. To viktige i konsept i Recoil er Atoms og Selectors. Eit atom er ei eining av staten som ein kan endre og abonnere p&#229;. Ved &#229; endre eit atom vil ein rendre alle komponentar som abonnerer p&#229; atomet p&#229; ny. Ein selector er ein funksjon som tek eit atom eller ein selector som input. Selector-funksjonen returnerer ein endra state kvar gong upstream-atom eller -selectors vert oppdatert. Ein komponent kan ogs&#229; abonnere p&#229; selectors.<\/p><p>&#160;<\/p><p>Recoil ser alts&#229; ut til &#229; ha liknande funksjonalitet som Redux og Mobx. Ein fordel med Recoil ser difor ut til &#229; vere at det ikkje er s&#229; mykje boilerplate for &#229; starte &#229; bruke det samanlikna med til d&#248;mes Redux. Recoil ser ut til &#229; ha mykje av funksjonaliteten ein &#248;nskjer innebygd, i staden for &#229; m&#229;tte laste inn fleire tredjepartsbibliotek. For &#229; ta i bruk b&#229;de Context API-et og Redux m&#229; ein splitte opp koden mykje, med Recoil vert staten lagra&#160;inkrementelt og distribuert. Dette kan ein b&#229;de sj&#229; p&#229; som ein fordel og som ei ulempe, d&#229; splitting kan gjere koden meir oversiktleg. Likevel kan det vere enklare &#229; forst&#229; kva som heng saman ved &#229; unng&#229; &#229; splitte koden like mykje.<\/p><p>Ein ulempe med Recoil kan vere at sidan det er eit ganske nytt bibliotek vil det ikkje finnest like mykje dokumentasjon om det. Og ein kan m&#248;te p&#229; st&#248;rre problem det ikkje end&#229; finst l&#248;ysingar p&#229;. For Redux og Mobx finst det derimot sv&#230;rt mykje dokumentasjon, d&#229; dette er dei mest brukte state management-biblioteka i dag. Recoil ser ogs&#229; ut til &#229; vere under stadig utvikling, noko som gjer at ein i st&#248;rre prosjekt kanskje vil mangle noko av den funksjonaliteten ein allereie finn i Redux og Mobx.<\/p><p>&#160;<\/p><p>https://www.telerik.com/blogs/recoil-in-react<\/p><p>https://recoiljs.org/<\/p><p>https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2084,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL er basert p&#229; at ein sender ei sp&#248;rring til serveren kor ein definerer b&#229;de s&#248;k og kva data som skal returnerast. P&#229; denne m&#229;ten kan ein hente alle data i ein request og ein unng&#229;r overfetching. Dette gjer at ein kan redusere antal HTTP requests, som forbetrar ytinga og sikkerheiten til applikasjonen. GraphQL nyttar berre JSON for utveksling av data. I GraphQL definerer ein eit skjema med objekt-typer og felt, dette avgjer kva som er gyldige sp&#248;rringar. I REST definerer ein eitt eller fleire endepunkt for &#229; lese, skrive eller endre p&#229; ressursar gjennom URI og HTTP requests. For kvar ressurs er det definert kva bestemte data som skal returnerast. For &#229; f&#229; tak i same mengd data som GraphQL hentar ut ved ei sp&#248;rring, m&#229; ein med REST ofte gjere fleire requests til ulike endepunkt p&#229; grunn av underfetching. Dette gjer at ein opplever overfetching sidan endepunkta gjerne returnerar eksta informasjon som ikkje er naudsynt. REST API har likevel ein fordel ved &#229; kunne nytte HTTP caching. Dersom nylege responses er lagra i cachen, vil REST bruke kortare tid p&#229; &#229; hente informasjonen. Denne funksjonaliteten har ein ikkje i GraphQL.<\/p><p>&#160;<\/p><p>https://restfulapi.net/caching/<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533607,"ext_inspera_userAssessmentSetupId":7140053,"ext_inspera_userAssessmentId":4841217,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Woldseth Tommy Eikrem (10039)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34553991,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2400,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De tradisjonelle teknikkene for tilstand og dataflyt i React er state og props. State-objektet er innebygd i React, og lagrer data, eller tilstanden til en komponent. N&#229;r denne tilstanden endres, vil komponenten re-rendres. Props brukes for &#229; sende data mellom komponenter. Dette fungerer ved at komponenter tar inn props som argumenter. Props fungerer p&#229; samme m&#229;te som argumenter til en funksjon i vanlig JavaScript. Denne vanlige fremgangsm&#229;ten for tilstand og dataflyt fungerer bra og intuitivt n&#229;r man har en liten og ukompleks applikasjon. N&#229;r vi heller skal lage en st&#248;rre applikasjon med h&#248;yere kompleksitet, kan det bli sv&#230;rt tungvint &#229; bare bruke state og props. Med mange n&#248;stede komponenter kan man risikere &#229; m&#229;tte sende de samme props&#39;ene gjennom mange komponenter som ikke trenger &#229; bruke dem, p&#229; veien fra der vi kan aksessere data&#39;en til der vi skal bruke den. Denne teknikken kalles &#34;prop drilling&#34;, og kan fort bli en uoversiktlig l&#248;sning som krever mer kode og er vanskelig &#229; opprettholde. Hvis vi for eksempel re-faktorerer bort en komponent eller endrer p&#229; komponent-hierarkiet, vil vi m&#229;tte rute de props&#39;ene som er p&#229;virket p&#229; nytt.&#160;<\/p><p>&#160;<\/p><p>For &#229; gj&#248;re h&#229;ndteringen av tilstand og dataflyt lettere finnes det flere biblioteker og API som l&#248;ser dette ved &#229; kunne hente state globalt. Et av disse er Context API&#39;et til React. Ved hjelp av Context API&#39;et kan man sende data gjennom komponent-treet, uten &#229; m&#229;tte sende den manuelt mellom komponentene. Dette gj&#248;res ved at det lages en global context hvor dataen lagres. Denne oppdateres ved hjelp av en reducer. I tillegg m&#229; man &#34;wrappe&#34; forelder-komponenten i en global provider. Da vil alle barne-komponentene kunne hente ut state til seg selv ved &#229; bruke useContext(). Dette er en l&#248;sning som ikke tar s&#229; lang tid &#229; implementere, og sparer mye tid i fremtidig utvikling av appen.&#160;<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; l&#248;se dette problemet p&#229; er biblioteket Redux. Her lager man en global store hvor man kan lagre all state man trenger. Man bruker actions og reducers for &#229; oppdatere denne globale store&#39;en. Man m&#229; ogs&#229; her &#34;wrappe&#34; forelder-komponenten i en provider. Da kan man hente ut og oppdatere data fra komponentene med hooks&#39;ene useSelector() og useDispatch(). Det er litt mer omfattende &#229; sette opp Redux enn Context, men dette er ogs&#229; en sv&#230;rt tidssparende l&#248;sning hvis man har et stort prosjekt. En fordel med Redux i forhold til Context er at i Redux blir bare de komponentene som er endre re-rendret. Med Context vil alle komponentene bli re-rendret. I en&#160;applikasjon med mye oppdatering og henting av state vil Redux derfor v&#230;re mer effektiv.<\/p><p>&#160;<\/p><p>I tillegg til disse finnes bibliotek som MobX, Flux, og mange flere som man kan bruke for &#229; h&#229;ndtere dataflyt i React.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2347,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for tilstandsh&#229;ndtering for React.&#160;Motivasjonen for &#229; lage dette biblioteket er at det kan v&#230;re en fordel &#229; bruke React&#39;s innebygde funksjonalitet for state-h&#229;ndtering&#160;fremfor &#229; bruke eksterne biblioteker for global state, med tanke p&#229; kompabilitet. For eksempel vil en problemstilling kunne v&#230;re at React utvikler seg p&#229; en annen m&#229;te enn et eksternt bibliotek, og vil derfor kunne bli mindre kompatibelt. Siden Recoil ligger tett p&#229; de innebygde React-funksjonene, vil React og Recoil kunne utvikle seg mer i takt. Konseptet for dataflyt i Recoil er at data blir sendt fra &#34;atoms&#34;, gjennom &#34;selectors&#34; og ned til de komponentene som vil bruke state&#39;en.&#160;I Recoil bruker man &#34;atoms&#34; som en enhet av tilstand. Disse lagrer data som blir brukt av komponenter. N&#229;r denne tilstanden oppdateres, vil alle komponentene som lytter til denne tilstanden re-rendres. N&#229;r flere komponenter lytter til samme &#34;atom&#34; deler de denne tilstanden, istedenfor &#229; ha egne lokale tilstander. For &#229; hente ut og oppdatere tilstand brukes hook&#39;et useRecoilState. Man bruker ogs&#229; selectors, for &#229; kunne modifisere en state. Noen fordeler med Recoil kontra andre l&#248;sninger er at det er enkelt &#229; sette opp, og trenger ikke mye ekstra kode som andre biblioteker kan ha behov for. Metodene for &#229; sette og bruke state ligner veldig p&#229; vanlig React local state, og man trenger derfor ikke &#229; l&#230;re seg s&#229; mye ekstra syntaks. Siden endringer av state f&#248;rer til at man returnerer en ny state istedenfor &#229; overskrive den gamle, kan man g&#229; frem og tilbake i tid ved debugging og se alle endringer i state. Dette gj&#248;r det mye enklere &#229; se n&#248;yaktig hvor og n&#229;r en tilstand ikke blir hentet eller skrevet p&#229; riktig m&#229;te.&#160;Biblioteket er fortsatt &#34;eksperimentelt&#34; og det er dermed kanskje ikke s&#229; lurt &#229; bruke det i et ferdig produkt enda, men populariteten har vokst mye i det siste p&#229; grunn av simplisiteten.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2352,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den st&#248;rste forskjellen mellom REST API og GraphQL, er at mens REST API er et regelverk, er GraphQL et queryspr&#229;k. Alle API&#39;er som f&#248;lger reglene til REST er dermed et REST API. Dette konseptuelle rammeverket ble f&#248;rst introdusert i 2000, og har siden blitt en standard for sending av data mellom en klient og en server. Dette blir gjort ved &#229; sende HTTP-requests til en URL, som s&#229; kan svare p&#229; denne foresp&#248;rselen ved &#229; sende data andre veien gjennom HTTP. Graphql er utviklet av Facebook, og er et query-spr&#229;k som ble tilgjengelig for offentligheten i 2015. I stedet for &#229; sp&#248;rre om data som ligger p&#229; en bestemt URL, bruker GraphQL et &#34;schema&#34; som definerer hvilken data som er tilgjengelig. Istedenfor &#229; bruke GET og POST requests som man gj&#248;r i REST API&#39;er, bruker man kodeordene &#34;query&#34; og &#34;mutation&#34; i GraphQL. GraphQL bruker ogs&#229; HTTP for &#229; sende og motta data,&#160;men hovedfordelen med GraphQL er at man kan definere hvilken data man er ute etter i en request.&#160;Dette gj&#248;r b&#229;de at man kan slippe &#229; hente un&#248;dvendig data p&#229; en URL, men ogs&#229; at man kan klare seg med f&#230;rre sp&#248;rringer om dataen man er ute etter ligger p&#229; forskjellige endepunkter. Dette f&#248;rer til mer effektiv henting av data, som kan gj&#248;re applikasjonen raskere. Dette kan for eksempel gjelde hvis klienten har en svak internettforbindelse. Det vil da v&#230;re raskere &#229; gj&#248;re &#233;n foresp&#248;rsel, istedenfor flere. Dette kan ogs&#229; gjelde om applikasjonen trenger &#229; hente ny data ofte. Da kan besparelsen p&#229; antall sp&#248;rringer &#248;ke responsiviteten til appen.&#160;Fordeler med REST er at det er enklere, da man f&#229;r ut et datasett per endepunkt uansett. Det er et enklere konsept &#229; l&#230;re seg, og har ogs&#229; et st&#248;rre samfunn av brukere.&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534065,"ext_inspera_userAssessmentSetupId":7140142,"ext_inspera_userAssessmentId":4841266,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Øien Erlend (10028)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331080,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstand i React h&#229;ndteres med state og props (properties), hvor props er readonly-verdier som sendes inn til en komponent og i tillegg til state-endringer, vil endrede props oppdatere komponenten. Det er props som tilgjengligj&#248;r dataflyt mellom komponenter.<\/p><p>&#160;<\/p><p>I et komponenthierarki g&#229;r dataflyten nedover i hierarkiet. Det er blitt en konvensjon &#229; ha state-h&#229;ndtering s&#229; langt oppe i hierarkiet som mulig fordi det kan v&#230;re forskjellige under-komponenter som baserer seg p&#229; samme state.Dermed kan det bli en unaturlig plassering av logikk for en komponent, men bedre generell tilgang til den. For &#229; kunne endre dataen oppover i hierarkiet, kan man sende med callbacks i props som kan kalles i sub-komponentene/&#34;child components&#34; for &#229; endre state til forelder, f.eks. om man har en knapp som skal endre noe&#160;hos forelder, kan man sende med en onClick-handler som props.&#160;<\/p><p>&#160;<\/p><p>N&#229;r man allerede har sentralisert state utenfor komponentene selv, skaper man en avhengighet mellom kompentene i hierarkiet.&#160;I tillegg kan det i st&#248;rre komponent-tr&#230;r v&#230;re bare mindre subtr&#230;r som trenger tilstandsoppdatering, men siden roten oppdateres, m&#229; hele treet ogs&#229; re-renderes. Dermed har global state management l&#248;sninger som Redux, Mobx og Context-apiet dukket opp. Det separerer state fra root-komponenten/h&#248;yt i hierarkiet til en egen store. I tillegg til delt, globalt tilgjengelig state, spesifiserer det i st&#248;rre grad hvilke deler av komponenthierarkiet som m&#229; rerenders.&#160;Med f.eks. Redux har man da at state er immutable, slik at for hver endring av state, skapes en ny state (lignende useState-hooken). Det tillater &#34;tidsreise&#34; ettersom tidligere states er tilgjengelig. Det er ikke n&#248;dvendigvis tilfelle med Mobx.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3784,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React og sammenlignbart med l&#248;sninger som Redux, Mobx, Apollo Client cache og Context API. De pr&#248;ver &#229; m&#248;te noe av kritikken mot Redux som er blant annet at det er mye &#34;boilerplate&#34;-kode, noe Mobx ogs&#229; har pr&#248;vd.&#160; Recoil er mer minimalistisk ved at man blant annet ikke m&#229; implementere stores og i mine &#248;yne en slakkere l&#230;ringskurve. Det kommer i tillegg til Context API-et, fordi Context&#160;kort sagt er for minimalt for kompleks multi-verdi state-h&#229;ndtering (https://recoiljs.org/docs/introduction/motivation/) (m&#229;tte hatt mange providers =&#62; Ineffektiv rendering).<\/p><p>&#160;<\/p><p>Recoil best&#229;r av <em>Atoms<\/em>, som er en &#34;state-enhet&#34; som kan oppdaters og&#160;komponenter kan subscribe til den slik at det oppdateres ved endringer. Recoil har ogs&#229;&#160;<em>Selectors<\/em>&#160;som brukes for &#229; lese/transformere state ved &#229; ta inn enten atoms eller andre selectors som input. Ved endringer p&#229; disse atomene eller selectorene,&#160;vil komponenten som gjorde selector-kallet re-renders. I tillegg er Recoils global state immutable, slik Redux ogs&#229; er og dermed har de samme mulighetene for &#34;tidsreise&#34;.<\/p><p>&#160;<\/p><p>Det som gj&#248;r Recoil spesielt nyttig er at det er lite boilerplate og virkem&#229;ten/syntaksen er lik React&#39;s core state management. Dermed er det lav terskel for &#229; benytte i utviklingen fordi man f.eks. kan bruke&#160;<em>useRecoilState-<\/em>hooken for &#229; lese og skrive til et atom (state), likt <em>useState<\/em>-hooken. Noe tilsvarende &#34;<em>useSelector<\/em>&#34;-hooken for Redux, har man <em>useRecoilValue<\/em>&#160;i Recoil for &#229; lese (derived) state. Med Redux m&#229;tte man ogs&#229; definerte reducers for hvordan den nye staten skal genereres. &#197; ha reducers kan gi mer eksplisitt kontroll for hvordan ny state skal genereres, men det blir mye boilerplate sammen med a<em>ctions<\/em>-definisjoner. Recoil kan ogs&#229; ha reducers for mer granulert kontroll, men det er ikke et krav.<\/p><p>&#160;<\/p><p>Kort fortalt er fordelene med Recoil at det er likt Reacts state-h&#229;ndtering og&#160;det har lite boilerplate kode, begge til fordel for rask utvikling. I tillegg st&#248;tter Recoil code splitting, noe ogs&#229; Redux gj&#248;r (https://redux.js.org/recipes/code-splitting), siden atomer/selectorer er &#34;kvantifisert&#34; og man kan laste de dynamisk. En anne fordel med Recoil over Redux er at de st&#248;tter b&#229;de asynkron og synkron state-tilgang <em>by default<\/em>, men i Redux m&#229; du bruke middleware. Mobx har et annet forhold til asynkrone actions, med sine <em>@flow<\/em>-annotasjon (https://mobx.js.org/actions.html). Recoil st&#248;ttes av Facebook slik at det i st&#248;rre grad vil v&#230;re tett knyttet mot React (med fordelen av delte verider og &#34;insight&#34;),&#160;enn andre tredjeparter som Redux og Mobx. Dette kan f&#248;re til raskere oppdatering og nye&#160;features for Recoil.&#160;Til forskjell er Redux mye brukt og godt dokumentert, mens Recoil fortsatt er relativt ungt og eksperimentelt.<\/p><p>&#160;<\/p><p>En annen fordel med Recoil er at det vil v&#230;re kompatibelt med concurrent mode, noe Redux ikke st&#248;tter (https://reactjs.org/docs/concurrent-mode-intro.html) enn&#229;.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1854,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er ment for &#229; standardisere overf&#248;ring av tilstand mellom applikasjoner/servere etc. ved &#229; benytte HTTP&#39;s GET/POST/UPDATE/DELETE-foresp&#248;rsler. GraphQl er et sp&#248;rrespr&#229;k som definerer hvordan man kan hente data fra et API i form av en graphql server. REST&#39;s API baserer seg ofte p&#229; URI-er for &#229; benytte ressurser og man m&#229; derfor ofte gj&#248;re flere foresp&#248;rsler til forskjellige endepunkter. Dette f&#248;rer til underfetching og dermed ogs&#229; overfetching fordi man trolig ikke trenger all dataen man henter.&#160;<\/p><p>&#160;<\/p><p>Graphql jobber for &#229; l&#248;se dette ved at man eksplisitt i en foresp&#248;rsel (Query - for &#229; lese data, Mutation for &#229; endre data) sier hva man vil hente/endre p&#229; et JSON-lignende format. Dermed henter man ikke mer enn akkurat det man trenger. For &#229; f&#229; til dette m&#229; man definere en &#34;schema&#34; for hvilke foresp&#248;rsler man kan skrive, samt hva disse foresp&#248;rslene kan hente. Dette er en fordel fordi man kan dermed validere dataen, men det binder ogs&#229; klient og tjener sammen, som ikke m&#229; v&#230;re en fordel. Dette er i motsetning til REST som er ment til &#229; v&#230;re tilstandsl&#248;st og mer &#34;generelt&#34; i den forstand at den pr&#248;ver &#229; generalisere koblingen mellom forskjellige klienter og potensielt forskjellige tjenere.&#160;<\/p><p>&#160;<\/p><p>For caching av requests kan REST enkelt cache GET-requests i browseren ved &#229; bruke HTTP&#39;s headers som&#160;<em>cache-control, last-modified&#160;og ETAG&#160;<\/em>for &#229; identfisere cached ressurser. GraphQL kan ikke gj&#248;re dette direkte (https://graphql.org/learn/caching/) og m&#229; derfor identifisere responser via sp&#248;rrespr&#229;ket. Apollo-plattformen, som brukes ofte med Graphql, har derfor implementert en normalized cache for blant annet dette form&#229;let, men ogs&#229; for local state h&#229;ndtering (for f.eks. React eller Vue). Andre Graphql-klienter som URQL st&#248;tter ogs&#229; caching, men ikke &#34;by default&#34;.<\/p><p>&#160;<\/p><p><strong>REST<\/strong><\/p><p><strong>-&#160;<\/strong>Handler om &#229; overf&#248;re tilstand mellom moduler/applikasjoner/servere etc.<\/p><p><strong>-&#160;<\/strong>Bruker HTTP&#39;s POST/UPDATE/DELETE etc<\/p><p>- Kan cache request/respons direkte med browser funksjonalitet<\/p><p>- Separerte endepunkter basert ofte p&#229; URI<\/p><p>- Trenger flere requests for forskjellig data som (kan) f&#248;re(r) til overfetching og underfetching<\/p><p>- Tilstandsl&#248;s og separat l&#248;sning<\/p><p>- Response kan v&#230;<\/p><p>&#160;<\/p><p><strong>GraphQL<\/strong><\/p><p>- Sp&#248;rrespr&#229;k for et API<\/p><p>- Skapt for blant annet &#229; fikse problemer med overfetching og underfetching<\/p><p>&#160; &#160; &#160;- Man eksplisitt skriver hva man vil ha fra API-et p&#229; et JSON-lignende format<\/p><p>- Responses er begrenset til JSON<\/p><p>- Data validering med schema (typer for data og sp&#248;rringer)<\/p><p>&#160; &#160; - --&#62; Knytter dermed tjener og klient sammen&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11534132,"ext_inspera_userAssessmentSetupId":7140032,"ext_inspera_userAssessmentId":4841248,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Grødem Aleksandra (10135)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35325669,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2100,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>useEffect, Redux, Mobex<\/p><p>&#160;<\/p><p>Noe React er kjent for er state management, og er nok mye av grunnen til at react er s&#229;pass polul&#230;rt og likt av mange.<\/p><p>&#160;<\/p><p>State brukes n&#229;r for elementer som skal endres hele tiden. Man kan si at state er dynamisk, mens props er statisk. Ved dynamsik menes det med at det rendres kontinuerlig.&#160;<\/p><p>&#160;<\/p><p>I en funskjon kan man holde styr p&#229; en state ved &#229; bruke useEffect, som er en del av React Hooks. useEffect holder da kun p&#229; en state innad i en klasse. Hvis en skal ha tak i en state i flere komponenter, kan Redux f.eks tas i bruk.<\/p><p>&#160;<\/p><p>For &#229; visualiere hvordan redux fungerer, kan man se for seg en boks som&#160;er utfor hirakiet.&#160;Og er&#160;n&#229; ikke lengre bundet til &#229; sende props kun nedover i hirakiet, men noe alle har tilgang til. Istedenfor &#229; ha dataen i en komponent, s&#229; gj&#248;r redux at en kan ha an &#34;Store&#34; utenfor hele hirakiet. Her holdes det styr p&#229; ulike states, som kan brukes p&#229; tvers av komponentene, selv om de er p&#229; samme niv&#229;. Dvs redux har en global state istedenfor at hver komponent har sin egen. Dette kommer til nytte n&#229;r applikasjonen er stor, og/eller n&#229;r flere vil ha tilgang til den samme tilstanden, men det ikke er naturlig med et parent-child forhold.<\/p><p>Istedenfor &#229; endre tilstanden direkte, erstatter en den med en ny istedenfor. Dette gj&#248;res ved bruk av actions. Actions er JS-objekt som beskriver hva som skjer, og endingen. De her snakker s&#229; med reducers, som oppdaterer/erstatter staten. Kort sagt s&#229; lager redux en reducer, som har en action som oppdatere store.&#160;<\/p><p>&#160;<\/p><p>MobX l&#248;ser mye av de samme problemene som Redux, bare ofte med minde kode. MobX har en action, som oppdater en observerble, og der de observable er oppdatert medf&#248;rer en reaksjon overalt der en observable har blitt brukt. Dette betyr at apllikasjonen kun trenger &#229; bli oppdatert noen steder. MobX har i motsetning til redux mer frihet n&#229;r det gjelder store, hvor mange og hvordan de skal brukes. I redux er det kun en, mens mobx kan ha flere. I mobex kan du ogs&#229; endre p&#229; stores, og ikke erstatte slik som redux.&#160;&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3429,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management system for react som brukes atoms og selectors. Bibiloteket tilbyr flere funskjononaliteter som er vanskelig med react alene. Istedenfor den getState-setState som brukes for &#229; lagre tilstader lokalt, kan det gj&#248;res p&#229; samme m&#229;te bare globalt med Recoil. Dette f&#248;rer bla til mindre boilerplate, enn f.eks ved&#160;redux. Det brukes som sagt atoms og selectors, der atoms er tilstandsenheter. Disse tilstandenhetene kan dele tilstanden med flere, og komponenter kan h&#248;re/abonnere/f&#248;lge med p&#229; disse tilstandene. Selectorene kan s&#229; transformere disse&#160;tilstadene samtidig eller hver for seg.&#160;<\/p><p>&#160;<\/p><p>I motsetning til redux og mobx slipper man med recoil &#229; lage en store for &#229; bevare/holde styr p&#229; de ulike tilstandene. Trenger heller ikke &#229;&#160;re-rendre hele applikasjonen for oppdatere en tilstand, slik som redux.<\/p><p>&#160;<\/p><p>Recoil l&#248;ser mange av problemene som contex API st&#229;r ovenfor. bla at contex kan bare holde p&#229; en enkel verdi, og ikke flere.<\/p><p>&#160;<\/p><p>Fordelen med recoil er at hvis atom blir brukt i flere komponenter, deler disse komponentene tilstand. Og en selector som lett kan endre p&#229; tilstandene.<\/p><p>&#160;<\/p><p>Ulemper med dette er at det er et relativt nytt bibilotek, som medf&#248;rer sine bakdeler.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1641,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest er en type m&#229;te &#229; bruke API&#39;er p&#229;. Det blir gjort et kall til apoiet , som deretter returnerer informaskpn fra databasen tilake.&#160;<\/p><p>&#160;<\/p><p>For &#229; fetche eller motta data fra en server i rest, kan man ende opp med &#229; lage request til flere endepoints. I GraphQl derimot, har man bare ett endepoint. Fordelen med grapql er alts&#229; at man kun trenger &#229; sende en foresp&#248;rsel for &#229; f&#229; tilgang p&#229; info til et objekt,&#160;mens med rest m&#229; det gj&#248;res flere. Dette f&#248;rer til at graphql reduserer nettverk foresp&#248;rsler.<\/p><p>&#160;<\/p><p>Med graphql henter man kun data man trenger fra serveen ved &#229; lage en spesifikk sp&#248;rring. Med rest er det ikke det samme, her har hvert endpoint en fast datastruktur som er ment &#229; returnere n&#229;r dette endepunktet blir kallt.&#160;<\/p><p>&#160;<\/p><p>Error h&#229;ndtering&#160;blir gjort p&#229; ulike m&#229;ter i REST og GraphQL. I GraphQL vil man alltid f&#229; en 200 OK status, og f&#229;r derfor feilmeldingen sendt til klientet istedenfor. Med REST er det lettere ettersom man kun trenger &#229; sjekke HTTP-status koden.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534141,"ext_inspera_userAssessmentSetupId":7140136,"ext_inspera_userAssessmentId":4841216,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Myklebust Peder (10118)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34567964,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2387,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Data i React-komponenter er lagret som enten properties eller state.&#160;<\/p><p>&#160;<\/p><p>I React-applikasjoner har vi en dataflyt som g&#229;r i en retning, som er fra &#34;parent&#34; til &#34;child&#34;. Alts&#229; at &#34;parent&#34; gir data, og oppdaterer&#160;hvert &#34;child&#34;.&#160;&#160;Dette medf&#248;rer at vi kan ha en komponent som holder all state, der de andre tar inn props og lager (rendrer) noe. Dette er typisk dataflyt for properties.<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulighet for &#229; sende data oppover med &#229; bruke callback-funksjoner som gj&#248;r det mulig for et &#34;child&#34; &#229; endre state til &#34;parent&#34;.&#160;<\/p><p>&#160;<\/p><p>N&#229;r vi vil aksessere data som endrer seg over tid s&#229; er state et bedre alternativ. Bruker this.state for &#229; initialisere staten / aksessere den, og setState for &#229; oppdatere den. I st&#248;rre prosjekter vil det v&#230;re hensiktsmessig &#229; bruke en form for global state management som React Redux eller Mobx. Da vil dataen oppdateres automatisk, og v&#230;re&#160;tilgjengelig globalt i prosjektet.&#160;<\/p><p>&#160;<\/p><p>For &#229; ta et eksempel s&#229; vil Redux gi en &#34;uni-directional&#34; dataflyt, som vil si at det bare g&#229;r en vei. N&#229;r noe i applikasjonen blir interagert med, vil dette bli regnet som en &#34;action&#34;. Denne &#34;action&#34;-en vil igjen bli h&#229;ndtert i en reducer som oppdaterer staten. Reduceren returnerer en ny state basert p&#229; den gamle staten + den spesifikke &#34;action&#34;-en som blir gjort. De ulike reducerene blir samlet i en &#34;store&#34; som holder all state i applikasjonen.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt eksperimentelt state-management bibliotek for React. Det blir introdusert &#34;atoms&#34; og &#34;selectors&#34;. Her er &#34;atoms&#34; brukt for &#229; lagre den lokale staten til react-komponentene, og &#34;selectors&#34; brukt for &#229; endre &#34;atom&#34;-staten. Komponenter kan &#34;subscribe&#34; til en &#34;selector&#34;, som vil medf&#248;re at den blir oppdatert (re-rendra) n&#229;r slectoren endres.&#160;<\/p><p>&#160;<\/p><p>I listen med l&#230;ringsm&#229;l har vi l&#230;rt &#229; bruke&#160;React-Redux og Mobx. Dette nye biblioteket kan v&#230;re en mulig konkurrent for disse.&#160;<\/p><p>&#160;<\/p><p>en fordel med Recoil sin dataflyt gj&#248;r slik at du kan sende state (atoms) gjennom funksjoner og inn i en React-komponent uten &#229; m&#229;tte tenke p&#229; at hele applikasjonen m&#229; oppdateres som i foreksempel Redux (med store).&#160;<\/p><p>&#160;<\/p><p>Recoil gir tilgang til en delt atom-state som ligner veldig p&#229; setState.&#160;<\/p><p>&#160;<\/p><p>en ulempe med Recoil er at det er basert p&#229; react hooks som f&#248;rer til at det kun vil funke for funksjonelle komponenter.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3233,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST har fordelen av caching p&#229; HTTP-layeret som er st&#248;ttet av alle nettlesere. Dette er ikke tilfelle med GraphQL.<\/p><p>&#160;<\/p><p>REST API har ikke type-kontroll, mens GraphQL har et system for det.<\/p><p>&#160;<\/p><p>GraphQL kan bli sett p&#229; som en graf der alt er samlet i&#160;1 endepunkt, mens REST har mange. Dette p&#229;virker b&#229;de&#160;fleksebilitet og effektivitet:<\/p><p>&#160;<\/p><p>REST kan&#160;kreve&#160;flere foresp&#248;rsler til ulike endepunkter&#160;for &#229; fetche &#248;nsket data. Med Graphql er det nok med en query som spesifiserer hvilken data som er &#248;nsket.&#160; REST er fortsatt et veldig fleksibelt valg, da data ikke er bundet til noen spesifikke metoder.<\/p><p>&#160;<\/p><p>Med REST er det ogs&#229; ganske vanlig &#229; oppleve &#34;over- og underfetching&#34;. Dette vil si at klienten enten laster ned for mye informasjon, eller at endepunktet ikke inneholder nok informasjon slik at flere foresp&#248;sler er n&#248;dvendig. GraphQL er mer spesifikk, og gir klare instrukser til backend om hvilke data som skal hentes. Dette kan spare ressurser p&#229; serveren da mindre prosessering er n&#248;dvendig.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker ogs&#229; &#34;schema&#34; som gj&#248;r det lettere for frontend og backend &#229; jobbe individuelt. Begge parter har oversikt over data-strukturen.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534159,"ext_inspera_userAssessmentSetupId":7139993,"ext_inspera_userAssessmentId":4841286,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Almestad Elise (10082)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303560,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2756,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De teknikkene jeg kommer til &#229; nevne som brukes for tilstand og dataflyt i React-applikasjoner er Context, react props, Redux og MobX. Her vil jeg gj&#248;re rede for hva de ulike teknikkene er og nevne forskjeller og ulikheter.&#160;<\/p><p>&#160;<\/p><p><strong>Context -&#62;<\/strong>&#160;Fordelen med Context API fremfor bruk av state er n&#229;r flere komponenter skal ha tilgang til samme data, er det enklere &#229; n&#229; dataen med context. Dette er fordi man slipper &#229; sende props manuelt ned i hvert niv&#229; av treet. Context provider alts&#229; denne fordelen.&#160;Det l&#248;nner seg &#229; bruke context hvis treet har 3 + niv&#229;er. Hvert context objekt f&#248;lger med en provider og consumer. Provideren lar oss sende props nedover. Hvis Consumeren er etterkommer av en provider, s&#229; vil den re-rendere hver gang provideren sin verdi endrer seg.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>React props -&#62;&#160;<\/strong>Dette er en av reacts stoltheter, nemlig props. Props er en funksjon som gir en verdi, som blir sendt inn/ delt mellom komponenter i et hierarktisk tre. Props kan sendes nedover i hvert niv&#229; av dette treet. Kan ogs&#229; bli sett p&#229; som argumenter som blir brukt/sendt inn i komponenter. Det er ogs&#229; en verdi som er &#34;read-only&#34;. Det betyr at n&#229;r propen sendes fra parent til child komponenten, s&#229; kan ikke child komponenten endre verdien, bare lese verdien. Viktig forskjell her er at b&#229;de props og context sender props fra &#34;parent&#34; to &#34;child&#34; komponent, mens redux har ikke samme hieraktiske ordning. I Redux kan man sende props hvor som helst.&#160;<\/p><p>&#160;<\/p><p><strong>Redux -&#62; <\/strong>Redux er et open-source bibliotek som egner seg godt n&#229;r man vil ha et forutsigbart oppbevaringssted for applikasjonstilstanden. Redux har en store som kan se ut som et tre. Denne store er oppdatert gjennom noe som kalles for en reducer, som vanligvis skal&#160; endrer en handling eller en verdi. N&#229;r den endrer verdien i storen s&#229; blir brukergrensesnittet oppdatert. Denne prosessen utf&#248;res ved at du dispatcher en action og s&#229; har en type action man planlegger &#229; gjennomf&#248;re. Denne actionen vil ha en verdi som dermed blir f&#248;rt gjennom en reducer som til slutt oppdqterer den uforanderlige tilstanden&#160;til storen.&#160;<\/p><p>&#160;<\/p><p><strong>MobX -&#62;&#160;<\/strong>Denne teknikken for tilstand og datafly har events som har actions. Disse actionsense&#160;oppdaterer noe man kaller for observables som dermed utl&#248;ser en reaksjon hvor enn denne obeservabelen har blitt brukt. Fordelen med dette er at det kanskje bare er noen f&#229; komponenter som m&#229; endres og man slipper &#229; endre alt. N&#229;r komponentene oppdateres s&#229; vil ogs&#229; UI (brukergrensesnittet) endres.<\/p><p>Mobx er derimot anebfalt dersom du har et lite team som skal starte et webapplikasjonsprosjekt fordi det krever mindre tid &#229; sette seg inn i og er mer fleksibelt enn redux (mtp store f.eks).&#160;&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2562,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De to viktige delene av recoil er Atoms og Selectors. Atoms er states som komponenter kan knytte seg til. Hver gang en state blir endret, s&#229; vil de tilh&#248;rende komponentene ogs&#229; bli re-rendret og endret. Selectorer er funksjoner som brulker atoms som inputargument. P&#229; samme m&#229;te som atoms, s&#229; kan ogs&#229; komponenter knytte seg til selectors, og hver gang en selector endrer seg s&#229; vil komponentene ogs&#229; bli re-rendret.&#160;<\/p><p>Dette kan sammenlignes med MobX hvor det kan finnes flere stores hvor man kan endre verdien tilknyttet, direkte. Alts&#229; s&#229; har begge bibliotekene en mutable/foranderlig state. Dette blir da ulikt fra redux siden redux har en store som er uforanderlig. Dette er fordi redux lar deg ikke endre storen med mindre du g&#229;r gjennom reducers og actions, mens mobX har gir deg direkte tilgang til storen(e). Det som er positivt med en immutable/uforanderlig store er at man ikke gj&#248;r endringer som egentlig ikke var meningen &#229; gj&#248;re, som da kan skje i mobX hvor man da kan endre variabler gjennom f.eks. funksjoner og komponenter. Disse endringene vil da automatisk re-render i applikajsonen.&#160;&#160;<\/p><p>&#160;<\/p><p>Recoil l&#248;ser mange av problemene som context st&#248;ter p&#229; og det g&#229;r f.eks. ut p&#229; det at context bare kan holde p&#229; enkelt verdier, mens recoil kan holde p&#229; uendelige verdier. Andre problemer som blir addressert av recoil som context ikke l&#248;ser er at hvis context m&#229; sende opp delte tilstander s&#229; m&#229; disse verdiene muligens gjennom mange niv&#229;er i treet og m&#229; da re-rendere treet. Recoil har en annen struktur, alts&#229; en rettet graf, ortogonal (rett p&#229; en linje), som ogs&#229; er knyttet til react treet, og da vil dette problemet bli l&#248;st. Alts&#229; vil Recoil utnytte React sine fordeler ved &#229; blir insspirert av React og utnytte react sitt oppsett for l&#248;se problemer som context har &#229; by p&#229;.&#160;&#160;<\/p><p>&#160;<\/p><p>I tillegg til diskuterte fordeler og ulemper over s&#229; er en annen&#160;ulempe med recoil kan v&#230;re det at det er et nytt open source bibliotek for React, som betyr at det fortsatt b&#229;de er under utvikling og ikke er s&#229; godt dokumentert. Dette betyr at det byr p&#229; en l&#230;ringskurve og det kan ta tid &#229; sette seg inn i.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1761,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De to som skal sammenlignes er to APIer. Et API er et grensesnitt, n&#230;rmere definert: &#34;Application programming interface&#34;. Dette kan sammenlignes med en reglebok og da brukes til kall p&#229; applikasjonen eller biblioteket. Dette grensesnittet ligger i programvaren og det gj&#248;r at deler av den kan aktivieres fra andre programvare(r).<\/p><p>&#160;<\/p><p>Hovedforskjellen mellom REST API og Graphql er at REST API har flere endepunnkter, mens graphql har et endepunkt. Det betyr at REST API krever flere URLs for &#229; hente ut dataen mens graphql krever&#160;bare en URL/request&#160;for &#229; hente den n&#248;dvendige dataen.Ytelsen kan dermed v&#230;re et problem for REST API fremfor graphql, siden man slipper &#229; sende s&#229; mange requests.&#160;Dette igjen resulterer i at siden graphql kun har et endepunkt s&#229; vil denne api&#39;en v&#230;re organisert i former og typer fremfor endpunkter. Endepunktene som REST API har er DELTE, PUT, GET, POST. Graphql bruker bare&#160;POST som request.<\/p><p>&#160;<\/p><p>En annen forskjell p&#229; REST API og Graphql er at REST API henter ut hele datasettet, mens Graphql setter begrensninger og ehnter ut dataen man vil ha. Dette gj&#248;r at man slipper &#229; &#34;over fetche&#34; Samtidig s&#229; vil REST API v&#230;re med skalerbar gjennom denne forskjellen.&#160;<\/p><p>&#160;<\/p><p>Det at REST API m&#229; sende flere request gj&#248;r at REST API er mer skalerbart. REST API er ogs&#229; stateless fordi den lagrer applikasjonstilstanden p&#229; klienten istedenfor serveren. Mens Graphql ligger n&#230;rmere serveren fordi den er basert p&#229; struktur som inneholder former og typer.<\/p><p>&#160;<\/p><p>REST API er i tillegg et mer etablert og kjent API fremfor grqphql. Dette gj&#248;r at graphql kommer med en bratt l&#230;ringskurve. Selvom graphQL f&#248;lger med en fleksibilitet som er nevnt over, s&#229; vil det dermed ikke alltid l&#248;nne seg for enkle API&#39;er og viktig &#229; overveie b&#229;de fordeler og ulemper f&#248;r man velger en av de til prosjektet sitt.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534345,"ext_inspera_userAssessmentSetupId":7140067,"ext_inspera_userAssessmentId":4841136,"dateLastModified":"2020-12-01T10:01:22Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:22Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ødegård Hanne Kyllo (10068)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":26655202,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2211,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Klassekomponenter har state og props som attributter. Her settes&#160;dataverdiene props ved kall/initialisering (disse er&#160;immutable), mens de interne variablene, states, kan oppdateres. Begge kan sendes nedover i hierarkiet. For funksjonelle komponenter blir Hooks tatt i bruk for &#229; holde orden p&#229; disse statesene. Den enkleste m&#229;ten &#229; gi en komponent tilgang til &#229; endre en annen komponents state er &#229; sende callback funksjoner&#160;for dette inn i barnekomponentene. Dette blir immidlertid sv&#230;rt tungvint ved store applikasjoner samt n&#229;r samme state skal brukes og settes i flere komponenter. I slike tilfeller b&#248;r man introdusere et global state management system. Dette tillater at de globale statesene kan lagres og hentes av hvert niv&#229; i hierarkiet. Det finnes flere mulige l&#248;sninger for dette, men de som er brukt i faget er mobx, redux og context (fra React) (noen har ogs&#229; brukt apollo).&#160;<\/p><p>Redux tar i bruk actions og reducers for &#229; endre og oppdatere states. For dette brukes dispatch som tar inn den gitte handlingen den skal utf&#248;re. Som en trygghet kan ingen andre deler av koden endre state.<\/p><p>MobX differensierer fra Redux ved at den har observable state, den gj&#248;r datastrukturer observerbare og tillater observat&#248;rer. MobX gj&#248;r det lettere &#229; oppdatere states enn Redux ved at den lar brukeren lage egne funksjoner for oppdatering som kan kalles fra hvor som helst i koden.&#160;<\/p><p>Context API kommer fra React (introdusert i 2018) og l&#248;ser i de fleste tilfeller de samme problemstillingene som MobX og Redux. Minuset med context er immidlertid at det ikke tillater deling av states mellom container komponenter, noe som medf&#248;rer at man fortsatt har behov for de overnevnte teknologiene.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1906,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. Det baserer seg p&#229; atomer som holder states og&#160;selektorer som er funksjoner som avlede states og sende dem til komponenter.&#160;<\/p><p>Atomene kan leses til og skrives til fra hvilken som helst komponent i hierarkiet ved hjelp av selectors. I motsetning til f.eks. context APIet m&#229; atomene derfor ikke v&#230;re lagret i rotnoden. Context APIet kan heller ikke lagre mer enn en verdi per variabel, mens Recoil tillater flere verdier med sine egne konsumere.<\/p><p>I motsetning til redux og mobX krever ikke Recoil stores siden&#160;all data er lagret i atomene. Den krever heller ikke spesielle funksjoner for oppdatering (reducers og actions) for &#229; oppdatere states slik Redux gj&#248;r. Syntaksen er veldig lik vanlig React og man slipper unna all boilerplatekoden man trenger i Redux.<\/p><p>I likhet med MobX vil en endring av state f&#248;re til at alle observat&#248;rene ogs&#229; gj&#248;r endringer som samsvarer og Recoil tillater ogs&#229; stor fleksibilitet i designet av statene.<\/p><p>&#160;<\/p><p>Noen av de store fordelene jeg ser er enkelheten med det mtp enkel syntaks, lett tilgjengelige states, enkle og endre samt hente avledede variabler.&#160;<\/p><p>Det st&#248;rste minuset er at biblioteket er veldig nytt og derfor trolig vil ha noen bugs og gjennomg&#229; flere endringer i den neste tiden, noe som kan f&#248;re til mye arbeid med vedlikehold.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2061,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST overf&#248;rer tilstand ved GET, PUT, POST og DELETE ved hjelp av HTTP requests, mens GraphQL baserer seg p&#229; sp&#248;rringer sendt til en server. For GraphQL er b&#229;de s&#248;ket&#160;og dataen som skal returneres definert, mens for REST gjelder dette bare dataen. Med&#160;GraphQL kan all data hentes p&#229; en sp&#248;rring og typesjekkes, noe som er verre for REST da det kan v&#230;re behov for &#229; hente data fra flere endepunkter og overfetching fort kan skje (Selv om dette ikke er farlig, krever det un&#248;dvendig tid og minne). En av fordelene til REST er at den utnytter caching-mekanismene i nettleserne den henter fra, dette kan ikke GraphQL gj&#248;re siden den henter rett fra serveren. GraphQl st&#248;tter ogs&#229; bare json, mens REST st&#248;tter flere formater som XML. Rest er ogs&#229; state-less.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534572,"ext_inspera_userAssessmentSetupId":7139965,"ext_inspera_userAssessmentId":4841290,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aase Aksel Lunde (10032)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34408397,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2751,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Prim&#230;rt har man react&#39;s egen state tilgjengelig. Dette kan man benytte v.h.a. `useState`-hooken i funksjonelle komponenter, eller `this.state` og `this.setState()`-egenskapene i klasse-komponenter. Hver gang man oppdaterer state v.h.a. for eksempel `this.setState()`, vil React s&#248;rge for at komponenten f&#229;r en sjanse til &#229; re-rendre. P&#229; denne m&#229;ten s&#248;rger man f&#229;r at brukergrensesnittet alltid gjenspeiler den siste staten man har satt, i stedet for &#229; vise utdatert data. Det er viktig &#229; ta hensyn til at state ikke er mutable. Det vil si at enhver endring man skal gj&#248;re p&#229; staten skal gj&#248;res via en setState-funksjon, i stedet for eksempelet under. Grunnen til dette er at dersom man muterer staten f&#229;r ikke React n&#248;dvendigvis med seg den endringen, og rerendrer derfor ikke komponenten, som gj&#248;r at UI havner out-of-sync med faktisk state. Man bruker alts&#229; setState for &#229; eksplisitt instruere react om at staten har oppdatert seg.<\/p><pre class=\"pre-formatted\">function WrongStateExample() {<\/pre><p>&#160;&#160;&#160; const [state, setState] = useState({prop: 5});<\/p><p>&#160;&#160;&#160; setTimeout(() =&#62; state.prop = 6, 1000); // Her burde `setState({prop: 6})` heller blitt brukt<\/p><p>&#160;&#160;&#160; return (&#60;div&#62;{state.prop}&#60;/div&#62;);<\/p><p>&#160;&#160;&#160; /*<\/p><p>&#160;&#160;&#160;&#160; Aller helst burde man brukt<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const [prop, setProp] = useState(5);<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .... setProp(5) ....<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return (&#60;div&#62;{prop}&#60;/div&#62;);<\/p><p>&#160;&#160;&#160; */<\/p><p>}<\/p><p>&#160;<\/p><p>En m&#229;te &#229; unng&#229; dette p&#229; er &#229; bruke Mobx. Mobx er et tredjepartsbibliotek som fors&#248;ker &#229; etterlikne standard JS-&#34;bruk&#34; og tilllater mutering av state gjennom vanlige objektreferanser. I MobX bygger man en &#34;store&#34; (samling av state med felles tema), og denne storen er s&#229;kalt observerbar. Det vil si at man kan observere og reagere p&#229; endringer av state i storen - reactive programming. Deretter kan man bygge observers - funksjoner eller React-komponenter som lytter til endringer i storen. Ved &#229; oppdatere storen med vanlig JS-assignments vil da alle observers som er avhengig av den ber&#248;rte state-verdien ogs&#229; varsler, som igjen vil oppdatere eventuelle React-komponenter og s&#248;rge for at UI er in-sync. Eksempel:<\/p><pre class=\"pre-formatted\">const { observable, autorun } = require(&#39;mobx&#39;);<\/pre><p>const store = observable({<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; prop: 5<br />});<\/p><p>autorun(() =&#62; console.log(store.prop)); // prints &#34;5&#34;, and attaches the arrow function as an observer to the store.prop property<\/p><p>store.prop = 6; // Updates the store and notifies any observers, thus &#34;6&#34; is printed.<\/p><p>&#160;<\/p><p>Et tredje, mye brukt, alternativ er Redux og react-redux bindingene. Redux fungerer ogs&#229; ved bruk av &#34;stores&#34;, men bruk og endring av state skjer mye mer eksplisitt enn i MobX, og minner om bruken av eksplisitt &#34;setState&#34; i React. I redux konfigurerer man nemlig en store, og den kan utelukkende oppdateres gjennom <em>actions<\/em>, som tolkes av storen p&#229; en eksplisitt m&#229;te. Lettere &#229; forklare med et eksempel. I koden under implementeres en <em>reducer<\/em>, alts&#229; en funksjon som tar inn n&#229;v&#230;rende state, og en action for &#229; oppdatere staten til en ny versjon. Reduceren returnerer den oppdaterte staten, og kan tolke actions som den &#248;nsker. Man kan alts&#229; implementere kompleks funksjonalitet i reduceren, slik at det &#229; oppdatere staten med en kompleks handling ofte kan gj&#248;res med en enkel dispatch med riktig action-type. Etter reduceren er definert kan man opprette en store (objektet som inneholder staten), og fra denne kan man hente ut n&#229;v&#230;rende state med `getState()`, og oppdatere staten ved &#229; kalle `dispatch` med en passende action. Denne actionen vil da g&#229; via reduceren v&#229;r, og dermed f&#248;re til en ny versjon av staten. Vi ser her at det kreves mye mer eksplisitt kode for &#229; oppdatere state (og ogs&#229; reagere p&#229; endringene, vi m&#229;tte gjenta console.log-linjene for hver oppdatering). Heldigvis s&#248;rger react-redux bindingene for &#229; automatisk oppdatere React-komponenter dersom de er avhengige av en store som endrer state, slik at man ogs&#229; med redux enkelt kan bruke reactive programming. M&#229;ten dette knyttes til React p&#229; er ved &#229; bruke React-komponenten `Provider` fra Redux som man wrapper rundt hele komponenttreet sitt. Provider bruker en react context for &#229; gj&#248;re store-objektet tilgjengelig nedover hele komponenttreet, og dermed slipper man &#229; gi storen som props hele veien ned. Dette brukes enklest sammen med funksjonelle komponenter, der man har `useDispatch` og `useSelector`-hooks tilgjengelige. Dersom man bruker disse hooksene eksplisitt vil react-komponenten oppdateres n&#229;r relevant state i storen oppdateres. Fordelen med MobX er at mye av koden gjemmes vekk og man slipper &#229; tenke p&#229; &#229; bruke spesielle funksjoner for &#229; hente og endre p&#229; state, men man kan argumentere for at man ogs&#229; mister en del kontroll dersom s&#229; mye gjemmes vekk.<\/p><pre class=\"pre-formatted\">const { createStore } = require(&#39;redux&#39;);&#10;&#10;function reducer(state, action) {&#10;        switch (action.type) {&#10;                case &#34;SET&#34;:&#10;                        return { ...state, prop: action.value };&#10;                case &#34;ADD&#34;:&#10;                        return { ...state, prop: state.prop + action.value };&#10;                default:&#10;                        return state;&#10;        }&#10;}&#10;&#10;const initialState = {&#10;        prop: 5&#10;};&#10;&#10;// Se oppgave 2 for et eksempel med middlewares&#10;&#10;const store = createStore(reducer, initialState);&#10;&#10;console.log(store.getState().prop);&#10;store.dispatch({type: &#39;ADD&#39;, value: 1});&#10;console.log(store.getState().prop);&#10;store.dispatch({type: &#39;SET&#39;, value: 7});&#10;console.log(store.getState().prop);<\/pre><p>NB! React props! Det inng&#229;r s&#229;klart under dataflyt det ogs&#229;. Fra en parent-komponent kan man gi `props` til child-komponenter, alts&#229; et dictionary med verdier rett og slett som child-komponenten kan bruke under rendring. Dette er vanligvis dataflyt nedover i treet (fra parent til child), s&#229; dersom man &#248;nsker at data skal flyte oppover i treet er det vanlig &#229; gi funksjoner som props til child-komponentene, s&#229;kalte callbacks. Dersom man for eksempel lager en egen Button-komponent vil det v&#230;re aktuelt at den komponenten tar inn en &#34;onClick&#34; prop, alts&#229; en funksjon som skal kalles n&#229;r knappen trykkes p&#229;. Da kan parent-komponenten gi inn en arbitr&#230;r funksjon, og n&#229;r knappen trykkes har alts&#229; parent-komponenten kontroll over hva som skjer, og man slipper at child-komponenten skal v&#230;re implementer spesifikt for &#229; utf&#248;re onClick-handlingen som parent-komponenten &#248;nsker &#229; utf&#248;re. Prinsippet med composability er sentralt i React - nemlig at man lager generiske komponenter som kontrolleres av props, slik at de kan gjenbrukes i mange forskjellige situasjoner.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2755,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er nok et bilbliotek for &#229; h&#229;ndtere state i react-applikasjoner. Recoil har trekk fra alle de tre variantene i forrige oppgave, og har med dette b&#229;de styrker og svakheter sammenliknet med alternativene. For det f&#248;rste ser jeg at utviklerene har fors&#248;kt &#229; gj&#248;re det s&#229; enkelt som mulig &#229; migrere fra en vanilla react-app til &#229; bruke recoil. Man trenger kun wrappe appen sin i en &#60;RecoilRoot&#62; (som sannsynligvis bruker Context eller liknende for &#229; gi en state-store nedover i treet), og deretter erstatte bruk at useState med useRecoilState (samt &#229; endre argumentet fra default-value til en instans av `atom` eller `selector`, mer om disse senere). En stor fordel vil alts&#229; v&#230;re at dette er enkelt &#229; benytte i en allerede deployet app.<\/p><p>&#160;<\/p><p>Man har s&#229; klart utvidet funksjonalitet utover dette, og kan benytte useRecoilValue for &#229; kun lese state, eller useSetRecoilState for &#229; kun skrive state. Dette er n&#248;dvendig ettersom Recoil benytter et observer-m&#248;nster som minner litt om MobX. En komponent som <em>leser<\/em> en verdi fra en state sies &#229; observere den staten, og vil rerendres dersom staten oppdaterer seg. Derimot vil en komponent som kun skriver til en state ikke v&#230;re avhengig av verdien, og trenger derfor ikke oppdateres heller. Riktig bruk av useRecoilValue og useSetRecoilState er derfor en performance-optimization. Derimot skrives kode mye mer eksplisitt med recoil enn i MobX, da man fremdeles har eksplisitte funksjoner for &#229; lese og endre state.<\/p><p>&#160;<\/p><p>Recoil&#39;s state/store er bygd opp av flere sm&#229; <em>atomer<\/em>, alts&#229; enkeltverdier adskilt fra andre verdier i storen. Atomer skrives alltid i sin helhet, og man kan derfor ikke mutere en property til et atom, men kun erstatte hele verdien. Dette er for at Recoil alltid skal f&#229; med seg endring av state for &#229; unng&#229; UI-out-of-sync, som diskutert i oppgave 1. Atomer leses ogs&#229; i sin helhet, men ved &#229; bruke <em>selector<\/em>s kan man omg&#229; dette til en viss grad. En selector fungerer likt som et atom med hensyn til useRecoilState og gjengen, men inneholder ikke state selv. N&#229;r verdien av en selector hentes vil selectoren hente verdi fra et eller flere atomer, og deretter avlede en ny verdi fra atomene. En selector kan dermed brukes for &#229; hente ut en dypt n&#248;stet property fra et atom og ryddigj&#248;re kode som bruker denne dypt-n&#248;stede egenskapen flere ganger.<\/p><p>&#160;<\/p><p>En fordel med atom-strukturen er at en store kan v&#230;re definert sammen med komponentene som hovesakelig bruker den. I en Todo-app kan staten med todo-listen v&#230;re definert sammen med selve komponenten, i stedet for i en separat del av kodebasen. Likevel er staten tilgjengelig for andre komponenter i koden (gitt at atomet eksporteres), i kontrast til React&#39;s interne useState() som er privat innad i komponenten. Andre vil argumentere for at Redux sin m&#229;te &#229; definere all state p&#229; samme sted er fordelaktig, da man kan ha mye bedre oversikt over den samlede staten i appen. Ved &#229; bruke samlet state kan man ogs&#229; implementere felles-funksjonalitet for alle state-operasjoner, og da tenker jeg p&#229; redux&#39;s middelwares. Dette er ekstra &#34;lag&#34; over redux-storen som kan utf&#248;re komplekse interaksjoner med f.eks. en backend (vha. redux-thunk), som fremdeles kan kj&#248;res ved et enkelt dispatch-kall. Dersom man &#248;nsker &#229; loggf&#248;re alle state-operasjoner kan man enkelt implementere en ekstra logging-middleware som kj&#248;res for hver eneste dispatch (se eksempel under). Slik felles funksjonalitet kan v&#230;re vanskeligere &#229; oppn&#229; n&#229;r state er spredt p&#229; tvers av mange filer. En naiv l&#248;sning vil v&#230;re &#229; manuelt kalle `console.log` hver gang man oppdaterer staten til et atom, og det er &#229;penbart ikke skalerbart. Riktignok har Recoil innebygd st&#248;tte for async selectors, noe som tillater samme funksjonalitet som redux-thunk gj&#248;r, bare at funksjonen kalles idet data hentes fra storen i steder for n&#229;r det dispatches til storen.<\/p><p>&#160;<\/p><p>Logging-middleware-eksempel (passer inn i eksempelet fra oppgave 1, bare inkluder `applyMiddleware` i import-statementet ogs&#229;):<\/p><pre class=\"pre-formatted\">const logger = (_) =&#62; (next) =&#62; (action) =&#62; {&#10;  console.log(action.type);&#10;  return next(action);&#10;};&#10;&#10;const middleware = applyMiddleware(logger);&#10;const store = createStore(reducer, initialState, middleware);<\/pre>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1653,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En stor forskjell mellom protokollene er valg av datastruktur for sp&#248;rringer og responser. REST bygger i st&#248;rst mulig grad p&#229; den standard HTTP-protokollen, og benytter features fra denne for &#229; forflytte data. Eksempelvis brukes URLen for &#229; spesifisere hvilken data som skal aksesseres, og HTTP-metoden brukes aktivt mellom GET/POST/PUT/DELETE for &#229; spesifisere hvilken handling som skal gj&#248;res p&#229; dataene. GraphQL benytter derimot en fast URL som endepunkt, benytter riktignok GET/POST for &#229; skille mellom lese/skrive-operasjoner, men resten av queryet er spesifisert i en streng/JSON-payload som sendes som data over HTTP-requesten.<\/p><p>&#160;<\/p><p>Denne forskjellen p&#229;virker i stor grad resten av API-designet. Ettersom JSON er langt mer fleksibelt og kan modellere mange forskjellige datastrukturer, forenkler det komplekse handlinger med noks&#229; enkle queries. Eksempelvis kan klienten spesifisere n&#248;yaktig hvilke felter som &#248;nskes, slik at ikke un&#248;dvendig mye data sendes fra serveren (over-fetching). Klienten kan ogs&#229; spesifisere at den &#248;nsker flere objects i samme query, for eksempel all info om en forfatter, men ogs&#229; alle b&#248;ker forfatteren har skrevet, og info om alle medforfattere for hver bok. Dette kan gj&#248;res i &#233;n request, og hindrer situasjoner der klienten m&#229; utf&#248;re flere requests for &#229; f&#229; tak i all dataen den trenger (underfetching). Her kan nemlig REST bli noe begrenset av URL-formatet for &#229; spesifisere data. Ett REST-endepunkt tilsvarer en fast datastruktur, og hvis klienten &#248;nsker mer data utover dette m&#229; klienten selv f&#248;lge opp med flere requests til andre endepunkter for &#229; hente resten av dataene.<\/p><p>&#160;<\/p><p>REST har derimot en fordel med simplisitet. Endepunkt-URLer er veldig enkle &#229; forst&#229;, og kan lett leses utifra eksisterende verkt&#248;y (f.eks. nettverkstabben i DevTools i diverse nettlesere). Her er det vanskeligere &#229; f&#229; innsikt i GraphQL-dataflyt, men det skal sies at det finnes veldig gode verkt&#248;y for GraphQL-debugging ogs&#229;. Under prosjekt 3 brukte jeg selv Apollo Playground aktivt for &#229; enkelt teste GraphQL-sp&#248;rringer mot backenden min, og standard JS debugging-teknikker fungerer veldig fint for &#229; forst&#229; den interne dataflyten i backenden.<\/p><p>&#160;<\/p><p>Ofte koker det ned til hvilke data man &#248;nsker &#229; tilgjengeliggj&#248;re. Har man et innviklet datasett med mange relasjoner (n&#248;kkelord) mellom objektene, da kan det l&#248;nne seg &#229; bruke GraphQL for &#229; forenkle det &#229; sp&#248;rre etter alle disse relasjonene. Har man derimot mange separate objektklasser der man sjeldent trenger &#229; sp&#248;r p&#229; tvers av objektklasser eller spesifisere hvilke felter fra objektene man &#248;nsker, da kan en REST-API v&#230;re enklere &#229; implementere. Eksempelvis implementerte jeg selv en liten REST-server p&#229; et hobbyprosjekt (raspberry pi som skrur av/p&#229; str&#248;mmen til en TV-skjerm via. en mekanisk relay), og her brukte jeg et enkelt REST-endepunkt med metodene POST /tv?state=on og POST /tv?state=off, samt GET /tv for &#229; hente staten. En GraphQL-API her ville v&#230;rt overkill fordi det rett og slett er ekstremt enkel data &#229; h&#229;ndtere, og det ville ogs&#229; tatt mye lengre tid &#229; implementere. Dette er s&#229; klart en veldig liten applikasjon, men illustrerer eksempelet om at use-case alltid vil p&#229;virke hva som er den beste l&#248;sningen.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11535482,"ext_inspera_userAssessmentSetupId":7139920,"ext_inspera_userAssessmentId":4841335,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bognæs Oscar Selnes (10185)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35329755,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1715,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>State:<\/strong><\/p><p>For klasse-komponenter h&#229;ndteres dette med state i konstrukt&#248;ren (this.state = {name: &#34;Carl&#34;}) og oppdateres med this.setState({name: &#34;Bob&#34;}) hvis du vil endre p&#229; state objektet name.<br /><br />For react med bruk av hooks definerer man state med const [name, setName] = useState(&#34;Carl&#34;) hvor man tar i bruk react sin useState hook og bruker setName til oppdatere state. Eksempel p&#229; oppdatering setName(&#34;Bob&#34;)<\/p><p>&#160;<\/p><p><strong>Props:<\/strong><\/p><p>For &#229; sende informasjon nedover i komponenttreet bruker man props, dette er properties man legger ved n&#229;r man bruker en komponent. Her kan man f.eks. sende ned &#60;Komponent color=&#34;#c4c4c4&#34;/&#62; som kan brukes i Komponent-komponenten i dette eksempelet.<\/p><p>&#160;<\/p><p>Props kan hentes som this.props for klasse komponenter og i react med hooks lage et interface props som inneholder alle verdiene eller bare bruke sende props inn som argument i den funksjonelle komponenten.<\/p><p>&#160;<\/p><p><strong>Callback funksjoner:<\/strong><\/p><p>Callback funksjoner er en m&#229;te for en child-komponent &#229; sende informasjon til parent. I parent sender man ned en funksjon som prop som en child-komponent kan f.eks. bruke p&#229; en kanpp for &#229; toggle mellom verdier eller endre p&#229; ting i parent. Eksempel p&#229; bruk:&#160;&#60;Button&#160;onClick={setMsgButton}/&#62; i child blir dette tatt i mot som&#160;en funksjon&#160;som tar imot en string og som ikke returnerer noe (onClick:&#160;(<em>arg0:&#160;string)&#160;=&#62;&#160;void<\/em>).<\/p><p>&#160;<\/p><p><strong>Andre m&#229;ter:<\/strong><\/p><p>Det kan fort bli veldig komplisert &#229; sende ting opp og ned i komponentstrukturen n&#229;r vi begynner &#229; f&#229; en stor applikasjon med mange komponenter, det kan da v&#230;re lurt &#229; bruke en global state manager. Eksempler p&#229; disse er f.eks. Context, Mobx eller Redux. M&#229;ten disse funker p&#229; er at de holder p&#229; alle tilstandene p&#229; ett sted og lar alle komponentene ha tilgang til tilstanden. Gjerne kommer det med en funksjon for &#229; endre p&#229; tilstanden ogs&#229;.<\/p><p>For Context fungerer dette med at vi har en provider som wrapper hele prosjektet og lar alt inni ha tilgang til &#229; endre og &#229; lese tilstanden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2649,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil<\/strong> er en type state management som skal l&#248;se samme problem som Redux og Context. Recoil bruker det som heter <strong>Atoms <\/strong>(Shared state)&#160;som komponenter kan &#34;abonnere p&#229;&#34;. N&#229;r det skjer en endring i state vil <strong>kun<\/strong> komponentene som abonnerer p&#229; det Atomet som holder tilstanden re-rendre. Flere komponenter kan abonnere p&#229; samme Atom og de vil da oppdateres likt. <strong>Selector&#160;<\/strong>er en ren funksjon som tar imot Atoms eller andre selectors som input. Selectors er brukt for &#229; modifisere og endre p&#229; anskaffet data basert p&#229; state. Dette kan f.eks. v&#230;re &#229; lage en ny liste fra listen i state som er sortert eller flitrert basert p&#229; et spesifikt kriterie. Komponenter kan ogs&#229; abonnere p&#229; Selectors<br /><br />Fordeler med &#229; bruke Recoil ovenfor f.eks. <strong>Context api&#39;et<\/strong> er at i Recoil er det <strong>kun<\/strong> komponentene som abonnerer p&#229; Atoms som blir oppdatert (re-rendered) mens i Context api&#39;et blir hele komponenttreet oppdatert. Context kan ogs&#229; kun lagre en verdi mens Recoil kan lagre et helt <em>set<\/em> med verdier som alle kan ha forskjellige abonnomenter.<\/p><p>&#160;<\/p><p><strong>Redux<\/strong> er ogs&#229; et&#160;vanlig state management. Men Redux har bare en kilde til staten, det som er lagret i store. dvs. staten er lagret et sted og er read-only og kan oppdateres med en funksjon. Mens Recoil kan ha Atoms som holder p&#229; tilstanden og selectors som modifiserer tilstanden, p&#229; denne m&#229;ten kan man f.eks ha tilgang p&#229; en sortert liste i state uten at man m&#229; ha logikken til &#229; sortere listen i hver komponent som bruker den.<\/p><p>&#160;<\/p><p>For <strong>MobX<\/strong> fungerer dette ganske likt som Recoil med at det er kun komponenter som bruker tilstanden som bli oppdatert. Man sier at en komponent er en observer og oppdaterer seg selv kun p&#229; endring.&#160;Dvs. jo mindre komponent man har jo mindre er endringen til re-render.&#160;<\/p><p>&#160;<\/p><p>Helhetlig virker det som at recoil er ment for &#229; v&#230;re simpelt og tar i bruk noe som minner om&#160;useState hooken til react med bruk av&#160;useRecoilState. En ulempe som ikke n&#248;dvendigvis er en sammenligning til de andre state managerene er at det st&#229;r at Recoil er ganske nytt, s&#229; det kan jo v&#230;re at det er feil eller mangler p&#229; utestede elementer av Recoil.<\/p><p>&#160;<\/p><p><br /><br /><strong>Kilder:<\/strong><\/p><p>https://recoiljs.org<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://recoiljs.org/docs/basic-tutorial/selectors/<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p><p>https://mobx.js.org/react-optimizations.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1817,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>REST API:<\/strong><\/p><p>Man definerer endepunkter som igjen&#160;henter ut informasjon fra databasen. Man kan f.eks. ha&#160;et&#160;movie-endepunkt som henter ut en film basert p&#229; tittel (f.eks. localhost:3000/api/movie/?title=Superman). Her m&#229; man definere alle m&#229;tene man mulig trenger for &#229; hente ut informasjon p&#229;. Alt av logikk for &#229; hente ut, filtere og sortere m&#229; ligge i endepunktene side det er de som bestemmer hva som blir hentet ut og returnert.<\/p><p>&#160;<\/p><p><strong>GraphQL:<\/strong><\/p><p>GraphQL er et sp&#248;rrespr&#229;k (query language) for api. Her beskriver man dataen sin og f&#229;r n&#248;yaktig det man sp&#248;r etter i form av et json objekt. Filtering og sortering gj&#248;res i enkelt i definisjonen av sp&#248;rringen. f.eks:<\/p><p>&#160;<\/p><p>Movie(filter: {title:superman}){<\/p><p>&#160; title<\/p><p>&#160; actors<\/p><p>}<\/p><p>&#160;<\/p><p>eller hvis du kun vil hente ut brukeren med id = &#34;542c2b97bac0595474108b48&#34;<\/p><p>&#160;<\/p><p>User(id: 542c2b97bac0595474108b48){<\/p><p>&#160; name<\/p><p>}<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>REST API vs GraphQL:<\/strong><\/p><p>Fordelene med &#229; bruke GraphQL er at man slipper &#229; definere alle mulige endepunkt for &#229; hente ut data, man trenger kun &#229; definere n&#229;r man skal bruke det. Med GraphQL er det ikke serveren som kontrollerer dataen, det er&#160;sp&#248;rringen. Dette gj&#248;r GraphQL raskere og mer stabli enn REST API.<\/p><p>&#160;<\/p><p>En ulempe med GraphQL er at alle applikasjonene som skal bruke API m&#229; ha egen kode for &#229; sende sp&#248;rringer mens i REST API er alle endepunktene der og det kan brukes av alle applikasjonene som trenger det&#160;s&#229; lenge det er tilgjengelig p&#229; en server. Ta eksemepelet med en filmdatabase, n&#229;r REST API er satt opp kan man lage s&#229; mange applikasjoner man bare vil som bruker samme endepunkt, i GraphQL m&#229;tte man ha laget egene sp&#248;rring per applikasjon som fungerte p&#229; samme m&#229;te.<\/p><p>&#160;<\/p><p>En annen ulempe med REST API er at man som regel kan f&#229;r det som heter over fetching eller under fetching hvor man f&#229;r for mye data eller for lite data mens i GraphQL f&#229;r man akkurat det man sp&#248;r etter.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><p>https://graphql.org/<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11535615,"ext_inspera_userAssessmentSetupId":7139955,"ext_inspera_userAssessmentId":4841158,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Øyhus Arnstein Thorstensen (10058)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331050,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2627,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En state i react er et innebygd&#160;objekt i en komponent som inneholder informasjon i form av variabler som kan forandre seg over tid. For &#229; endre p&#229; denne tilstanden kan man bruke en rekker verkt&#248;y<\/p><p>Hvordan disse endres p&#229; bestemmes ut fra komponenttypen. Ettersom en funksjonell komponent kun er en javascript funksjon kan man ikke benytte seg av setState p&#229; samme m&#229;te som man gj&#248;r i en class-komponent. Derfor benytter man seg av Hooks i funksjonelle komponenter. For &#229; bruke hooks m&#229; man importere useState fra React. Videre deklarerer man slik const [stateVar, setStateVar] = usestate(variabelInformasjon). Man kan n&#229; benytte seg av setStateVar(variabelinformasjon) for &#229; endre p&#229; tilstanden til stateVar. Dette er en annerledes m&#229;te &#229; endre state p&#229; enn i class-komponents der man endrer ved &#229; bruke this.setState({stateVar: variabelInformasjon}).<\/p><p>&#160;<\/p><p>Props<\/p><p>&#160;<\/p><p>Vi kan ogs&#229; bruke StateManagement bibliotek. Her kan vi flere biliotek &#229; velge mellom, men i dette emnet har vi hovedsaklig fokusert p&#229; 3 stykker: Redux, MobX og Context<\/p><p>&#160;<\/p><p>Redux har en enkelt store der man kan h&#229;ndtere tilstand.&#160;Man kan her ha flere undergrupper av tilstander. Disse vil v&#230;re tilgjengelige globalt s&#229; lenge man importerer denne undergruppen av tilstander. Om man oppdaterer staten i Redux vil ikke siden rerendres slik den gj&#248;r n&#229;r man ender state i komponenten. For &#229; benytte seg av disse undergruppene i state m&#229; man importere disse til komponenten. State i Redux er immutable. Alts&#229; er den read only. For &#229; endre p&#229; staten i Redux dispatcher man actions som endrer tilstanden i Redux storen<\/p><p>&#160;<\/p><p>MobX benytter seg ogs&#229; av Stores. Forskjellen her er at MobX kan ha flere stores. MobX er ogs&#229; bedre egnet for mindre prosjekter da det er enklere og sette opp. I kontrast til redux er staten i MobX mutable. Alts&#229; slipper man &#229; benytte seg av actions slik som i Redux.<\/p><p>&#160;<\/p><p>Context h&#229;ndterer ogs&#229; tilstand. Om man endrer tilstanden&#160;i context vil man da rerendre siden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1462,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for react. Biblioteket er<\/p><p>&#160;<\/p><p>Recoil benytter seg av atoms. Et atom fungerer som en tilstandsvariabel der man kan lagre data.<\/p><p>Dette fungerer p&#229; samme m&#229;te som en state i React der man kan endre p&#229; staten. Forskjellen er at atoms er globale, s&#229; man kan endre p&#229; disse fra en hvilken som helst komponent.&#160;<\/p><p>&#160;<\/p><p>For &#229; benytte seg av atoms bruker man selectors. Disse kan hente eller endre data i atoms.<\/p><p>&#160;<\/p><p>Endrer alt overalt i koden i<\/p><p>&#160;<\/p><p>Endre state hvor du vil<\/p><p>&#160;<\/p><p>context - recoil utviklet for &#229; dekke shortcomings til context. recoil er en&#160;mellomting<\/p><p>&#160;<\/p><p>Recoil maintainer&#160;en&#160;datagraph. Alts&#229; om noe blir oppdatert fetcher recoil denne dataen og oppdaterer tilstanden<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3098,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en arkitektur som gj&#248;r det enklere for systemer og kommunisere med hverandre. I REST&#160;henter man data fra et spesifikt endepunkt. Dette endepunktet kan for eksempel v&#230;re en&#160;url. Denne URLen inneholder da ett datasett. REST vil da hente ut hele dette datasettet. Denne filen kan da v&#230;re veldig stor, noe som betyr at vi muligens m&#229; laste inn en mye st&#248;rre mengde med data enn det vi egentlig trenger, dette kalles overfetching. For &#229; hente data bruker man Get. man kan ogs&#229; bruke Post, Delete og Put. Disse benyttes for &#229; henholdsvis opprette, slette eller endre p&#229; data.<\/p><p>&#160;<\/p><p>Graphql er derimot et query spr&#229;k.&#160;GraphQL opererer over et enkelt endpoint. N&#229;r man bruker REST for &#229; fetche informaon vil man alltid f&#229; tilbake hele datasettet til endepunktet&#160;man henter fra. Om man da vil hente data fra flere objekter m&#229; man ogs&#229; da komme med flere sp&#248;rringer. Med GraphQL slipper man &#229; g&#229; &#34;flere turer&#34; til endepunktet. I stedet kan man bruke GraphQL sp&#248;rringene til &#229; hente ut data fra flere objekter samtidig. Dette gj&#248;r at man slipper &#229; laste inn hele datasettet og s&#229; filtrere p&#229; dette slik man gj&#248;r i REST. I prosjekt 2 benyttet vi oss av REST for &#229; hente ut data fra poetryDB. Her endte vi da opp med &#229; bruke 8 forskjellige kall for &#229; hente ut 8 dikt. Om det hadde v&#230;rt mulig &#229; benytte GraphQL her ville det ha holdt med ett. Alts&#229; er GraphQL mer&#160;effektivt enn REST fordi man kun henter dataen man er ute etter.<\/p><p>&#160;<\/p><p>Et annet viktig element er hvor utbredt disse to teknologiene er. REST er sv&#230;rt utbredt og blir ofte sett p&#229; som en industristandar. GraphQL er ogs&#229; utbredt, men ikke i samme grad.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11535672,"ext_inspera_userAssessmentSetupId":7140029,"ext_inspera_userAssessmentId":4841166,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tveiten Lukas Nicholas (10125)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35109839,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1535,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En React-komponent best&#229;r av to hovedmekanismer for dataflyt: props og state. Props (kort for Properties) er egenskaper med en komponent som blir satt av foreldrekomponenten ved start. De er immutable, alts&#229; verdier som ikke kan endre tilstand. State er tilstand som blirt kontrollert internt i komponenten. State kan endres, og en endring vil som regel f&#248;re til re-rendring av komponenten, som i&#160;tillegg blir gjort asynkronisk&#160;s&#229; det ikke m&#229; fullf&#248;res fullstendig f&#248;r annen kode kan kj&#248;res.<\/p><p>&#160;<\/p><p>Vanlig dataflyt i en React-applikasjon er at foreldre-komponenter gir data nedover til child-komponentene gjennom props. Disse&#160;dataene kan ogs&#229;&#160;v&#230;re state og f&#248;re til re-rendring. Hvis man &#248;nsker at tilstand skal endres og reflekteres i foreledre-komponenten&#160;fra child-komponenten m&#229; man i tillegg sende med en &#34;callback&#34;-funksjon fra foreldrekomponenten. I st&#248;rre applikasjoner med mye data og mange komponenter, kan man f&#229; mye s&#229;kalt prop-drilling med mange props og callback-funksjoner som m&#229; sendes med. Da kan det v&#230;re hensiktsmessig &#229; bruke context-apiet som er innebygd i React og gj&#248;r at alle child-komponenter har tilgang til utvalgt data uten at det m&#229; sendes med som props. Det finnes ogs&#229; andre tredjepartsbiblioteker som kan gj&#248;re dette enklere, som for eksempel redux og mobx.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3539,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek, alts&#229; et verkt&#248;y som gj&#248;r det enkelere &#229; organisere global tilstander som skal brukes av flere komponenter og p&#229; forskjellig niv&#229; i komponent-hierarkiet. Det er spesielt laget for React og har dermed enkel og god integrasjon. Recoil har en sv&#230;rt enkel arkitektur/design ved at den tar i brukt to konsepter: atoms og selectors. Atoms er enkle tilstander som kan v&#230;re primitive verdier, objekter, arrays osv.. React-komponenter kan kan ta de i bruk p&#229; den vanlige m&#229;te man er vant med hvis man har brukt hooks, useRecoilValue&#160;istedenfor useState. Selectors er tilstand som er avledet av andre tilstander. Man kan dermed ha tilstander som dynamisk oppdaterer seg dersom annen tilstand som den er avhengig av oppdateres seg, i henhold til en ren funksjon. Fra komponent-perspektiv kan selectors bli lest p&#229; samme m&#229;te som atoms, med sm&#229; unntak.<\/p><p>&#160;<\/p><p>En fordel forhold til redux er at man ikke trenger &#229; bruke mye oppstartstid til &#229; sette opp actions, reducers og koble React-komponetene opp mot redux-store. Man kan i tillegg bruke de samme mekanismene for tilstandsh&#229;ndtering man er vant med fra React fra f&#248;r av, som gj&#248;r at kostnadene knyttet til &#229; l&#230;re seg bilbioteket blir mye mindre. Mye av den samme fordelen har man ogs&#229; med mobx, men vil p&#229;st&#229; at det er enda enklere med Recoil fordi det fungerer omtrent p&#229; samme m&#229;te som vanlig React.<\/p><p>&#160;<\/p><p>En annen ting som jeg vil si at Recoil er bedre enn n&#229;r det kommer til mobx, er at det er enklere dele opp tilstanden i atoms og ta i bruk selectors n&#229;r det er n&#248;dvendig. Det er mulig &#229; dele opp tilstand i mobx, men det krever at man m&#229; ha en context-komponent for hver av dem. Grunnen til at man vil dele opp tilstand p&#229; denne m&#229;ten er at man ikke &#248;nsker un&#248;dvendig re-rendring av komponenter som ikke bruker deler av tilstanden. Det er her jeg vil p&#229;st&#229; at redux generelt har en fordel, fordi man har st&#248;rre kontroll over hva som er actions, reducers osv. og man kan programmere disse til &#229; fungerere som man selv &#248;nsker (s&#229; lenge de holder med prinsippene om rene funksjoner osv.). Dette er en fordel som ikke bare gjelder med &#229; dele opp tilstand, men ogs&#229; andre ting som f.eks at man kan ta i bruk redux-thunks, som gj&#248;r det mulig &#229; ha callbacks (f.eks api-kall) etter tilstandsendringer. Man har generelt mer kontroll med redux, men samtidig gj&#248;r det at man programmere mer enn b&#229;de mobx og Recoil.<\/p><p>&#160;<\/p><p>Recoil er spesielt laget for React, og er dermed ikke laget for &#229; bli brukt for generelle JavaScript applikasjoner. Dette kan derimot redux og mobx. Hvis man hadde brukt et annet rammeverk som ikke var React, f.eks Angular, kunne man ikke brukt Recoil. Vet ikke om Recoil fungerer hvis man f.eks bruker ReactNative, men antar det siden tilstandsh&#229;ndtering er generelt det samme i React for web og React for mobil.<\/p><p>&#160;<\/p><p>Noe som kan v&#230;re en annen fordel for Recoil er at det er st&#248;ttet av Facebook, som ogs&#229; st&#248;tter React. Da kan man forvente god kompatibilitet mellom Recoil og React, i tillegg til god vedlikehold og dokumentasjon.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2042,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST API baserer seg p&#229; et design der man organiserer lesing og skriving av ressurser med&#160;URI-er, mens Graphql er f&#248;rst og fremst et sp&#248;rrespr&#229;k som tar i bruk en JSON-lignende syntaks. REST tar i bruk HTTP-foresp&#248;rselene GET, POST, PUT, DELETE for &#229; tilgang p&#229; ressursene.&#160;I tillegg baserer det seg p&#229; prinsipp om at det skal v&#230;re tilstandsl&#248;s kommunikasjon. Dette gj&#248;r det enklere for nettleseren eller maskiner i n&#230;rheten p&#229; nettverket &#229; bruke caching, slik at man slipper &#229; sende foresp&#248;rseler til serveren hver gang, noe som gj&#248;r at klient og serveren f&#229;r bedre ytelse og brukeropplevelse.<\/p><p>&#160;<\/p><p>I Graphql har man et annet system der man har spesifisert typer, og man kan lage queries og mutations som sier n&#248;yaktig hva slags data man &#248;nsker &#229; f&#229; eller endre. Graphql har spesielt fordeler n&#229;r man har mer komplekse data, som man i REST kanskje m&#229; bruke flere endepunkter for &#229; f&#229; tilgang p&#229;. Dette kan i Graphql gj&#248;res med kun en query eller mutation. Man unng&#229;r &#229; sende flere foresp&#248;reseler, som potensielt er avhengig av hverandre og da kan doble eller triple tiden man trenger &#229; vente p&#229; dataene. I tillegg unng&#229;r man med Graphql &#229; laste inn for mye data fordi man kan spesifisere n&#248;yaktig de feltene man vil ha. Typesystemet i Graphql gj&#248;r det ogs&#229; mulig &#229; validere dataene. Man f&#229;r spesielle feilmeldinger dersom data ikke kommer som forventet. En mulig ulempe med Graphql er at det kun st&#248;tter bruk av json-format, og derfor vil det ogs&#229; v&#230;re vanskeligere for nettleserne &#229; ta i bruk caching slik som REST kan. En annen ting er at kobling mellom server og klient blir tettere med Graphql enn med REST. Dette er fordi skjemane som typer og mutations m&#229; v&#230;re klart p&#229; forh&#229;nd for b&#229;de klient og server.&#160;Dette kan v&#230;re positivt fordi det legger til rette for enklere validering og hva slags data som er forventet. Samtidig fra et arkitektur-perspektiv kan v&#230;re negativt fordi endringer i en av plassene vil medf&#248;re endringer andre plasser, og klient og server blir dermed mindre uavhengig.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535775,"ext_inspera_userAssessmentSetupId":7139960,"ext_inspera_userAssessmentId":4841219,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Faugstad Kari Stam (10010)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37535381,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3367,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For tilstand (state) og dataflyt i React-applikasjoner kan man enten bruke intern tilstand i komponenter og sende data som props (properties) (hirearkisk dataflyt), eller bruke tredjepartbiblioteker for &#229; h&#229;ndtere global tilstand.&#160;<\/p><p>&#160;<\/p><p>Intern tilstand:<\/p><p>Intern tilstand er en eller flere variabler i en komponent som har en verdi som kan endre seg i l&#248;pet av komponentens livvsyklus. N&#229;r tilstanden endrer seg rendres komponenten p&#229; nytt.<\/p><p>&#160;<\/p><p>M&#229;ten intern tilstand implementeres kommer an p&#229; om man bruker funsjons- eller klassekomponenter. Originalt sett ble funsjonskomponenter kalt &#34;stateless components&#34; fordi de ikke kunne ha intern tilstand slik som klassekomponenter. Dette endret seg imidlertid med &#34;useState&#34;-hooken, som gj&#248;r at man ogs&#229; kan ha tilstand i funksjonskomponenter.&#160;<\/p><p>&#160;<\/p><p>I klassekomponententer brukes state og setState for &#229; definere og endre den interne tilstanden. Vi kan ogs&#229; deklarere metoder for spesifikke tilfeller i en komponents livssyklus, f.eks. componentDidMount(), som kj&#248;rer n&#229;r det opprettes en instans av komponenten, og componentWillUnmount() som brukes for &#229; &#34;rydde opp&#34; n&#229;r instanen taes ned igjen.<\/p><p>&#160;<\/p><p>I funksjonskomponenter brukes som nevnt useState-hooken, som deklarerer en tilstandsvariabel i komponenten (og en funksjon for &#229; endre den). I funksjonkomponenteneter brukes useEffect() som metode knyttet til komponentens livssyklus, tilsvarende som for metodene i klassekomponenter. Med useEffect() definerer en selv n&#229;r i livssyklusen den skal kj&#248;res/ hva som skal f&#229; den til &#229; kj&#248;re.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Hirearkisk dataflyt:<\/p><p>&#160;<\/p><p>Dataflyt mellom komponenter i React er (uten global tilstandsh&#229;ntering) hirearkisk, alts&#229; at data sendes fra foreldre til barn. Dette oppn&#229;s ved at&#160;props (properties) blir gitt som input n&#229;r en intans av en komponent opprettes. Denne dataen kan akksesseres innad i komponenten ved &#229; bruke this.props.xxx(navn p&#229; props), for klassekomponenter, og ved props.xxx i funksjonskomponenter.&#160;<\/p><p>&#160;<\/p><p>Ofte lagres tilstand h&#248;yt oppe i hirearkiet, for s&#229; &#229; sende informasjon nedover i komponentene. For at komponenter lenger ned i hirarkiet skal kunne endre p&#229; tilstanden lenger opp brukes callback funksjoner. Det vil si at funksjoner sendes som props nedover i hirearkiet, og trigger endringer i tilstanden til foreldrekomponenter n&#229;r de kj&#248;res lenger ned.&#160;<\/p><p>&#160;<\/p><p>For sm&#229; applikasjoner kan intern tilstand og hirearkisk datalfyt v&#230;re mest hensiktsmessig. men i st&#248;rre applikasjoner hvor mange komponenter skal buke samme informasjon eller props m&#229; sendes nedover veldig mange niv&#229;er (props-drilling), vil global tilstandsh&#229;ndtering v&#230;re mer hensiktsmessig.<\/p><p>&#160;<\/p><p>Global tilstandsh&#229;ndtering:<\/p><p>&#160;<\/p><p>Global tilstandsh&#229;ndtering kan oppn&#229;s ved bruk av Context APIet i react, eller tredjepartbiblioteker som MobX eller Redux.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av disse metodene opprettes en global tilstand med variabler som alle&#160;komponententer i applikasjonen har tilgang til &#229; bruke og endre. Den spesifikke m&#229;ten&#160;det gj&#248;res varierer fra metode til metode, men overordnet s&#229; inneb&#230;rer det &#229; lage variabler for tilstand, og tilh&#248;rende funksjoner for &#229; endre p&#229; disse. Komponenter gj&#248;res til observat&#248;rer av disse variablene, og rendres p&#229; nytt dersom variablene endres. Komponenter kan ogs&#229; bruke funksjonene for &#229; endre p&#229; de globale tilstandsvariablene. Den globale tilstanden gj&#248;res tilgjengelig for komponentene gjennom en provider som &#34;wrappes&#34; rundt den overordnede komponentnen i hirarkiet (ofte app.tsx).<\/p><p>&#160;<\/p><p>Contect APi et tilbyr global tilstand uten &#229; m&#229;tte sende data gjennom hele komponenhirearkiet med props. Det er imidlertid vanskelig &#229; feils&#248;ke, og har d&#229;rlig yteevne (performance), defor brukes ofte tjedjepartsbiblioteker som Mobx og Redux fremfor context.<\/p><p>&#160;<\/p><p>I MobX gj&#248;res dette med Stores med&#160;@observable verdier og @action funksjoner&#160;som endrer p&#229; disse verdiene. Komponententer som observerer @observable verdiene rendres p&#229; nytt n&#229;r disse endres. Oppsett av MobX er enkelt, og er ikke s&#229; mye &#229; sette seg inn i f&#248;r det kan implementeres.<\/p><p>&#160;<\/p><p>Redux krever mer oppsett (boilerplate) og er litt mer &#229; sette seg inn i, men til gjengjeld har du fll komtroll p&#229; alle handlinger som utf&#248;res p&#229; den globale tilstanden.&#160;Store inneholder alle globale tilstander, og man lager&#160;actions og reducers for &#229; endre p&#229; disse. Acions forteller hva som skal gj&#248;res og inneholder informasjon (f.eks. en streng fra brukerinput). Reducers tar inn actions som forteller hva som skal gj&#248;res, og som har med informasjon, og endrer p&#229; tstate basert p&#229; dette, og returnerer ny state.&#160;<\/p><p>&#160;<\/p><p>Om Redux eller MobX egner seg best kommer an p&#229; prosjketet, for mindre prosjekter kan MobX v&#230;re hensiktsmessig fordi det krever mindre oppsett, en Redux er mer skalerbart for st&#248;rre prosjekter, samt at man har mer kontroll p&#229; egen kode.<\/p><p>&#160;<\/p><p>Der hvor informasjon kun trenger &#229; flyttes fra foreldrekomponententer til deres barn er det fortsatt mest hensiktsmessig &#229; bruke intern tilstand og hirearkist dataflyt.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2204,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for &#229; h&#229;ndtere tilstand i React.&#160;<\/p><p>&#160;<\/p><p>Recoil best&#229;r av atoms (atomer) som inneholder data om applikasjonens tilstand. Komponenter som leser denne tilstanden abonnerer (subscribes) p&#229; det atomet. Om atomet oppdateres vil komponenter som abonnerer p&#229; det rendres p&#229; nytt. I recoil defineres selectors (selektorer) som tilsander som er hentet eller transformert, alts&#229;&#160;informasjon so skal&#160;brukes&#160;i en komponent. Hooken useRecoilValue() brukes for &#229; hente atoms fra applikasjonens tilstand.<\/p><p>&#160;<\/p><p>Overordnet kan man si at recoil lar deg lage en dataflyt som g&#229;r fra atomer, vi selektorer og ned til react komponenter. Det krever ikke opprettelse av store-komponenter, og det er kun de komponentene som abonnerer p&#229; et endret atom som rendres p&#229; nytt.<\/p><p>&#160;<\/p><p>Tilsvarende l&#248;sninger for global tilstandsh&#229;ndtering er Context, MobX&#160;og Redux som ble nevnt i oppgave 1.<\/p><p>&#160;<\/p><p>Sammenliknet med disse (da med fokus p&#229; MobX og Redux som ogs&#229; er tredjeparts biblioteker) likner spr&#229;ket i recoil mer p&#229; react. I dokumentasjonen skriver de ogs&#229; selv at de ville lage noe som &#34;f&#248;les ut som&#34; react. Redux og MobX innf&#248;rer egen terminiologi, mens terminilogien i recoil er&#160;mer lik react, hvor navnene likner p&#229; kjente react hooks, og det f&#248;les ut som en utvidelse heller enn en en &#34;tilleggspakke&#34;. Dette kan v&#230;re en fordel, da det gj&#248;r det lettere for utviklere &#229; sette seg inn i, og forst&#229; hva de ulike metodene gj&#248;r.<\/p><p>&#160;<\/p><p>Redux krever mye &#34;boilerplate&#34;, alts&#229; mye oppsett for &#229; komme i gang. Med recoil er oppsettet enkelt, og det er ikke s&#229; mye man trenger &#229; l&#230;re&#160;for &#229; komme i gang. Dette er en stor fordel, s&#230;rlig dersom det er snakk om mindre prosjekter, der man ofte &#248;nsker en lav oppstartskostnad.<\/p><p>&#160;<\/p><p>P&#229; en annen side er recoil veldig nytt, og dermed ikke s&#229; etablert. Det st&#248;ttes helles ikke av ES5, s&#229;&#160;det kan v&#230;re problematisk &#229; bruke med nettlesere som ikke st&#248;tter&#160;ES6. Allikvel har de en god dokumentasjon og introduksjon som gj&#248;r at det skal v&#230;re oversiktilig &#229; bruke, men dersom man&#160;st&#248;ter&#160;p&#229; uventede problemer under utvikling finnes det sannsynligvis f&#230;rre svar p&#229; nettet sammenliknet med Redux og MobX. Men ettersom Recoil blir mer brukt vil ogs&#229; denne forskjellen bli mindre og mindre.<\/p><p>&#160;<\/p><p>Recoil sin store fordel er alts&#229; at det likner react i terminilogi, og er lett &#229; sette seg inn i og sette opp. Redux og MobX har forelen av &#229; v&#230;re mer brukt og etablert.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1606,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST&#160;API og GrapgQL er to m&#229;ter &#229; opprette API for &#229; hente data (ofte json) fra en database. En vesentlig forskjell&#160;er at i RESTgj&#248;res dette ved &#229; definere spesifikke endepunkter med GET, POST, DELETE osv. som kan brukes av klienten med fetch() eller axios. Om man f.eks. bruker GET for &#229; hente data kan man definere endepunkter som gir ulike antall data, f.eks hente et spesifikt objekt, eller alle objektene i en database. Uansett vil man alltid f&#229; tilbake <u>hele<\/u> objektet, med&#160;alle tilh&#248;rende felter. I GraphQL ha man heller et typesystem, hvor man beskriver dataene som er tilgjengelige i APIet. Ved foresp&#248;rsel fra klienten brukes POST request samen med en query (sp&#248;rring), som definerer hvilke felter for objektet en &#248;nsker &#229; f&#229; returnert. Dette gj&#248;r at man kan definere akkurat hvilke felter man trenger, og kun f&#229;r returnert disse. dette gj&#248;r at man kan f&#229; alt fra flere objekter, til kun enkelte felter fra et spesifikt objekt.<\/p><p>&#160;<\/p><p>Resultatet av denne forskjellen er at man kan si at GraphQL forhindrer overfetching og underfetching. Overfetching vil si at man henter mer informasjon enn n&#248;dvendig, mens underfetching vil si at man henter mindre enn n&#248;dvendig. At GrephQL hindrer overfetching er lett &#229; fort&#229; ut ifra forklaringen over: man f&#229;r kun den informasjonen man sp&#248;r om, og trenger ikke hente alle felter fra et objekt. Grunnen til at GraphQL hindrer underfetching er at dersom du med REST API &#248;nsker informasjon om et objekt som ligger under et annet objekt i databasen, m&#229; du gj&#248;re to kall. Mens i GraphQL kan du enktelt definere at du &#248;nsker denne informasjonen.<\/p><p>&#160;<\/p><p>Allikvel er REST API fortsatt mye brukt, da det er enkelt &#229; implementere og veldig etablert. I tillegg vil det i noen tilfeller v&#230;re mer hensiktsmessig, slik som i noen tilfeller&#160;i prosjekt 3 (og 4) i dette emnet. Om en&#160;selv setter&#160;opp databasen vet&#160;hvilke felter man&#160;&#248;nsker, og alle disse feltene er n&#248;dvendige i frontend. Da vil&#160;det v&#230;re enkelt &#229; bruke REST ettersom det ikke er n&#248;dvendig &#229; definere en sp&#248;rring med alle feltene til hvert objekt.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11536628,"ext_inspera_userAssessmentSetupId":7140060,"ext_inspera_userAssessmentId":4841247,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Harnes Håkon Egset (10069)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":57997146,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2534,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har mange forskjellige forskjellige m&#229;ter &#229; h&#229;ndtere state.<br /><br />Den enkleste m&#229;ten &#229; h&#229;ndtere state er med react sine inebygde mekanismer for state i komponenter. I klassekomponenter, som n&#229; i stor grad er p&#229; vei ut, bruker en gjerne this.state og this.setState(obj). Her setter en f&#248;rst en default state, typisk ved initialisering av komponenten, og oppdaterer senere state gjennom setState etter behov. Et viktig prinsipp er at state er immutable, alts&#229; at en ikke kan endre p&#229; selve state objektet direkte, men m&#229; sende inn et nytt objekt som den oppdaterte state. Dette trigger s&#229; en rerender av komponenten, hvor en kan tegne opp komponenten p&#229; nytt basert p&#229; oppdatert state.<\/p><p>&#160;<\/p><p>I funksjonelle komponenter gjelder lignende mekanismer, men en bruker her heller react sitt hooks API og tar i bruk useState hooken. Den returnerer b&#229;de en state variabel, samt en funksjon for &#229; oppdatere denne variabelen. P&#229; tilsvarende m&#229;te vil variabelen v&#230;re immutable og trigge rerender ved oppdateringer. Her kan en i utgangspunktet bruke en monolittisk state p&#229; samme m&#229;te som en ville gjort med this.state og this.setState, men det er vanligere &#229; bruke en hook for hver enkelt variabel. Dette muligj&#248;r mer hensiktsmessig bruk av useEffect hooken, hvor en kan instruere react til &#229; kj&#248;re en kodeblokk hvis og bare hvis en variabel er endret, ved &#229; sende den med i useEffect sitt dependency array.<br /><br />Det er ogs&#229; vanlig &#229; ta i bruk diverse tredjepartskomponenter for tilstandsh&#229;ndtering. Det mest kjente biblioteket for dette er Redux, som faget ogs&#229; underviser i. Her lager man en store (en kan ogs&#229; lage flere, men det er vanlig &#229; ha en global store) som inneholder all tilstand for hele applikasjonen. Denne initialiseres med en default state for hele applikasjonen. I applikasjonens livsl&#248;p vil en kunne oppdatere state ved &#229; utf&#248;re s&#229;kalte actions p&#229; state. Actions kan v&#230;re (konseptuelt) av typen, &#248;k en counter verdi, toggle en boleansk verdi (synlig / ikke synlig) etc. Etter at en har utl&#248;st en action, vil en s&#229;kalt reducer h&#229;ndtere hva som skal skje med state. Dette er en ren funksjon som tar inn forrige tilstand, og deretter konstruere et nytt tilstandsobjekt som den returnerer, og som vil v&#230;re den nye tilstanden. Dette er en ren funksjon, alts&#229; er redux state p&#229; lik linje med react state immutable og skal ikke endres direkte. Redux er et kraftigere state verkt&#248;y enn react sin innebygde state h&#229;ndtering, og gir utviklere en rekke muligheter som ikke er like enkle &#229; bruke i ren react state. Eksempler p&#229; dette kan v&#230;re &#229; serialisere actions p&#229; state og lagre dem for bug reports som utviklere senere kan bruke til enkelt &#229; reprodusere bugs. Et annet eksempel kan v&#230;re nesten &#34;gratis&#34; implementasjon av undo og redo funksjonalitet. I mange tilfeller vil redux v&#230;re et verkt&#248;y som en ikke egentlig trenger &#229; benytte seg av i enklere applikasjoner.<sup>[1]<\/sup><\/p><p>&#160;<\/p><p>Det finnes ogs&#229; en rekke andre verkt&#248;y for tilstandsh&#229;ndtering som en kan bruke, som f.eks. mobx som er nevnt i faget. Enkelte rammeverk gj&#248;r ogs&#229; deler av tilstandsh&#229;ndteringen, spessielt for data, for deg, slik som Apollo Client og facebook&#39;s egne Relay.<br /><br />N&#229;r det kommer til dataflyt er det igjen en rekke forskjellige m&#229;ter &#229; gj&#248;re dette p&#229;.<\/p><p>&#160;<\/p><p>Den enkleste formen for dataflyt er gjennom props. Ved &#229; sende variabler ned i komponenter gjennom properties kan de konsumeres i komponenten. Oppdaterer props seg rerendrer komponenten med oppdaterte data. Dette er en god m&#229;te &#229; h&#229;ndtere dataflyt p&#229; der komponentene som er avhengig av data ligger n&#230;rme hverandre i komponentstrukturen. Der en raskt kan st&#248;te p&#229; problemer dog, er om komponentene er langt fra hverandre i strukturen. Om du m&#229; sende data gjennom props i mange lag (&#34;s&#229;kalt prop-drilling&#34;) kan dette fort bli uoversiktelig.<br /><br />Tideligere var det f&#229; gode alternativer til dette annet enn &#229; ta i bruk redux og benytte seg av redux sin&#160;mapStateToProps, der du kunne mappe deler av state til props i enkeltkomponenten, og slik unng&#229; &#229; sende data gjennom prop-drilling. Dette var selvsagt bare noe som var mulig om en brukte redux.<br /><br />En av de st&#248;rre nyvinningene i senere tid i React er det s&#229;kalte context APIet. Dette ble utviklet nettopp med tanke p&#229; dette problemet&#160;og muliggj&#248;r p&#229; en lignende m&#229;te som redux &#229; hente ut tilstand og data i enkeltkomponenter, uten prop-drilling. Her definerer man en provider p&#229; et niv&#229; i komponenttreet, og deretter kan komponenter under i treet f&#229; tilgang til dataene gjennom en consumer, uavhengig av hvilket niv&#229; de ligger p&#229;. Dette er ogs&#229; tilgjengelig gjennom hooks APIet for en enda mer ellegant l&#248;sning. P&#229; lik linje som med props vil endringer i tilstanden som provideres av provideren f&#248;re til rerender av komponentene som er avhengig av denne dataen.<\/p><p>&#160;<\/p><p>Redux har ogs&#229; tilgjengeligjort dataen sin gjennom hooks p&#229; en lignende m&#229;te i nyere tid. Istedefor &#229; mappe state til props kan en bruke useSelector hooken til &#229; hente ut biter av tilstanden og rerendre komponenten etter behov. Tilsvarende kan en ogs&#229; dispatche actions gjennom hooks for &#229; oppdatere tilstanden. Dette er ikke n&#248;dvendigvis like enkelt med context APIet.<br /><br />[1]&#160;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2477,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et eksperimentelt rammeverk for tilstandsh&#229;ndtering i React. Det er blitt brukt internt hos facebook og er i &#229;pen test-fase for andre utviklere.<br /><br />Recoil ser ut til &#229; gj&#248;re deling av state enklere mellom komponenter. Ved &#229; gjenbruke konvensjoner fra useState hooken er det enkelt og intuitivt for eksisterende react utviklere &#229; ta i bruk. Recoil kan ogs&#229; tilgjengeligj&#248;re transofmasjoner vha. selectors. Eksempelet de bruker i dokumentasjonen er &#229; legge til px p&#229; enden av fontSize. En kunne ogs&#229; tenke seg at en selector fille filtrert data fra state og lignende. Dette vil tilsvarende kunne brukes i mange forskjellige komponenter, og trigge rerender ved en oppdatering.<\/p><p>&#160;<\/p><p>En av fordelenen med recoil ser ut til &#229; v&#230;re en reduksjon av rerenders i komponenttreet. Der en i dag kanskje har st&#248;rre objekter i en provider som konsumeres av mange komponenter. Der endringer i dette objektet ikke n&#248;dvendigvis f&#248;rer til endringer i komponentene, vil en med recoil sin struktur kun rerendre akkurat de komponentene som er p&#229;virket.<br /><br />Der en tidligere typisk m&#229; passe setters av state som deles av komponenter opp i komponenttreet, er dette behovet eliminert ved bruk av recoil js. Recoil kan omg&#229; dette behovet ved &#229; lage en rettet data-graf for &#229; definere avhengighetene, og slik omg&#229; &#229; un&#248;dig m&#229;tte h&#229;ndtere tilstandsoppdateringer i komponenter som ikke beh&#248;ver &#229; tegnes p&#229; nytt.<\/p><p>&#160;<\/p><p>En annen fordel ser ut til &#229; v&#230;re f&#248;rsteklasses support for asynkrone operasjoner, slik som henting av data fra API. Det er enkelt &#229; integrere med React&#39;s kommende concurrent mode, som gj&#248;r bla. loading indikasjoner enklere&#160;og feilh&#229;ndtering enklere. Igjen er dette ogs&#229; med p&#229; &#229; redusere un&#248;dig tegning (rerender) av komponenter.<\/p><p>&#160;<\/p><p>Til forskjell fra redux er det ikke behov for &#229; beskrive tilstandsendringer som rene objekter (actions). Dette reduserer boilerplate noe. Det er heller ikke n&#248;dvendig &#229; lage reducers i samme forstand som i redux, men det er en mulighet om det er behov for det (gjennom getters og setters). I recoil beskriver du heller ikke et globalt state objekt, men definerer state som enkeltst&#229;ende variabler eller mindre objekter (de kaller dette atomer). De kan defineres p&#229; runtime, og hvor som helst i koden (til forskjell fra redux hvor hele staten initialiseres n&#229;r applikasjonen intialiseres). En viktig ting &#229; ta hensyn til her er at disse atomene krever globalt unike n&#248;kler.&#160;<br /><br />Som med ethvert eksperimentelt rammeverk m&#229; en selvsagt veie fordelene og ulempene. Det er sannsynlig at syntaks og API vil v&#230;re i rask endring og ofte brekke tidligere kode som har bygget p&#229; visse antagelser. Det er ogs&#229; mer sannsynlig at det er flere bugs. Som med alle nye rammeverk er det antagelig mange scenarier for bruk recoil teamet ikke enn&#229; har tenkt p&#229;, og som milj&#248;et ikke enn&#229; har en god m&#229;te &#229; l&#248;se p&#229;. Ofte vil det v&#230;re slik at modne rammeverk har konvensjoner for n&#230;r sagt alt du &#248;nsker &#229; gj&#248;re, mens yngre rammeverk kan det v&#230;re vanskeligere &#229; finne gode m&#229;ter &#229; l&#248;se problemer p&#229;.<\/p><p>&#160;<\/p><p>Testing kan ogs&#229; v&#230;re et omr&#229;de som er mindre utviklet. I dokumentasjonen dedikerer de omtrent bare en paragraf til testing. Hvor lett det er &#229; teste er vanskelig &#229; si uten &#229; ha pr&#248;vd rammeverket i bruk, men det er en mulig utfordring. Mer etablerte rammeverk har typisk sv&#230;rt gode konvensjoner og andre rammeverk igjen for &#229; forenkle testing.<br /><br />Til slutt ser det ut som at toolingen for recoil er mindre utviklet enn for f.eks. redux. Med tooling mener jeg verkt&#248;y rundt milj&#248;et, slik som redux dev tools. Disse kan v&#230;re en viktig del av utviklingsprosessen og gj&#248;re det enklere &#229; finne bugs og forst&#229; koden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1663,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL API er HTTP baserte web API strukturer brukt til &#229; hente data til en klientapplikasjon.<br /><br />GraphQL ble utviklet i stor grad med motivasjonen &#229; unng&#229; mange av utfordringene en s&#229; med REST api. Der REST API grunnlegende tilgjengeliggj&#248;r ressurser p&#229; enkelt-endepunkt f.eks.<\/p><pre class=\"pre-formatted\">/user/42<\/pre><p>med en (typisk) fastsatt struktur p&#229; objektet, er GraphQL et sp&#248;rrespr&#229;k hvor en sp&#248;rr etter akkurat de feltene man er interresert i. F.eks.<\/p><pre class=\"pre-formatted\">query getUser(42) {&#10;  id&#10;  name&#10;}&#10;<\/pre><p>Dette er blant annet motivert av at en s&#229; at mange API fikk mange forskjellige endepunkt for ulike opplevelser. Der et REST API returnerte like mye data til desktop brukere til mobilbrukere, kunne graphql returnere kun den dataen klienten faktisk beh&#248;vde. Ofte var behovet p&#229; mobil lavere. Istedefor &#229; lage mange ulike endepunkt kunne en da konsolidere alt i et enkelt API.<\/p><p>En annen stor fordel med graphql er at det reduserer behovet for s&#229;kalte round-trips. Der en med REST API kanskje m&#229;tte gj&#248;re to, tre, fire eller flere kall kall for &#229; f&#229; dataene en beh&#248;vde, feks.<\/p><pre class=\"pre-formatted\">Hent venner&#10;/user/42&#10;  For hver venn hent interesser&#10;  /user/:friendId&#10;<\/pre><p>kunne en med graphql utnytte kraften i et sp&#248;rrespr&#229;k til &#229; redusere slike round-trips, f.eks.<\/p><pre class=\"pre-formatted\">query getUser(32) {&#10;  friends {&#10;    interests&#10;  }&#10;}&#10;<\/pre><p>hvor hentingen av data h&#229;ndteres s&#248;ml&#248;st p&#229; serversiden. I REST kunne en ogs&#229; tilgjengeliggjort denne informasjonen p&#229; user objektet, men en m&#229;tte da implementert dette for hvert endepunkt, mens en f&#229;r dette gratis i graphql og helt s&#248;ml&#248;st.<br /><br />Det hevdes ofte at GraphQL ikke beh&#248;ver versjonering. Et problem en ofte st&#248;tte p&#229; i produksjon med web API var at kunder var avhengig av eksisterende implementasjoner. En kunne ikke uten videre endre p&#229; eksisterende endepunkt, da applikasjoner ville knekke om en gjorde det. L&#248;sningen er da og versjonere, alts&#229; lage en ny versjon av APIet som kunne ligge under f.eks.<\/p><pre class=\"pre-formatted\">/v2/user/42&#10;<\/pre><p>I graphql kan en v&#230;re noe mer liberal med hvordan man endrer p&#229; skjemaet (APIet&#39;s struktur) og legge p&#229; felter og resolvers som en &#248;nsker uten frykt for at eksisterende implementasjoner skal slutte &#229; fungere. Denne fordelen er likevel noe overdrevet, da det enn&#229; ikke er mulig &#229; gj&#248;re st&#248;rre endringer eller fjerne felter uten &#229; bryte eksisterende avhengigheter. En kan derfor ogs&#229; i graphQL API v&#230;re tvunget til &#229; versjonere.<br /><br />Det er ikke bare fryd og gammen i graphql verden dog. Noen av de f&#248;rste utfordringene en st&#248;ter p&#229; med graphql i en produksjonssammenheng er vanlige driftsutfordringer, som vi har gode og standariserte m&#229;ter &#229; h&#229;ndtere i REST sammenheng, men der det ikke finnes like mange gode og modne l&#248;sninger i graphql verden. Et godt eksempel p&#229; dette er ressursbegrensning. Hvordan hindrer en klienter fra &#229; bruke opp ressursene til serveren ved &#229; utf&#248;re alt for mange og tunge kall?<br /><br />I REST verden er dette rimelig greit h&#229;ndtert gjennom rate limitting. Der sier en ofte at klientene bare f&#229;r gj&#248;re s&#229; s&#229; mange kall til visse endepunkt over en viss periode. I graphql er ikke dette like rett frem. Klienten har stor frihet til &#229; hente data og kombinere den p&#229; ulike m&#229;ter som utviklere av API ikke p&#229; forh&#229;nd kan vite om. Det er fort gjort &#229; lage sp&#248;rringer som er sv&#230;rt krevende for serveren &#229; serve. Github har fors&#248;kt &#229; l&#248;se dette ved &#229; knytte kostnader til felter du foresp&#248;rr, og gi deg et budsjett for hver sp&#248;rring. Dette er en mulig l&#248;sning p&#229; dette problemet. Kostnaden her er selvsagt at en har flyttet noe av kompleksiteten fra konsumer av APIet til utvikleren av APIet n&#229;r det kommer til kompleksitet og utviklingstid.&#160;Dette er et p&#229;g&#229;ende felt for forskning og utvikling.<sup>[1]<\/sup><br /><br />Dette gj&#248;r seg selvsagt mest gjeldende i public API, mens private API ikke i like stor grad har denne utfordringen, spessielt ikke i sm&#229; teams.<br /><br />[1] https://medium.com/dev-genius/a-principled-approach-to-graphql-query-cost-analysis-8c7243de42c1<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11536646,"ext_inspera_userAssessmentSetupId":7140009,"ext_inspera_userAssessmentId":4841281,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aune Kristin (10060)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33649309,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3953,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React finnes det flere teknikker man kan benytte seg av for &#229; h&#229;ndtere state. Hvilken teknikk man benytter seg av avhenger ofte av hvor komplisert applikasjonen og komponenttreet er.&#160;<\/p><p>&#160;<\/p><p>Hvis man har en veldig enkle applikasjon med kun f&#229; komponenter s&#229; kan man benytte seg av mekanismene som allerede befinner seg i <strong>React-biblioteket<\/strong>. Den fungerer ved at man kan sende props, som er data, til andre komponenter som er barn av komponenten som opprettet&#160;denne propsen. Barn som mottar denne propsen kan endre p&#229; staten.&#160;Man kan endre state ved &#229; kalle p&#229; this.setState der this kaller p&#229; den n&#229;v&#230;rende staten. Vi kan ogs&#229; benytte oss av lifecycle-funksjonene for &#229; oppdatere state n&#229;r DOM-oppdateres. Det som er problematisk med denne metoden er at det kun er komponenten som inneholder staten som vet om den, og ingen andre komponenter. Staten er lokal.&#160;Hvis noen av de andre komponentene vil ha tak i staten, eller er avhengig av den, m&#229; den sendes nedover i komponenttreet som en props. Det er ikke mulig &#229; sende props oppover, og heller ikke til s&#248;sken-komponentene. Dermed m&#229; staten ligge i den f&#248;rste komponenten som er felles for de komponentene som skal ha tilgang til propsen. I mange tilfeller vil det v&#230;re i den &#248;verste komponenten i komponenttreet, og dette kan ofte f&#248;re til at denne komponenten blir veldig komplisert og inneholder mye data.&#160;<\/p><p>&#160;<\/p><p>For &#229; l&#248;se dette problemet s&#229; ble <strong>Context<\/strong> utviklet. Context l&#248;ste problemet med &#229; sende data/props gjennom komponenttreet uten &#229; m&#229;tte sende props manuelt gjennom alle niv&#229;er av komponenttreet. Context handler om at man lagrer informasjon/data/props et sentralt sted ogs&#229; kan alle komponenter som &#248;nsker tilgang til denne dataen f&#229; tilgang til den. Dermed, om en komponent endrer staten, s&#229; vil staten ogs&#229; oppdatere seg i alle de andre komponentene som bruker samme context. P&#229; denne m&#229;ten unng&#229;r vi &#229; m&#229;tte sende props gjennom komponenter som egentlig ikke benytter seg av propsen, men som kun er et mellomledd for &#229; komme til riktig komponent. For &#229; benytte seg av context m&#229; man opprette en og deretter bruke den i de komponentene som det er n&#248;dvendig. Vi m&#229; ha en provider som lar oss beskrive data som skal v&#230;re tilgjengelig for komponentene som benytter seg av den. Til slutt m&#229; det opprettes en consumer som lar alle komponentene i komponenttreet som trenger dataen f&#229; tak i den. Med context kan man ogs&#229; benytte seg av hooks for &#229; h&#229;ndtere state p&#229; en enkel og ryddig m&#229;te. Dette er funskjoner som enkelt oppretter en state med useSatet og oppdaterer state med&#160;setState.&#160;<\/p><p>&#160;<\/p><p><strong>Redux<\/strong> er en annen m&#229;te man kan h&#229;ndtere state p&#229; i React. Redux skulle ogs&#229; l&#248;se problemet med &#229; dele data&#160;mellom s&#248;sken-komponenter, samt en felles store der man kan hente ut state. Redux fungerer ved at data/props ligger i en felles store som alle komponenter har tilgang til. Om en komponent endrer staten som en annen komponent ogs&#229; benytter seg av s&#229; vil denne staten automatisk oppdateres i store og dermed vil komponentene som benytter denne staten ogs&#229; oppdatere seg.&#160;Man sier at Redux benytter seg av en global state. Redux best&#229;r av tre byggeklosser:<\/p><p>- Action: sender data fra applikasjonen til Redux store. For &#229; gj&#248;re dette benytter den seg av store.dispatch(). Det er med action at man kan endre staten. Action kommuniserer med Reducer (beskrevet under).&#160;<\/p><p>- Store: holder staten til alle komponenter til enhver tid. Om det skjer en oppdatering av staten vil dette ogs&#229; oppdateres i store.&#160;<\/p><p>- Reducer: Funksjoner som tar inn den forel&#248;pige staten og oppdaterer store med den nye staten. Dette sier noen om hvordan staten endrer seg avhengig av hvilken action som sendes til store.&#160;<\/p><p>&#160;<\/p><p>Siste er <strong>MobX<\/strong>. Denne har vi ikke benyttet i v&#229;re prosjekter, men prinsippet handler om at alle endringer i state oppdateres automatisk. MobX har ogs&#229; en store som holder orden p&#229; state, og denne er ubegrenset. Hovedkomponentene i MobX er:<\/p><p>- Den som blir observert: lar oss observere endringer i state som kan brukes andre steder.&#160;<\/p><p>- Action: endring av state&#160;<\/p><p>- Computed: lar oss f&#229; ut noen verdier basert p&#229; endringen i state.&#160;<\/p><p>- Observat&#248;ren: den som observerer om det skjer en endring i state.&#160;<\/p><p>- Store: b&#229;de date og funksjoner som endrer dataen ligger her i store. &#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1880,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en annen m&#229;te &#229; h&#229;ndtere state p&#229; i React. Den benytter seg av Atom, som inneholder state. N&#229;r en state oppdaterer seg s&#229; vil kun de komponentene som benytter seg av den staten oppdateres, ikke alle slik som med Context. Man sier at en komponent &#34;subscriber&#34; en atom. For &#229; gj&#248;re dette benyttes det en hook som kalles useRecoilState som har ca. samme funksjon som useState. Recoil definerer ogs&#229; selectorer. De tar inn atoms, eller andre selectors, og n&#229;r disse oppdateres s&#229; vil selector-funksjonen kj&#248;res p&#229; nytt. Selectors er funksjoner som bruker data for &#229; oppdatere state, dermed tar de inn atoms som inneholder state. Alts&#229;, n&#229;r atom, det vil si staten, oppdaterer seg s&#229; brukes selector-funksjonene til &#229; gj&#248;re endringer p&#229; staten og applikasjonen.&#160;<\/p><p>&#160;<\/p><p>Forskjellen:<\/p><p>- N&#229;r man oppdaterer en state s&#229; vil det kun v&#230;re de komponentene som benytter seg av denne staten som oppdateres, ikke alle slik som med&#160;Context. N&#229;r en state oppdaterer seg s&#229; vil selector-funksjonene kj&#248;re og dermed endre staten i applikasjonen kun der det er n&#248;dvendig.<\/p><p>- N&#229;r man skal oppdatere en state med Redux m&#229; man kalle p&#229; action s&#229; den kj&#248;res. Med Recoil benytter vi kun selector-funksjonene.&#160;<\/p><p>- Enklere &#229; sette opp strukturen med Recoil enn med Redux.&#160;<\/p><p>&#160;<\/p><p>Fordeler:<\/p><p>- Trenger ikke opprette en store for &#229; lagre alle states<\/p><p>- Det er kun de komponentene som benytter den staten som oppdateres som oppdateres og kj&#248;rer selector<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>- Man m&#229; l&#248;fte staten opp i atoms. Med Redux vil man ha en global state s&#229; dermed er ikke det n&#248;dvendig her.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":959,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>- REST&#160;definerer&#160;hva slags data som skal returneres, mens med GraphQL sendes det sp&#248;rringer til en server der man spesifiserer hvilke type data som skal returneres, eller eventuelt oppdateres.&#160;<\/p><p>&#160;<\/p><p>- REST benytter seg av URI eller HTTP-request, mens med GraphQL spesifiserer man med json hva man vil hente ut eller skrive til.&#160;<\/p><p>&#160;<\/p><p>- REST benytter seg av flere endepunkter for &#229; f&#229; tak i data, mens med GraphQL s&#229; sender man en sp&#248;rring der man sp&#248;rr etter all data man &#248;nsker seg.&#160;<\/p><p>&#160;<\/p><p>- Med REST vil man kunne f&#229; mer data enn man egentlig skal ha. Mens med GraphQL f&#229;r man kun det man sp&#248;rr etter. Dermed sitter man ikke igjen med overfl&#248;dig data som ikke brukes.&#160;<\/p><p>&#160;<\/p><p>- REST kan bruke caching, det vil si lagring av data som brukes mye. GraphQL kan ikke det.<\/p><p>&#160;<\/p><p>- GapthQL har muligheten til &#229; validere og bruker skjema for &#229; bestemme hva slags data som hentes ut.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537337,"ext_inspera_userAssessmentSetupId":7140015,"ext_inspera_userAssessmentId":4841211,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Brakedal Mats Sandtorv (10095)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35154775,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1610,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Ser p&#229; props og states bruk i React:<\/strong><\/p><p>&#160;<\/p><p>- Props eller&#160;Properties er&#160;navngitte dataverdier gis som input n&#229;r en komponent kalles/opprettes.&#160;Props er immutable, dette betyr&#160;at verdiene en komponent mottar ikke kan endres.&#160;(data flyter fra parent til child)<\/p><p>State er interne variabler i komponenten som kan endres med setState(). Typis vil endring i state f&#248;re til ny rendring av komponenten (og barn av denne).&#160;All data som er relatert til applikasjonen holdes i State, i en komponent. N&#229;r noe i state endres oppdateres DOMen. Alle steder i en applikasjon som bruker samme state blir da oppdatert. F.eks la oss si at vi bruker state for &#229; holde telling p&#229; hvor mange ganger brukeren trykker p&#229; en knapp;<\/p><p>&#160;<\/p><p>class Main extends React.Component {<\/p><p>&#160; state = {<\/p><p>&#160; numEks: 10<\/p><p>&#160;&#160;}<\/p><p>&#160;render(){<\/p><p>&#160;return(<\/p><p>&#160;&#60;div className=&#34;Hello&#34;&#62;<\/p><p>&#160;&#60;Header siteName=&#34;Hello World!&#34;/&#62;<\/p><p>&#160;&#60;button&#62;{this.state.numEks}&#60;/button&#62;<\/p><p>&#160;&#60;/div&#62;) }<\/p><p>&#160; }<\/p><p>&#160;<\/p><p><strong>&#160;Verkt&#248;y for State management:<\/strong><\/p><p>Gjennom prosjektetene ble det brukt eksterne verkt&#248;y som Redux, MobX, Axios og ContextAPI for statemangement, nevner kort om hvordan disse ble tatt i bruk;<\/p><p>&#160;<\/p><p>MobX kunne bli brukt til&#160;til &#229; lage mye av brukerinteraksjonen p&#229; nettsiden. Flere av komponetene henter variabler fra MobX som bestemmer hva som skal vises (for eksempel alle objekter eller et&#160;spesifikk), dette bestemmes ved at klikkbare komponenter oppdaterer disse variablene ut ifra brukerens valg. Kort fortalt setter Mobx applikasjonen opp som et rekneark med forskjellie states.<\/p><p>&#160;<\/p><p>Redux&#160;er et popul&#230;rt og etablert bibliotek for state mangament og legger til rette for mange l&#248;sninger. En m&#229;te &#229; anvende Redux p&#229; var &#229; ha f.eks noen redusere som SearchA, SearchB og Bruker.&#160;SearchA inneholder alle parameterne som skal sendes med til backend n&#229;r det skal utf&#248;res s&#248;k. SearchB er resultatet man f&#229;r fra et s&#248;k. Bruker inneholder informasjon om brukeren som er logget inn, og inneholder ogs&#229; favorittene som er valgt. Dette er tilstand som vi ser p&#229; som globale fordi de g&#229;r p&#229; tvers av flere komponenter og kreves p&#229; forskjellige niv&#229;er av komponent-hierarkiet.<\/p><p>&#160;<\/p><p>Bruk av Axios og state f.eks&#160;for &#229; hente ut data fra databasen,&#160;denne dataen lagres i tilh&#248;rende state. Data hentes ut ved at URL-en tilpasses etter hva som er s&#248;kt, filtrert eller sortert p&#229;. N&#229;r brukeren velger &#229; spesifisere disse valgene, lagres de i state og legges til i URL-en. Den siste HTTP-requesten som har blitt utf&#248;rt lagres alltid i query-staten, slik at man kan ta utgangspunkt i den n&#229;r det legges til flere detaljer ved s&#248;ket.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1776,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil blir brukt som et state-management biblotek for React.<\/p><p>- Komponenter&#160;kan skrive til og lese fra &#34;Atoms&#34;&#160; som representerer deler av en state. Komponeneter som leser av et atom er da linket til dette, s&#229; viss et atom oppdateres vil alle komponeneter som er linket til dette ogs&#229; oppdateres.<\/p><p>&#160;eks:<\/p><p><em><strong>const textState = atom({<\/strong><\/em><\/p><p><em><strong>key: &#39;textState&#39;, // unique ID (with respect to other atoms/selectors)<\/strong><\/em><\/p><p><em><strong>default: &#39;&#39;, // default value (aka initial value)<\/strong><\/em><\/p><p><em><strong>});<\/strong><\/em><\/p><p>&#160;<\/p><p>Det brukes en selctor for &#229; beskrive en endring av state hvor en staen kan sees p&#229; som en output til en funskjon som modifiserer staten.<\/p><p>eks:&#160;<\/p><p><em><strong>const charCountState = selector({<\/strong><\/em><\/p><p><em><strong>key: &#39;charCountState&#39;, // unique ID (with respect to other atoms/selectors)<\/strong><\/em><\/p><p><em><strong>get: ({get}) =&#62; {<\/strong><\/em><\/p><p><em><strong>const text = get(textState);<\/strong><\/em><\/p><p><em><strong>return text.length;<\/strong><\/em><\/p><p><em><strong>},<\/strong><\/em><\/p><p><em><strong>});<\/strong><\/em><\/p><p>&#160;<\/p><p>Viss vi ser p&#229; l&#230;ringsm&#229;lene skal vi ha kunnskap og ferdigheter i state management fra Redux, MobX og litt Context.<\/p><p>&#160;<\/p><p>ReduX:<\/p><p>- Stort og vanskelig &#229; mestre til det fulle.<\/p><p>- Vansklig &#229; behandle&#160;asynkroniseringsdata, her m&#229; en bruke tredj-parts biblotek.<\/p><p>- Vanslki &#229; implmentere i et prosjekt som ikke ble bygd opp av Redux.<\/p><p>&#160;<\/p><p>Context:<\/p><p>- Laget for &#229; l&#248;se prop drilling.<\/p><p>- Mosettning til Redux bra n&#229;r det er lite oppdateringer i prosjektet.<\/p><p>- Lagrer bare en verdi per provider, dette kan medf&#248;re mye ekstra.<\/p><p>- Kan ikke lage dynamiske kontekst.<\/p><p>&#160;<\/p><p>Redux virker noelunde lik i m&#229;ten man behandler states p&#229;, men man vil f&#229; lite til ingen &#34;boilerplates&#34; med Recoil hvor det blir som &#229; bruke useState fra React, man trenger bare &#229; wrappe appen i &#60;RecoilRoot&#62;. Kan med andre ord ha s&#229;&#160; mage uavhengige globale states man vil. Recoil vireker &#229; v&#230;re mer dynamisk ogs&#229; etterosm det lar deg lage dynamsik globale states med atom Family og selectorFamily.<\/p><p>&#160;<\/p><p>En ulempe kan v&#230;re at Recoil er sv&#230;rt nytt og forsatt under utvikling samt det er forsatt usikkert hva som er eventuelle begrensninger og utfordringer.<\/p><p>&#160;<\/p><p>Litt d&#229;rlig besvarelse pga litt d&#229;rlig tidsbergning.<\/p><p>https://recoiljs.org/docs/introduction/getting-started<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3744,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Lister f&#248;rst opp hva og hvordan REST API og Grapql er ment virke hver for seg og legger til ulemper og fordeler.<\/p><p>&#160;<\/p><p><strong>REST API:<\/strong><\/p><p>&#160;<\/p><p>REST API fungerer som en overordnet arkitektur/design for web-basert klient/tjener kommunikasjon med fokus p&#229; lesing og skriving av ressurser.&#160;Prinsippene er stateless kommunikasjon, design som legger til rette for bruk av browserens caching, her defineres det ett eller flere endepunkter for &#229; skrive, lese eller endre p&#229; entiteter vha URI og HTTP requester og det er definert hvilke data som skal returneres for en entitet. Eksempler p&#229; f&#229;resp&#248;rsler kan v&#230;re&#160;GET, PUT, POST, DELETE for &#229; lese, endre, opprette eller slette ressurser.<\/p><p>&#160;<\/p><p><strong>Potensielle fordeler:<\/strong><\/p><p>- Man kan benytte seg av caching-mekanismen som per default st&#248;ttes av alle weblesere.<\/p><p>- Passer bra hvor prosjektet ikke har for mange relasjoner og gj&#248;r f&#229; kall om gangen.<\/p><p>&#160;<\/p><p><strong>Potensielle ulemper:<\/strong><\/p><p>- Med mange endepunket (mer kompleks informasjon) m&#229; man gj&#248;re mange kall for &#229; hente ut dataen man trenger.<\/p><p>&#160;<\/p><p><strong>Graphql:<\/strong><\/p><p>&#160;<\/p><p>Graphql er prim&#230;rt et sp&#248;rrespr&#229;k og en runtime. Du spesifiserer i json hva du vil hente og hvilke data du vil ha. Det er basert p&#229; at en sender en sp&#248;rring til en server hvor en har definert b&#229;de s&#248;k og hvilke data som skal retuneres.&#160;<\/p><p>&#160;<\/p><p>enkel gjenomgang av funnksjon:<\/p><p>&#160;<\/p><p>N&#229;r GraphQL-serveren svarer p&#229; en&#160;foresp&#248;rsel, begynner den med &#34;sp&#248;rreroten&#34;, og den s&#248;ker over hvert felt p&#229; det forespurte objektet. Et overordnet n&#248;kkel kart legger til grunn for hvert felts verdi og kan returnere et objekt som igjen kan velge&#160;et annet sett med felt. Dette fortsetter til bare en streng eller et nummer returneres. Serveren svarer deretter med et nestet sett med objekter.<\/p><p>&#160;<\/p><p><strong>Potensielle fordeler:<\/strong><\/p><p>&#160;<\/p><p>- Data kan hentes ut i en request og en ung&#229;r lasting av for mye data. (kan legge til at man ung&#229;r lenkende kall til backend)<\/p><p>- Det er typesystem som gj&#248;r det mulig &#229; validere.<\/p><p>-&#160;<\/p><p>&#160;<\/p><p><strong>Potensielle ulemper:<\/strong><\/p><p>&#160;<\/p><p>- Mangel p&#229; implisitt caching i HTTP.<\/p><p>- St&#248;tter kun JSON-data.<\/p><p>-(Kobling mellom tjener og klient kan ogs&#229; v&#230;re noe tettere i ved bruk av GraphQL siden det brukes skjema som definerer struktur og typer, men dette kan ogs&#229; vurderes som en fordel siden det muliggj&#248;r validering.)<\/p><p>&#160;<\/p><p><strong>Hoved forskjeller:<\/strong><\/p><p>&#160;<\/p><p>-&#160;REST API er laget som&#160;en overordnet arkitektur for netverk basert software, mens Graphql er mer som et query spr&#229;k som opererer med et endepunkt gjennom HTTP. REST API er ogs&#229; mer designet for for &#229; lage nye API`er mens Graphql er mer optimalisert for ytelse og felksibilitet.<\/p><p>&#160;<\/p><p>- Hvor en ser en stor forskjell p&#229; Graphql og REST API er om&#160; f.eks en vil ha informajson fra 2 objekter med REST API. Da trengs det&#160; 2 requester hvor en f&#229;r tilbake et komplett datasett fra et &#34;endepunkt&#34;&#160;selv om man kanssje bare var ute etter noe spesifikt.&#160;(Man kan ogs&#229; si at dette n&#248;dvendigvis ikke kun er negativt ettersom det gir et enkelt bilde p&#229; hva data som presenteres selv om det er et helt datasett gir det mulighet for &#229; bli&#160;behandlet/manipulert). Dette er hovedsaklig en ulempe ettersom viss du vil ha spesifikk data fra et endepunkt vil man uansett f&#229; hele datasettet noe som kalles for over fetching. Her er derimot Graphql mye bedre ettersom man kan spesifiserere kallet til akkuratt det man trenger i entiten.<\/p><p>&#160;<\/p><p>- Viss man ser p&#229; automatiserte porsseser er Graphql sv&#230;rt &#229; f&#229;retrekke grunnet hva man sparer for hvert kall. Overtid vil en ha spart opp mye un&#248;dvendige n&#229;r en gj&#248;r mange kall.<\/p><p>&#160;<\/p><p>- En fordel med REST API over Grapql er at REST API er blitt en marekdstandar for brukere av API. S&#229; ved bruk i API`er REST mye mer polert og tilrettelagt.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533510,"ext_inspera_userAssessmentSetupId":7140116,"ext_inspera_userAssessmentId":4841204,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Olaussen Hauk Aleksander (10217)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34192168,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1859,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere m&#229;ter og teknikker for &#229; h&#229;ndtere state og data-flow i en react applikasjon. Hvilken teknikk som brukes blir ofte valgt ut ifra hvor stor applikasjonen er. St&#248;rre applikasjoner trenger n&#248;dvendigvis en mer strukturert og rigid m&#229;te &#229; h&#229;ndtere ting p&#229; enn mindre applikasjoner.<\/p><p>&#160;<\/p><p>For mindre applikasjoner kan det v&#230;re nok &#229; dele data mellom komponenter ved &#229; sende dataen som props nedover komponent-hierarkiet. Grunnen til at dette fungerer greit med mindre applikasjoner er at en forelder-komponent (parents)&#160;har 2-3 barne-komponenter (child). State kan endres ved bruk av setState() i klasse komponenter, eller useState()-hooken i funksjonelle komponenter.&#160;Dersom vi vil implementere data-flow&#160;oppover i treet (fra child til parent) s&#229; m&#229; vi sende s&#229;kalte &#34;callback&#34;-funksjoner som &#34;child&#34; kan kalle p&#229; i &#34;parent&#34;.&#160;Dette kan fort bli mye &#229; holde styr p&#229; i st&#248;rre applikasjoner ettersom&#160;&#34;parents&#34; kan ha massevis av &#34;children&#34;. Da m&#229; vi tenke annerledes.&#160;<\/p><p>&#160;<\/p><p>Det finnes flere metoder og biblioteker som er laget for &#229; takle dette problemet. Redux er et eksempel p&#229; et slikt bibliotek. Redux er et bibliotek som bruker enveis data-flow. Dette vil si at data flyter fra &#34;parent&#34; til &#34;child&#34;. For &#229; oppdatere state i redux s&#229; m&#229; vi ha s&#229;kalte &#34;actions&#34;. Disse kan s&#229; bli &#34;dispatched&#34; via en dispatch(action) funksjon. Vi m&#229; deretter ha en funksjon kalt en &#34;reducer&#34; som leser av hva slags type av action som ble dispatched, og vil dermed oppdatere staten deretter. Actions har ofte payload som spesifiserer hva i staten som skal endres basert p&#229; de ulike typene av actions. Staten blir lagret i noe vi kaller for en &#34;store&#34;, som kan bli aksessert fra hvor som helst i applikasjonen ved bruk av f.eks. useSelector()-funksjonen.<br />Som vi kan se, s&#229; lager dette et sentralisert &#34;lager&#34; for staten, hvor man ikke trenger &#229; sende data nedover hierarkiet for &#229; s&#229; bruke callbacks for &#229; oppdatere parent<\/p><p>&#160;<\/p><p>Man kan ogs&#229; bruke context apiet for &#229; gj&#248;re data-flowen mellom komponenter litt enklere i visse tilfeller. Context gj&#248;r det mulig for &#34;children&#34; og &#34;parents&#34; &#229; dele ulike variabler og verdier uten at man trenger &#229; bruke props nedover i hierarkiet som man vanligvis gj&#248;r.&#160;&#160;Dersom det bare er to komponenter blir dette ofte overkill, men dersom man trenger at flere komponenter i samme deltre trenger &#229; akessere den samme verdien, s&#229; kan context v&#230;re en god l&#248;sning p&#229; problemet.<\/p><p>&#160;<\/p><p>Man bruker ofte ikke kun &#233;n av disse. Det er vanlig &#229; bruke de ulike metodene der de er nyttige for problemet som man skal l&#248;se, og da kan det godt hende at applikasjonen inneholder flere av metodene diskutert her OG andre som ikke er det.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3096,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som - for det meste - er bygd opp av &#34;Atoms&#34; og &#34;Selectors&#34; virker det som. Atomene&#160;er en del av en state, mens selectorene&#160;er funksjoner som tar inn atomer eller andre selectors for &#229; kalkulere dataer basert p&#229; state. Bare komponenter som er subscribed ser endringene i selectoren (og atomene). Dette gj&#248;r at man ikke trenger gj&#248;re mer enn n&#248;dvendig.&#160;Recoil&#160;ble laget for &#229; dekke hullene som eksisterer i React og Context. Recoil lager en data-flow graf som flyter fra atomer igjennom selectors ned til komponentene. Komponentene kan subscribe til de ulike atomene og selectorene, og blir re-rendered dersom de endres.<\/p><p>&#160;<\/p><p>Recoil kommer som et svar p&#229; biblioteker slik som Redux. I Redux m&#229; man konfigurere en global state i en store - noe man ikke trenger &#229; gj&#248;re i Recoil. P&#229; samme m&#229;te som at man i Redux lager reducers for &#229; endre state basert p&#229; hvilken action som blir dispatched, s&#229; bruker Recoil atomer (som er en del av en state) og sender de igjennom selectors for &#229; endre p&#229; den. For &#229; lese og endre staten med Redux kan vi bruke f.eks. useSelector() og useDispatch() hooks, mens man i Recoil kan lese og endre staten ved bruk av useRecoilState() og useRecoilValue().&#160;<\/p><p>&#160;<\/p><p>Det virker veldig kjekt &#229; ikke m&#229;tte re-rendere komponenter som ikke trenger &#229; bli re-rendered (dette er jo ogs&#229; mulig i Redux). Dette gj&#248;r brukeropplevelsen mye bedre p&#229; st&#248;rre applikasjoner, eller komponenter som inneholder mange mindre komponenter som m&#229; oppdateres dersom &#34;parent&#34; oppdateres (eksempelvis et spillbrett med mange ruter&#160;- say minesweeper).&#160;Det virker som Recoil gj&#248;r at mange&#160;av &#34;mellomdelene&#34; som man m&#229; sette opp i Redux (store, actions, reducers) er lettere &#229; sette opp. Dette kan gj&#248;re prosjektstrukturen enklere &#229; sette opp fra start, og gir en mer komprimert versjon enn en tilsvarende Redux applikasjon. Noen ganger har man kanskje lyst til &#229; ha denne oppdelingen av prosjektet som Redux krever for &#229; ha et&#160;mer oversiktlig prosjekt.&#160;Recoil gir en l&#248;sning p&#229; det problemet&#160;at en state bare kan bli delt med andre komponenter dersom den blir &#34;dyttet&#34; opp til en felles &#34;parent&#34; ved bruk at denne &#34;subscribe&#34; metoden. Den fikser ogs&#229; problemet i Context APIet som sier at Context kun kan lagre &#233;n verdi.<\/p><p>&#160;<\/p><p>Det finnes ogs&#229; negative sider ved et nytt bibliotek ogs&#229;. Ved &#229; innf&#248;re et nytt bibliotek innen state-handling s&#229; krever det at utviklere IGJEN m&#229; sette seg inn i ny teknologi. Dette er jo ikke negativt i seg selv, men det virker som at Recoil ikke kommer med noe nytt p&#229; banen annet enn at den gj&#248;r ting mer konsise. Jeg kan ikke finne problemer som Recoil kan l&#248;se, men ikke Redux. Ettersom de fleste utviklere i dag kan Redux fra f&#248;r, s&#229; virker det som dette kan gj&#248;re fremtredelsen av Recoil treigere enn det kunne ha v&#230;rt. Det virker derimot veldig enkelt &#229; sette seg inn i (basert p&#229; det jeg har lest i dokumentasjonen) - og tanken om atomer er jo noe alle har innebygd i seg. Jeg mener at Recoil ikke har en like bratt l&#230;ringskurve som eksempelvis Redux og MobX har - og som forklart over, s&#229; er det&#160;&#229;penbart sterkere enn Context APIet. Det at man kan bruke asynkrone funksjoner i synkrone render-funksjoner (og p&#229; den m&#229;ten &#34;blande&#34; asynkron og synkron kode) er ogs&#229; veldig greit n&#229;r man m&#229; bruke Promises for &#229; eksempelvis hente data fra REST APIer.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Docs:&#160;https://recoiljs.org/<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1722,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er to ulike m&#229;ter for kommunikasjon mellom klient og server.<\/p><p>&#160;<\/p><p>REST er en mer statisk, rigid og stateless m&#229;te &#229; l&#248;se kommunikasjonen p&#229; enn Graphql. For &#229; hente data via et REST API s&#229; m&#229; man spesifisere ulike endepunkter - alts&#229; hvor dataene man vil ha ligger. Dette kan v&#230;re eksemeplvis <strong>/biler/&#60;regnr&#62;<\/strong>(1) som vil hente en bil med gitt regnr.&#160;For &#229; hente ut hvilket merke bilen er kan man f.eks. ha et endepunkt&#160;<strong>/biler/&#60;regnr&#62;/merke<\/strong>(2) og likedan for antall seter&#160;<strong>/biler/&#60;regnr&#62;/antallseter<\/strong>(3)&#160;&#229;rsmodell <strong>/biler/&#60;regnr&#62;/modell<\/strong>(4) etc. Dersom du vil ha b&#229;de merket og &#229;rsmodell s&#229; vil man da antagelig like s&#229; godt hente hele bil-objektet ved bruk av (1). Dette gj&#248;r derimot at man henter mer data enn man trenger - s&#229;kalt &#34;overfetching&#34; - ettersom REST returnerer akkurat det som er spesifisert i endepunkene. Ikke mer, ikke mindre - noe som ogs&#229; &#229;pner opp for &#34;underfetching&#34;, som er akkurat det samme bare at man henter mindre data enn man trenger, og m&#229; da gj&#248;re enda et kall.&#160;En m&#229;te &#229; l&#248;se dette p&#229; i REST er &#229; ha mange ulike endepunkter for &#229; &#229;pne for muligheten av mange ulike kall,&#160;men i applikasjonen s&#229; m&#229; man jo da n&#248;dvendigvis gj&#248;re mange kall mot APIet for &#229; hente de eksakte dataene man vil ha, noe som &#229;penbart ikke er &#248;nskelig. Med REST f&#229;r man ogs&#229; ulike HTTP respose codes basert p&#229; hva serveren svarte p&#229; requesten. Dette kan v&#230;re 200 OK, 400 Bad Request, 404 Not Found etc. I Graphql s&#229; vil alle responses - data og errorer - v&#230;re 200 OK, men man kan se de eventuelle errorene i et error objekt som kan gj&#248;re det lettere &#229; debugge hva som evt gikk feil.<\/p><p>&#160;<\/p><p>Graphql l&#248;ser dette problemet ved at man sender en query som spesifiserer hva man vil ha - som i dette tilfelle ville v&#230;rt merket og &#229;rsmodell. Fordelen er jo at all data som hentes er relevante data, ettersom man f&#229;r returnert akkurat det man spurte etter. Alt skjer ogs&#229; i &#233;n request, s&#229; man trenger ikke gj&#248;re flere kall. Graphql implementerer ogs&#229; en m&#229;te for &#229; validere at dataen som blir hentet er av riktig type via ulike skjema som man definerer. Man g&#229;r derimot glipp av cachingen og st&#248;tte for andre typer av data enn JSON - som man f&#229;r ved bruk av REST.<\/p><p>&#160;<\/p><p>Graphql docs:&#160;https://graphql.org/<br />REST wikipedia:&#160;https://en.wikipedia.org/wiki/Representational_state_transfer<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533521,"ext_inspera_userAssessmentSetupId":7139989,"ext_inspera_userAssessmentId":4842169,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Mæland Jens (10101)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35008356,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3061,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-applikasjoner benytter seg av dataflyt for &#229; la komponenter &#34;snakke med hverandre&#34;, og benytte seg av informasjon som finnes i andre deler av applikasjonen enn bare den enkelte komponenten.<\/p><p>&#160;<\/p><p>State: State er et objekt som representerer delen av objektet som kan endre seg. Dette kan v&#230;re relativt konkrete ting som&#160;fargetema og teksten som ligger i et s&#248;kefelt, eller v&#230;re med abstrakte ting, som f.eks state som benyttes for &#229; gi beskjed til alle barnekomponenter at foreldrekomponenten loader. State er alts&#229; et objekts tilstand.&#160;<\/p><p>&#160;<\/p><p>Ofte benytter forskjellige objekter seg av hverandres state. Denne staten kan sendes mellom objektene som props. Dette er den mest grunnleggende formen for dataflyt.&#160;<\/p><p>&#160;<\/p><p>Komponenter kan ogs&#229; v&#230;re n&#248;stede. Et eksempel p&#229; dette, er et skjema, hvor skjemaet best&#229;r av mange mindre tekstinputs og informasjonsbokser. La oss si at sp&#248;rsm&#229;lene i sp&#248;rreskjemaet er forskjellige for menn og kvinner. La oss si at en bruker m&#229; logge inn for &#229; kunne svare p&#229; skjemaet, og informasjon om brukeren h&#229;ndteres av state&#160;i foreldrekomponenten, alts&#229; skjemaet. I dette eksempelet vil det v&#230;re en god id&#233; &#229; la hver enkelt sp&#248;rsm&#229;lsboks, som i dette tilfellet er en egen komponent, vite hvilket kj&#248;nn brukeren er, for &#229; kunne displaye riktig sp&#248;rsm&#229;l. Dette gj&#248;res ved at foreldrekomponenten(skjemaet) passer sin state til barnekomponentene(hvert enkelt sp&#248;rsm&#229;l) vha props.&#160;<\/p><p>Dersom sp&#248;rsm&#229;l/svar endrer seg basert p&#229; tidligere inputs, alts&#229; at prosessen er episodisk og ikke sekvensiell, vil dataflyt vha passing av state v&#230;re sv&#230;rt nyttig for en utvikler &#229; benytte seg av, for &#229; oppn&#229; &#248;nsket funksjonalitet.&#160;<\/p><p>Dersom en underveis i en utviklingsprosess kommer p&#229; at det kanskje hadde v&#230;rt fordelaktig for andre komponenter &#229; ha tilgang til en enkelt komponents state, gj&#248;r man ofte noe som kalles &#229; &#34;heve staten&#34;. Dette inneb&#230;rer &#229; flytte state opp ett hakk, fra barnenode til foreldrenode. Da vil staten kunne aksesseres av komponentene som trenger den, med form&#229;let om &#229; holde en felles state&#160;synkronisert p&#229; tvers av barnekomponentene. Props kan ogs&#229; sendes oppover i hierarkiet, vha callbacks.<\/p><p>&#160;<\/p><p>Men hva om en vil utvikle en nettside m/ p&#229;loggingsfunksjon, hvor alle komponenter baserer seg p&#229; f.eks. brukernavnet til personen som er p&#229;logget/et fargetema? Det er fors&#229;vidt mulig &#229; passe state nedover i hierarkiet vha props&#160;og ut til alle komponenter, men dette kan fort bli sv&#230;rt uoversiktlig, og virkelig tidkrevende om funksjonalitet skal endres. Dette er et ypperlig omr&#229;de &#229; benytte seg av global state&#160;p&#229;. Eksempler p&#229; teknologier som gj&#248;r dette mulig er Redux, MobX og Context. Jeg tar utgangspunkt i Redux, for &#229; slippe &#229; skrive tiln&#230;rmed det samme tre ganger.<\/p><p>Viktig &#229; merke seg at Redux ikke er React-spesifikt, dog er det sv&#230;rt ofte benyttet i React-applikasjoner.&#160;<\/p><p>Redux er et open-source javascriptbibliotek, med form&#229;l om &#229; administrere upper-level state p&#229;, som kan aksesseres av alle komponenter. I stedet for &#229; passe state ned og ut i alle komponenter, har alle komponenter tilgang til redux-state, og komponentene kan benytte seg av denne direkte. Oppdatering av global state kan v&#230;re litt tricky mtp. alle avhengige komponenter, noe Redux gir sv&#230;rt gode m&#229;ter &#229; h&#229;ndtere, vha modularisering av redux-funksjonalitet inn i actions, reducers,&#160;selectors, og storen.<\/p><p>&#160;<\/p><p>Context-APIet&#160;blir ogs&#229; benyttet mye for &#229; h&#229;ndtere global state. Konsensen n&#229; til dags er &#229; benytte se av redux for &#229; h&#229;ndtere global state, imens context skal brukes for &#229; passe props, men de to teknologiene har mulighet til &#229; gj&#248;re mange av de samme oppgavene.&#160;<\/p><p>&#160;<\/p><p>Funksjonelle komponenter l&#248;ser state-h&#229;ndtering vha hooks, som mange foretrekker fremfor klassekomponenters state grunnet enklere oppsett, en trenger ikke binde osv.<\/p><p><br />Oppsummert, er state og dataflyt essensielt i ikke-statiske React-applikasjoner. Utviklere benytter seg av state for &#229; definere komponenters tilstander, som kombinert kan presentere bruker for en applikasjon skreddersydd for han/henne. Lokal state kan benyttes av andre komponenter ved &#229; passe state som props, og ofte benyttes global state for &#229; forenkle distribusjon av vital state til flere komponenter. P&#229; denne m&#229;ten blir stateh&#229;ndtering under utvikling forenklet.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3177,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et stateh&#229;ndteringsbibliotek for React. Sammenlignet med tilsvarende l&#248;sninger vi har p&#229; listen over l&#230;ringsm&#229;l, vil jeg sammenligne det med Redux,&#160;Context og&#160;MobX.<\/p><p>&#160;<\/p><p>Fordelene ved Recoil virker &#229; v&#230;re mange.&#160;<br />Recoil benytter seg av lik syntax som react, som er sv&#230;rt nyttig dersom ens spr&#229;kskompetanse best&#229;r prim&#230;rt av React. Det benyttes ingen boilerplate, som&#160;tilsynelatende gj&#248;r Recoil sv&#230;rt enkelt &#229; sette opp i motsetning til Redux, som har en del oppstartskostnader selv for et mvp. Implementasjonen virker ogs&#229; &#229; v&#230;re minimal, som gj&#248;r det mye enklere &#229; sette seg inn i enn f.eks Redux, som kan v&#230;re litt intimidating&#160;for mennesker som ser det for f&#248;rste gang. Recoil st&#248;tter b&#229;de synkrone og asynkrone funksjoner, som er sv&#230;rt hendig i kombinasjon med bruk av synkrone react renderfunksjoner(Redux har ikke built-in support for dette). Recoil virker &#229; v&#230;re ytelsesfokusert, som kan gj&#248;re det til en god konkurrent for Context, som er mer fokusert rundt bakgrunnsoppdatering av state, som feks tema og brukerh&#229;ndtering. Sammenlignet med Redux, virker det ogs&#229; som at en ikke trenger &#229; restrukturere prosjektet i like stor grad som en m&#229; dersom en skal implementere Redux i et allerede eksisterende prosjekt.&#160;<\/p><p>&#160;<\/p><p>Ulemper :&#160;<\/p><p>Det virker som om redux tilbyr mye av den samme funksjonaliteten(og enda mer), som kanskje gj&#248;r det overfl&#248;dig &#229; sette seg inn i enda en ny teknologi. Redux har ogs&#229; sv&#230;rt gode devtools utviklet over flere &#229;r, som kan gj&#248;re det mye enklere &#229; h&#229;ndtere st&#248;rre prosjekter. Forel&#248;pig virker det ikke som at Recoil tilbyr devtools p&#229; et likt niv&#229;.<\/p><p>&#160;<\/p><p>Det virker all in all som Recoil er et bra alternativ &#229; g&#229; til dersom en &#248;nsker global state-h&#229;ndtering, men ikke trenger all funksjonalitet tilbudt av Redux.&#160;Recoil skryter p&#229; seg &#229; v&#230;re reactish, som er en god ting n&#229;r en benytter seg av React under utvikling, og gir prosjektet en mer sammenhengende finish. Det virker ogs&#229; som at det tar minimalt med tid &#229; sette opp, som kan v&#230;re sv&#230;rt nyttig ved utvikling av mindre applikasjoner som fremdeles ser fordeler ved bruk av global state.<\/p><p>&#160;<\/p><p>Kilder :&#160;<\/p><p>https://recoiljs.org/docs/introduction/motivation/<\/p><p>https://recoiljs.org/docs/introduction/getting-started<\/p><p>https://recoiljs.org/docs/basic-tutorial/intro<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2697,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST APIer er utviklet med flere endpoints in mind. Dette vil si, at n&#229;r en applikasjon vil ha informasjon fra backend, m&#229; den kontakte den gitte endpointen som kan servere klienten med informasjonen den vil ha. Det snakkes mye om over/underfetching n&#229;r det kommer til REST APIer, som bunner ut i nettopp dette. En kan tenke p&#229; det slik at selve &#34;objektet&#34; som pinges er definert i backenden p&#229; REST APIer. Det vil si, at en klient kan ikke velge &#229; bare f&#229; deler av informasjonen suppliet av et endpoint, den m&#229; ta alt. Dette er et problem om en komponent trenger bare litt av informasjonen fra et endpoint, men trenger informasjonen fra flere endpoints. Dette resulterer i overfetching, alts&#229; at mye informasjon som egentlig ikke trenger &#229; bli sendt, blir sent. Dette medf&#248;rer en kostnad. Et eksempel p&#229; dette kan f.eks v&#230;re informasjon om en bruker. Dersom klienten bare trenger brukerens navn, m&#229; den likevel sp&#248;rre om hele brukerobjektet, feks med personnummer, bilde, epost osvosv.&#160;<\/p><p>GraphQL derimot, er forskjellig ved at det bare har ett endpoint. Klienten sp&#248;r om n&#248;yaktig det den vil ha, og f&#229;r informasjonen supplyet av backend. En kan derfor si at &#34;objektet&#34; blir definert frontend, i motsetning til i REST APIer, hvor &#34;objektet&#34; blir definert backend. Her er det intet problem &#229; bare requeste brukernavnet; Queryen mottas, og bare brukernavnet serveres.<\/p><p>&#160;<\/p><p>Utvikling med REST APIer og Graphql kan v&#230;re sv&#230;rt forskjellige, men ogs&#229; sv&#230;rt like.<br />REST APIer sies &#229; v&#230;re sv&#230;rt skalerbare. REST APIer er modulariserte, som vil si at klientkode og serverkode(frontend og backend) kan endres uavhengig av hverandre, som gj&#248;r at utviklingen av en applikasjon/webside kan skje sv&#230;rt raskt ved at flere utvikler uavhengige deler samtidig.&#160;<\/p><p>Dersom ny funksjonalitet skal utvikles frontend, er det bare &#229; legge opp for st&#248;tte for dette i backend. Dersom informasjonen som trengs frontend allerede er ish st&#248;ttet backend, er det bare for frontend &#229; sp&#248;rre om informasjon fra flere endpoints, s&#229; supplyes dette.<\/p><p>REST APIer cacher informasjon automatisk, i motsetning til GraphQL, som forel&#248;pig ikke har automatisk caching, noe som &#248;ker ressursbruk noe. GraphQL er nok enda mer&#160;effektivt under frontendutvikling, ettersom frontend kan utvikles helt uavhengig av backend, gitt at informasjonen er tilgjengelig backend. Utviklere kan lage masse ny funksjonalitet frontend uten &#229; m&#229;tte utvide backend-ufnksjonalitet.(som nevnt, ogs&#229; mulig med REST APIer, men f&#248;rer ofte til overfetching) GraphQL er ogs&#229; strengt typet, som f&#248;rer til at dersom b&#229;de frontend og backend-utviklere er klar over datastrukturen, kan de jobbe helt separat fra hverandre.<\/p><p>&#160;<\/p><p>Feilh&#229;ndtering i REST ofte enklere, ettersom utviklere kan gi egendefinerte feilmeldinger dersom feil oppst&#229;r ved de forskjellige endpointsene. GraphQL kan ogs&#229; gi andre feilmeldinger, men dette er mye mer tidkrevende, ettersom GraphQL bare har ett enkelt endepunkt, og feilh&#229;ndtering m&#229; defineres p&#229; egenh&#229;nd, ettersom utvikler definerer alt av in<\/p><p>&#160;<\/p><p>For &#229; oppsummere, er det mange likheter mellom REST og GraphQL, men ogs&#229; mange ulikheter.<\/p><p>REST har lenge v&#230;rt bransjestandarden, men&#160;GraphQL ser mer og mer av dagens lys. GraphQL er nok litt mer komplisert enn REST APIer, men kan med fordel benyttes i store prosjekter for &#229; redusere un&#248;dvendig ressursbruk pga over/underfetching. Selve &#34;objektet&#34; som skal hentes blir ved bruk av REST API definert i backend, i motsetning til GraphQL, hvor objektet blir definert frontend(Du f&#229;r n&#248;yaktig det du &#248;nsker).<\/p><p>Begge teknologier l&#248;ser samme problemer, men p&#229; forskjellig m&#229;te.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533526,"ext_inspera_userAssessmentSetupId":7139912,"ext_inspera_userAssessmentId":4841426,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Schjerven Øyvind Jalland (10017)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":32433956,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3879,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstand i et prosjekt kan h&#229;ndteres med react sin innebygde funksjonalitet, eller med eksterne biblioteker.<\/p><p>&#34;Vanilla&#34; react bruker lokal tilstandsh&#229;ndtering.&#160;Variabelverdier lagres i komponenter, og kan sendes videre til andre komponenter som bruker data lagret i variablene. Dette gj&#248;res med bruk av props og state i komponentene. Props tas inn av komponentene (som et parameter), mens state h&#229;ndteres inni komponentene. Ved bruk av lokal tilstand er tilstand kun mulig &#229; sende en vei. Det vil si at komponenter som kalles fra en annen kompontent, kan ta inn data fra tilstanden til&#160;&#34;forelder-komponenten&#34;, og bruke denne, men forelderkomponenten har ikke tilgang til barnas lokale tilstand.&#160;Derfor m&#229; tilstand ved bruk av lokal state lagres i den &#248;verste komponenten som skal benytte seg av dataen, slik at alle komponenter som bruker denne kan hente den ovenfra.<\/p><p>For &#229; bruke global state kan man benytte seg av context (innebygd i react) eller et eksternt bibliotek (Mobx, Redux, etc.). Ved bruk av global state er tilstand tilgjengelig overalt (eller der man har spesifisert at det skal v&#230;re tilgjengelig), og dataflyt kan dermed g&#229; b&#229;de oppover og nedover i komponenttreet. Tilstand lagres utenfor komponentene, og hentes inn av hver enkelt komponent som trenger tilgang til data fra tilstanden.<\/p><p>En fordel med dette er at data ikke m&#229; sendes nedover i komponenttreet, men kan hentes direkte fra der den er lagret.<\/p><p>&#160;<\/p><p>Ved bruk av context lagres tilstand og en context-provider som en egen fil utenfor komponenttreet. Provideren brukes for &#229; gi komponenter tilgang til tilstanden. Dette gj&#248;res ved &#229; &#8220;wrappe&#8221; komponentene som skal ha tilgang inni provideren, p&#229; samme m&#229;te som man kan wrappe p-tags inn en div-tag. Dermed kan context ogs&#229; brukes &#34;semiglobalt&#34; ved at en begrenset del av komponentene wrappes inn i provideren.<\/p><p>&#160;<\/p><p>MobX lagrer tilstand i to eller flere stores. Det opprettes en store for UI-data og en eller flere for domain-data.<\/p><p>Dette gj&#248;r det mulig &#229; bruke store inni store, som kan v&#230;re nyttig i enkelte situasjoner. Store er tilgjengelig utenfor komponenttreet, og kan dermed n&#229;s av alle komponenter. Tilstand i MobX er observerbar og muterbar, som vil si at komponenter kan b&#229;de lese og gj&#248;re endringer i state. N&#229;r data i en tilstand endrer seg, trigger det en automatisk oppdatering av alle komponenter som observerer tilstanden. Dermed benytter komponentene seg alltid av oppdatert data. Dette gj&#248;r MobX veldig rett frem &#229; bruke, siden tilstand kan h&#229;ndteres enkelt direkte fra komponentene. En ulempe med dette er at det gir begrenset kontroll over dataflyten, siden tilstand kan endres fra hele komponenttreet, og det ikke holdes noen oversikt over hvor endringer kommer fra eller hva som endres.<\/p><p>&#160;<\/p><p>Redux lagrer global tilstand i en enkelt store. Denne er tilgjengelig for alle komponenter, men er kun lesbar, og kan dermed ikke endres direkte fra komponentene. For &#229; oppdatere tilstanden brukes actions og reducers. Oppdatering skjer ved at en komponent kj&#248;rer en action funksjon med parametere som skal brukes til endringen. Actions fungerer ved &#229; ta inn parametere, og sende disse til en reducer sammen med en gitt action-type, som forteller reduceren hva den skal gj&#248;re med dataen den mottar. Reducers mottar dataen sendt fra actions, og bruker denne til &#229; oppdatere tilstand. Oppdateringen som gj&#248;res avhenger av hvilken action som trigges, og benytter &#34;payloaden&#34; som sendes sammen med action-typen. Dette gj&#248;res ved at reduceren tar inn gammel tilstand, og genererer en ny kopi av tilstanden med endringene som skal gj&#248;res. Slik holdes tilstand&#160;immutable, ettersom hver versjon av tilstanden ikke endres. Dette gir bedre kontroll p&#229; dataflyt enn MobX, men er ogs&#229; mye mer tungvint &#229; implementere. Som f&#248;lge av mye &#34;boilerplate&#34; kode som er n&#248;dvendig for at Redux skal fungere, er det veldig lite praktisk &#229; bruke p&#229; sm&#229; prosjekter, men p&#229; st&#248;rre prosjekter kan den ekstra kontrollen over dataflyt, i tillegg til at tilstanden blir lettere &#229; debugge, v&#230;re verdt tungvint implementasjon av tilstandsendring.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1635,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som brukes til &#229; h&#229;ndtere global tilstand, alts&#229; har det samme bruksomr&#229;de som Redux og MobX beskrevet i forrige oppgave. Istedenfor &#229; ha en eller flere stores som inneholder tilstand, bruker Recoil noe som kalles atoms. Disse har samme hensikt som store i MobX og Redux, men er mindre, slik at tilstanden deles opp i flere separate deler. Atoms er, i likhet med store i MobX, muterbare og mulig &#229; f&#248;lge med p&#229; for komponenter. Endringer gjennomf&#248;res med bruk av selectors. Disse er s&#229;kalte pure functions (samme type funksjon som reducers i Redux) og brukes av komponentene for &#229; gjennomf&#248;re endringer. Endring av et atom trigger oppdatering av komponentene som f&#248;lger med p&#229; dette atomet. En fordel&#160;med &#229; dele opp tilstanden i mindre atomer, er at kun de komponentene som f&#248;lger med p&#229; den spesifike delen av tilstanden som endres trenger &#229; rerendres. Dermed hindrer man at store rerendringer m&#229; gj&#248;res hver gang en liten endring i tilstanden skjer.<\/p><p>Recoil er et veldig nytt bibliotek, og benytter seg utelukkende av hooks. Dette medf&#248;rer at man m&#229; l&#230;re seg hooks for &#229; kunne bruke biblioteket, i motsetning til for eksempel Redux, som kan brukes b&#229;de med og uten hooks.<\/p><p>Recoil ligner dermed en del p&#229; MobX, i den forstand at tilstand er muterbar og observerbar fra komponentene. Likevel har den bedre kontroll p&#229; dataflyt, ettersom endringer gj&#248;res med selectors, og fordi kun den delen av tilstanden som ligger i atomet endringen skjer p&#229; blir endret.<\/p><p>Fordeler: Tilstand er delt opp, og rerendrer kun n&#248;dvendige komponenter ved oppdatering. Ikke n&#248;dvendig med boilerplate kode for &#229; fungere. Virker veldig enkelt og praktisk &#229; bruke sammenlignet med Redux. Virker ogs&#229; som det har bedre kontroll over dataflyt enn MobX. Ser derfor ut som det kombinerer flere av fordelene fra Redux og MobX, samtidig som det eliminerer noen av ulempene.<\/p><p>Ulemper: Fungerer kun med bruk av hooks. Er veldig nytt, og dermed mindre brukt enn andre alternativer. Kan dermed v&#230;re bugs som ikke er oppdaget, og det er trolig vanskeligere &#229; s&#248;ke opp l&#248;sninger p&#229;&#160;feil som oppst&#229;r.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1641,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er to forskjellige m&#229;ter &#229; h&#229;ndtere kommunikasjon mellom klient og server. REST har v&#230;rt standarden som har blitt brukt i mange &#229;r, mens graphql er relativt nytt.<\/p><p>REST fungerer ved at man definerer endepunkter som klienten bruker for kommunikasjon vi HTTP-requests. Dette gj&#248;res ved at man definerer hvilken data som skal v&#230;re tilgjengelig p&#229; hvert endepunkt. Hvert endepunkt kan s&#229; n&#229;s ved &#229; bruke forskjellige URI&#39;er for hvert endepunkt. Det er dermed definert hva hver enkelt endepunkt inneholder, og klienten er begrenset til disse ved kommunikasjon med serveren. En ulempe med dette er at all data tilgjengelig p&#229; et gitt endepunkt m&#229; hentes ut, selv om klienten muligens kun trenger en liten del av dataen. Dette kalles overfetching. For &#229; hindre dette, kan det settes opp flere endepunkter, med mer spesifik data. For eksempel kan en URI som ender med /users inneholde data for alle brukere i systemet, mens users/*userid* kan returnere data for en spesifik bruker. Dette fungerer fint hvis klientet trenger data for en spesifik bruker, men l&#248;ser ikke problemet hvis klienten trenger data til en gitt gruppe brukere som det ikke er spesifisert noe eget endepunkt for.<\/p><p>&#160;<\/p><p>Graphql er designet for &#229; kunne gi mer effektive sp&#248;rringer. Dette gj&#248;res ved at man kan spesifisere i sp&#248;rringer hva slags type data man vil ha, men ogs&#229; legge til ulike begrensninger p&#229; datasettet som returneres. For eksempel kan man spesifisere ulike krav til dataobjektene. For &#229; fortsette med eksempelet om brukere, kan man i en graphql-sp&#248;rring spesifisere at man kun &#248;nsker brukere som tilfredstiller et gitt krav. Dette kan v&#230;re feks kj&#248;nn for brukeren. Det er ogs&#229; mulig &#229; spesifisere hvilke datafelt man &#248;nsker &#229; hente ut. For eksempel kan man spesifisere at man kun &#248;nsker id, navn og alder for brukerne. Med REST m&#229;tte man ha hentet ut all informasjonen om hver bruker, selv om man kun &#248;nsket &#229; benytte seg av tre verdier hva hver bruker. Dette er en kjempefordel med graphql, ettersom det tillater &#229; gj&#248;re begrensninger p&#229; datasettet f&#248;r det sendes fra server til klient. Selve sendingen mellom server og klient tar som regel betydelig lenger til en filtrering av datasetter og lignende. Derfor er det en stor fordel &#229; kunne filtrere f&#248;r datasettet sendes, siden det vil medf&#248;re at selve datasette blir mindre, og sp&#248;rringen tar kortere tid. Bruk av graphql er ogs&#229; begrenset til h&#229;ndtering av json-data, men dette er ikke noe problem i de flerste situasjoner.<\/p><p>&#160;<\/p><p>En annen forskjell er at REST har mange forskjellige request som kan brukes (GET, POST, PUT, PATCH og DELETE), mens graphql gjennomf&#248;rer all kommunikasjon mellom server og klient (b&#229;de fetching og mutasjoner) med bruk av POST.<\/p><p>&#160;<\/p><p>For sm&#229; prosjekter kan det v&#230;re enklere &#229; bruke REST, ettersom det er begrenset hvor mange endepunkter det er behov for. Det kan ogs&#229; bli un&#248;dvendig komplisert &#229; definere typer og skjemaer som er n&#248;dvendig i graphql. &#160;I st&#248;rre prosjekter vil derimot dette v&#230;re verdt &#229; gj&#248;re, ettersom det kan utgj&#248;re en betydelig forberding i hvor effektivt data h&#229;ndteres.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533879,"ext_inspera_userAssessmentSetupId":7140000,"ext_inspera_userAssessmentId":4841345,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Pettrem Markus Rosenvinge (10070)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":45043924,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3075,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Callback funksjoner gj&#248;r det mulig for children-komponenten &#229; sende funksjoner som props til parent-komponenten. En callback funksjon&#160;sendes ned til en&#160;child-komponent&#160;og sendes tilbake til parenten med en ny state, gjerne p&#229; et senere tidspunkt gjerne gjennom noe interaksjon med child-komponenten.<\/p><p>&#160;<\/p><p>Propdrilling er prosessen man m&#229; gjennom for &#229; hente ut data nedover i React-strukturen. Uten en god m&#229;te &#229; l&#248;se dette p&#229;, vil det kreve mye energi lagt inn i &#229; grave nedover i hierakiet for &#229; hente de ut. Her kommer bruk av statemanegements inn, som Context,&#160;Redux og MobX. Her kan du hente store data og sende ut informasjon til de komponentene som trenger det. Det l&#248;ftes alts&#229; ut informasjon som lagres et sted det er tilgjengelig fra hvor som helst i appen&#160;<\/p><p>&#160;<\/p><p>Hooks er et relativt nytt konsept, og&#160;lar en bruke state-&#160;og livssyklusmetoder p&#229; komponenter som ikke er klassekomponenter. Det reduserer antall boilerplates for hver komponent og gj&#248;r det lettere &#229; holde oversikt. Du kan f.eks. hooke en React state til en funksjonell komponent. Det hookes p&#229; ved useState(). Det er en effektiv m&#229;te &#229; bruke &#229; gjenbruke funksjonalitet mellom komponenter.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1521,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek og en m&#229;te &#229; l&#248;se global&#160;state management p&#229; i React. Den har f&#230;rre boilerplates enn f.eks. Redux og er mer skalerbart da man slipper &#229; gj&#248;re om hele koden for &#229; implementere det. Den fungerer slik at det g&#229;r en dataflow via&#160;<em>atoms, <\/em>via&#160;<em>selectors&#160;<\/em>og inn i komponentene. Atoms inneholder states og selectors er enkle funksjoner som tar inn atomsene som input og gj&#248;r det mulig &#229; endre statsene. Man kan ogs&#229; knytte flere komponenter opp mot samme state.&#160;Det er som er praktisk med atoms er at n&#229;r en state endrer seg, vil kun de komponentene som er tilknyttet staten re-rendre seg, og ikke alle komponentene. Dette i kontrast til f.eks. ContextAPi. Dette gj&#248;r applikasjonen mer effektiv. Man slipper ogs&#229; &#229; lage en separert store for &#229; handle states. Recoil syntaksen er ogs&#229; n&#230;rmere React, som gj&#248;r l&#230;ringskurven mindre bratt hvis man allerede kan React. I&#160;likhet med redux og&#160;context wrapper du det ogs&#229; i en provider, her kalt RecoilRoot. I redux m&#229; man dispatche en funksjon for &#229; oppdatere den, i Recoil gj&#248;res dette i selectoren.&#160;<br /><br />En ulempe med Recoil er at det kun kan brukes p&#229; funskjonelle komponenter, grunnet bruk av hooks. Det m&#229; ogs&#229; tas i betrakting at det er nytt, eksperimentelt og ikke ferdig utviklet.<\/p><p>&#160;<\/p><p>Alt i alt virker det som en god og effektiv m&#229;te &#229; l&#248;se statemanage p&#229;, men har godt av &#229; videreutviklet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2274,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Med Rest definerer vi ett, eller flere, endepunkter for &#229; skrive, lese eller endre ressurser ved hjelp av URI og HTTP-requests. Caching lar deg lagre all informasjonen som hentes ut via Rest i nettleseren. En klar ulempe med Rest er at der det skal hentes ut mye infromasjon, s&#229; blir det fort mange endepunkter, som gj&#248;re at&#160;det er fare for overfetching. Da hentes mer data ut enn du kanskje trenger og kan senke effektiviteten.<\/p><p>&#160;<\/p><p>Mens Rest er et mer arktitektuelt konsept, er GraphQL et spr&#229;k og et sett med verkt&#248;y som opererer med ett edepunkt via HTTP.&#160;Med GraphQL slipper du overfetchingen som i Rest, da dataen som hentes ut hentes i en request og man f&#229;r tilbake kun den man ettersp&#248;r. Det l&#248;ses alts&#229; slik at man sender en foresp&#248;rsel til serveren der man bestemmer s&#248;ket og hva som skal returneres. Det vil dermed v&#230;re mangelfull caching, i motsetning til i Rest, siden du aldri henter ut mer infromasjon enn du trenger.&#160;GraphQL sjekker ogs&#229; om en sp&#248;rring er gyldig eller ikke, slik at server og klient effektivt kan si ifra dersom den ikke er det. Med GraphQL opprettet man et schema som forteller hvordan en klient skal hente ut data fra serveren.&#160;GraphQL st&#248;tter bare JSON-filer, som kan v&#230;re en ulempe. GraphQL vil ofte ha en brattere l&#230;ringskurve med &#229; sette seg inn i, s&#229; Rest vil v&#230;re enklere bruke for nyoppstartede.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535361,"ext_inspera_userAssessmentSetupId":7140026,"ext_inspera_userAssessmentId":4841368,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gahre Greger Tronstad (10088)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22048036,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1744,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er bygget p&#229; en hierarkisk struktur over komponentene (komponenttre). La oss si at en komponent som ligger lavt nede i komponenttreet &#248;nsker informasjon fra en komponent som ligger h&#248;yere oppe, m&#229; denne informajsonen sendes gjennom alle leddene av komponenter for &#229; komme til &#248;nsket komponent. Dette kalles prop-drilling. Hvis applikasjonen er stor og best&#229;r av mange ledd i komponenttreet, vil man helst unng&#229; &#229; benytte seg av prop-drilling. En annen form for&#160;utveksling av informasjon p&#229; tvers av leddene i komponenttreet, er&#160;callback funksjoner. Ved callback funksjoner kan du sette inn en funksjon som parameter til en annen funksjon, og forventes &#229; bli kalt opp igjen p&#229; et senere tidspunkt. P&#229; den m&#229;ten kan man jobbe litt p&#229; tvers av React-hierarkiet. I stedet for prop-drilling og callback funksjoner kan&#160;kan man&#160;heller ta i bruk state management, som lagrer globale states, for &#229; unng&#229; alle ekstra&#160;ledd&#160;mellom der informasjonen befinner seg og der den &#248;nskes &#229; hentes opp. Det flytter data fra ulike komponenter, og gj&#248;r den mer&#160;tilgjengelig i applikasjonen. Eksempler p&#229; dette er Context, Redux og MobX. Ved bruk av state-managenent blir det en mer oversiktlig struktur som er lettere &#229; skallere.<\/p><p>States brukes for &#229; lagre ulike ting i applikasjonen etter at siden er refreshet. For at en skal kunne benytte seg av states i funksjonelle komponenter m&#229; man bruke hooks.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3669,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><u>Recoil<\/u><\/p><p>Recoil er et React-bibliotek for globale state-management. Et problem med andre l&#248;sninger n&#229;r det kommer til globale state management, er at det er mye man m&#229; sette seg inn i og mange boilingplates. Recoil er en mer s&#248;ml&#248;s overgang fra React, det er et enklere system og man trenger ikke sette seg inn i noe helt nytt.&#160;<br />Recoil best&#229;r av atoms og selectors, hvor atoms er globale state-verdier, mens selectors er funksjoner som tar inn atoms og returnerer en oppdatert state hver gang atoms&#39;ene blir oppdatert.&#160;<\/p><p>&#160;<\/p><p><u>Likheter<\/u><\/p><p>Basert p&#229; samme prinsipp som MobX, mtp observers og observables, hvor selectors returnerer oppdatert state n&#229;r atoms endrer seg.<\/p><p>&#160;<\/p><p><u>Fordeler med Recoil<\/u><\/p><p>Det er enkelt &#229; komme i gang med da det&#160;er et mindre &#34;kompleks&#34; system enn for eksempel Redux. I tillegg til at det er f&#229; boilingplates.&#160;<\/p><p>Recoil f&#248;les i st&#248;rre grad som React, det skiller seg ikke s&#229; mye ut som de andre (MobX, Redux etc).<\/p><p>Trenger ikke rerender hele appen hver gang en state oppdateres. Rerendrer kun komponenten(e) som er knyttet til det atoms&#39;et som endrer seg, som f&#248;rer til at hele applikajsonen er mer effektiv.<\/p><p>Med Recoil er det ikke n&#248;dvenig &#229;&#160;lage separert store.<\/p><p>M&#229; ikke gjennom s&#229; mange ledd hver gang states skal oppdateres.<\/p><p>Hvis man bruker Redux p&#229; et prosjekt, et det lurt &#229; v&#230;re klar over det fra starten. Recoil er mye mer skallerbart, og man trenger ikke omstrukturere filen i like stor grad&#160;hvis du velger &#229; bruke det.<\/p><p>Recoil har ogs&#229; likere syntax som React, enn for eksempel Redux og MobX.<\/p><p>&#160;<\/p><p><u>Ulemper med Recoil<\/u><\/p><p>Recoil er fremdeles relativt nytt, og er derfor ikke nok utviklet og brukt enda, sammenlignet med Redux.&#160;<\/p><p>Man kan bare bruke Recoil i funksjonelle komponenter, da de tar i bruk hooks.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://blog.logrocket.com/simple-state-management-react-recoil/<\/p><p>https://www.telerik.com/blogs/recoil-in-react<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1745,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL er begge&#160;backend api.<\/p><p>I REST API er kommunikasjonen mellom server og client bygget p&#229; HTTP requests hvor endepunktene er med p&#229; &#229; bestemme hva som hentes ut. Ved hjelp av blant annet GET,- PUT- og POST-requests kan en bruker hente opp, legge til og endre data fra en database. I og med at dataen hentes opp ved hjelp av endepunktene kan det&#160;resultere i at en m&#229; benytte seg av mange kall, noe som igjen kan resultere i at for mye data blir hentet opp i forhold til hva du trenger. Dette kalles overfetching. REST API benytter seg av caching, som vil si at data som hentes opp blir lagret i nettleseren, slik at det ikke er n&#248;dvendig &#229; hente opp samme data flere ganger.&#160;<\/p><p>P&#229; samme m&#229;te som med REST API, henter ogs&#229; GraphQL informasjon fra databasen gjennom HTTP-request, men med GraphQL er det kun ett endepunkt som blir brukt ( gjerne &#34;/graphql&#34;). Ved &#229; sende en query til serveren, er det mulig &#229; spesifisere &#248;nsket data, slik at man unng&#229;r overfetching. GraphQL mangler bruken av caching, og st&#248;tter kun JSON data, noe som kan til tider v&#230;re problematisk. GraphQL legger til rette for at bruker kan validere, gjennom &#229; spesifisere queriene.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535463,"ext_inspera_userAssessmentSetupId":7139925,"ext_inspera_userAssessmentId":4842164,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Elling Helene (10172)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34481460,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2597,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt handler om &#229; kunne sende &#34;callback&#34; funksjoner fra foreldre til barnekomponenter. Her brukes det&#160;states, der funksjoner&#160;i barnekomponenter kan sette&#160;tilstander&#160;i komponenter h&#248;yere i komponenthierarkiet&#160;(foreldre komponenter). For klasser s&#229; kan man legge til local states, slik&#160;vi kan unytte this.state og staten man vil bruke. Local state&#160;bruker rent javaScript til &#229; holde p&#229; informasjonen. States plasseringen&#160;er isolert innenfor den&#160;komponent den er brukt i. Dette kan i tillegg oppn&#229;s via&#160;hooks. Hooks er et sett av ulike funksjoner som man kan bruke i funksjonelle komponenter, slik at man unng&#229;r&#160;&#229; lage en klasse. Man kan bruke hooks som useState&#160;for &#229; legge til en state i en funksjonell komponent. Der states kan bli satt i foreldre komponenter ved bruken av setState. En state vil vanligvis endre seg n&#229;r det oppst&#229;r en ny rendering av en komponent, og barnekompnentene hvis det er noen. Man kan ogs&#229; benytte seg av bibliotek som MobX og Redux for &#229; utnytte deres states managements. Dette forenkler&#160;oversikten og kontroll over alle statesene som blir brukt i en applikasjon. State management&#160;som Redux og MobX&#160;lar programmeren&#160;samle alle states i en plass, samt muligheten til &#229; endre statesene&#160;hvor som helst i komponenthierarkiet. Siden data flyter nedover, blir det et hierarki.&#160;Forskjellen mellom h&#229;ndteringene&#160;er at Redux er single store og uforanderlig, mens MobX&#160;er multiple stores, der de alle avledninger oppdateres automatisk. Redux har fokus p&#229; bruken av reducers og actions. MobX&#160;velger &#229; ha&#160;enklere syntaks for &#229; redusere eksess kode.&#160;<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2962,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management. Recoil&#160;var konstruert for&#160;&#229; l&#248;se tre states problemer som andre states managments stod ovenfor. Det f&#248;rste er fleksibel&#160;deling av states. Det andre er muligheten til &#229; avlede&#160;data og s&#248;k. Det tredje er&#160;muligheten til &#229; observere states i hele appen (app-wide). Med fleksibel&#160;deling av states, &#248;nsker man optimal&#160;syncing blant forskjellige deler av react appen. Det er viktig at appen fortsatt yter p&#229; et h&#248;yt niv&#229;. &#160;Avledede data og s&#248;k handler om &#229; beregne ting basert p&#229; forandrende states. Prosessen skal v&#230;re effektiv og&#160;robust slik at man kan unng&#229;r bugs, selv med en h&#248;y h&#229;ndteringshastighet. Muligheten for &#229; obserevere states&#160;betyr&#160;&#229; kunne observere alt som skjer i appen for en komponent. Tilsvarende l&#248;sninger vi har og har brukt er Redux og MobX, siden alle tre er ulike former for state management.&#160;<\/p><p>Frodelen med &#229; bruke Recoil er muligheten til &#229; dele en del av en state med flere ulike komponenter, uten potensiell&#160;ytelseskomplikasjoner.&#160;Dette kan v&#230;re nyttig hvor man har nettsider&#160;der man m&#229; lagre states for mange indiviuelle deler hele tiden. For eksempel ved bruke av nettside som lar deg tegne diagrammer. Ved tradisjonell bruk av states (eller gjennom Redux/MobX)&#160; m&#229; hele&#160;applikasjon rendres p&#229; nytt n&#229;r noe endres. Eventuelt m&#229; komponenten&#160;der staten endres, rendres p&#229; nytt. Dette vil som regelen ta lang tid &#229; implementere og ikke v&#230;re den optimale m&#229;ten &#229; gj&#248;re det p&#229;. Derfor vil biblioteket Recoil l&#248;se dette problemet ved at man kan ta ut deler av states (atoms) og gi komponenter kun de delene. Kun verdien vil endre&#160;seg n&#229;r staten endres.&#160;<\/p><p>I de fleste situasjoner vil Recoils funksjonsbredde v&#230;re un&#248;dvendig.&#160;Dersom en ikke trengerer&#160;slike state managements, vil&#160;Redux og MobX&#160;v&#230;re nok for de fleste&#160;applikasjoner. Recoil ble i bunn og grunn laget for ytelsesproblemer ved endring av mange objekter med mange states, og hvis man ikke skal det s&#229; har man ikke noe bruk for biblioteket.&#160;<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://medium.com/swlh/brief-introduction-of-recoil-js-9d579197c8c8<\/p><p>https://recoiljs.org<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2811,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en arkitektur for web basert kommunikasjon mellom klient og tjener, der fokuset er p&#229; &#229; brukte HTTP foresp&#248;rsler til &#229; aksessere og bruke data. Data vil v&#230;re orgianisert i et grensesnitt.&#160;Her benytter man seg av foresp&#248;rsler som GET, POST , PUT, DELETE for &#229; lese, opprette, endre eller slette resusser. REST handler om &#229; ha en stateless kommunikasjon og vil derfor kunne bruke cashing, URI for &#229; identifisere resusser og HTTP foresp&#248;rslene. Rest kan ha et eller flere endepunkter der den&#160;kan&#160;endre, skrive eller lese p&#229; ressurser&#160;ved bruken av HTTP&#160;foresp&#248;rslene og URI.&#160;<\/p><p>GraphQL er et query spr&#229;k (sp&#248;rrespr&#229;k) for APIer og en runtime. Her organiseres data i en graf fremfor et gresesnitt s&#229;nn som REST gj&#248;r. Her spesifiserer man i en JSON&#160;hva man &#248;nsker &#229; hente og hva slags data man vil ha. GraphQL baserer seg p&#229; at man sender sp&#248;rringer om s&#248;k og hva slags data man &#248;nsker &#229; retunere eller oppdatere. Her hentes data i request, noe som gj&#248;r at man unng&#229;r &#229; hente for mye data. Man kan ikke bruke cashing i HTTP-laget siden GraphQL kun st&#248;tter bruken av JSON-data. REST kan derimot bruke cashing noe som kan v&#230;re nyttig for noen applikasjoner.&#160;<\/p><p>Hovedforskjellen&#160;mellom REST og GraphQL er at rest er et arkitekturkonsept for nettverks basert programvare.&#160; I motsetning er GraphQL et sp&#248;rre spr&#229;k som opererer over kun et endepunkt ved bruken av HTTP. N&#229;r REST henter&#160;informasjon f&#229;r man tilbake hele dataset.&#160;Ettersp&#248;rsel av data fra flere objekter vil dermed&#160;gi hele dataen til de objektene. Her f&#229;r man like mange endepunk som antall objekter man &#248;nsker data&#160;fra. Derfor vil dataen fra REST v&#230;re un&#248;dvendig mye, s&#229;ledes&#160;kan man ved bruken av&#160;GraphQL ha sp&#248;rringer som er spesifike i forhold til den som er &#248;nskelig. Med GraphQL kan man da unng&#229; un&#248;dvendig sp&#248;rringer og&#160;henting av data. Her er det viktig at man forteller akkurat hva man &#248;nsker, for det er det som vil bli hentet. REST er mer brukt n&#229;r man skal distribuere (deploy) API. Det er fordi det er lettere &#229; f&#229; tak i analyse fra APIet med Rest, siden GraphQL har begrenset verkt&#248;y.<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis#:~:text=The%20Core%20Difference%20Between%20REST,a%20single%20endpoint%20using%20HTTP.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535550,"ext_inspera_userAssessmentSetupId":7139962,"ext_inspera_userAssessmentId":4841259,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sæther Jonas (10120)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35325796,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2290,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har mange muligheter for &#229; h&#229;ndtere tilstand og dataflyt. F&#248;rst og fremst har komponentene man lager ofte intern state, enten i form av hooks (useState), eller den litt eldre varianten med klasser og this.state. Her er tanken at enkeltkomponentene har bruk for &#229; lagre tilstand basert p&#229; feks input fra brukeren, men at ikke andre komponenter i utgangspunktet trenger tilgang p&#229; denne. P&#229; denne m&#229;ten kan man forenkle strukturen, ved &#229; slippe en st&#248;rre tilstand for hele applikasjonen. Ved bruk av useState feks, definerer man en initiell verdi for hver state-verdi, og kan aksessere og endre p&#229; disse hvor som helst i komponentet.<br /><br />Likevel er det ofte &#248;nskelig i en React-applikasjon med tilstand for hele applikasjonen. Her kan&#160;context-apiet brukes til &#229; definere tilstand for hele kodeblokken som &#34;wrappes&#34; i en provider. Eksempelvis kan man tilf&#248;re context til alle komponentene sine ved &#229; implementere denne i app.js som man ofte finner i react-prosjekter. Konseptet er ganske likt som useState, men useContext-hooks kan importeres i alle &#248;nskelige komponenter, og brukes derfra. Dette kan gj&#248;res hvis flere komponenter m&#229; ha tilgang p&#229; noe tilstand/data, feks innlogget bruker eller darkmode p&#229; applikasjonen.<\/p><p>&#160;<\/p><p>Komponenter trenger ikke context for &#229; snakke sammen, det kan de gj&#248;re &#34;direkte&#34; via props. Props kan sende hva som helst, veldig ofte tilstand, nedover eller oppover mellom komponentene. Et vanlig bruksomr&#229;de er en forelder-komponent som skal rendre mange underkomponenter, eksempelvis et resultat-komponent i en s&#248;kemotor&#160;som skal vise frem x-antall linjer med s&#248;keresultater. Da kan man enkelt gi underkomponentene tilgang p&#229; relevant state, ved &#229; definere props. Bruk av props er i mange tilfeller mer gunstig og enklere enn andre alternativer, men krever at komponentene ligger &#34;n&#230;rt hverandre&#34;. Dersom en m&#229; sende props gjennom mange lag av komponenter, er det gjerne en d&#229;rlig l&#248;sning, fordi un&#248;dvendig mange komponenter m&#229; forholde seg til data som sendes.<\/p><p>&#160;<\/p><p>Et annet vanlig alternativ for state i React-applikasjoner er Redux og React-Redux. Redux er et bibliotek for h&#229;ndtering av en st&#248;rre state (store), mens react-redux knytter dette opp mot React. Redux l&#248;ser mye av samme problematikken som context gj&#248;r, men&#160;beregnet p&#229; mye tilstand,&#160;og brukes ofte som et mellomledd for data fra et api. Her definerer man &#34;actions&#34; som brukes til &#229; sjekke hva storen allerede inneholder, og evt fetche mer data fra api. Disse kj&#248;res gjerne i&#160;livssyklusmetoder i komponenter som trenger gitt data. Et eksempel kan v&#230;re henting av en brukerprofil. I det du trykker p&#229; &#34;Min profil&#34;, vil kanskje en profil-komponent rendre med en useEffect som inneholder en &#34;getProfile&#34;-action.&#160;Dermed vil redux kj&#248;re denne funksjonen, og s&#248;rge for &#229; populere storen med&#160;resultatet. Profil-komponentet b&#248;r da ha tilgang p&#229; riktig del av redux-storen (definert av selectors), som mates inn via props. P&#229; denne m&#229;ten kan react-komponentene slippe &#229; ta stilling til fetching av data, men bare fortelle n&#229;r de trenger noe data, og f&#229; tilgang til resultatet som props fra redux-storen og react-redux.<\/p><p>&#160;<\/p><p>Kilde: egen erfaring<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2344,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er rammeverk som i f&#248;lge docs skal l&#248;se en del problematikk rundt context. Umiddelbart virker det som et alternativ til redux/mobex/etc, fordi det skal v&#230;re et alternativ til vanlig react state som flyttes mye rundt mellom komponentene, og til context som ikke er beregnet til veldig mye tilstand. Recoiljs bruker &#34;atoms&#34;, som minner veldig p&#229; vanlig state ved at du definerer en default-verdi, og hooks som brukes for &#229; aksessere/endre p&#229; atomene. I motsetning til vanlig useState kan disse deles mellom komponenter, ved at man p&#229; tilsvarende m&#229;te som i Redux definerer selectors. Disse selectorene er funksjoner som henter ut relevant tilstand, og gir komponenter tilgang p&#229; state fra et eller flere atoms. Dersom tilstand endrer&#160;seg, vil en selector returnere ny data, og komponentene som lytter p&#229; den vil rendre p&#229; nytt. Selectorene her brukes ogs&#229; til &#229; endre p&#229; atomer, alts&#229; oppdatere tilstand.&#160;<\/p><p>&#160;<\/p><p>Fordeler med Recoil er at det likner p&#229; vanlig react-syntax (tilsvarende useState eller useContext), og benytter seg av hooks. Det er fort gjort &#229; sette opp, uten noe s&#230;rlig boilerplate. Begge disse gj&#248;r at utvikling med bruk av recoil antakelig er enkelt &#229; sette seg inn i, og relativt enkelt &#229; strukturere. Men, samtidig har eldre biblioteker som redux&#160;st&#248;tte for utvidelser som &#34;Redux DevTools&#34;, noe som er en klar fordel under utviklingen. Selv om redux kan v&#230;re mer tungvint &#229; sette opp, har det flere funksjoner (som reducers, og ulik middleware), som gj&#248;r at det gjerne er bedre enn recoil p&#229; st&#248;rre prosjekter. Recoil-docs p&#229;st&#229;r at recoil skal gi bedre ytelse ved at de bruker en rettet graf som er ortogonal p&#229; komponent-treet ditt. Her er alts&#229; poenget at data kan hentes rett fra atomene, via selector-funksjonene og inn i komponenter, uten &#229; m&#229;tte rendre annet en komponenten p&#229; l&#248;v-niv&#229; i React-treet. Med andre ord vil applikasjonen yte bedre enn om du feks hadde sendt state som props hele veien&#160;fra app.jsx, men dette er ogs&#229; samme problematikken som feks Redux l&#248;ser. Dermed er st&#248;rste fordelen som nevnt at Recoil har et mindre fotavtrykk, med enklere setup enn tilsvarende biblioteker.<\/p><p>&#160;<\/p><p>Kilde: recoil docs<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2547,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST api er en mye brukt form for API, med&#160;forh&#229;ndsdefinerte&#160;metoder/ressurser som aksesseres gjennom ulike routes/endpoints. For eksempel kan et api ta i mot GET eller POST til en gitt url, og returnere data fra en spesifikk metode basert p&#229; dette. Rest-apier er veldig strukturerte, ettersom man alltid har en definert struktur p&#229; routing av foresp&#248;rsler, og p&#229; data som skal returneres. Ulik data er separert. GraphQL&#160;derimot, ser p&#229; tilgjengelig data som en graf. Det medf&#248;rer mer en flytende struktur, og f&#230;rre restriksjoner p&#229; sp&#248;rringer til apiet. GraphQL&#160;har et eget sp&#248;rre-spr&#229;k som gj&#248;r det mulig &#229; bruke et enkelt endepunkt til &#229; sp&#248;rre om eksakt &#248;nsket data, i stedet for &#229; bruke ulike forh&#229;ndsdefinerte REST-endepunkter. Denne friheten gj&#248;r at GraphQL gjerne blir mindre forutsigbart&#160;og vanskeligere &#229; feilh&#229;ndtere. Samtidig er GraphQL&#160;mer fleksibelt, noe som &#229;pner for flere fordeler:<\/p><p>&#160;<\/p><p>Skal man eksempelvis hente ut b&#229;de en profil fra et sosialt nettverk, samt hobbyene som personen har valgt,&#160;gjennom et&#160;REST api, m&#229; en antakelig f&#248;rst sp&#248;rre etter personen og&#160;deretter gj&#248;re et kall for hver hobby. Det funker, men vil kreve flere sp&#248;rringer p&#229; data som egentlig er relatert. GraphQL&#160;l&#248;ser dette ved at man spesifiserer den dataen og feltene de som trengs. Dermed vil en f&#229; returnert alt p&#229; et kall til api-et, fordi relatert data er knyttet sammen i grafen. Ulempen er at en m&#229; v&#230;re mer n&#248;yaktig for &#229; definere slike sp&#248;rringer til GraphQL, men en har ogs&#229; mye mer muligheter for tilpassing.<\/p><p>&#160;<\/p><p>P&#229; den andre siden risikerer man &#229; f&#229; ut mer data enn n&#248;dvendig fra et REST api, alts&#229; irrelevant informasjon. Det er fordi en forh&#229;ndsdefinert respons ikke kan tilpasses slik som i GraphQL, en kan feks ikke sp&#248;rre om kun navn- og f&#248;dselsdato-feltene hos en bruker. En risikerer derfor overhead som gj&#248;r at responsen blir st&#248;rre og tar lenger tid, pluss at en m&#229; filtrere data frontend.<\/p><p>&#160;<\/p><p>Disse to ulempene med REST gj&#248;r at mange velger GraphQL&#160;for &#229; alltid kunne hente ut n&#248;yaktig den informasjonen som trengs.&#160;<\/p><p>&#160;<\/p><p>Kilde: https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11537688,"ext_inspera_userAssessmentSetupId":7139991,"ext_inspera_userAssessmentId":4841331,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Fossland Tore Apeland (10178)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":43342770,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1108,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstand brukes for &#229; holde orden p&#229; klassevariabler, og blir satt i konstrukt&#248;ren n&#229;r objektet blir definert. En endring i tilstand vil f&#248;re til at komponenten lastes p&#229; nytt. Disse tilstandsvariablene kan brukes hvor som helst i hele komponenten.<\/p><p>&#160;<\/p><p>I React kan&#160;dataflyten g&#229; begge veier i komponenthiarkiet. Man kan sende rent lesbare tilstander fra&#160;foreldrekomponenten&#160;til barnkomponenten. Disse blir endret i barnekomponenten n&#229;r foreldrekomponenten sin tilstand endres.<\/p><p>&#160;<\/p><p>For at dataflyten skal g&#229; opp igjen i hierarkiet m&#229; vi bruke det som kalles &#34;callbacks&#34;. En callback er en varsling til forelderen om at det har skjedd en endring i props. Man unng&#229;r dermed at foreldre sin tilstand blir direkte p&#229;virket av barna&#160;som&#160;gj&#248;r applikasjonen mer robust.<\/p><p><br />Dataflyten p&#229; tvers av komponenter kan fort bli rotete, da man m&#229; kombinere disse to teknikkene for &#229; g&#229; opp og ned i hierarkiet. Det er her man gjerne &#248;nsker en form for global tilstandsh&#229;ndtering, som lar alle relevante komponenter hente det man trenger direkte fra et delt lager.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":4160,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et helt nytt &#34;state management library&#34; lagd av Facebook. Det best&#229;r i hovedsak av to ting, nemlig &#34;atoms&#34; og &#34;selectors&#34;.<\/p><p>&#160;<\/p><p>Et atom er en &#34;piece of state&#34;, det vil si at den bare inneholder et objekt med en n&#248;kkel og verdi.<\/p><p>Den har ikke bruk for et sentralisert store som inneholder alle objektene i ett. Dette er annerledes enn det vi har gjort i tilsvarende l&#248;sninger tidligere (Context, Redux). Dette f&#248;rer til at man slipper un&#248;dvendige &#34;re-renders&#34; sammenlignet med f.eks&#160;Context og Redux. MobX st&#248;tter ogs&#229; denne funksjonaliteten vha. observable.<\/p><p>&#160;<\/p><p>Et atom kan bli lest og skrivd til fra alle komponenter og krever lite hjelpekode.<\/p><p>Komponenter som leser fra&#160;atomet&#160;abbonnerer p&#229; denne verdien. N&#229;r verdien endres vil disse, og bare disse,&#160;bli&#160;lastet p&#229; nytt med oppdatert verdi. Dette er etter min opfatning samme funksjonalitet som observer hook&#39;en i mobx.<\/p><p>&#160;<\/p><p>Hvert atom har egen n&#248;kkel, bruker dette for &#229; hente tilstanden i&#160;objektet.<\/p><p>Komponenter som m&#229; b&#229;de lese og skrive bruker useRecoilState, som fungerer p&#229;&#160;samme m&#229;te som usestate.<\/p><p>N&#229;r man endrer verdien til denne hooken oppdateres de andre abbonnerende komponentene automatisk.&#160;<\/p><p>Kan ta inn b&#229;de atom og selector.<\/p><p>Selector er en &#34;pure function&#34;, dvs at den gir samme output for lik input.<\/p><p>Denne returnerer en ny&#160;state etter at input state har blitt modifisert p&#229; en eller annen m&#229;te.&#160;<\/p><p>kan sammenlignes med reducer i redux (tar inn state og action, returnerer ny modifisert state).<\/p><p>&#160;<\/p><p>Fordeler:<\/p><ul>\t<li>lagd av facebook (samme som react), vet det kommer til &#229; bli vedlikeholdt.<\/li>\t<li>Enkel m&#229;te &#229; dele state p&#229; tvers av komponenter og unng&#229;r ytelsesproblem med lasting av hele app p&#229; nytt.<\/li>\t<li>Trenger veldig lite boilerplate kode (se forkalring)<\/li>\t<li>Oppn&#229;r alt dette med et enkelt api, kontra spesielt&#160;Redux.<\/li><\/ul><p>Ulemper:<\/p><ul>\t<li>M&#229; skrive om kodebasen p&#229; eksisterende prosjekt.<\/li>\t<li>Mange applikasjoner vil ikke n&#248;dvendigvis ha bruk for denne funksjonaliteten. (Hvis man har performance problem s&#229; er det forst&#229;elig &#160;men ellers hvorfor bruke all tid p&#229; &#229; endre kodebasen?)<\/li>\t<li>Veldig nytt og eksprimentelt, lite dokumentasjon &#229; finne enn&#229;.<\/li>\t<li>Redux dev tools er veldig nytt, recoil har ikke noe tilsvarende enn&#229; som jeg kunne finne.<\/li><\/ul><p>&#160;<\/p><p>kilder: https://recoiljs.org<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1868,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Diskusjonen ved bruk av REST API og Graphql er h&#248;yst relevant i dag, og er en problemstilling som er i konstant utvikling.<\/p><p>&#160;<\/p><p>En vesentlig forskjell mellom REST API og Grapql er hva man henter for en gitt sp&#248;rring. REST m&#229; ofte gj&#248;re mange kall for &#229; hente data du trenger&#160;hvis dataen befinner seg i flere endepunkt. Man f&#229;r i tillegg alltid et komplett datasett, uavhengig av hvor mye av dette man trenger. Dette kalles &#34;overfetching&#34;.<\/p><p>&#160;<\/p><p>Fordelen med REST API er hvor enkelt det er &#229; benytte. Du har et endepunkt som du kjenner oppgaven til, som gj&#248;r det lett &#229; forst&#229; og behandle. (Et gitt endepunkt gir en gitt data).<\/p><p>&#160;<\/p><p>I GraphQL vil man derimot definerere b&#229;de s&#248;k og hvilke&#160;data som skal returneres eller oppdateres,&#160;f&#248;r man sender sp&#248;rringen. Dette gj&#248;r man ved hjelp av query-spr&#229;ket deres. Her kan man skreddersy hvilke data man &#248;nsker &#229; hente, som kan v&#230;re alt fra hele datasettet til spesifikke objektvariabler. Den store fordelen med dette er at du bare henter data du &#248;nsker. Dette f&#248;rer til at behandlingskostnaden av &#229; hente datasettet reduseres dramatisk.<\/p><p>&#160;<\/p><p>En annen stor fordel med REST API er at man bruke caching-mekanismen som st&#248;ttes av alle weblesere som standard. P&#229; grun av virkem&#229;ten til Grapql vil ikke det samme&#160;v&#230;re mulig, siden den ikke f&#248;lger den samme HTTP spesifikasjonen for caching og bruker heller et enkelt endepunkt. Dette kan l&#248;ses vha. flere eksterne bibliotek, vi brukte&#160;&#34;Apollo Graphql&#34; for &#229; l&#248;se dette. Et annen ulempe med Graphql&#160;er at det st&#248;tter bare JSON-data, i kontrast til REST som kan benytte en rekke mulige datatyper. I Graphql har med p&#229; en annen side mulighet for &#229; type variablene i schema, som ikke er mulig i REST.<\/p><p>&#160;<\/p><p>REST API har v&#230;rt industristandarden en god stund, og dette reflekteres i mengden verkt&#248;y og informasjon det er &#229; finne. Graphql har&#160;fortsatt veldig lite hjelpeverkt&#248;y tilgjengelig&#160;men dette er noe som blir forbedret dag for dag. Med tanke p&#229; hvor lenge Graphql har v&#230;rt aktuelt, vil det v&#230;re h&#229;p for store endringer av dette i n&#230;r framtid.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11537736,"ext_inspera_userAssessmentSetupId":7140064,"ext_inspera_userAssessmentId":4841388,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:08Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Haugrud Thomas Dørum (10167)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":23131504,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2009,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-applikasjoner har flere l&#248;sninger p&#229; tilstand og dataflyt mellom komponenter.<\/p><p>&#160;<\/p><p><strong>Props<\/strong><\/p><p>Alle komponenter kan ta properties som input. Her f&#229;r man da muligheten til &#229; sende data mellom komponenter. Dette kan v&#230;re rene data variabler eller funksjoner som gj&#248;r (state) endringer i andre komponenter. Properties fungerer p&#229; samme m&#229;te som vanlige funksjonskall med properties og kan da bruke disse i komponenten som man selv &#248;nsker.<\/p><p>&#160;<\/p><p><strong>Komponent state<\/strong><\/p><p>Dette er den mest basic formen for tilstand i React. Her vil en komponent h&#229;ndtere sin egen state. Dette gj&#248;res ved hjelp av hooken `useState`. Her f&#229;r man da en variablen som holder staten og en funksjon (`setState`) for &#229; oppdatere denne variablen. En viktig forskjell mellom bruk av state og bare lokale variabler er at state trigger en re-render av komponenten.&#160;<\/p><p>&#160;<\/p><p><strong>Prop-drilling<\/strong><\/p><p>Dette er et konsept hvor man sender data opp og ned komponent treet ved hjelp av props. Her f&#229;r man da tilgang til data utenfor sin egen komponent.<\/p><p>&#160;<\/p><p>For eksempel gitt to komponenter: Parent og Child. Parent en counter state og Child en knapp. N&#229;r knappen i Child trykkes p&#229; &#248;nsker vi &#229; oppdatere Parent sin state. L&#248;sningen her blir &#229; sende `setState` funksjonen fra Parent ned til Child via props. Da kan Child bruke denne funksjonen som en onclick-action p&#229; knappen som vil oppdatere Parent sin state.<\/p><p>&#160;<\/p><p>Et problem med denne typen dataflyt er at det fort blir komplekst om man skal g&#229; langt opp/ned i treet. Det fungerer veldig bra som i eksempelet over med et tydelig definert parent/child forhold, men blir tungvindt om man snakker om et globalt state som gjelder for st&#248;rre deler av applikasjonen.<\/p><p>&#160;<\/p><p><strong>Context<\/strong><\/p><p>Context er en l&#248;sning til problemet nevnt over og React sin m&#229;te &#229; h&#229;ndtere globalt state. Det bygger p&#229; lage Providers som en wrapper til komponentene. Alle komponenter som ligger under denne i komponent treet vil ha tilgang til contexten. I motsetning til prop-drilling hvor data sendes ned er det komponentene under som vil lytte/hente context selv. Akkurat hva context best&#229;r av er en implementasjonsdetalj da det kan v&#230;re alt fra konstanter til state.<\/p><p>&#160;<\/p><p>Fordelen med Context i forhold til Prop-drilling er at man slipper &#229; tenke p&#229; &#229; sende nedover properties. For eksempel gitt tre komponenter: Parent, Child og Grandchild. Parent har fortsatt en counter state, Child er bare en proxy for Grandchild og Grandchild har en knapp som &#248;nsker &#229; oppdatere staten i Parent. Her kan vi da lage en Context Provider i Parent som inneholder `setState` funksjonen. Grandchild f&#229;r da muligheten til &#229; hente dette ved &#229; bruke `useContext` og kalle `setState` funksjonen for &#229; oppdatere Parent sitt state.<\/p><p>&#160;<\/p><p>En annen fordel er ettersom det kun er Consumers som bruker Contexten vil dette spare oss for re-renders av komponenter i treet som ikke bruker den. S&#229; om det er et dypt tre trenger man ikke n&#248;dvendig vis &#229; rerendre hele veien opp bare fordi en endring ble gjort.<\/p><p>&#160;<\/p><p><strong>Andre bibliotek<\/strong><\/p><p>Det finnes ogs&#229; andre l&#248;sninger for dataflyt i React ved hjelp av tredjepartsbibliotek. For eksempel Redux eller MobX. G&#229;r ikke inn p&#229; hvordan disse fungerer her pga. tidsbruk ettersom det dekkes til dels i Oppgave 2.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2151,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et React bibliotek for state management alternativ til Context / Redux / MobX og lignendne. M&#229;let er &#229; l&#248;se en del av problemene&#160;som oppst&#229;r i disse:&#160;<\/p><p>- Context er ikke designet for h&#248;y frekvens oppdatering og man f&#229;r fort en tett kobling mellom komponenter.<\/p><p>- Redux er veldig komplekst med mye boilerplate og struktur av kode.<\/p><p>&#160;<\/p><p>Recoil bygges opp av <strong>Atoms<\/strong> og <strong>Selectors<\/strong>. Viktig &#229; merke seg at dette er et eksperimentelt bibilotek per n&#229; og drastiske endringer kan skje da kun er p&#229; versjon 0.1.2 per i dag.<\/p><p>&#160;<\/p><p>Atoms er Recoil sitt state og kan brukes i steden for React sitt state i komponenter. Disse kan oppdateres og subscribes s&#229; flere komponenter kan bruke samme state og lytte til endringer.<\/p><p>&#160;<\/p><p>Selectors&#160;er funksjoner som tar atoms eller andre selectors som input og h&#229;ndterer re-rendering. Disse kan ogs&#229; subscribes av komponenter og det er da kun komponenter som er subscribed som vil bli rerenderet n&#229;r en selector blir evaluert. Viktig &#229; vite at disse er _pure_ funksjoner som vil si de ikke manipulerer annet state, men returnerer verdiene.<\/p><p>&#160;<\/p><p><strong>Recoil vs Redux<\/strong><\/p><p>Redux har en del boilerplate som m&#229; p&#229; plass f&#248;rst blant annet Store.<\/p><p>&#160;<\/p><p>Redux setter s&#229; opp et State ved hjelp av Reducers mens Recoil gj&#248;r det ved hjelp av Atoms. Atoms state er veldig likt React state med veldig lite kode for &#229; f&#229; p&#229; plass et globalt state.<\/p><p>&#160;<\/p><p>Redux bruker dispatch funksoner for &#229; gj&#248;re endringer i state. Recoil gj&#248;r dette ved bruk av Selectors som nevnt over. Her lager man en Selector som bruker et Atom sitt state til &#229; gj&#248;re en evaluering (ikke oppdatering av staten direkte).<\/p><p>&#160;<\/p><p>Implementasjon i en komponent med Redux vil man bruke `useSelector` og `useDispatch` hooksene til `react-redux` og disse vil da gj&#248;re state managmente direkte. I Recoil derimot kombineres dette ved bruk av React state som tar inn et Atom og en Recoil value som er Selectoren.<\/p><p>&#160;<\/p><p><strong>Fordeler&#160;<\/strong><\/p><p>- Frihet av kodestruktur<\/p><p>- Lav l&#230;ringskurve da det er veldig likt React State<\/p><p>- Robust, optimalisert,&#160;oppdatering av data i hele applikasjonen<\/p><p>&#160;<\/p><p><strong>Ulemper<\/strong><\/p><p>- Overkill? Ikke n&#248;dvendig &#229; bruke det f&#248;r man virkelig ser behovet<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee#:~:text=In%20redux%2C%20actions%20are%20fired,shared%20atom%20state%20using%20selectors<\/p><p>&#160;<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2977,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er begge APIer som sender JSON data over HTTP (er egentlig ikke et krav at det m&#229; v&#230;re JSON for REST, men ganske bransjestandard n&#229;).&#160;<\/p><p>&#160;<\/p><p>REST bygges gjerne opp med endepunkt som peker til resurser. Disse endepunktene kan man s&#229; interagere med via de forskjellige HTTP metodene (GET, POST, PUT, DELETE). Her kan man flittig ta i bruk statuskoder for &#229; gi feedback om hva som skjedde med requesten. Det kan v&#230;re greit &#229; merke seg at denne typen API ikke har en bestemt struktur, men det finnes en god del best practices for RESTful APIer som sier noe om hvordan disse b&#248;r utformes. I tillegg til endepunktene kan det brukes Query parameters for &#229; sende ekstra informasjon for eksempel filtrering &#180;/cars?year=1920` i alle requests og PUT/POST requests har en body som fylles med json data.<\/p><p>&#160;<\/p><p>F&#248;lger vi RESTful practices kan vi for eksempel ha endepunkt som:<\/p><p>GET /cars/:id<\/p><p>PUT /cars/:id<\/p><p>POST /cars<\/p><p>DELETE /cars/:id<\/p><p>GET /stores/:id/employees<\/p><p>GET /stores<\/p><p>...<\/p><p>&#160;<\/p><p>GraphQL har kun ett endepunkt (&#39;/graphql&#39;) hvor alle operasjoner blir utf&#248;rt. Her har man gjerne ogs&#229; definert resurser p&#229; samme m&#229;te som et endepunkt i REST, men ogs&#229; mer deskriptive &#34;metoder&#34; som utf&#248;rer andre operasjoner. Alle kall til et GraphQL API vil bruke POST metoden og alltid returnere statuskode 200 gitt at det er en valid request i forhold til schema. Her m&#229; man da v&#230;re obs p&#229; strukturen som returneres for error h&#229;ndtering (Har gjerne strukturen {data: {...}, errors: {...}}). I motsetning til REST er GraphQL sterkt typet hvor alt som kan sp&#248;rres om og alt som returneres er definert i et schema.<\/p><p>&#160;<\/p><p>Skal vi ha de samme resurrserne i GraphQL kan schema se s&#229;nn ut:<\/p><p>&#160;<\/p><p>type Query {<\/p><p>&#160; &#160;getCars: [Car]<\/p><p>&#160; &#160;getCar(id: ID!): Car<\/p><p>&#160; &#160;getStores: [Store]<\/p><p>&#160; &#160;getStore(id: ID!): Store<\/p><p>}<\/p><p>&#160;<\/p><p>type Mutation {<\/p><p>&#160; &#160;addCar(input: AddCarInput): Car<\/p><p>&#160; &#160;deleteCar(id: ID!): Car<\/p><p>&#160; &#160;updateCar: (input: UpdateCarInput): Car<\/p><p>}<\/p><p>&#160;<\/p><p>input AddCarInput {<\/p><p>&#160; &#160; model: String!<\/p><p>}<\/p><p>&#160;<\/p><p>input&#160;UpdateCarInput {<\/p><p>&#160; &#160; id: ID!<\/p><p>&#160; &#160; model: String!<\/p><p>}<\/p><p>&#160;<\/p><p>type Car {<\/p><p>&#160; &#160;id: ID!<\/p><p>&#160; &#160;model: String!<\/p><p>}<\/p><p>&#160;<\/p><p>type Employee {<\/p><p>&#160; &#160;id: ID!<\/p><p>&#160; &#160;name: String!<\/p><p>}<\/p><p>&#160;<\/p><p>type Store {<\/p><p>&#160; &#160;id: ID!<\/p><p>&#160; &#160;employees: [Employee]!<\/p><p>&#160; &#160;name: String!<\/p><p>}<\/p><p>&#160;<\/p><p>&#216;nsker man &#229; hente ut navnet p&#229; alle butikker og deres ansatte s&#229; kan dette gj&#248;res i &#233;n request i GraphQL ved:<\/p><p>&#160;<\/p><p>query {<\/p><p>&#160; &#160; getStores: {<\/p><p>&#160; &#160; &#160; &#160; name<\/p><p>&#160; &#160; &#160; &#160; employees: {<\/p><p>&#160; &#160; &#160; &#160; &#160; &#160; &#160;name<\/p><p>&#160; &#160; &#160; &#160; }<\/p><p>&#160; &#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>Mens REST m&#229; dette utf&#248;res i flere steg ved &#229; f&#248;rst kalle &#180;/stores` for &#229; f&#229; id og navn til butikkene for deretter &#229; kalle `/stores/:id/employees` for hver av butikkene. Her kan man argumentere for at APIet er d&#229;rlig oppbygd og man kunne inkludert/embeded employees i `/stores`&#160;resursen for &#229; unng&#229; flere HTTP kall, men da f&#229;r man ett annet problem: overfetching. I GraphQL er ikke dette et problem da man eksplisitt m&#229; be om hvilke fields man &#248;nsker skal bli returnert.<\/p><p>&#160;<\/p><p>Det finnes l&#248;sninger i REST som kan hjelpe til &#229; l&#248;se disse problemene.&#160;<\/p><p>1) Man kan inkludere query parameters som trigger embedding av sub-resurser i responsen.<\/p><p>2) Man kan ha egne endepunkt som har ekstra data eller er lettere tilgjengelig (unng&#229; deep nesting av resurser.<\/p><p>&#160;<\/p><p>Caching er et annet punkt som er verdt &#229; nevne. Ettersom GraphQL alltid bruker samme endepunkt med en POST request kan man ikke ta i brukt den innebygde HTTP cachingen i nettlesere som REST kan. Her m&#229; man gjerne ha egne bibliotek frontend som hjelper til med &#229; l&#248;se dette problemet.<\/p><p>&#160;<\/p><p>Ettersom GraphQL er sterkt typet betyr det ogs&#229; at kravene til frontend og hvordan disse kommuniserer er tydelig definert. Her f&#229;r man da en veldig tett kobling mellom frontend og backend i forhold til REST hvor frontend kan bygges veldig uavhengig s&#229; lenge den h&#229;ndterer AJAX kall.<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11535512,"ext_inspera_userAssessmentSetupId":7140003,"ext_inspera_userAssessmentId":4841245,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ravndal Tjøl (10003)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34564262,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2467,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er et bibliotek man bruker for &#229; lage Single Page Applikasjoner, og er basert p&#229; en komponentstruktur. For at sidene skal oppdateres riktig er derfor tilstand(state) en viktig del av en komponent for &#229; sikre at riktige komponenter viser riktig informasjon til riktig tid, og oppdaterer komponenter n&#229;r det trengs, og ikke gj&#248;r det n&#229;r man ikke trenger det.&#160;<\/p><p>&#160;<\/p><p>React har en innebygget state funksjon som man kan bruke i komponenter. Dersom man endrer state inne i komponenten s&#229; vil denne komponenten re-rendres. Disse statene kan ogs&#229; sendes til andre komponenter i trestrukturen, dersom andre komponenter har behov for og bruk for denne. Denne staten kan sendes til f.eks en barnekomponent, som tar inn denne staten som en Property. Barnekomponenten leser forelderens state som en property, og dersom forelderens state endrer seg s&#229; vil ogs&#229; barnekomponenten som bruker staten som property oppdatere seg (re-rendre) seg.&#160;<\/p><p>Noen ganger s&#229; &#248;nsker ogs&#229; barnekomponenten &#229; oppdatere state hos en forelder, og da kan state-funksjonen i forelder sende en callback-funksjon til barnet som gir barnet lov til &#229; oppdatere forelder sin state gjennom callback-funksjonen.&#160;<\/p><p>Dette er nyttig f.eks hvis man vil lage en telle-applikasjon, hvor man har en forelderkomponent som heter &#60;CounterOverview /&#62;&#160;og to barnekomponenter &#60;CounterIncrement /&#62; og &#60;CounterDecrement /&#62;. Dersom CounterOverview har en state som heter &#34;count&#34;, og den kan oppdares med funksjonen &#34;setCount&#34;. Denne setCount funksjonen kan da sendes ned som callback-funksjon til de to telleknappene, som gir dem lov til &#229; oppdatere&#160;staten &#34;count&#34; hos forelderkomponenten CounterOverview.&#160;<\/p><p>&#160;<\/p><p>Dersom man har en st&#248;rre applikasjon med mange komponenter er det ofte at mange komponenter &#248;nsker tilgang til samme tilstand. Dersom man &#248;nsker &#229; sende states til mange komponenter kaller vi dette for prop-drilling, og det er ineffektivt og kan fort bli veldig rotete og f&#248;re til&#160;un&#248;dvendig kode.&#160;<\/p><p>&#160;<\/p><p>Et alternativ til dette kan v&#230;re &#229; bruke React sitt eget Context API, som lar deg opprette en s&#229;kalt Provider, som gj&#248;r at en eller flere tilstander kan n&#229;s fra alle komponenter som er barn av denne Provider komponenten. Komponenter som da &#248;nsker &#229; bruke denne tilstanden kan bruke Consumer-funksjonaliteten fra Context API-et, eller useContext-hooken, for &#229; f&#229; tilgang til tilstand fra provider. Dersom man setter Provider i roten av prosjektet s&#229; f&#229;r man en global tilstand, som kan v&#230;re nyttig dersom man f.eks &#248;nsker &#229; ha tilstand som hvilken bruker som er innlogget, hvilket spr&#229;k denne brukeren foretrekker og hvilket fargetema som er valgt.&#160;<\/p><p>&#160;<\/p><p>Redux er et tredjepartsbibliotek som man kan bruke i Javascript applikasjoner for &#229; h&#229;ndtere tilstander. P&#229; samme m&#229;te som Context kan man bruker Redux til &#229; h&#229;ndtere global state, og ofte vil man sende inn en store (som holder en eller flere tilstander) i en provider i roten av applikasjonen. For &#229; endre en tilstand i redux m&#229; man bruke redux sine metoder for &#229; sikre riktig oppf&#248;rsel. Skal n&#229; forklare et kort eksempel p&#229; hvordan en tilstand oppdateres med redux:<\/p><p>1. Store initialiseres med default fargetema p&#229; en side er &#34;light&#34;. Denne tilstanden&#160; kan brukes av alle komponenter som trenger &#229; vite om den skal vise &#34;light&#34; eller &#34;dark&#34; farger.&#160;<\/p><p>2. N&#229;r en bruker toggler Theme fra &#34;light&#34; til &#34;dark&#34; s&#229; vil den komponenten dispatche en action til redux. Action sender med hvilken type action som ble kalt og data. f.eks { type: UPDATE_THEME, payload: &#34;dark&#34; }.<\/p><p>3. Action kaller en reducer funksjon, som oppdaterer den globale tilstand i store med den nye tilstanden for theme.<\/p><p>4. Store er oppdatert, og i applikasjonen s&#229; vil alle komponenter som bruker den tilstanden i store oppdateres. Komponentene gj&#248;r en re-rendring, og endrer fargetema fra light til dark.&#160;<\/p><p>&#160;<\/p><p>Det &#229; oppdatere en tilstand i redux krever en del kode, og flere liker ikke redux siden de synes det er mye som er un&#248;dvendig for &#229; oppdatere states. Likevel s&#229; er det veldig enkelt og forutsigbart &#229; f&#248;lge med p&#229; hva som skjer med endringer i states, siden reglene og metodene for &#229; oppdatere og bruke tilstanden i redux er fast bestemte. Dette er nok en av grunnene til at mange i st&#248;rre applikasjoner anbefaler &#229; bruke redux for tilstandsh&#229;ndtering.&#160;<\/p><p>&#160;<\/p><p>MobX er et annet rammeverk for global tilstandsh&#229;ndtering som er et godt alternativ til Redux. Her er ikke reglene like strenge for hvordan man oppdaterer tilstand, siden MobX skjuler mer av det som faktisk skjer, slik at utviklerne trenger &#229; skrive mindre kode for &#229; oppn&#229; samme funksjonalitet, vs Redux hvor man f.eks er n&#248;dt til &#229; benytte seg av actions og reducere. I MobX s&#229; har man ulike actions som man kan bruke, og flere observers som lytter p&#229; tilstanden.&#160;<\/p><p>&#160;<\/p><p>Vi har n&#229; sett p&#229; en del ulike m&#229;ter &#229; h&#229;ndtere tilstand / dataflyt i React applikasjoner, og de har sine fordeler og ulemper. I mindre prosjekter kan det v&#230;re nok med Reacts innebygde state h&#229;ndtering og evt. Context API, men i st&#248;rre applikasjoner er nok det beste alternativet &#229; bruke et tredjepartsbibliotek som Redux eller MobX.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2735,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de React og Recoil er laget av Facebook. I oppgave 1 diskuterte jeg ulike m&#229;ter &#229; h&#229;ndtere dataflyt og tilstandsh&#229;ndtering p&#229;, og konkluderte med at React&#39;s innebygde state-funksjonalitet er begrenset og egner seg best p&#229; sm&#229; applikasjoner. For st&#248;rre applikasjoner har tredjepartsbibliteker som Redux og MobX v&#230;rt n&#248;dvendige for god stateh&#229;ndtering, og det virker derfor som at Recoil er Facebooks neste l&#248;sning p&#229; tilstandsh&#229;ndtering. Facebook &#248;nsker nok at de som bruker React skal bruke mest mulig biblioteker som Facebook har laget, og sitert fra motivation til Recoil: &#34;keeping both the API and the semantics and behavior as Reactish as possible&#34; [2]. Her diskuterer de og ulemper med vanlig state i React og Context API-et.&#160;<\/p><p>&#160;<\/p><p><strong>Recoil<\/strong><\/p><p>Recoil er alts&#229; et bibliotek for state-management laget av Facebook for &#229; forh&#229;pentligvis erstatte tredjepartsbiblioteker som Redux og MobX. Recoil best&#229;r i hovedsak av to hovedelementene Atoms og Selectors som jeg n&#229; skal forklare.<\/p><p>&#160;<\/p><p>I recoil lagres en state som &#34;Atoms&#34;. Et atom kan f.eks v&#230;re en teller som lagres med f&#248;lgende syntax:<\/p><p>const counter&#160;= atom({<\/p><p>key: &#39;counterState&#39;,<\/p><p>default: 0,<\/p><p>});<\/p><p>Dette atomet kan s&#229; brukes som state i ikke bare en, men i mange&#160;komponenter. Man kan bruke hooken useRecoilState() for &#229; lagre en const som holder p&#229; verdien til state, og funksjon for &#229; endre state. E.g:<\/p><p>const [counter, setCounter] = useRecoilState(counterState);<\/p><p>Vi ser at dette ligner veldig p&#229; useState() - hooken fra React, noe som kan gj&#248;re l&#230;ringskurven til utviklerne enklere.&#160;<\/p><p>&#160;<\/p><p>En selector har samme interface som et atom, men det er en ren funksjon som tar inn et atom eller en annen selector som input. Selectoren kan kalkulere data eller gj&#248;re endringer p&#229; data f&#248;r den returneres. Komponenter kan subscribe p&#229; selectors p&#229; samme m&#229;te som atoms, og de vil re-rendres n&#229;r selectoren forandres.<\/p><p>&#160;<\/p><p><strong>Sammmenligning med Redux<\/strong><\/p><p>Jeg vil n&#229; sammenligne Redux med Recoil for &#229; se p&#229; ulikheter og likheter.&#160;<\/p><p>- B&#229;de Redux og Recoil bruker en provider i rot av applikasjon for &#229; gi alle komponenter tilgang til state, der sistnevntes tilsvarende provider&#160;kalles RecoilRoot.&#160;<\/p><p>- I Redux m&#229; man opprette en store som sendes til provider, mens i Recoil trenger man ikke lage en store.<\/p><p>- For &#229; opprette en state som kan deles og brukes av flere komponenter vil man i Redux opprette en reducer, mens i Recoil oppretter man et atom.&#160;<\/p><p>- I redux bruker man redux&#39; dispatch metode for &#229; avfyre actions for &#229; f.eks &#248;ke en teller. I Recoil vil man bruke en selector for &#229; modifisere et atom som er delt mellom komponenter.&#160;<\/p><p>- Redux m&#229; man bruke egne metoder for &#229; dispatche actions og hente state fra redux store (f.eks useSelector og useDispatch fra react-redux). I Recoil s&#229; bruker man metodene useRecoilState og useRecoilValue for &#229; bruke et atom/selector i en komponent og oppdatere tilstand.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper i utvikling<\/strong>&#160;<\/p><p>En fordel med Recoil er at det er mindre &#34;boilerplate-kode&#34; enn f.eks Redux for &#229; oppn&#229; mye av den samme funksjonaliteten.<\/p><p>Syntax er laget veldig lik som reacts hook useState() som veldig mange allerede kjenner til. Det vil gj&#248;re at utviklere raskere vil kunne l&#230;re seg Recoil, og forh&#229;pentligvis ogs&#229; gj&#248;re at flere utviklere vil begynne &#229; bruke det siden det ser kjent ut.&#160;<\/p><p>Recoil og React er laget av Facebook, og det vil v&#230;re en fordel at man bruker deres egne State-management siden Facebook er designerne av React og vet hvordan det kan brukes med dens styrker og svakheter bedre enn noen andre. Dersom Recoil fungerer bra og er p&#229;litelig kan det v&#230;re at det blir en del av React en tid i fremtiden, som vil styrke React betraktelig.&#160;<\/p><p>&#160;<\/p><p>Recoil er fortsatt ganske nytt, og kan derfor ha noen ulemper med seg som ikke har kommet frem i lyset enda siden det ikke er testet skikkelig.&#160;<\/p><p>En av fordelene med Redux er at det er veldig etablert og kjent rammeverk som tillater bruk av flere andre tredjeparts-biblioteker. Det er ikke sikkert Recoil kommer til &#229; legge til mulighet for &#229; bruke de tredjepartsbibliotekene som Redux st&#248;tter i dag, og det kan for noen utviklere v&#230;re en essensiell grunn til&#160; &#229; ikke velge Recoil.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><p>1: https://recoiljs.org<\/p><p>2: https://recoiljs.org/docs/introduction/motivation<\/p><p>3: https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1933,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL er s&#229;kalte Web API som man kan bruke for klient-server kommuniasjon i web applikasjoner. Likevel skiller de seg p&#229; en del omr&#229;der som vi n&#229; vil dr&#248;fte.&#160;<\/p><p>&#160;<\/p><p>- REST definerer ett eller flere endepunkter (f.eks &#34;dittDomeneNavn.no/users&#34;, &#34;dittDomeneNavn.no/users/userId?=GUID&#34; eller &#34;dittDomeneNavn.no/partners&#34;)&#160;for &#229; lese / skrive data til databasen (server), hvor man i GraphQL bruker bare ett endepunkt (ofte &#34;dittDomeneNavn.no/<strong>graphql<\/strong>&#34;)<\/p><p>&#160;<\/p><p>- I Rest definerer man p&#229; forh&#229;nd hvilke data som kan returneres for hver entitet. Dersom vi skal hente en spesifikk bruker p&#229; endepunktet&#160;users/userId?=GUID, og user-objektet ser ut som f&#248;lger:&#160;<\/p><p>user {<\/p><p>&#160; userId: GUID,<\/p><p>&#160; name: string,<\/p><p>&#160; birthYear: int,&#160;<\/p><p>&#160; address: string,<\/p><p>&#160; country: string<\/p><p>}<\/p><p>, s&#229; m&#229; man definere hvilke av attributtene som skal returneres. Dersom man velger at alle attributtene skal returneres her, men senere vil bare hente name og address, s&#229; m&#229; man enten skrive et nytt endepunkt som returnerer bare de to attributtene, eller bruke samme endepunkt og hente inn mer data enn man trenger.&#160;<\/p><p>&#160;<\/p><p>N&#229;r man bruker GraphQL s&#229; kan man spesifikt velge hvilke attributter som skal returneres i hver foresp&#248;rsel. Dette gj&#248;r at man bruker samme endepunktet for begge de to ulike brukscenarioene nevnt over, men sp&#248;rrestrengen definere bare hvilke attributter man &#248;nsker &#229; ta med, og f&#229;r derfor ikke mer data enn man trenger.&#160;<\/p><p>&#160;<\/p><p>- Ved Rest m&#229; man gj&#248;re flere requests dersom man &#248;nsker &#229; hente data fra flere entiter, mens i GraphQL kan man hente data fra flere entiteter i samme request. En viktig forskjell er at&#160;Rest henter data fra separate ressurser, men i GraphQL er alt data koblet sammen i en samlet graf som er koblet sammen.<\/p><p>Un&#248;dvendig mange&#160;requests vil det belaste nettverk i st&#248;rre grad, og dersom man f.eks leier skytjeneste og betaler for hver request vil man spare penger p&#229; &#229; gj&#248;re f&#230;rre requests enn n&#248;dvendig.&#160;<\/p><p>&#160;<\/p><p>- Rest API benytter de ulike HTTP metodene GET, PUT, POST, PATCH og DELETE, mens GraphQL kun bruker HTTP metoden POST (for b&#229;de lesing (query) og skriving (mutation) av data).&#160;<\/p><p>&#160;<\/p><p>- Caching i rest API st&#248;ttes ved default av alle weblesere. Caching av GraphQL gj&#248;r ikke det, men man kan bruke en tredjepartsklient i frontend som gj&#248;r det for deg. Apollo er en popul&#230;r graphQL klient som blant annet har funksjonen InMemoryCache som gj&#248;r det enkelt &#229; lagre data i cache, og gir mulighet til &#229; hente data fra cache i stedet for en ny request til server dersom data nylig har v&#230;rt hentet.&#160;<\/p><p>&#160;<\/p><p>-GraphQL st&#248;tter typevalidering, noe som Rest ikke gj&#248;r.&#160;<\/p><p>&#160;<\/p><p><strong>Kilder:<\/strong><\/p><p>https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535519,"ext_inspera_userAssessmentSetupId":7140135,"ext_inspera_userAssessmentId":4841275,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Eggelen Thor-Herman Van (10183)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34682074,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1457,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et essensielt konsept for dataflyt i React-applikasjoner er props (properties). Det er data som en komponent kan sende til komponenter under seg. Man har alts&#229; en slags trestruktur i React der komponenter sender data nedover. Ofte har man noen avanserte komponenter som gj&#248;r mange endringer i staten sin, og s&#229; sender de verdiene ned til komponenter som viser den frem p&#229; et vis (ved &#229; motta dataen som props). Dermed kan man bruke samme komponent til &#229; vise forskjellig data avhengig av propertiesene som den mottar, istedenfor &#229; hardkode mange komponenter.<\/p><p>&#160;<\/p><p>Ofte vil man at en komponent lenger nede i hierarkiet skal kunne for&#229;rsake en endringer lenger oppe. Her sender man da en callback funksjon fra parent ned til en child, som s&#229; kaller p&#229; callbacken under visse omstendigheter og dermed for&#229;rsaker en endring hos parent.<\/p><p>&#160;<\/p><p>Noen ganger har man en komponent h&#248;yt oppe i hierarkiet som man &#248;nsker at skal bli oppdatert av en komponent langt lenger nede. For &#229; slippe &#229; sende callbacken som props gjennom alle komponentene mellom, s&#229; benytter man ofte React sitt Context-api. Da kan man hente ut propertien direkte hos de komponentene som &#248;nsker det, uten &#229; m&#229;tte sende den eksplisitt gjennom alle lagene. Man m&#229; da wrappe komponenten i en Context.Provider komponent, og hente ut dataen ved hjelp av feks. useContext().<\/p><p>&#160;<\/p><p>I vanillla React s&#229; er staten til komponenter lokal til dem. Gj&#248;r man endringer i staten s&#229; vil komponenten re-rendere. For &#229; sende state mellom komponenter i hierarkiet s&#229; benytter man tidligere nevnte props. Hvis man &#248;nsker &#229; dele staten mellom to komponenter som er p&#229; samme niv&#229; i hierarkiet m&#229; man f&#248;rst sende den opp til en felles parent som s&#229; sender den ned igjen, dersom man bruker vanlig React.<\/p><p>&#160;<\/p><p>Tidligere har man kun hatt state i klassekomponenter mens funksjonskomponenter har kun hatt tilgang til props. Med React Hooks kan man n&#229; ogs&#229; ha state i funksjonelle komponenter. Man bruker da enten this.setState() eller hooken useState() for &#229; gj&#248;re endringer i staten.<\/p><p>&#160;<\/p><p>Som tidligere nevnt kan man bruke Context for &#229; sende properties gjennom mange lag i applikasjoner. Dette kan man ogs&#229; benytte til &#229; oppn&#229; &#34;global&#34; state. Da kan man gj&#248;re staten tilgjengelig for mange komponenter ved &#229; bruke Context-apiet. Likevel er det mange andre biblioteker som ogs&#229; tilbyr state management, og som har mer komplekse systemer og mer funksjonalitet. Derfor er det vanlig &#229; bruke feks. Redux eller MobX for &#229; ha en global state i applikasjonen sin. Ofte kombinerer man dette med lokal state, for &#229; skille mellom state det er n&#248;dvendig &#229; dele, og state man kun trenger i &#233;n komponent.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3649,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Hva dette er:<\/strong><\/p><p>Recoil.js er et state management library for &#229; h&#229;ndtere state i React. Hovedkonseptene i biblioteket er Atoms, som er en global state, og Selectors, som brukes for &#229; endre den hentede dataen fra atoms p&#229; et vis for &#229; vise den p&#229; en annen m&#229;te.<\/p><p>&#160;<\/p><p><strong>Sammelignet med Redux og MobX:<\/strong><\/p><p>Siden det er et eksternt bibliotek og konkret handler om state management vil jeg sammenligne det med Redux og MobX fremfor Context, da Context brukes hovedsakelig for &#229; forenkle sending av props og er innebygd i React.<\/p><p>Recoil, Redux og MobX gj&#248;r at man kan ha global state. Komponenter kan s&#229; abonnere p&#229; deler av denne staten, og endringer vil medf&#248;re at de re-renderes. Det er ogs&#229; likt at man m&#229; wrappe komponentene sine for at de skal ha tilgang til den samlede staten.<\/p><p>&#160;<\/p><p>En vesentlig forskjell mellom Recoil og Redux/MobX er at Recoil er spesifikt designet for React.js. B&#229;de Redux og MobX er generelle state management libraries for JavaScript, og har derfor mange bruksomr&#229;der utenfor kun React.js. Likevel er det kanskje React de er mest kjent for &#229; brukes med.<\/p><p>&#160;<\/p><p>En stor forskjell mellom Recoil og Redux er hvordan den samlede staten er lagret. I Recoil best&#229;r hovedstaten av forskjellige atoms med forskjellige id-er som man s&#229; kan direkte hente ut ved &#229; indeksere. Dette ligner mer p&#229; MobX sin tiln&#230;rming til state, hvor man gj&#248;r en del av staten sin observable for enkelte komponenter. I Redux er all state lagret under en root state, og s&#229; henter man ut den delen av staten som man trenger. Det er en s&#229;kalt single source of truth. Det er fors&#229;vidt <em>mulig <\/em>&#229; bruke flere stores i Redux ogs&#229;, men det er ikke et anbefalt pattern og sjeldent brukt.<\/p><p>&#160;<\/p><p>I Recoil kan du modifsere staten sv&#230;rt enkelt ved &#229; kun bruke en funksjon fra en hook, mens i Redux er dette en god del mer komplisert. Her m&#229; man f&#248;rst f&#229; tak i dispatch og deretter dispatche actions, som oftest ved bruk av action creators. Disse actionsene sendes s&#229; til alle reducers i storen og kun de som abonnerer p&#229; actionen vil gj&#248;re en endring. En fordel med denne implementasjonen er fors&#229;vidt at en action kan endre mange deler av staten. Man kan argumentere for at Recoil minner mer om MobX, da begge skjuler en god del av implementasjonen bak til fordel for &#229; gj&#248;re det enklere &#229; bruke. Likevel krever Recoil enda mindre kode enn MobX for &#248;yeblikket.<\/p><p>&#160;<\/p><p>Et hovedkonsept i Recoil er selectors, som man bruker for &#229; omformulere staten i atoms. Selectors finnes ogs&#229; i Redux, som er tydelig ut fra den ene hooken useSelector(). Likevel er det best practice &#229; benytte tredjepartsbiblioteker som reselect eller re-reselect for &#229; virkelig utnytte selectoregenskapene i Redux. I Recoil har man ganske avanserte selectors innebygd, slik som muligheter for &#229; bruke selectors inni andre selectors<\/p><p>&#160;<\/p><p>Recoil er ogs&#229; et sv&#230;rt nytt bibliotek. Den nyeste versjonen er 0.1.1. Redux og MobX har v&#230;rt standarder i en god stund, og er dermed mer vanlig &#229; komme over i applikasjoner, og vil derfor ogs&#229; ha mer st&#248;tte.<\/p><p>&#160;<\/p><p><strong>Fordeler:<\/strong><\/p><p>En fordel med Recoil er at det er et veldig enkelt bibliotek. Det er en kort dokumentasjon og lite &#229; sette seg inn i. Derfor er det enklere &#229; begynne &#229; utvikle med. I tillegg er det sv&#230;rt lite kode som skal til for &#229; lage atoms og hente/endre state, i motsetning til feks. Redux som krever ganske mye boilerplate kode (action creators og reducers). Det er dog mulig Recoil blir mer kompleks med tiden.<\/p><p>&#160;<\/p><p>En annen fordel er at asynkrone requests er innebygget i biblioteket og enkelt &#229; gjennomf&#248;re. I Redux kreves det at man benytter middleware, slik som Redux-Thunk for &#229; gj&#248;re asynkrone handlinger. I Recoil kan du benytte vanlig JS syntax med Async og Await.<\/p><p>&#160;<\/p><p><strong>Ulemper:<\/strong><\/p><p>En ulempe ved &#229; benytte Recoil er at det ikke har like stor st&#248;tte som Redux og MobX. Disse har langt flere utvidelser og biblioteker som bygger p&#229; dem. I tillegg vil det v&#230;re enklere &#229; finne kode-eksempler for et av disse bibliotekene. Samtidig kan man argumentere for at det er en fordel &#229; bli kjent med Recoil allerede, da det kan vokse og bli stort i femtiden.<\/p><p>&#160;<\/p><p>En st&#248;rre ulempe er det at Recoil kun fungerer med React. Siden det er spesifikt designet for dette biblioteket kan man ikke benytte samme koden i andre prosjekter, slik som for eksempel i en Native app eller om man bruker feks. Vue. Med Redux eller MobX er det f&#229; endringer som skal til for &#229; gj&#248;re det. Samtidig kan man si at det er en fordel at den er spesifikk for React, da man kan gj&#248;re flere konkrete optimaliseringer for biblioteket.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>Forelesningsnotat om MobX<\/p><p>https://recoiljs.org/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2035,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En vesentlig forskjell mellom et REST API og GraphQL er at REST er en arkitektur/prinsipp for web-api mens GraphQL er et konkret query language og server-side runtime. For &#229; bruke GraphQL m&#229; man laste ned spesifikke biblioteker som st&#248;tter det. Dermed kan man si at REST er mer universell og omfatter mer, mens GraphQL er mer spesifikt. Dette kan man feks. se i at med REST er det ikke konkret hvilket filformat man skal benytte for &#229; sende informasjon, mens i GraphQL s&#229; kan man kun sende JSON. I v&#229;re applikasjoner er det realistisk bare JSON vi bruker for REST-apiene ogs&#229;.<\/p><p>&#160;<\/p><p>Videre er det store forskjeller i hvordan man f&#229;r tilgang p&#229; data og endrer den i REST og GraphQL. REST sier at alle ressurser skal identifiseres vha. URI-en deres, for eksempel &#39;www.my-rest.com/movies/id/0&#39; for &#229; hente ut filmen med id 0. Det gj&#248;r det ogs&#229; sv&#230;rt enkelt &#229; sette seg inn i nye REST-API, siden det er forutsigbart hvordan de kommer til &#229; v&#230;re strukturert. Det er fordel da man gjerne benytter mange eksterne API i &#233;n applikasjon. I GraphQL bruker man skjemaer for &#229; beskrive de forskjellige ressursene. Deretter gj&#248;r man queries hvor man sier hvilken data man vil ha og hvilke attributter man vil f&#229; tilbake. Slik f&#229;r man ikke mer data enn man &#248;nsker. Skjemaene kan parameteriseres for &#229; hente ut konkrete deler av dataen. Parameterisering i REST gj&#248;res i lenken. Med REST kan man m&#229;tte gj&#248;re s&#229;kalt overfetching, siden man alltid f&#229;r tilbake hele dataen for en viss URI. I mange tilfeller er det kun deler av den man bryr seg om. I tillegg kan man m&#229;tte gj&#248;re mange foresp&#248;rsler p&#229; rad for &#229; f&#229; ut den dataen man &#248;nsker, dersom det er en mer kompleks foresp&#248;rsel med avhengigheter. Med GraphQL kan man ofte gj&#248;re dette med kun ett query.<\/p><p>&#160;<\/p><p>En stor fordel med bruk av REST er at det utnytter cachingen som er i weblesere som standard. GraphQL gj&#248;r ikke dette.<\/p><p>En annen stor forskjell er at GraphQL har et typesystem. N&#229;r man deklarerer skjemaer s&#229; man spesifisere typen til hver attributt, om det er &#233;n eller flere, og om den alltid m&#229; v&#230;re med eller ikke. I REST er det ikke noe slikt typesystem involvert.<\/p><p>GraphQL skiller mellom queries, mutations og subscriptions for &#229; hente data og gj&#248;re endringer. I REST benytter man de klassiske HTTP-headerene GET/POST/PUT etc. Dette skyldes antakelig at REST er inspirert av HTTP 1.1 og URI spesifikasjonene.<\/p><p>En annen forskjell mellom REST og GraphQL er hvor lenge de har eksistert. REST kom i 2000 som et svar p&#229; mangel p&#229; standardisering i web-api. GraphQL ble f&#248;rst public i 2015. Derfor er det veldig mange flere API-er som bruker REST enn GraphQL.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>Forelesningsnotater om REST og GRAPHQL<\/p><p>https://graphql.org/learn/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11536476,"ext_inspera_userAssessmentSetupId":7140129,"ext_inspera_userAssessmentId":4841352,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bjørgan Håkon Collett (10152)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33168982,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2344,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State i react kan tenkes p&#229; som variable som tas hensyn til n&#229;r applikasjonen bestemmer hva som skal vises frem (rendres) til brukeren. I forlengelsen av det er det implementert spesifikk funksjonalitet for &#229; oppdatere staten, slik at ikke applikasjonen krever for mye ressurser og generelt gir god brukskvalitet. En av mekanismene i denne sammenhengen er ReactDOMen. N&#229;r det skjer en tilstandsendring sjekker applikasjonen endringen opp mot ReactDOMen, og hvis endringen tilsier en faktisk endring i hva som skal vises til brukeren, rendres dette og opppdaterer dermed DOMen. Dette m&#248;nsteret &#229; gj&#248;re endringer p&#229; sparer ressurser da operasjoner i DOMen som regel er tregere og mer ressurskrevende enn &#229; tilsvarende i ReactDOMen.&#160;<\/p><p>&#160;<\/p><p>Det er to m&#248;nstre man kan implementere state vha i React. Den gamle m&#229;ten, som i praksis fases ut selv om dette ikke er utalt fra utviklerenes side, er gjennom klassebaserte komponenter og bruk av this.state. Den nye m&#229;ten, introdusert i oppdatering versjon 16 ish, er gjennom hooks og useState(). Funksjonaliteten blir det samme, selv om det skrives p&#229; to forskjellige m&#229;ter. I begge tilfeller f&#229;r du tilgang p&#229; en metode (setState()) som lar deg oppdatere staten. Gjennom kall av denne funksjonen setter du i gang en prosess&#160; med bla kall til livssyklusfunksjoner som ender opp med at staten oppdateres til &#248;nsket verdi. Et viktig poeng her er at man bruker denne metoden, kontra &#229; oppdatere variablen direkte. Sistnevnte vil ikke sette i gang de n&#248;dvendige prosessene for &#229; sikre at staten blir riktig h&#229;ndtert i applikasjonen.<\/p><p>&#160;<\/p><p>Et gjentagende problem ved st&#248;rre applikasjoner er at staten blir unh&#229;ndterlig n&#229;r applikasjoen vokser og antall komponenter med litt state i hver&#160;blir st&#248;rre. Det samme gjelder n&#229;r state i &#233;n komponent skal endre tilstand i andre komponenter etc. Det finnes flere forskjellige l&#248;sninger p&#229; dette. Tredjepartsbiblioteker som f. eks. redux lar deg samle all staten p&#229; ett sted i en s&#229;kalt store, som du s&#229; tilgjengeliggj&#248;r for hele applikasjonen. Dette kan gj&#248;re stateh&#229;ndteringen mer oversiktlig og lar deg dermed lettere utvide applikasjonen. En annen mye brukt l&#248;sning er bruk av React sitt context API. Dette fungerer litt p&#229; samme m&#229;te ved at du lager en context som kan holde state, som du tilgjengeliggj&#248;r (provider) for de komponentene som har behov for &#229; vite den aktuelle staten (disse blir consumers).<\/p><p>&#160;<\/p><p>De ovennevnte l&#248;sningen l&#248;ser ogs&#229; et annet &#34;problem&#34; i React-applikasjoner i forbindelse med dataflyt. Det vanligste m&#248;nsteret for dataflyt er gjennom bruk av props. Props er variable som en komponent kan ta i mot fra foreldrekomponenter. Dette fungerer fint hvis komponenttreet ikke er veldig dypt. Blir derimot applikasjonen din st&#248;rre kan du ende opp med &#229; m&#229;tte propdrille en varibel 3-4+ komponenter ned. Dette blir etterhvert tidskrevende og muligheten for at feil oppst&#229;r blir st&#248;rre, samt at det blir mindre og mindre enkelt &#229; gj&#248;re endringer, da disse m&#229; gj&#248;res flere og flere steder. Har du derimot en context eller store som komponenten din kan consume kan du simpelthen gj&#248;re dette der du trenger, og hoppe over de komponentene i treet som ikke har behov for det.<\/p><p>&#160;<\/p><p>React byr ogs&#229; p&#229; funksjonalitet som lar deg utf&#248;re sideeffekter av at state og propsendringer. I klassebaserte komponenter var dette stort sett gjennom&#160;componentDidUpdate(), mens det ved bruk av hooks h&#229;ndteres gjennom useEffect().<\/p><p>&#160;<\/p><p>Kilde: Har dobbeltsjekket litt med React-docsene underveis.&#160;https://reactjs.org/docs/getting-started.html&#160;&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2685,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et statemanagementverkt&#248;y p&#229; lik linje med f. eks. redux.&#160;<\/p><p>&#160;<\/p><p>En &#229;penbar fordel med det er at det utvikles av Facebook, som ogs&#229; er utvikleren bak React. Dette vil mest sannsynlig s&#248;rge for at fremtidige oppdateringen i et av bibliotekene vil ihensynta endringer i det andre. P&#229; sikt vil dette kunne spare utviklere for mye arbeidere i form av &#229; unng&#229; breaking changes etc. Videre vil forh&#229;pentlig interaksjonsm&#248;nsteret med recoil v&#230;re i samme gate som det med react, slik at om du kjenner til react vil l&#230;ringskurven for &#229; sette seg inn i recoli v&#230;re mindre bratt, enn f. eks. et uavhengig tredjepartsbibliotek. Dette bekreftes ogs&#229; i docsene: &#34;We want to improve this while keeping both the API and the semantics and behavior <strong>as Reactish as possible<\/strong>.&#34;&#160;<\/p><p>&#160;<\/p><p>Recoil ser ogs&#229; ut til &#229; kunne utkonkurrere noe av bruksomr&#229;dene til context APIet. Fra docsene til recoil st&#229;r det &#34;<\/p><ul>\t<li>Context can only store a single value, not an indefinite set of values each with its own consumers.<\/li><\/ul><p>&#34;. Dette fungerer derimot ved bruk av recoil, gjennom at hver bit av state (som de kaller atom) kan subscribes til av en komponent.&#160;<\/p><p>&#160;<\/p><p>Slik jeg ser det vil recoil kunne v&#230;re sv&#230;rt velkomment i utviklings&#248;yemed. Basert p&#229; det lille jeg har lest meg opp p&#229; det n&#229;, ser det ut til at det er vesentlig lettere &#229; komme i gang med, kontra f. eks. redux som jeg l&#230;rte meg i forbindelse med prosjektene i faget. Videre ser det ut til at mengden kode som m&#229; skrives for &#229; f&#229; ting opp og g&#229; er sv&#230;rt liten, ved at du wrapper delen av applikasjonen som skal ha tilgang p&#229; recoil med&#160;&#60;RecoilRoot /&#62; kan du begynne &#229; definere atoms og selectors rett i komponentfilene&#160;dine. Sammenlignet med redux hvor det i alle fall i mitt tilfelle krevde en god del lesing samt pr&#248;ving og feiling for &#229; f&#229; ting opp og g&#229;, med x antall filer med action creators, reducers, actiontypes etc, virker dette vesentlig enklere.<\/p><p>&#160;<\/p><p>En &#34;ulempe&#34; om man kan kalle det det, er at dette er enda en ny ting &#229; sette seg inn i for de som allerede kan andre statemanagementverkt&#248;y. &#34;Ulempe&#34; i hermetegn, da dette er &#229; forvente for folk som driver webutvikling og er interessert i &#229; holde seg oppdatert med hva som er state of the art. En annen ulempe er at biblioteket er veldig nytt, og f&#248;lgelig ikke helt ferdigutviklet (i&#160;den grad man noensinne sier seg ferdigutviklet). En kjapp kikk innom repoet p&#229; github s&#229; det ut som noen av bugsene som var rapportert inn kunne v&#230;re litt alvorlige. Dette er dog for &#229; ta p&#229; seg de kritiske brillene, og jeg ville anta at de aller aller fleste bruksomr&#229;der fungerer fint.<\/p><p>&#160;<\/p><p>&#160;&#160;&#160;&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/getting-started/<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee#:~:text=In%20redux%2C%20actions%20are%20fired,shared%20atom%20state%20using%20selectors.<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2131,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API&#160;og Graphql er hver sine m&#229;ter &#229; intereager med en server p&#229; i forbindelse med datautveksling. Det ligger i navnet, men jeg presiserer det likevel, at graphql er et spr&#229;k, mens REST&#160;er en arkitektur.&#160;<\/p><p>&#160;<\/p><p>REST API&#160;er en samling av endepunkter som hvert har en eller annen funskjonalitet knyttet til seg. Stort sett er de definert med en funskjon som trigges ved kall til endepunketet. Et vanlig m&#248;nser er at man sender en request til et endepunkt, en funskjon trigges med hele eller deler av dataen sendt med requesten som variabel, f&#248;r serveren s&#229; sender en respons basert p&#229; utfallet av funksjonen. F. eks. et kall til /getUsers med en liste med brukerIDer som payload. Requesten trigger en funksjon som henter informasjon om brukerene i en database, som s&#229; sendes tilbake til klienten. Slik vil man bygge opp en rekke endepunkter som f. eks. /get/users, /get/movies, /login, /signup, /update/userProfile etc. Samlingen av disse endepunktene vil utgj&#248;re REST APIet.&#160;<\/p><p>&#160;<\/p><p>Graphql legger opp til en annen type oppbygging, ved at det kun er et enkelt endepunkt for interaksjon mtp datautveksling. Til dette endpunktet sender man queries eller mutations som respektivt vil hente eller oppdatere data. De forskjellige queriesene og muteringene man kan gj&#248;re er definert av utvikleren og sender respons basert p&#229; querien/muteringen. Denne m&#229;ten &#229; strukturere p&#229; gj&#248;r at man kan unng&#229; s&#229;kalt under- og overfetcing, samt ekstra kall til serveren. Der man ved bruk av REST ofte vil m&#229;tte f&#248;rst sende et kall for &#229; f&#229; informasjon om et sett med brukere, for s&#229; &#229; sende et nytt kall for &#229; hente f. eks. alle filmene de forespurte brukerene har likt. Dette kan man unng&#229; ved bruk av GraphQL gjennom &#229; presiserer hvilken data man vil ha om brukerene. Dette forutsetter selvf&#248;lgelig at ting er korrekt satt opp backend mtp database osv. I querien kan man da feks velge &#229; sende&#160;<\/p><p>&#160;<\/p><p>query {User(id)<\/p><p>&#160; &#160; &#160; name<\/p><p>&#160; &#160; &#160; likedMovies{...}<\/p><p>}<\/p><p>&#160;<\/p><p>om man vil ha med filmer, eller &#229; sl&#248;yfe den parameteren om man ikke vil ha den.&#160;<\/p><p>&#160;<\/p><p>Dette kan selvf&#248;lgelig ogs&#229; implementeres i et endepunkt i et REST API, men den gjengse oppfatningen er at slike betingede request med conditionals etc fort blir uoversiktlig.<\/p><p>&#160;<\/p><p>Siden GraphQL er et spr&#229;k byr det f&#248;lgelig ogs&#229; p&#229; noe tilh&#248;rende funksjonalitet. En del av dette er typedefeinsjoner for &#229; beskrive dataen din. Slike typedefinisjoner kan gj&#248;re det enklere i et utviklingssammenheng &#229; s&#248;rge for &#229; unng&#229; feil. Typedefinisjonene du defienrer p&#229; serveren kan eksporteres slikat du f&#229;r tilgang til dem i forbindelse med &#229; utvikle klienten. Ved &#229; bruke dem s&#248;rger du for at du ikke ber om felter som ikke eksisterer etc.&#160;<\/p><p>&#160;<\/p><p>Det er verdt &#229; nevne at det ikke er enten REST eller GraphQL. De kan godt eksistere ved siden av hverandre. Du kan ha et REST API hvor det ene endpunktet ditt er til graphql og h&#229;ndterer datafetching/oppdatering, mens du har andre endpunkter som s&#248;rger for annen funksjonalitet som f. eks. tokenustedelse etc.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>&#160;<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis#:~:text=The%20Core%20Difference%20Between%20REST,a%20single%20endpoint%20using%20HTTP.<\/p><p>https://graphql.org/learn/<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11536478,"ext_inspera_userAssessmentSetupId":7140130,"ext_inspera_userAssessmentId":4841291,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Håberg Kristin (10054)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37535418,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2207,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Innebygd i React&#160;har vi props og state som brukes for &#229; &#39;passe p&#229;&#39; tilstanden og dataen&#160;til komponenten underveis i livssyklusen. Props (properties)&#160;initialiseres med&#160;hver komponent. Props er ikke-foranderlige, mens de&#160;interne tilstandsvariablene&#160;State kan endres gjennom livssyklusen til komponenten. M&#229;tene man oppdaterer state er ulik om man har klasse eller funksjonell komponent.&#160;<\/p><p>&#160;<\/p><p>I funksjonelle komponenter bruker man hooks for &#229; endre p&#229; state. Da bruker man useState, som &#39;hooker&#39; inn i staten til komponenten. Med useState&#160;definerer man en funksjon for &#229; endre p&#229; staten, i tillegg til state variabelen. I klassekomponenter bruker man setState(). N&#229;r state endres rerendres komponenten, og barnekomponentene.<\/p><p>&#160;<\/p><p>For &#229; sende data oppover&#160; eller mellom s&#248;sken i komponenthierarkiet bruker man callback funksjoner, der foreldrekomponentene kan hente data og state-endringer&#160;fra barnekomponentene.<\/p><p>&#160;<\/p><p>For &#229; unng&#229; &#34;prop-drilling&#34;, alts&#229; at endringer i state&#160;m&#229; hentes fra langt&#160;nede i komponenthierarkiet finnes m&#229;ter for &#229; globalt h&#229;ndtere state i React- dette kalles Global State Management. Global state management gj&#248;r det ogs&#229; enklere for ulike data/states&#160;&#229; bli brukt i ulike komponenter mange steder i applikasjonen.<\/p><p>&#160;<\/p><p>Global state management gj&#248;r det mulig &#229; lagre states et &#39;eget sted&#39;, hvor alle de andre komponentene kan hente ut data uavhengig av hierarki. Alle de&#160;&#39;ber&#248;rte&#39; komponentene oppdateres automatisk ved endringer i state. Noen eksempler p&#229; global state management&#160;er Context, MobX og Redux.&#160;<\/p><p>&#160;<\/p><p>Context:&#160; lager en ny&#160;context for tilstander/data som trenger &#229; v&#230;re tilgjengelig flere steder. Bruker Provider og Consumers, eller useContext istedenfor consumer. Provider er der man setter opp dataen som skal v&#230;re tilgjengelig, mens i Consumer er der du &#34;subscriber&#34; til dataen fra provideren. Man kan ogs&#229; h&#229;ndtere&#160;funksjoner i context. Hver gang man oppdaterer Context vil alle komponente som bruker den contextens data rerendres.<\/p><p>&#160;<\/p><p>MobX: I MobX m&#229; man ogs&#229; lage en provider, slik som i context. Her kan man bruke egne metoder, eller benytte seg av Context sin Provider. Man bruker @Observable og @action. @Observable er alle data/states som er globale. @Action er den funksjonen/metoden som brukes for &#229; oppdatere denne observerbare dataen. B&#229;de de globale variablene og action funksjonene kan hentes fra de komponentene der det trengs.<\/p><p>&#160;<\/p><p>ReduX: I ReduX har man kun en store hvor alle de globale dataene ligger. De ulike komponentene kan da hente dataen de trenger fra denne storen. Store er et s&#229;kalt immutable object, alts&#229; at man ikke kan endre p&#229; state der direkte. Man trenger en egen funksjon som tar inn store som argument og returnerer den oppdaterte storen. Disse funkjsonene kalles reducers, og i tillegg til &#229; ta inn store tar de inn action, som er det som beskriver p&#229; hvilke eventer som store skal oppdateres. Reducer funksjonen forst&#229;r basert p&#229; hvilken action hvilke data i store som skal oppdateres.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3136,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. I Recoil lager man globale tilstandsvariabler, som kalles&#160;Atoms, gjennom funksjoner som&#160;kalles&#160;Selectors. Selector&#39;ene kan ogs&#229; oppdatere&#160;Atoms&#160;enten synkront eller asynkront. Atoms, de globale state tilstandsvariablene, kan&#160;abboneres p&#229;&#160;av komponentene dine. N&#229;r en tilstandsvariabel oppdateres vil alle komponentene som abbonerer p&#229; denne rerendres. Atom&#39;ene kan ogs&#229; endres direkte i komponentene ved hooken useRecoilState, som oppdaterer tilstanden til Atomen i alle komponenter som abbonerer p&#229; den.<\/p><p>&#160;<\/p><p>Sammenligner man Recoil med Context, Redux og MobX (som jeg skrev litt om i forrige oppgave) kan man se at i forhold til Context hvor man m&#229; opp til &#248;verste provider for &#229; f&#229; tilgang til/endre p&#229; state, kan man i Recoil gj&#248;re dette med en ny type datastr&#248;mming. Tilstanden kan endres gjennom &#34;r&#248;ttene&#34;, men kan ogs&#229; endres gjennom disse selector funksjonene og i de egne komponentene ved useRecoilState.&#160;<\/p><p>&#160;<\/p><p>I Redux er state separert fra UI, mens med disse hooksene i Recoil kan man&#160;endre state i komponentene og. Der Recoil ligner litt p&#229; Redux er med disse selector funksjonene, som ligner p&#229; reducer funksjonen til Redux. I Redux tar man inn hele store og s&#229; action som parameterne, mens selector i Recoil godtar atomer eller andre selectors.&#160;<\/p><p>&#160;<\/p><p>Det at komponentene abbonerer p&#229; Atoms og Selectors, og oppdateres ettersom disse oppdateres, ligner p&#229; slik det fungerer i Context, med Provider og Subscriber, og i MobX. Redux derimot har kun &#233;n store (eller atom i Recoil spr&#229;k) som alle komponenter henter fra.<\/p><p>&#160;<\/p><p>Noen fordeler med Recoil er at det enkelt/intuitivt&#160;&#229; bruke da man kan oppdatere delt tilstand med samme type grensesnitt som React local state (hooks). Det er flere m&#229;ter &#229; strukturere atom og selectors p&#229;, s&#229; man kan strukturere filer som man vil. I tillegg kan State&#160;kan erstattes med avledede data, uten &#229; endre komponentene som bruker den og denne dataen kan bevege seg mellom &#229; v&#230;re asynkron eller synkron.<\/p><p>&#160;<\/p><p>En mulig ulempe vil v&#230;re at Recoil er forholdsvis nytt. Mye av funksjonaliteten er fortsatt experimental (som man kan lese i&#160;https://recoiljs.org/blog).&#160; En annen &#34;ulempe&#34; er at det er tett knyttet til React, og laget spesifikt for &#229; fungere sammen med&#160;React, s&#229; man kan ikke bruke feks Angular med Recoil slik man kan med andre state management bibliotek som MobX.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>&#160;<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p><p>&#160;<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1670,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er to ulike tjenester for &#229; hente fra en database.<\/p><p>&#160;<\/p><p>REST API bruker endepunkter (URLer) for &#229; hente spesifikk data fra ulike HTTP endepunkter som defineres. Hvis du har laget et eget REST API kan du definere endepunktene selv ettersom hva du skal hente. Man m&#229; definere om man vil bruke POST, GET, DELETE, PUT&#160;for &#229; lese, skrive, endre data, i requestene du skal gj&#248;re mot datasettet i databasen. N&#229;r man for eksempel definerer endepunktene sine kan man legge til ulike queries i URL&#39;en for &#229; definere hva som skal filtreres/sorteres p&#229;.&#160;Deretter lager man egne metoder i serveren&#160;for &#229; hente og gi tilbake riktig data fra databasen ut ifra hvilket endepunkt som kalles. Dette er annereldes enn graphql, der det er klienten selv som sp&#248;r etter akuratt det den trenger.&#160;I REST brukes caching mekanismen, som gj&#248;r at man lagrer responsen fra databasen&#160;i klienten og slipper &#229; sende requesten igjen og igjen. Du definerer ogs&#229; p&#229; hvilken form du vil ha dataen tilbake (XML /json).<\/p><p>&#160;<\/p><p>GraphQL definerer typer som beskriver dataen som ligger i databasen (eller APIet) vi skal bruke. I frontend sender man kun requests med de relevante kriteriene som vi ber om, s&#229; du definerer der&#160;hvilken data du vil ha retunert. Du kan hente all dataen du trenger med en request.&#160;P&#229; denne m&#229;ten er det forskjell fra REST, ved at vi allerede i requesten v&#229;r i frontend foresp&#248;r spesifik data, og kan unng&#229; under- og/eller overfetching, slik man kan risikere med REST (hvor man kanskje henter mer data enn n&#248;dvendig). GraphQL er ogs&#229; annereldes fra REST ved at de ulik foresp&#248;rsel&#34;typene&#34; (lese/skrive)&#160;ikke spesifiseres gjennom HTTP-typen men i queryen til foresp&#248;rslen.&#160;Graphq bruker heller ikke implisitt caching mekanismen, og returnerer kun json (ikke xml som REST kan).<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11536615,"ext_inspera_userAssessmentSetupId":7140007,"ext_inspera_userAssessmentId":4841151,"dateLastModified":"2020-12-01T10:01:23Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:23Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Laurvik Torgeir Sandnes (10059)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":16738903,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2128,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har vi flere mekansimer som kan brukes for dataflyt. Enkleste variant er en kombinasjon av props og call-back funksjoner. Utvikleren bruker props for &#229; sende data fra en parent-komponent til et av sine children. Hvis utvikleren vil sende data fra et child til en parent vil den m&#229;tte bruke callback-funksjoner. Hvis en komponent vil sende data til en av sine &#34;etterkommere&#34;(som ikke er child), s&#229; m&#229; man benytte seg av det som kalles prop-drilling. Dette betyr at hvert mellomledd i veien fra komponenten som sender dataen til komponenten som skal bruke den, m&#229; ta inn dataen som props og videresende&#160;den ved hjelp av props til det aktuelle child. Hvis programmet har stor dybde kan dette b&#229;de f&#248;re til at programmmet blir mer uleselig (st&#248;rre sjanse for feil og vanskeligere for en selv og andre &#229; sette seg inn i), og det vil ogs&#229; f&#248;re til un&#248;dvendig mye kode.&#160;<\/p><p>Som reaksjon p&#229; behovet for en bedre l&#248;sning for dataflyt kom derfor dedikert global state management(GSM) p&#229; banen. Av verkt&#248;y for GSM som vi har l&#230;rt om i dette faget kan det nevnes Context API, Redux og&#160;MobX.<\/p><p>Felles for alle disse er at man operer med en state store, som kan hele eller deler av programmet kan lese/skrive av variabler. Fordelen med dette er at man slipper prop-drilling og state er alltid oppdatert for hele systemet.&#160;<\/p><p>N&#229;r vi snakker om state forst&#229;r jeg i denne sammenhengen som state-variabler hvis endring vil tvinge&#160;en rerender av aktuelle komponent og dens etterkommere. For state-variabler har vi to likeverdige l&#248;sninger, avhengig av om man bruker funksjonelle eller klassekomponenter. For funksjonelle komponenter bruker vi React-hooken, useState.&#160;<\/p><p>Ved klassekomponenter bruker vi state-variabler som settes i en konstrukt&#248;r, eller utenfor en konstrukt&#248;r.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for global state management, p&#229; samme m&#229;te som Redux og&#160;MobX.&#160;<\/p><p>Mens vi med &#34;vanlig&#34;/komponentspesifikk state bruker de to variablene returnert av&#160;useState() for &#229; lese/skrive til state, bruker vi i Recoil&#160; to variabler&#160; returnert av useRecoilState(), interfacet for read/write lokal og global state, og det er slik jeg ser det er viktig argument for &#229; bruke Recoil. Dette skiller seg fra Redux og MobX som har andre interface for &#229; r/w&#160; global state som henholdsvis bruker dispatch &#38; getState for Redux og observable i MobX.&#160;<\/p><p>I Recoil operer vi med to typer state-variabler; atoms og selectors. Atoms er state-variabler slik vi er vant til, mens selectors er s&#229;kalte derived state (i mangelen p&#229; et bedre uttrykk p&#229; norsk). Dette betyr at selectorenes state er avhengig av en (eller flere) atom(s) sin state, eksempelvis at en selector-variabel holder lengden av strengen lagret i et atom. Dette kan jeg tenke meg at kan v&#230;re praktisk funksjonalitet&#160;f.eks. hvis denne derived state er en verdi som vi kommer til &#229; bruke flere ganger, og vi gjerne vil slippe &#229; regne ut flere ganger.<\/p><p>&#160;<\/p><p>En annet viktig argument for Recoil er at komponenter som bruker verdien til et&#160;atom&#160;automatisk vi tvinges til re-render hvis verdien til et av atom-ene som den &#34;subscriber&#34; til endres. Hvis man hadde brukt Redux eller MobX derimot, s&#229; m&#229;tte en GSM-variabel kopieres over i lokal state for at den skulle tvinge re-render. Dette er en ide jeg liker, fordi det dette er noe som man som utvikler ofte m&#229; gj&#248;re. Variablene som ligger i GSM vil som regel v&#230;re variabler som er viktige og som derfor skal bestemmer hva som er rendret.<\/p><p>&#160;<\/p><p>Litt avhengig av at jeg igjennom dette faget har f&#229;tt mer og mer&#160;<\/p><p>&#160;<\/p><p>Slik jeg ser det s&#229; er Recoil er nyttig bibliotek for GSM i React. Jeg er alltid for at ideomatisk kode, s&#229; hvis React kan bli mer &#34;pure&#34; React, s&#229; st&#248;tter jeg det. Det er slik jeg ser det fremdeles slik at Redux er standarden for GSM i industrien, s&#229; jeg tror at for at jeg som datastudent skal v&#230;re attraktiv p&#229; markedet s&#229; er det Redux som er mest bang-for-the-buck (attraktivitetsmessig) enn s&#229; lenge.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2466,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL&#160;er&#160;systemer for &#229; hente data fra en database.<\/p><p>&#160;<\/p><p>Hovedargumentet for &#229; bruke GraphQL fremfor REST API er for &#229; unng&#229; over-/underfetching.<\/p><p>N&#229;r jeg snakker om overfetching mener jeg at applikasjonen f&#229;r levert mer data enn den trenger. Hvis jeg f.eks. hadde kontaktet et API for IMdb i forbindelse med en applikasjonen som handlet om filmer, s&#229; kan det sannsynlig at IMdb har vanvittig mange felter med data for hver film (eksempelvis kommentarer gjort av brukere, rollebesetning av de statistroller, osv.) Hvis min applikasjonen derimot kun skulle benytte seg av filmtittel og hovedrolleinnhavere, s&#229; hadde det ikke v&#230;rt mulig &#229; requeste kun disse feltene vha. REST, vi hadde uavhengig av hva vi trengte blitt servert all dataen for valgte film. Dette hadde f&#248;rt til un&#248;dvendig store datapakker, som hadde f&#248;rt til en trege applikasjon.&#160;<\/p><p>&#160;<\/p><p>En sp&#248;rring i API gj&#248;res vha. HTTP-metoder (GET, POST, PUT, osv.), hvilke paths som er definert av server bestemmer hvilken form sp&#248;rringene m&#229; ha, og hvor avanserte sp&#248;rringer en kan gj&#248;re.<\/p><p>Ved GraphQL derimot kan du presisere hvilke datafelter du er interessert i, p&#229; samme m&#229;te som man ville gjort med SQL (uten videre sammenligning). En sp&#248;rring&#160;i GraphQL er p&#229; JSON-format.<\/p><p>&#160;<\/p><p>Vi kan ogs&#229; oppleve underfetching som kan v&#230;re et annet problem med REST API. Hvis dataobjektet vi henter ut har fremmedn&#248;kler til andre dataobjekter som vi ogs&#229; &#248;nsker &#229; hente ut, s&#229;&#160;m&#229; dette gj&#248;res med flere sp&#248;rringer. &#201;n sp&#248;rring for objektet som holder fremmedn&#248;klene, og &#233;n sp&#248;rring for hver andre de assosierte objektene. Eksempelvis fire sp&#248;rringer hvis det f&#248;rste objektet har fremmedn&#248;kler til tre andre objekter. Ved graphQL derimot kan dette gj&#248;res ved &#233;n sp&#248;rring, fordi man i JSON-objektet som man sender inn til server kan definere hvilke felter en &#248;nsker &#229; hente ut for de objektene som er linket.(Denne funksjonaliteten likner p&#229; JOIN fra SQL).<\/p><p>&#160;<\/p><p>For &#229; koble denne oppgaven til prosjektene vi har hatt i h&#248;st, s&#229; kan jeg si at problematikken med overfetching ikke var like relevant for oss i disse prosjektene. Siden det var vi som satte opp databasen og serveren med applikasjonen v&#229;r i bakhodet, s&#229; var det ingen henting av datafelter som vi ikke trengte.<\/p><p>Problematikken med overfetching er spesielt relevant n&#229;r forskjellige type klienter skal bruke APIet, det kan tenkes at en applikasjon for maskinl&#230;ring kan &#248;nske alle feltene som en database tilbyr, mens et applikasjon installert p&#229; Apple Watch trenger mange f&#230;rre datafelter.<\/p><p>&#160;<\/p><p>Da jeg i forkant av denne eksamenen skulle lese meg opp p&#229; fordeler med REST over GraphQL, s&#229; kom jeg over at caching av resultat fra sp&#248;rringer kan v&#230;re et argument som taler for bruk av REST API. Dette er spesielt viktig i applikasjoner som sender det samme sp&#248;rringene mange ganger hele tiden.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11538957,"ext_inspera_userAssessmentSetupId":7140068,"ext_inspera_userAssessmentId":4841402,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:07Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tengs Simen Sælevik (10211)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":23103834,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2496,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er et javascript bibliotek der man lett kan inndele en web-applikasjon i komponenter, og laste disse inn dynamisk p&#229; en enkel html side istedenfor &#229; m&#229;tte laste inn flere html sider. For &#229; h&#229;ndtere og organisere en slik applikasjon (SPA), er det en del teknikker og mekanismer som brukes for endre tilstanden og dataflyten i applikasjonen.<\/p><p>&#160;<\/p><p>Tlstanden i react applikasjonen er viktig for &#229; kunne dynamisk oppdatere data. Hver komponent kan ha en lokal state som brukes til &#229; endre tilstand i komponenten, det kan for eksempel v&#230;re state for &#229; endre UI komponenten &#39;checkbox&#39;. Disse lokale tilstandene kan sendes videre som props til barnekomponentene. I barnekomponenten kan man da hente disse ved &#229; bruke hendholdsvis this.props.<\/p><p>Dersom man skal s&#229; langt ned i komponent treet (3 eller flere ledd), og fortsatt trenger tilstanden til foreldrekomponenten, kan det v&#230;re hensiktsmessig &#229; ta i bruk Reacts eget Context api. Context lar deg lage s&#229;kalte Globale states, som oppdateres via en store, og man slipper &#229; g&#229; gjennom hele komponent-treet ved &#229; wrappe barnekomponentene inn i &#60;Providers&#62;, som viser til hvilke komponenter som skal arve de globale tilstandene.<\/p><p>Det er ogs&#229;&#160;mulig&#229; ta i bruk 3. parts state management bibliotek for &#229; ha en mer sentralisert logikk i applikajsonen. Den mest brukte er Redux, en best practice l&#248;sning der man bruker Actions og Reducers til &#229; mutere data. State i storen til redux er immutabel, men det er lett &#229; debugge og skalere en redux applikasjon pga strukturen som bla. annet bare er en store. Andre alternativ er Mobx, en simplere alternativ der man kan mutere state i storen direkte, og man kan ha flere stores.&#160; Actions her er hvilken som helst kode som kan endre tilstanden, og alle derivasjoner er automatisk oppdatert n&#229;r tilstanden endret.<\/p><p>&#160;<\/p><p>Det er det ogs&#229; mulig &#229; ta i bruk ferdiglagde state-management bibliotek som gir deg mulighet til &#229; lett h&#229;ndtere b&#229;de lokale og remote data.&#160;Dette kan v&#230;re hensiktsmessig n&#229;r man jobbet opp mot en database og ett&#160;backend API. Eksempler p&#229; slike bibliotek er Apollo Client for GraphQL og React-query eller SWR for REST<\/p><p>&#160;<\/p><p>Det er hendholdsvis to m&#229;ter &#229; bygge opp en react applikasjon p&#229;, med klassekomponenter eller med funksjonelle komponenter. Klassekomponenten kommer med innebygde funksjoner til &#229; endre tilstand basert p&#229; hvor i livssyklussen komponenten er, s&#229;kalte livssyklus-funksjoner. Et eksempel p&#229; dette er ComponentDidMount(), som kj&#248;res en gang etter&#160;f&#248;rste render(). Disse funksjonene er viktige for &#229; kontrollere dataflyt i applikasjonen. Funskjonelle komponenter ligner mer enkle javascript funskjoner som returnerer html UI, og har ikke disse livssyklus funksjonene og states, men bruker &#39;hooks&#39; til &#229; oppn&#229; det samme. Til &#229; lage tilsvarende states i funksjonelle komponenter bruker man useState() hooket. For &#229; oppn&#229; lignende funskjonalitet som livssyklusfunksjonene kan man manipulere hooks til &#229; bli slik man &#248;nsker.&#160;Eksempelvis for &#229; oppn&#229; en tilsvarende funksjon som componentDidMount, kan man bruke useEffect() hooket.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2926,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil<\/strong> er et nytt open source bibliotek for React som bruker s&#229;kalte atoms og selectors. Det er et state-management bibliotek som drar inn ekstra funksjonalitet. Det er p&#229; samme m&#229;te som alle andre state-management l&#248;sninger ikke reacts offisielle state management bibliotek.&#160;<\/p><p>&#160;<\/p><p><strong>Atoms <\/strong>er tilstandsenheter som man kan manipulere og abbonnere p&#229;. Det fungerer slik at hvis n&#229;r en &#34;atom&#34; er oppdatert / endret p&#229;, blir alle komponentene som abbonnerer p&#229; dette atomet rendret p&#229; nytt med den nye verdien.<\/p><p>&#160;<\/p><p><strong>Selectors<\/strong>&#160;er en funksjon som tar inn atomer eller andre selectors som input. N&#229;r atomer blir oppdatert, vil selector funksjoner ogs&#229; kj&#248;re igjen. Komponenter kan abbonnere p&#229; selector funksjoner p&#229; samme m&#229;te som at de kan abbonnere p&#229; atomer, og endring vil ogs&#229; f&#248;re til rerendering av komponenten.&#160;En bra fordel med &#229; bruke recoil er at man kan utf&#248;re async operasjoner i selectors.<\/p><p>&#160;<\/p><p>Hvis vi sammenligner recoil med Redux, som forel&#248;pig er det mest popul&#230;re tredjeparts state-management biblioteket for React, s&#229; trenger man ikke ved bruk av recoil &#229; lage en seperat store til &#229; lagre data. Man trigger tilsvarende &#39;actions&#39; i redux ved bruk av selectors i redux.&#160;Atomer kan fungere&#160;som ett alternativ til lokal state som beskrevet i forrige oppgave. Forskjellen her er at hvis flere komponenter bruker samme atom,&#160; deler alle disse komponentene p&#229; samme state. Da har Recoil den fordelen at man kan b&#229;de kan bruke den til lokal state, men ogs&#229; som flere komponenter deler p&#229;.<\/p><p>&#160;<\/p><p>I Recoil&#160;m&#229; p&#229; samme m&#229;te som ved bruk av for.eks&#160;context eller mobx &#39;wrappe&#39; komponentene man vil bruke inn i en provider, i recoils tilfelle &#60;RecoilRoot&#62;. Det er flere hooks som f&#248;lger med react.Recoil som ligner veldig p&#229; vanlige react hooks. For eksempel useRecoilState og useState. En fordel med Recoil er at det f&#248;lger med noen andre hooks som ikke vanlig react har. For eksempel useRecoilValue, som muligj&#248;r readOnly aksess til states innenfor recoil.<\/p><p>&#160;<\/p><p>Redux burde aldri bli brukt til &#229; UI verdier, fordi hver gang man oppdaterer redux store, lager man en kopi av den ny storen, endrer verdien det er snakk om og s&#229; sletter den gamle storen. Dette er ikke bra dersom storen er veldig stor da man kan oppn&#229; d&#229;rligere performance. oppdatere UI direkte er en bedre l&#248;sning ved bruk av Recoil, da den ikke har noen store.&#160;<\/p><p>&#160;<\/p><p>En&#160;ting som er positivt med recoil er at ved &#229; bruke atomer til &#229; h&#229;ndtere states til komponenter, er at de kan bli identifisert med ider, s&#229; man kan h&#229;ndtere og organisere status til hver komponent ved bare &#229; legge til en dynamisk verdi til id&#39;en til hvert atom. en vesentlig&#160;ulemper&#160;med de eksisterende state-management bilbiotekene kontra recoil er hvor effektivt det er &#229; skalere dem. Det er blandt annet mer boilerplate i Redux grunnet den ekstra storen og mer omfattende kode i Reducere og Actions.&#160;<\/p><p>&#160;<\/p><p>Recoil er fortsatt i et veldig tidlig stadie. Det kan v&#230;re vanskelig &#229; implementere dette biblioteket i eksisterende apper dersom de bruker state management bibliotek som redux, da det er ganske annerledes. Det ser dog ut som et spennende bibiotek &#229; pr&#248;ve ut for nye prosjekter.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1742,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den aller viktigste forskjellen som jeg vil trekke frem f&#248;rst er at selv om et&#160;REST API og Graphql blir brukt til hendholdsvis de samme form&#229;lene, er de to forskjellige paradigmer. REST er en arkitekturstil, mens GraphQL er et framework / query language. Man kan ikke direkte erstatte den ene med den andre.&#160;<\/p><p>&#160;<\/p><p>I GraphQL bruker bruker man ett endepunkt, der man lager queries ved &#229; bruke GraphQL syntax til &#229; spesifisere request informasjonen slik at vi f&#229;r&#160;<em>akkurat&#160;<\/em>den dataen vi vil ha fra databasen. I et REST API bruker man flere forskjellige statiske endepunkter, slik at man da heller endrer hvilke endepunkt man bruker for &#229; endre p&#229; hvilke data man vil hente.<\/p><p>Jeg synes det er vesentlig &#229; utdype litt mer om betydningen av denne forskjellen, da det er en av de viktigste forskjellene i forhold til bruksomr&#229;dene til dem begge. Det man oppn&#229;r med REST er simplisitet - der vi har ett endepunkt som henter et bestemt dataset, som er lett &#229; manipulere og jobbe med, men man risikerer &#229; hente un&#248;dvendig mye data(Overfetching). I GraphQL kan man som nevnt bare definere akkurat hvilke data man vil hente eller oppdatere, s&#229; man slipper overfetching.<\/p><p>&#160;<\/p><p>Ved bruk av GraphQL er det god practise &#229; filtrere og behandle data p&#229; server-siden (i resolvers), noe som ikke n&#248;dvendigvis er n&#248;dvendig i REST.&#160;<\/p><p>&#160;<\/p><p>I GraphQL sender man bare en POST request, uansett om man skal hente, poste eller mutere data, mens i REST har man GET, POST, PUT og PATCH.<\/p><p>&#160;<\/p><p>I REST API kan man&#160; utnytte caching-mekanisme&#160;i HTTP-laget, som ikke er mulig i GraphQL.<\/p><p>&#160;<\/p><p>Begge har sine bruksomr&#229;der. Det kan for eksempel v&#230;re lurt &#229; bruke GraphQL n&#229;r det er snakk om direkte kommunikasjon mellom klienten og API-inngangsporten. For eksempel hvis det er mange forskjellige typer klienter (desktop, mobil, etc) som gjerne trenger forskjellige data-spesifikasjoner. Mens det kan v&#230;re hensiktsmessig &#229; bruke REST dersom det bare er snakk om en type klient, eller mellom API-inngangsporten og andre mikrotjenester, der man lettere kan forutsi hvilke typer data man skal innhente.&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11539129,"ext_inspera_userAssessmentSetupId":7139942,"ext_inspera_userAssessmentId":4841373,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:12Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Brooks Jonathan (10087)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34408956,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2662,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I all hovedsak er state en variabel som gj&#248;r det mulig for deg &#229; lagre informasjon eller verdier innad i React komponentene dine. Om staten endrer seg vil komponenten re-rendre, som vil si at om du f.eks. har satt en overskrift til &#229; v&#230;re lik staten din vil overskriften alltid endre seg n&#229;r staten endrer seg.<\/p><p>&#160;<\/p><p>Ved bruk av props har du mulighet til &#229; sende data fra en foreldrekomponent til barnekomponentene. Dette gj&#248;res p&#229; en veldig lik m&#229;te som &#229; sende argumenter til en funksjon. Dette er den enkeleste m&#229;ten &#229; sende informasjon til andre komponenter.<\/p><p>&#160;<\/p><p>Noen ganger vil du at en state skal kunne bli brukt av flere komponenter. Originalt m&#229;tte man bruke en form for prop-drilling hvor man sender state fra foreldre-komponenten ned til barna ved bruk av props. Dette er en ganske tidkrevende og overkomplisert m&#229;te &#229; gj&#248;re det p&#229;. Da hooks kom ut gjorde det hele denne prosessen mye lettere. Man kunne bruke en hook som heter context, som vil gj&#248;re det mulig for deg &#229; ta i bruk verdier i alle komponentene dine uten &#229; m&#229;tte sende verdiene ned som props. Med context trenger man bare en Provider i &#34;hovedkomponenten&#34; (ofte App) din, ogs&#229; i alle barna kan man f&#229; tak i verdiene ved &#229; importere useContext.<\/p><p>&#160;<\/p><p>Om man bestemmer seg for at man ogs&#229; vil endre staten man sender med context m&#229; man ogs&#229; sende med setState funksjonen knyttet til den. Dette kan implementeres mye &#34;cleanere&#34; om man bruker React Redux. Da lagrer man dataen sin et sted, dette heter store. Store er read-only, og man kan bare endre det ved bruk av actions som man selv definerer. I komponentene kan man kalle p&#229; actionsene ved bruk av dispatch. Man kan ogs&#229; bruke et bibliotek som heter MobX, som har samme funksjon som Redux, men implementerer heller en observerbar state. En fordel med MobX er at den krever mindre boilerplatekode.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/getting-started.html<\/p><p>WebDev powerpoint 05.10.2020<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2847,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som har som hensikt &#229; forenkle hvordan man kan dele state mellom komponenter i React. De tar i bruk noe de kaller atoms. Hvert atom inneholder en state, og alle atoms er mulig &#229; oppdatere og abonnere til. Hver gang et atom oppdateres, vil alle komponenter som abonnerer til atomet re-rendres.<\/p><p>&#160;<\/p><p>Recoil kan sammenlignes med Context, Redux og MobX, siden alle pr&#248;ver &#229; l&#248;se problemet med &#229; dele state mellom komponenter. I motsetning til de andre bibliotekene trenger man ikke noe boilerplatekode i Recoil, det &#229; lage et nytt atom er like lett som &#229; lage en ny state. Dette er en fordel, siden det kan ta en del tid &#229; sette opp de andre state management bibliotekene riktig. I likhet med de andre bibliotekene trenger man en Provider i rot-komponenten din. I Recoil kan man ogs&#229; bruke selectors p&#229; samme m&#229;te som actions, til &#229; endre p&#229; dataen. Komponenter kan ogs&#229; abbonere p&#229; selectoren, p&#229; samme m&#229;te som atoms. Jeg mener at m&#229;ten de har laget selectors er mye mer intuitivt enn f.eks. Redux actions, dermed er dette en fordel, men dette kommer an p&#229; hva man er vandt med.<\/p><p>&#160;<\/p><p>Akkurat n&#229; ser jeg ingen ulemper med Recoil i forhold til de andre bibliotekene annet enn at det er ganske nytt, og kanskje ikke ferdigtestet enda. Men det virker veldig lovende, da det er mye lettere &#229; implementere. Jeg vil tro at etterhvert s&#229; kommer Recoil til &#229; bli mer og mer brukt, og kanskje til og med foretrukket over biblioteker som Redux og MobX.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/motivation/<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1592,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I REST m&#229; du definere flere endepunkter hvor du sier i forkant hvilken data de skal returnere, mens i GraphQL har du bare et endepunkt hvor du kan fra frontenden si akkurat hvilken data du vil hente ut. Dette gj&#248;r at GraphQL kan kreve mindre HTTP requests enn om du hadde brukt REST, og at man ikke f&#229;r tilsendt noe un&#248;dvendig data.<\/p><p>GraphQL tar ikke ordentlig i bruk HTTP-koder, s&#229; om du sender noe galt i requesten din vil du f&#229; tilbake en pakke med statuskode 200 OK, som vil inneholde erroren i &#34;bodyen&#34;. I REST API vil man kunne ta ordentlig i bruk HTTP-koder, om man har satt opp backenden riktig.<\/p><p>En stor fordel med GraphQL er enkel validering av inputs, siden man i backenden bruker typer. S&#229; man kan lett sjekke om en request er gyldig, i forhold til et vanlig REST API der man m&#229; implementere en del egne valideringsfunksjoner.<\/p><p>Om du bruker REST API kan det v&#230;re litt vanskelig &#229; oppdatere frontenden din, uten &#229; m&#229;tte endre mange funksjoner i backenden. Mens med GraphQL kan du lett endre hvordan frontenden ser ut, siden man lett kan endre p&#229; requesten til &#229; f&#229; bare den nye dataen man trenger.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://graphql.org/learn/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11539235,"ext_inspera_userAssessmentSetupId":7140133,"ext_inspera_userAssessmentId":4841418,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:08Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tronstad Johanne (10197)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330614,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2266,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Redux er et eksempel p&#229; state management som er mye brukt i React-applikasjoner, og som gj&#248;r det enklere &#229; vedlikeholde de forskjellige tilstandene. Med Redux blir tilstanden til applikasjonen lagret i en felles uforanderlig&#160;&#34;store&#34;, og hver komponent f&#229;r tilgang til staten den trenger fra denne &#34;storen&#34; uten &#229; m&#229;tte hente sende props fra en komponent til en annen. Redux lager en datastruktur med JavaScript objekter som du kan&#160;lese fra. Det er tre forskjellige deler: actions, stores and reducers. Actions er &#34;eventer&#34;, og den eneste m&#229;ten du kan sende data fra applikasjonen til storen, bruker store.dispatch() metoden. Reducers er funksjoner som tar den n&#229;v&#230;rende tilstanden til applikasjonen, gj&#248;r en endring og returnerer en ny state. Store lagrer applikasjonens tilstand, og kan bli aksessert og oppdatert.<\/p><p>Redux er forutsigbart, og det er enkelt &#229; reversere oppdateringer p&#229; tilstandene.<\/p><p>&#160;<\/p><p>Uten state management er man n&#248;dt til &#229; hente staten fra en komponent, l&#248;fte den til n&#230;rmeste parent-element og videre til en komponent som er felles for komponenten du henter staten fra og til komponenten du vil hente staten til. Dette kan fort bli komplisert uten state management.&#160;<\/p><p>&#160;<\/p><p>MobX er en annen, mindre popul&#230;r, metode for state management. I motsetning til Redux bruker den minst 2 stores, &#233;n for UI og en for domain state - som er staten for serversiden av applikasjonen. Dette gj&#248;r at du kan gjenbruke staten (for eksempel i andre applikasjoner)&#160;og teste domain staten universalt, og for eksempel ha en state inni en annen state.<\/p><p>MobX observerer ogs&#229; endringer i statene, og sporer disse endringene automatisk. Redux p&#229; den andre siden sporer oppdateringer manuelt helt til man har lagt til listeners.<\/p><p>I MobX er tilstandene&#160;<em>mutable<\/em>, som gj&#248;r at man kan oppdatere med nye verdier. Dette gj&#248;r applikasjonen vanskeligere &#229; teste og vedlikeholde siden de ikke alltid returnerer forutsigbare outputs.<\/p><p>&#160;<\/p><p>Valget mellom state managers burde baseres p&#229; kompleksiteten til applikasjonen. Hvis du vil ha god kontroll p&#229; dataflyt og har en st&#248;rre applikasjon er Reduxe et godt alternativ. Hvis applikasjonen er mindre og enklere med mindre &#34;boilerplate code&#34; er kanskje MobX et bedre alternativ.<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://blog.logrocket.com/redux-vs-mobx/<\/p><p>https://www.imaginea.com/redux-vs-mobx-what-you-need-to-know/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1373,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de Redux og MobX krever en del konfigurasjon og set up for &#229; komme i gang.&#160;<\/p><p>Recoil er et state manangement bibliotek som ble utviklet av Facebook, og er relativt enkelt &#229; komme i gang med og sette seg inn i. Recoil deler samme tilstand i forskjellige komponenter, og har state observation som kan observere alt som skjer i applikasjonen fra &#233;n komponenet.&#160;<\/p><p>Recoil bruker atomer - som er en enhet av tilstanden som kan endres og bli subscribet til ved &#229; bruke en <em>useRecoilState<\/em> hook. Dersom man endrer verdien til et atom vil hver komponent som er subscribet til dette atomet endres, og alle disse komponentene deler tilstand. Man kan enkelt returnere verdien til en spesifikk tilstand ved &#229; bruke&#160;<em>useRecoilValu<\/em><em>e.<\/em><\/p><p>&#160;<\/p><p>Recoil bruker ogs&#229; selectors, som er funksjoner som kan ta inn atomer eller en selektor som input. Selektoren returnerer en modifisert tilstand hver gang atomene eller selektorene blir oppdatert. Disse kan ogs&#229; bli subscribet til.&#160;<\/p><p>&#160;<\/p><p>I Recoil er det ikke n&#248;dvendig &#229; lage en separat store, som det er i Redux og MobX. I Redux lager vi &#248;nsket tilstand ved bruk av reducers, mens med Recoil bruker vi atomer til dette.<\/p><p>Ved &#229; bruke recoil slipper man &#229; lage stores, og re-rendre hele komponenttreet n&#229;r en tilstand oppdateres, men man kan enkelt lage en dataflyt graf som flyter fra atomer gjennom selectors og ned til React komponentene.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>- https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3487,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST og GraphQL er et API designarkitektur, som lar to programmer kommunisere med hverandre. Begge teknologiene sender en HTTP sp&#248;rring og begge kan returnere et JSON objekt. GraphQL har mange av de samme elementene som REST.<\/p><p>&#160;<\/p><p>GraphQL er en fleksibel metode som organiserer data inn i en graf, hvor objekter er representert som noder. GraphQL er et &#34;query language&#34; hvor du kan endre sp&#248;rringen slik at den&#160;fetcher akkurat den dataen du trenger. Man kan kombinere entiteter og spesifisere attributter man &#248;nsker &#229; ha med i responsen. GraphQL har kun ett endepunkt. Har ikke noe automatisk caching system som REST har, man kan bruke for eksempel Apollo til caching for &#229; redusere trafikken til serveren.<\/p><p>GraphQL lar utvikleren gj&#248;re endringer p&#229; klient-siden uten &#229; r&#248;re serveren.<\/p><p>&#160;<\/p><p>REST bruker HTTP sp&#248;rringer for &#229; aksessere og bruke&#160;data. Hovedideen er er at alt er en resource som identifiseres av en URL. Bruker metodene GET, PUT, POST og DELETE. REST har flere endepunkter, og kan cache sp&#248;rringene.<\/p><p>Dersom du skal&#160;hente data fra flere kilder med REST m&#229; du bruke flere sp&#248;rringer, og sp&#248;rringen fetcher alltid hele datasettet. Hvis du skal ha informasjon fra to objekter m&#229; du ha to&#160;sp&#248;rringer til REST API&#39;et, mens med GraphQL hadde du bare trengt &#233;n. Dette f&#248;rer til over- og under-fetching problemer.<\/p><p>To store fordeler er at REST er scalable og fleksibelt.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://graphql.org/<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11539320,"ext_inspera_userAssessmentSetupId":7139966,"ext_inspera_userAssessmentId":4842168,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:13Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Olstad Bård (10131)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":24798851,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":4621,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>P&#229; lokalt niv&#229; i react-applikasjoner kan man bruke enten useState eller setState. Man kan bruke disse mekanismene i st&#248;rre skala i applikasjonen ogs&#229;, men mange komponenter i et h&#248;yt komponent-tre vil gj&#248;re det tungvint &#229; bruke disse, da tilstand og dataflyt kan m&#229;tte sendes gjennom flere komponenter i hierarkiet uten &#229; bli brukt.<\/p><p>&#160;<\/p><p>SetState er den eldste av de to mekanismene, og den kan brukes i klassebaserte komponenter. Bruken er rimelig rett fram, hvor man oppretter en state i komponenten med de data og startverdi man m&#229;tte &#248;nske. Videre kan man endre tilstanden i komponentens metoder ved &#229; skrive &#34;setState&#34; og inne i metoden endre p&#229; de data man &#248;nsker. I bruken av denne mekanismen er det god praksis &#229; lage midlertidige variabler for &#229; ikke endre p&#229; uforanderlige (immutable) data, og for &#229; ikke overskrive noe f&#248;r man er sikker p&#229; at det er det som skal gj&#248;res i metoden.<\/p><p>&#160;<\/p><p>UseState er en&#160;nyere mekanisme, og er en del av det som er kjent som react hooks. React hooks ble introdusert for &#229; gj&#248;re det mulig &#229; endre tilstand og bruke livssyklus-metoder i mindre kompliserte komponenter kjent som funksjonelle komponenter. Funksjonelle komponenter er komponenter som best&#229;r av kun &#233;n metode/funksjon, og de er ikke klassebasserte. Dermed kunne de ikke f&#248;r hooks endre state, s&#229; man m&#229;tte enten bruke en klassebasert komponent eller sende data til en h&#248;yereordens komponent (hoc) og endre state der. Ved &#229; bruke useState kan man n&#229; endre state i funksjonelle komponenter ved &#229; lage en variabler med tilh&#248;rende metode, og sette en initialtilstand ved hjelp av &#34;useState&#34;. Eks: const [count, setCount] = useState(0).<\/p><p>&#160;<\/p><p>&#160;<\/p><p>N&#229;r applikasjonene blir store og det er mange komponenter som har tilkoblinger til samme state kan det l&#248;nne seg &#229; bruke tredjepartsbiblioteker f&#229;r &#229; h&#229;ndtere tilstand og dataflyt i applikasjonen p&#229; et mer globalt niv&#229;. Redux og MobX er ikke spesifikt laget for react, men de er meget lett &#229; implementere i en react-applikasjon. Noe tilstand og dataflyt kan og burde h&#229;ndteres lokalt, hvis det bare benyttes lokalt. Har applikasjonen derimot tilstand og dataflyt som flere komponenter benytter seg av og hvis disse komponentene er langt unna hverandre i applikasjonsstrukturen, s&#229; er en global h&#229;ndtering foretrukket.<\/p><p>&#160;<\/p><p>Redux h&#229;ndterer tilstand og dataflyt ved &#229; lage en global Store hvor alle tilstander og data kan lagres hvis man &#248;nsker det. Innholdet i en slik store har bare tilh&#248;rende reducers muligheten til &#229; endre p&#229;. Reducers er komponenter som brukes for &#229; h&#229;ndtere state og dataflyt, og det lages for &#229; h&#229;ndtere noen bestemte states, og det bruker Actions for &#229; vite hvordan og hva de skal gj&#248;re med staten de har tilgang p&#229;. Ofte inneholder reducers en switch med et sett med cases, hvor hvilken case som skal brukes bestemmes av innkommende action. Inni hver case endres staten i den globale storen p&#229; den bestemte m&#229;ten som er screvet i casen. En Action som sendes til reduceren inneholder hvilken case og dermed metode som skal brukes, og den inneholder payloaden som er data som skal brukes i endringen av tilstand/data. Bare reducers kan endre p&#229; det som er lagret i storen, men alle komponenter kan ved &#229; importere store lytte til endringer i den, og reagere deretter om &#248;nskelig.<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; h&#229;ndtere tilstand og dataflyt globalt i en react-applikasjon er &#229; bruke MobX. Den st&#248;rste forskjellen mellom Redux og MobX er at MobX ikke har en global store hvor alt lagres, men heller knytter individuelle komponenter sammen etter &#248;nske. MobX lager i stedet en observer/observed-relasjon mellom de komponentene man &#248;nsker. P&#229; denne m&#229;ten kan man sende tilstand og data mellom komponenter som er langt unna hverandre. I stedet for &#229; sende data gjennom alle komponentene som er mellom de to komponentene man &#248;nsker &#229; koble sammen, lager man er relasjon mellom dem direkte.<\/p><p>&#160;<\/p><p>Redux og MobX har ulike styrker og svakheter. Redux sin store er global og oversiktlig, og bruken av reducers og actions som skrives i egne filer gj&#248;r at det blir lite ekstra kode i de komponentene som benytter seg av den globale storen. MobX p&#229; sin side tilf&#248;rer mye koden i komponentene som er en del av observer/observable-systemet og uten en tydelig plass og lagre data kan man fort rote seg bort. P&#229; en annen side er det mye kode som m&#229; skrives (i egne filer) for &#229; bruke Redux p&#229; en god m&#229;te, og det burde v&#230;re mye tilstand og dataflyt som skal sendes mellom komponenter f&#248;r det l&#248;nner seg &#229; bruke Redux. MobX er ogs&#229; bedre egenet til &#229; reagere p&#229; at de globale tilstandene endres. I Redux m&#229; man &#34;lytte&#34; til hele storen, s&#229; n&#229;r mange komponenter lytter til storen og f&#229;r beskjed n&#229;r data endres, s&#229; er det kanskje bare en av komponentene som faktisk skal utf&#248;re en handling som f&#248;lge av endringen. Her er MobX bedre stilt, hvor man kan lage spesifikke forhold som observer/observed mellom komponenter.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>React Hooks:&#160;https://medium.com/@mateuszroth/react-hooks-advantages-and-comparison-to-older-reusable-logic-approaches-in-short-f424c9899cb5&#160;<\/p><p>MobX:&#160;https://mobx.js.org/react-integration.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1412,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er bibliotek laget for &#229; h&#229;ndtere tilstand, og det bruker&#160;<em>atoms&#160;<\/em>for &#229; sende data/tilstand mellom&#160;<em>selectors<\/em>. S&#229; atoms er informasjonspakkene og selectors er det funksjonene som tar i mot og bruker innholdet i et atom.&#160;Intensjonen bak bibliotektet er &#229; redusere antallet komponenter som vurerer &#229; re-renderes eller som faktisk rerenderes. Som nevnt i forrige oppgave s&#229; har redux en stor ulempe ved at man ikke kan lytte til &#233;n spesifikk del av storen. Dermed blir antallet komponenter som vurdere en re-render h&#248;yt, noe som kan birdra til &#229; gj&#248;re en web-applikasjon tregere. I sammenligning med mobx kan man si at mobx er i andre enden av skalaen, og blir for spesifikt gjennom bruken av observer/observable. Recoil sine atoms og selectors er mer generelle og kan benyttes av flere komponenter p&#229; en enklere m&#229;te. De minner mye om react hooks, og de er ogs&#229; godt egnet for &#229; bli brukt i samhandling med disse.<\/p><p>&#160;<\/p><p>&#197; bruke et bibiliotek som er under utvikling har en stor ulempe n&#229;r det kommer til levetid. Alle parter i programmering som biblioteker og mekanismer har en viss levetid. De kan fungere &#34;for alltid&#34; men at det kommer bedre funskjoner og biblioteker er s&#229; og si garantert, s&#229; alt forventes &#229; blir foreldet. Bruker man biblioteker under utvikling m&#229; man regne med at hvor lenge det er til metodene man har brukt har blitt foreldet eller byttet ut kan g&#229; fra to &#229;r til to m&#229;neder.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<br />https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1555,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Hvor REST API er &#229; putte neven ned i nonstop-sk&#229;la og s&#229; plukke den fargen du hadde lyst p&#229; fra din egen h&#229;nd, s&#229; er Grahpql &#229; plukke &#233;n nonstop av fargen du &#248;nsket fra sk&#229;la.<\/p><p>&#160;<\/p><p>Rest vil hente et mer generelt datasett en det graphql (gq) vil gj&#248;re. Dette kan sees som b&#229;de en fordel og en ulempe. Som i eksempelet med nonstop s&#229; kan rest hente st&#248;rre sett med data i en sp&#248;rring, men det er mulig at du bare &#248;nsket en spesifikk bit av datasettet, og oppsettet av data p&#229;&#160;serversiden tillater ikke n&#248;dvendigvis &#229; hente ut den spesifikke dele man &#248;nsker. Dette kan f&#248;re til overfetching, hvor man henter store mengder data man ikke har bruk for. Alle nonstop med farger man ikke hadde lyst p&#229; vil v&#230;re tilsvatende den overfl&#248;dige data man hentet. Et annet problem med rest er at det kan oppst&#229; underfetching, hvor man ikke f&#229;r nok &#248;snkelig data gjennom et request, og m&#229; gjenta prosessen.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Et annet eksempel er hvis man &#248;nsker &#229; hente ut adressen til en liste med brukere. Da kan et rest api m&#229;tte hente ut hele listen, for s&#229; &#229; sortere ut adressene fremfor &#229; sp&#248;rre om de spesifikt. Gq p&#229; sin side bruker&#160;GraphQL Schema Definition Language (SDL) for &#229; hente ut de spesifikke data man &#248;nsker. Nedsiden med gq er hvor spesifikt det er, s&#229; for &#229; hente ut adressene, er man n&#248;dt til &#229; utf&#248;re et kall til serveren per bruker.&#160;SDL er en kontrakt mellom server og klient, og bestemmer hvordan klienten er tillatt &#229; hente ut data fra serveren.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11539477,"ext_inspera_userAssessmentSetupId":7139954,"ext_inspera_userAssessmentId":4841252,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Andersen Philip Hall (10234)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":38204636,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1151,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>H&#229;ndtering av &#34;state&#34; i React-applikasjoner kan l&#248;ses p&#229; flere forskjellige m&#229;ter, og hvilken l&#248;sning som egner seg best avhenger mye&#160;av&#160;oppgaven som skal l&#248;ses. React har innebygd en simpel form for &#34;state management&#34; som fungerer bra til mindre kompliserte applikasjoner. Lokal tilstand kan lagres med useState-hook og delt tilstand mellom flere komponener kan h&#229;ndteres med Context. Problemene kommer f&#248;rst n&#229;r applikasjonen og dataen som skal h&#229;ndteres blir mer komplisert, f. eks ved et&#160;flersidet innfyllingsskjema som deler tilstanden mellom flere sider. Ved slike oppgaver kan det v&#230;re lurt &#229; benytte seg av et tredjeparts-bibliotek som f. eks Redux eller Mobx. Fordelen med &#229; gj&#248;re dette er at koden blir mer oversiktlig og gj&#248;r at man f&#248;lger standarder som er lettere &#229;&#160;gjenkjenne&#160;for andre utviklere som skal se p&#229; koden. En viktig ting &#229; notere er at selv om man benytter seg av et &#34;state management&#34; bibliotek i en applikasjon for h&#229;ndtering av global / delt tilstand, s&#229; er det ofte mange tilfeller hvor lokal tilstand h&#229;ndteres kun med f. eks useState-hook&#39;en. Dette forhindrer un&#248;dvendig data i &#229; lagre seg i den globale tilstanden, slik at den kun lagrer det som er n&#248;dvendig.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":923,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som tilbyr en forenklet syntaxen til h&#229;ndtering av global / delt tilstand i applikasjoner i forhold til tidligere kjente biblioteker som Redux og Mobx. Sammenlignet med Redux, som jeg selv brukte i prosjektoppgavene, er mengden kode som er n&#248;dvending drastisk redusert. Dette gj&#248;r Recoil mye raskere &#229; implementere, og reduserer sjansen for at man skriver noe feil. Hovedulempen jeg ser med Recoil er at koden fort blir uoversiktlig ved st&#248;rre applikasjoner, da man m&#229; lage &#34;atomer&#34; og huske den tilh&#248;rende &#34;selector&#39;en&#34; for hver eneste enkelt tilstands-objekt som lagres. En annen ulempe er at det ikke er direkte st&#248;tte for &#229; skrie funksjoner som kan ta inn parametere og endre tilstanden p&#229; en spesifik m&#229;te, slik som man kan i f. eks Redux ved &#229; lage &#34;Actions&#34; og tilh&#248;rende &#34;Reducers&#34; som definerer hvordan tilstanden skal endres av funksjonen. Alt i alt tror jeg at for mange applikasjoner vil Recoil v&#230;re tilstrekkelig, og kan spare en del tid i utviklingen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1472,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av de st&#248;rste forskjellene mellom REST API&#160;og Graphql er at med et REST API m&#229; servern du sender foresp&#248;rsler til endepunkter som kun returnerer data p&#229; det formatet som er predefinert i serveren. Dette f&#248;rer til at man ofte m&#229; sende flere ettersp&#248;rsler sammenlignet med GraphQL hvis dataen man skal hente ut ligger spredt utover flere endepunkter. De predefinerte endepunktene i REST API&#39;er f&#248;rer ofte ogs&#229; til at man mottar mer data enn man egentlig &#248;nsker. En fordel med de predefinere endepunktene er at man har mindre sjanse for &#229; gj&#248;re en feil n&#229;r man skriver ettersp&#248;rselen, og man trenger kun &#229; skrive inn en URL for &#229; motta dataen man &#248;nsker.&#160;I GraphQL definerer man istedenfor et stort objekt som inneholder all dataen p&#229; en server.&#160;I ettersp&#248;rselen definerer man s&#229; dataformatet man &#248;nsker, slik at man kun mottar akkurat den dataen man &#248;nkser med en enkel ettersp&#248;rsel. En annen fordel med GraphQL er at man kan hente ut data fra flere niv&#229;er i objektet p&#229; serveren, f. eks ved &#229; hente ut data om en bruken og noe irrelevant data om noe annet samtidig i en og samme ettersp&#248;rsel. Hvis man ser bort fra det rent tekniske kan man ogs&#229; argumentere for at&#160;GraphQL er enklere &#229; l&#230;re og bruke i praksis enn REST API, grunnet den simple og intuitive syntaxen som ligner mye p&#229; objekter i JavaScript.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11537619,"ext_inspera_userAssessmentSetupId":7140141,"ext_inspera_userAssessmentId":4842162,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:07Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ockernahl Agnes Marie Ødegård (10177)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":10471522,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2261,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har en hierarkisk dataflyt som er enveis, man har en hovedkomponent (foreldre komponenten) som ofte er App.js&#160; (App.tsx) filen, denne har s&#229; en eller flere child components, som igjen kan ha barne komponenter.&#160;<\/p><p>For &#229; h&#229;ndtere tilstand har React mekanismene props, setState (med class komponenter) useState (react hook som brukes med funksjonelle komponenter) og Context. Props sendes fra foreldre komponentene til barnekomponentene, lignende funksjonsparametre, mens setState/useState er h&#229;ndtert innad i komponentene. setState er lokalt tilstand, mens Context er en global tilstand og kan n&#229;s fra alle komponenter hvor context provider er wrappet rundt. Context er hensiktsmessig hvis man har et komplisert komponent tre og tilstanden beh&#248;ves flere steder i applikasjonen, og man kan da unng&#229; &#34;prop drilling&#34;, som betyr at man sender props ned gjennom mange komponenter, som kanskje ikke har bruk for tilstanden for &#229; n&#229; barne komponenten hvor det er behov for tilstanden. Ved en slik komplisert komponent hierarki vil det bli vanskelig &#229; vedlikeholde applikasjonen og det vil v&#230;re mer hensiktsmessig med globale tilstand h&#229;ndteringer.&#160;<\/p><p>&#160;<\/p><p>I tillegg finnes det tredjepartsl&#248;sninger for &#229; h&#229;ndtere tilstand slik som Redux og MobX. Ulempen med Context er at n&#229;r tilstanden oppdateres oppdateres (rerendres) alle komponenter som Context er wrappet rundt og har tilgang tilstanden. Jo h&#248;yere opp i hierarki treet Context er wrappet rundt jo flere komponenter vil rerendres ved oppdatering og dette kan p&#229;virke ytelsen i stor grad. Hvis man har en tilstand som oppdateres hyppig vil det v&#230;re mer hensiktsmessig &#229; bruke en tilstand h&#229;ndterer slik som Redux eller MobX som ikke vil rerendre alle komponentene, men kun der den egenskapen som oppdateres blir brukt. MobX og Redux gir ogs&#229; global state slik som Context. MobX kan ha multiple stores i likhet med Context, mens Redux har single store. Redux er den mest brukte tredjepartsl&#248;sningen og mange er derfor kjent med oppsettet. Redux har nok en st&#248;rre oppstartkostnad, da man m&#229; sette opp reducers, actions og storen, mens MobX krever mindre kode for &#229; settes opp. MobX kan derimot v&#230;re vanskeligere for andre utviklere &#229; sette seg inn i din kode, b&#229;de fordi det er mindre brukt, men ogs&#229; fordi det ikke har en like oversiktlig struktur.<\/p><p>&#160;<\/p><p>kilder:&#160;<\/p><p>https://reactjs.org/docs/thinking-in-react.html<\/p><p>https://reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props<\/p><p>Forelesninger og kunnskap opparbeidet gjennom prosjektene<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3658,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek av React og bygger derfor p&#229; React mekanismer og er ment &#229; forenkle global state management. I likhet med Context s&#229; wrappes appen med en RecoilRoot slik at tilstandene skal v&#230;re tilgjengelig for alle komponenter. Recoil best&#229;r av Atoms som er enheter av tilstand, som b&#229;de er mulig &#229; oppdatere og abonnere p&#229; gjennom selectors, som er funksjoner som aksepterer enten atoms eller andre selectors som input. Hvert Atom har en unik n&#248;kkel og selectors kan transformere atomets tilstand enten &#34;synchronously&#34; eller &#34;asynchronously&#34;. Man bruker en react hook useRecoilState for &#229; kunne lese eller endre p&#229; tilstanden, slik som ved bruk av useState og istedenfor &#229; putte inn en default sate i useState, putter man in atomet inn i useRecoilState funksjonen. Dette gj&#248;r at logikken er gjenkjennbar og dermed enkelt &#229; g&#229; ifra useState over til Recoil. Forskjellen fra useState er at tilstanden er tilgjengelig globalt og ikke kun lokalt innad i komponenten den blir definert i. Som diskutert i forrige oppgave er dette nyttig, hvis man har behov for en tilstand i flere forskjellige komponenter og ikke &#248;nsker &#229; bruke props. I tillegg slipper man ulempene med &#229; opprette stores, slik man m&#229; i Redux og MobX, og re-rendre hele applikasjonen, slik det gj&#248;res med Context. Ved at man unng&#229;r &#229; rerendre alle komponentene Context er wrappet rundt, kan gi store ytelse gevinster og kan derfor v&#230;re fordel &#229; bruke Recoil. I Recoil rerendres kun de komponentene som abonnerer p&#229; atomet som blir oppdatert. En annen ulempe med Context er at det kan bare lagre en verdi og ikke et uendelig sett med verdier, ved &#229; kunne ha flere atoms l&#248;ser recoil denne ulempen. For &#229; sette opp og bruke Redux m&#229; man skrive mye kode og kan derfor v&#230;re lite tidseffektivt, fordelen med Recoil er at det er lett &#229; sette opp og krever ikke like mye kode og var noe av motivasjonen til at det ble laget. En av ulempene med MobX i forhold til Recoil er at MobX krever god forst&#229;else av apiet, og metoder slik som observable og action, som ikke er vanlige React standarder og kan derfor v&#230;re mer komplisert &#229; sette seg inn i hvis man allerede er vant til React.&#160;<\/p><p>&#160;<\/p><p>Merk: Denne oppgaven gikk litt inn i den forrige oppgaven hvor jeg ogs&#229; snakker om Redux, Context apiet og MobX, og jeg antar at sensor har lest forrige oppgave f&#248;rst, og bruker dermed noen av argumentene jeg kom med der, uten &#229; forklare de noe utdypende i denne oppgaven.<\/p><p>&#160;<\/p><p>kilder:<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://www.youtube.com/watch?v=KBE7Ezn7h0A<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3008,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Disse to teknologiene er l&#248;sninger for kommunikasjon mellom klient og server i webapplikasjoner.<\/strong><\/p><p>&#160;<\/p><p><strong>Rest er en &#34;architectural&#34; og har det man kaller multiple endpoint som betyr at for &#229; hente forskjellig informasjon sender man en request til serveren via forskjellige endpoints. Rest st&#248;tter get, post, put, patch osv som er HTML metodene for &#229; opprette, slette endre eller lese data. En av de mest diskuterte ulempene med REST er under-/overfetching, som kommer p&#229; grunn av at REST gir et statisk endpoint, som man ikke kan spesifisere ut fra behov og forandre en spesifikk respons, og dermed f&#229;r man ofte for mye data eller for lite. Fordeler derimot er at det er godt etablert og vanlig &#229; bruke, som gj&#248;r det lett for andre &#229; sette seg inn i. Det er ogs&#229; hensiktsmessig hvis man har behov for all informasjonen eller mye av informasjonen. Rest har ogs&#229; st&#248;tte for caching, som er viktig for effektivitet og skalerbarhet. Rest gir ogs&#229; en intuitiv m&#229;te &#229; fetche data med HTML metodene slik som PUT, gir enkel og lesbar kode p&#229; klient siden.&#160;&#160;<\/strong><\/p><p>&#160;<\/p><p><strong>GraphQL er et query language, hvor man sender sp&#248;rringer til server og har single endpoint. Dette gj&#248;r at man kun henter ut den dataen man &#248;nsker, da daten endrer seg basert p&#229; queryen og eventuell input, og l&#248;ser dermed problematikken med under-/overfetching som man har med REST. GraphQL st&#248;tter kun post, men har i tillegg mutations for &#229; kunne endre data og dermed f&#229;r man den samme funksjonaliteten som med REST, selv om kun POST st&#248;ttes. For GraphQL skjer filtreringen logikken p&#229; server siden via bruk av resolvers og schema. Dette har f&#248;rt til at GraphQL kan v&#230;re noe mer kompleks &#229; sette opp p&#229; backend enn REST og man kan ende opp med mye repeterende kode siden Graphql krevet et eget graphql schema, i tillegg til skjema til databasen. Dette f&#248;rer til noe un&#248;dvendig kode og noe man helst &#248;nsker &#229; unng&#229; at man m&#229; skrive dobbelt med kode. En fordel med GraphQL derimot er at det er et type system, som gir deg fordeler som at man oppdager errors tidligere og forteller deg hva feilen, det gj&#248;r ogs&#229; at den er selvdokumenterende og kan v&#230;re lettere for andre utviklere &#229; sette seg inn i din kode. I tillegg er det lettere &#229; bruke sammen med typescript da man vet hvilke typer dataen er. I tillegg har GraphQL flere tredjeparts komponenter man kan bruke sammen med det som gir deg mye gratis n&#229;r man skal kode slik som Apollo, gj&#248;r at man for eksempel enkelt kan refetche data, caching, osv. Noen ulemper i forhold til REST som det ofte diskuteres er at det er vanskeligere &#229; cache og problematikk med rate limit, caching har med &#229; gj&#248;re at browseren lagrer lokale kopier av web ressursene og rate limit er antallet api kall en applikasjon kan gj&#248;re over en gitt tidsperiode. Problemet med caching gj&#248;r at man kan resultere i &#229; overbelaste serveren med requests. Det er ogs&#229; vanskeligere &#229; observere ytelse (performance) i GraphQL enn i REST, da GraphQL opererer med single endpoint og ofte nesting av queries, blir det vanskelig &#229; se hvor lang tid en resolver brukte p&#229; &#229; be om dataen.&#160;<\/strong><\/p><p>&#160;<\/p><p><strong>REST er det som er mest brukt og kanskje det flest utviklere kjenner til, GraphQL er derimot nyere, men er mange som mener at REST er p&#229; vei ut og at GraphQL er p&#229; vei til &#229; ta over. Det er ogs&#229; noen som mener at man burde bruke GraphQL hvis man har flere klienter eller sider som har bruk for forskjellig data, og kan dermed tilpasse dette lettere med GraphQL, men ellers et at man burde bruke REST. <\/strong><\/p><p>&#160;<\/p><p>Kilder:<\/p><p>Forelesning&#160;<\/p><p>https://www.youtube.com/watch?v=4akSaaEYJqs&#160;<\/p><p>https://www.youtube.com/watch?v=AYZOHt6kz6Y<\/p><p>https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers<\/p><p>https://developers.facebook.com/docs/graph-api/overview/rate-limiting/<\/p><p>https://www.youtube.com/watch?v=ZLKbF8-KLh8<strong>&#160;<\/strong><\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537664,"ext_inspera_userAssessmentSetupId":7140063,"ext_inspera_userAssessmentId":4841251,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Kjuus Sverre (10052)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33636202,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2434,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":1,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Med Props kan man sende data nedover i komponent-hierarkiet. Ved &#229; bruke en callBack-funksjon kan man ogs&#229; oppdatere en forelder fra en barnekomponent.<\/p><p>&#160;<\/p><p>Rammeverk for h&#229;ndtering av state (Redux/MobX/Context). State&#39;ene blir globale og lagres som en instans. Gir fordelen av at det blir lettere &#229; vedlikeholde state som er mer omfattende, man kan f&#229; f&#230;rre callbacks som ikke trengs, og state flyttes til foreldrekomponent<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2618,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil: Recoil er et state bibliotek for state management for React og lar deg lage grafer over dataflyt fra &#34;atomer&#34; gjennom &#34;selectors&#34;.<\/p><p>&#34;Atomene&#34; er state-enheter med unike id&#39;er som&#160;kan oppdateres og &#34;abonneres&#34; til. Atomene brukes i stedet for React local component state. Alle komponenter kan b&#229;de skrives til&#160;og leses fra atomene, og alle komponenter som &#34;abonnerer&#34; p&#229; et atom vil bli re-renderet hvis atomet oppdateres.<\/p><p>&#34;Selectors&#34; er funksjoner som kan ta inn atomer eller andre selectors. N&#229;r et atom&#160;oppdateres vil alle selectors som abonnerer p&#229; atomet oppdatere&#160;selector-funksjonen sin.<\/p><p>&#160;<\/p><p>Fordeler:<\/p><p>Recoil gj&#248;r&#160;h&#229;ndtering av state enklere. Med recoil kan mandele en state i flere komponenter. Recoil kan sammenlignet med Redux minske antall re-renders man m&#229; gj&#248;re.<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>Sammenlignet med Redux er Recoil i en tidlig fase, mens Redux allerede har et etablert bibliotek. Redux kan ogs&#229; v&#230;re mer p&#229;litelig ettersom man oppretter alt manuelt og har mer kontroll.<\/p><p>Ulemper ved recoil kan v&#230;re at hvis et atom er knyttet til mange komponenter, vil det kreve at mange komponenter re-renderes samtidig n&#229;r atomet oppdateres. Generell un&#248;dvendig re-rendering av komponenter.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2118,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Med REST m&#229; man gj&#248;re et API-kall som returnerer data som deretter m&#229; lagres i state, mens man med GraphQL kan rendere data direkte uten at man m&#229; bruke h&#229;ndtere state.<\/p><p>Med REST gj&#248;r man typisk flere API-kall for &#229; hente den dataen man trenger, og REST vil da hente all dataen knyttet til kallene, mens man med GraphQL kan gj&#248;re &#34;queries&#34; for &#229; hente den akkurat den dataen fra databasen man &#248;nsker.<\/p><p>GraphQL bruker et endepunkt (/graphql), mens REST bruker mange endepunkter og kan ha&#160;en tendens til &#229; over- og underfetche. Overfetching vil si man f&#229;r mer data enn man trenger, mens underfetching betyr at man ikke f&#229;r all den &#248;nskede dataen og man vil m&#229;tte gj&#248;re flere kall.<\/p><p>I REST er endepunktet man kaller p&#229; id&#39;en til objektet, mens for GraphQL er id&#39;en til objektet og m&#229;ten man henter det separate.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11538606,"ext_inspera_userAssessmentSetupId":7139979,"ext_inspera_userAssessmentId":4841249,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:08Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Strømmen Mathias Beisswenger (10229)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34788949,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2093,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Mekanismer rundt tilstander er states. I klassekomponenter kan this.state brukes for &#229; bruke tilstanden.<\/p><p>&#160;<\/p><p>Dataflyt i React er typisk props. Disse blir sendt inn i en komponent og kan da brukes i denne komponenten. Dataflyt kan ogs&#229; v&#230;re context eller hooks. Eksempel p&#229; dette er useState(), som hvor man kan kalle og ender p&#229; staten i funksjonene i komponenten.&#160;<\/p><p>&#160;<\/p><p>Har man mange komponenter som bruker det samme tilstandene, kan det v&#230;re vanskelig &#229; holde styr p&#229; alle. Da kan man bruke eksterne bibliotek for &#229; lage globale tilstander, som alle kan hente states fra. Redux og Mobx er slike bibliotek, som lager globale tilstander(states).&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3496,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Litt f&#248;r jeg g&#229;r inn i dokumentasjonen:<\/p><p>&#160;<\/p><p>Recoil er veldig nytt, og dermed og ganske eksperiementelt. Det er st&#248;rre muligheter for bugs enn i et mer etablert og veltestet bibliotek. Det er ogs&#229; nytt for utviklere, som igjen betyr at de har lite erfaring med det. Dette betyr at det er vanskelig &#229; f&#229; hjelp p&#229; feks stackoverflow, og blant andre utviklere. I tillegg krever nok Recoil en ny versjon av React.&#160;<\/p><p>&#160;<\/p><p>S&#229; til dokumentasjonen:<\/p><p>&#160;<\/p><p>Recoil er et eksperimentelt state management system for React. I Recoil kan man lage en &#34;data-flow&#34; graf som &#34;flows&#34; fra atom og selectors ned til React komponenter. Kan sees litt p&#229; som globale states. Recoil bruker Atoms, som er enheter for states. I motsetning til vanlige state management system, s&#229; kan man &#34;abonnere&#34;&#160;p&#229;&#160;en state individuelt. Det betyr at n&#229;r en state blir oppdatert, er det kun komponentene som &#34;abonnerer&#34; p&#229; denne staten som re-rendere seg. Recoil har ogs&#229; Selectors, som er en ren funksjon som kan ta inn et &#34;Atom&#34; som input. N&#229;r Atomet oppdaterer seg s&#229; vil ogs&#229; funksjonen kj&#248;re p&#229; nytt.&#160;<\/p><p>&#160;<\/p><p>Dette er litt de samme funksjonene som Context og Redux/Mobx, og til dels Hooks har.&#160;<\/p><p>Ved &#229; bruke Recoil s&#229; vil man slippe &#229; bruke Context og redux/mobx for state management. I tillegg vil det gj&#248;re nettsiden mer smooth, da man kun oppdaterer komponentene som bruker de oppdaterte statesene. N&#229;r det kommer til ulemper s&#229; er det vanskelig fra dokumentasjonen &#229; finne noe spesifikt, s&#229; m&#229; da g&#229; tilbake til det jeg skrev i starten av oppgaven, med bugs og nytt bibliotek.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1596,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r man fetcher data vha. REST s&#229; kan dette f&#248;re til over- og under-fetching, som er &#229; hente for mye data, eller ikke nok, slik at man m&#229; calle p&#229; et nytt endpoint. Dette f&#248;rer til at man bruker mer b&#229;ndbredde enn &#248;nsket, enten ved &#229; fetche for mye data, eller ved &#229; sende flere HTTP requests enn n&#248;dvendig.&#160;<\/p><p>Dette er umulig i GraphQL.<\/p><p>&#160;<\/p><p>N&#229;r man kaller p&#229; et endpoint i REST, kaller man p&#229; det objektet sin identitet. Objektet sin identitet har ingenting &#229; si p&#229; hvordan man fetcher det i GraphQL. S&#229; for &#229; si det kort, REST definerer objektet (st&#248;rrelse og shape)&#160;i backend, GraphQL definerer det i Frontend, slik at serveren vet hva den trenger, og fetcher akkurat dette.&#160;<\/p><p>&#160;<\/p><p>REST bruker cachen-mekanismen&#160;som er default i alle wablesere, GraphQL ikke har dette. Dette gj&#248;r at REST henter data raskere dersom dataen ligger i cachen.&#160;<\/p><p>&#160;<\/p><p>Error handling i REST er lettere &#229; bruke sammenlignet med GraphQL.&#160;<\/p><p>&#160;<\/p><p>GraphQL kan kun bruke JSON, mens REST st&#248;tter flere forskjellige data format. Ikke en vesentlig forskjell, men greit &#229; vite.&#160;<\/p><p>&#160;<\/p><p>GraphQL er en tettere kobling mellom tjener og klient, som kan v&#230;re en fordel, da dette gjer at det er mulig &#229; enklere f&#229; til validering.&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11540117,"ext_inspera_userAssessmentSetupId":7140096,"ext_inspera_userAssessmentId":4841238,"dateLastModified":"2020-12-01T10:01:29Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:29Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Wilson Andreas Wågø (10149)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":58138054,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1955,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React sin innebygde mekanisme for h&#229;ndtering av state og dataflyt kan i hovedsak gj&#248;res p&#229; to m&#229;te:.<\/p><p>&#160;<\/p><p>Den ene m&#229;ten er &#229; sende &#34;props&#34; nedover i komponenthierkiet. Props er data som sendes inn til en komponent n&#229;r den opprettes. State refererer til komponentenes tilstandsdata som kan endres i kj&#248;retid- Ved &#229;&#160;sende ved call-back funksjoner kan barn endre staten til foreldre. N&#229;r en state blir endret s&#229; re-rendrer react automatisk dataen som har blitt endret.&#160;Den m&#229;ten vi h&#229;ndterte&#160;denne typen state p&#229; i dette faget var &#229; bruke React Hooks og React.usestate, React.useEffect&#160;<\/p><p>Men kan ogs&#229; bare h&#229;ndtere state lokalt i en komponente, f.eks. ved h&#229;ndering av en s&#248;keinput fra brukeren. Det fungerer p&#229; samme m&#229;ten som ovenfor, men da sender man ikke props videre til andre komponentner.<\/p><p>&#160;<\/p><p>Den andre hovedm&#229;ten &#229; h&#229;ndtere state p&#229; med reacts innebygde mekaniske er &#229; bruke &#34;global state managment&#34; ved &#229; anvende reacts context api. Da lagres alle dataen p&#229; ett sted og ber&#248;rte komponenter blir oppdatert n&#229;r data endres. Context er i hovedsak tiltenkt ved bruk av &#34;low frequency unlikely updates&#34;&#160; s&#229; det finnes derfor en flere tredjepartsbiblioteker som er utviklet for &#229; bruke ved &#34;high frequency updates&#34;.<\/p><p>&#160;<\/p><p>En tredje m&#229;te &#229; h&#229;ndere&#160;tilstand p&#229; er &#229; benytte seg av tredjepartsbiblioteker slik som f.eks. Redux eller Mobx. Disse fungerer etter samme hovedprinsipp som react context hvor man lagrer all dataen p&#229; en plass og oppdaterer komponentene som er ber&#248;rt etter som at dataen endrer seg. En fordel med disse bibliotekene er at der er bedre optimalisert slik at ikke hele komponenttreet m&#229; oppdateres n&#229;r en state endres.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://github.com/facebook/react/issues/14110#issuecomment-448074060<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3600,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managment library for react. Sammenlignbare l&#248;sninger p&#229; listen over l&#230;ringsm&#229;l er React Context, Redux og MobX.<\/p><p>&#160;<\/p><p>Recoil best&#229;r i hovedsak av to ting. Atoms og Selectors.&#160;<\/p><p>Atom representerer en del av en state og kan bli lest og skrevet av fra alle komponenter.&#160;<\/p><p>Komponenter som leser data fra et atom blir da implisitt subscribed til det atomet slik at en endring p&#229; atomet vil re-rendre alle komponentene som er subscribed.&#160;<\/p><p>&#160;<\/p><p>Selector er en &#34;pure function&#34; (i.e. en funksjon ikke har noe sideeffekt og som gir det samme resultatet hver gang for samme input). En selector kan ta imot atom eller andre selectors som input. Selectorene brukes til &#229; representere en bit av en &#34;derived state&#34;, ie. den kalkulerer hvilken state vi skal ha. Tanken er at man bruker atoms til &#229; lagre et minimalt set av states og resten kalkuleres som en funksjon av atomer (eller selectors). Dette har store likehetstrekk med dekoratoren @computed til mobx.<\/p><p>&#160;<\/p><p>Det at det kan leses og skrevet fra alle komponenter er likt som ved context, redux og mobx. M&#229;ten det er gjort p&#229; en forskjellig. I Context API s&#229; vil alle komponentene som er koblet opp mot en context oppdateres n&#229;r data i context ender. Dette vil f&#248;re til at mer enn n&#248;dvendig i komponenttreet vil m&#229;tte re-rendre n&#229;r man endrer p&#229; staten.<\/p><p>I mobx kan man oppdatere kun komponentene som trengs, og performancen til mobx er anset &#229; v&#230;re best. Men mobx kan v&#230;re vanskelig &#229; f&#229; til riktig da man m&#229; kjenne APIet godt.<\/p><p>Redux fungerer ogs&#229; slik at det kun er kompontene som er ber&#248;rt som oppdateres, s&#229; p&#229; dette punktet er redux og recoil like. Forskjellen ligger i hvordan komponentene er koblet sammen med staten.&#160;I&#160;recoil s&#229; subscriber en komponent direkte til atoms s&#229; recoil er asymptopisk kj&#248;retid O(1). I redux s&#229; m&#229; hver komponent som er koblet til storen sp&#248;rres om den m&#229; oppdateres, dvs O(n).<\/p><p>&#160;<\/p><p>B&#229;de Context, Redux, MobX og Recoil er like med at hele applikasonen m&#229; wrappes av en &#34;provider component&#34;-<\/p><p>&#160;<\/p><p>Boilerplatekoden for &#229; f&#229; recoil til &#229; kj&#248;re ser ut til &#229; v&#230;re veldig mye mindre enn f.eks. redux, noe som jeg anser som en stor fordel.<\/p><p>&#160;<\/p><p>Recoil ser ut til &#229; v&#230;re lettere &#229; bruke enn MobX, men ikke n&#248;dvendigvis like rask som mobx. Oppfatningen ser ut til &#229; v&#230;re at mobx er raskes, men at det er vanskelig &#229; bruke riktig p&#229; store prosjekter&#160;<\/p><p>En ulempe med recoil er den ikke st&#248;tter middleware.&#160;<\/p><p>En stor ulempe med recoil er fortsatt eksperimentell og API og funkjsonalitet kan endre seg. Det er ogs&#229; mindre utbredt en f.eks. redux noe som gj&#248;r at det kan v&#230;re vanskeligere &#229; finne eksempler og informasjon om hvordan en utfordring kan l&#248;ses.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kider:<\/p><p>recoiljs.org<\/p><p>https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p><p>https://github.com/facebookexperimental/Recoil/issues/236<\/p><p>https://www.youtube.com/watch?v=_ISAA_Jt9kI&#38;feature=youtu.be<\/p><p>https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>https://www.emgoto.com/redux-vs-recoil/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1091,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I Rest API s&#229; hentes det data fra URI og HTTP request. Det er forh&#229;ndsdefinert hvilken data du kan hente ut / skrive ved &#229; sende get/post/put/delete request til uri. F.eks. sender man en get request til&#160;/users/&#60;id&#62;/posts f&#229;r man typisk alle innlegene en bruker med &#60;id&#62; har skrevet.<\/p><p>En fordel med REST API er at det er bred st&#248;tte for caching-mekanismer. Utvikleren har ogs&#229; mer kontroll p&#229; hvilke data som kan returneres og hvordan.<\/p><p>Det er ogs&#229; enklere &#229; gj&#248;re API analyser p&#229; REST enn ved GraphQL.<\/p><p>En mulig ulempe med rest api er at det kan v&#230;re vanskelig &#229; kombinere data og man m&#229; ha flere kall for &#229; sette sammen dataen.<\/p><p>&#160;<\/p><p>GraphQL er basert p&#229; at man sender en sp&#248;rring til serveren og definerer b&#229;de s&#248;ket som skal brukes og dataen som skal returneres. Da f&#229;r man hvrken over- eller underfetching, men f&#229;r akkurat den dataen man trenger. I tillegg er det et typesystem som gj&#248;r det mulig &#229; validere koden. Ulemper med GraphQL er at det anses &#229; ha en brattere l&#230;ringskurve enn REST API. Det st&#248;tter kun JSON-data, og det er vanskeligere &#229; gj&#248;re API analyser enn det er ved REST. Utvilkeren gir ogs&#229; fra seg mer ansvar til klienten, noe som kan v&#230;re&#160;b&#229;de en ulempe og en fordel.<\/p><p>&#160;<\/p><p><br />Kilder:<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis#:~:text=The%20Core%20Difference%20Between%20REST,a%20single%20endpoint%20using%20HTTP.<\/p><p>Eksamen 2019<\/p><p>https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540129,"ext_inspera_userAssessmentSetupId":7140107,"ext_inspera_userAssessmentId":4841250,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Skjærseth Anne Høgdahl (10191)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303212,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2441,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dataflyt i react-applikasjoner:&#160;<\/p><p>I react kan man sende en tilstand nedover i komponenthierarkiet med&#160;props fra foreldre til barnekomponenter. Barnekomponentene kan bruke state til &#229; kommunisere med foreldrekomponentene for &#229; oppdatere tilstanden. For applikasjoner med mer omfattende state blir denne flyten vanskelig &#229; vedlikeholde. Staten vil havne i komponeneter det ikke er naturlig &#229; ha den, og mange callbacks. Derfor er det vanlig &#229; bruke andre teknikker for mer komplekse prosjekter, sli som redux, context og MobX.<\/p><p>&#160;<\/p><p>Redux:<\/p><p>Redux er en teknikk som gj&#248;r at det er enkelt for komponenter &#229; kommunisere p&#229; tvers av hierarkiet. Alle komponetene har tilgang p&#229; en tilstand uavhengig om den er lagret i en forelder- eller barnekomponent. Dette er ofte nyttig for st&#248;rre prosjekter der det inng&#229;r mange komponenter, da blir det veldig tungvint &#229; opprere med props og state ettersom tilstanden m&#229; sende via mange komponenter. For sm&#229; prosjekter kan det bli mye overfl&#248;dig kode siden det er mye setup kode som m&#229; implementeres med redux.<\/p><p>Med redux har man en uavhengig &#34;store&#34; man kan hente ut tilstanden fra.<\/p><p>Overodrnet er strukturen til redux slik:<\/p><p>Store - oppbevarer staten til appen.<\/p><p>Action - beskriver forandringene i staten til appen.<\/p><p>Reducer - gj&#248;r den faktiske tilstandsendringene utifra hvilken action som skal skje.<\/p><p>Litt mer detaljert:<\/p><p>En action creater er en funksjon som returnerer en spesifikk action. Det er action creater som blir kalt for &#229; gj&#248;r det mulig &#229; endre en tilstand, action creater returner den tilh&#248;rende action. N&#229;r man kaller p&#229; en action creater brukes&#160;dispatch. Da dispatcher man den tilh&#248;rende action som blir returnert. Dispatch sender action til reduceren som endrer tilstanden. Da blir det opprettet en ny state fra den angitte action.&#160;<br />Staten til hver action er lagret i storen. Alle komponentene i hierarkiet kan hente ut staten til alle actions som er lagret her.<\/p><p>&#160;<\/p><p>Context:<\/p><p>Dette er en teknikk som lar deg sende data gjennom komponenter i komponenthierarkiet uten &#229; m&#229;tte sende props manualt i hvert niv&#229;. Context er ikke designet for hyppig dataforandring, og det er vanskelig &#229; vedlikeholde i komplekse apper.<\/p><p>Context fungerer slik:<\/p><p>For hver unik del av dataen som skal v&#230;re tilgjengelig igjennom hirerarkiet&#160;m&#229; det bli opprettet en ny context. For eksempel en context for &#229; endre bakgrunnsfarge og en context for &#229; endre&#160;spr&#229;ket p&#229; siden. Hver context med ha en provider og en consumer.<\/p><p>Provider gj&#248;r at dataen blir tilgjengelig gjennom hele komponenttreet, eller kan &#34;erkl&#230;re&#34; dataen tilgjengelig. Consumer gj&#248;r at hvilken som helst komponent i hierarkiet som &#248;nsker dataen kan &#34;abbonere&#34; p&#229; den, alts&#229; f&#229; den tilgjengelig.&#160;<\/p><p>&#160;<\/p><p>MobX:<\/p><p>MobX er bedre for mindre prosjekter der redux blir overfl&#248;dig.<\/p><p>MobX brukere flere stores, der redux bare har &#233;n. MobX m&#229; ha minst to, en for UI state og en (eller flere) for domain state. MobX bruker observerbar data for &#229; automatisk &#34;spore&#34; endringer gjennom subscriptions. Denne automatiseringen gj&#248;r at mobX er enklere &#229; bruke enn redux. MobX tillater at staten kan overskrives og oppdateres med nye verdier. Det gj&#248;r det lett &#229; implementere, men vanskligere &#229; h&#229;ndtere og vedlikeholde koden ettersom tilstanden kan ha uforutsettt ouput.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3407,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Hva er Recoil:<\/p><p>Det er et state management biliotek. Det tillater dataflyt fra delt tilstand til rene funksjoner ned igjennom React-komponttreet. Det gj&#248;res ved &#229; definere en ortogonal rettet graf p&#229; det eksisterende hierarkiet. Man kan se for seg at man gj&#248;r treet tredimensjonalt. I denne tredje dimensjonen er det en komponent, et atom,&#160;som tilh&#248;rer hver av barnkomponentene som skal&#160;endre state, som re-rendres n&#229;r staten endrer seg. Disse atomene s&#248;rger for at endringen bare skjer for de tilh&#248;rende barnekomponentene. Man kan ogs&#229; bruke en selector til &#229; knytte&#160;flere komponenter til samme atom, og endre staten til alle disse.<\/p><p>&#160;<\/p><p>Tilsvarende l&#248;sninger fra l&#230;ringsm&#229;l:<\/p><p>- Redux<\/p><p>- MobX<\/p><p>- Context<\/p><p>Dersom man har en state som skal deles i to barnekomponenter som er langt fra hverandre kan det v&#230;re problematisk &#229; skyve det opp til foreldrekomponenten, noe som context krever, dersom det er mye informajson i foreldrekomponentene. Det vil ta veldig lang tid &#229; rerendre denne komponenten.&#160;<\/p><p>Dersom dette skulle l&#248;st med context hadde det v&#230;rt en provider i forelderkomponenten og en consumer i hver av barnekomponentene. Men dersom dette gjelder for x states i barnekomponentene, m&#229;tte man hatt x proveders i forelderkomponenten. Problemet er dersom man ikke vet hvor mange x tilsvarer, da er det ikke mulig &#229; bruke context lenger.<\/p><p>&#160;<\/p><p>I likhet med redux, mobX og contect lar recoil deg ha et sted &#229; lagre&#160;staten til dataen som skal deles, og re-render bare de essensielle komponentene. Slik som mobX og redux sin store er atomene uavhengige komponenter som staten er lagret i. Istdenfor &#229; m&#229;tte h&#229;ndtere hele &#34;boilerplaten&#34; med action, reducers og store som i redux gir recoil deg bare et sted &#229; oppbevare den delte tilstanden som trengs, atomene. Itillegg til hooks som binder komponentene til den staten.&#160;<\/p><p>Selectoren til recoil kan sammenlignes med decorator i mobX. Dette gj&#248;r at den avledet staten kan bli synkronisert eller asynkronsiert slik som mobX. Recoil tar bare utgangspunkt i det osm trengs &#229; deles slik som mobX, uten all ekstra &#34;arkitektur&#34;. Ulempen med dette er at recoil, som mobX, blir vanskligere &#229; debugge sammenlignet med redux.<\/p><p>&#160;<\/p><p>Fordeler og ulemper med Recoil:<\/p><p>Fordeler:<\/p><p>- kan endre&#160;et ubestemet antall verdisett<\/p><p>- deler state p&#229;tvers av et komponenttre<\/p><p>- re-rendrer bare de komponentene som endrer state<\/p><p>- Mindre overfl&#248;dig kode sammenlignet med redux.<\/p><p>Ulemper:<\/p><p>- En tydlig ulempe er at dette er et veldig nytt biblitok som ikke er brukt mye eller ferdigutviklet. Det gj&#248;r at det kan v&#230;re d&#229;rligere testet og mangel p&#229; dokumentasjon.<\/p><p>- Man m&#229; implementere mye av koden selv, sammenlignet med mobx og redux som er veletablerte teknikker, selvom recoil er mer primitive &#229; implementere.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1307,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Arkitektur vs sp&#248;rrespr&#229;k:<\/p><p>Rest er en&#160;overordnet arkitektur for web-basert klienter. Det er en stateless kommunikasjons kanal som tilrettelegger for browseren sin caching. Caching vil si at det er mulig &#229; lagre kopier av dataen flere steder langs &#34;responsstien&#34;. Dette er viktig for effektivitet og sikkerhet. Stateless vil si at serveren ikke trenger &#229; vite noe om klienten sin forrige tilstand.<\/p><p>GraphQL derimot er et sp&#248;rrespr&#229;k med en runtime. Sp&#248;rrespr&#229;ket vil si at man spesifiserer i json hvilken data som skal hentes ut. Der REST st&#248;ttere mange typer data, st&#248;tter graph bare json. Graph har dermed ikke implisitt caching.<\/p><p>&#160;<\/p><p>Endepunkter:<\/p><p>Det som blir trukket frem som den st&#248;rste forskjellen mellom disse er endepunktene. GraphQL har bare ett endepunkt (POST), imens REST kan ha mange (GET, POST, PUT, DELETE). Graph trenger bare ett endepunkt ettersom man spesifiserer i query&#39;en hva som skal bli hentet ut fra endepunktet. Dette f&#248;rer til minre kode som er mer presis. For REST kan man ha mange forskjellige endepunketer avhengig av hvilken data man &#248;nsker.&#160;Her m&#229; klientene lage en request til serveren for &#229; hente ut, eller endre, p&#229; dataen p&#229; serversiden. Ulempen med dette er at det kan f&#248;re til mye overfetching, som vil si at man f&#229;r mye mer data enn man trenger.<\/p><p>&#160;<\/p><p>Utviklersyn:<\/p><p>REST API er eldre s&#229; flere utviklere er mer vant til &#229; bruke dette, noe som kan f&#248;re til bedre dokumentasjon. Det er ogs&#229; et API som er enklere &#229; bygge en Graph. Til tross for dette er det mange gode tredjepartskomponenter som st&#248;tter graph, og gj&#248;r det enekelt &#229; bygge med bruk av disse.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11542028,"ext_inspera_userAssessmentSetupId":7139963,"ext_inspera_userAssessmentId":4841156,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:39Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Langaard Sindre (10201)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":47067553,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2896,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For &#229; h&#229;ndterere tilstand&#160;i React-applikasjoner finnes det en rekke forskjelle mekanismer og teknikker.<\/p><ul>\t<li>I klassiske React klasser er det vanlig &#229; bruke&#160;<em>this.state<\/em>&#160;i konstrukt&#248;ren til komponenten. Der kan man initialisere de forskjellige verdiene til state og holde&#160;oversikt. Verdiene i <em>state<\/em> objektet&#160;kan brukes lokalt i komponenten eller sendes videre ned i komponenttreet. Dette kan fort komme ut av kontroll og gj&#248;re det vanskelig &#229; holde oversikt, men fungerer godt lokalt i komponenten og ved mindre applikasjoner.<br />\t&#160;<\/li>\t<li>I funksjonelle komponenter brukes&#160;<em>state hook<\/em>. Den brukes til &#229; deklarere en state-variabel som gis en initiell&#160;verdi. Dette er i motsetning til this.state ikke et objekt, s&#229; state variabelen kan gis f.eks. en int-verdi hvis det er alt som trengs. Som&#160;<em>this.state <\/em>fungerer&#160;ogs&#229; state hooks godt lokalt, men kan fort bli vanskelig &#229; holde oversikt ved store applikasjoner.<br />\t&#160;<\/li>\t<li>For &#229; holde p&#229; global state kan man bruke&#160;<em>context-hooken.<\/em>&#160;Den eksporteres og kan brukes av resten av applikasjonen hvis det trengs.<br />\t&#160;<\/li>\t<li>For &#229; gj&#248;re det lettere &#229; holde kontroll p&#229; global state i store applikasjoner kan man ta i bruk et bibliotek som f.eks. Redux eller Mobx.&#160;F.eks. i Redux holdes kontroll p&#229; state som brukes mellom mange komponenter i en separat sentralisert&#160;<em>store.<\/em>&#160;Staten som lagres her kan updateres og endres gjennom&#160;<em>actions<\/em>. Dette er veldig effetkiv for &#229; holde kontroll p&#229; state gjennom st&#248;rres applikasjoner. Det finnes mange forskjellige tredjeparts-biblioteker for &#229; hjelpe til med dette.<\/li><\/ul><p>&#160;<\/p><p>For &#229; h&#229;ndtere dataflyt i React-applikasjoner kan man bruke:<\/p><ul>\t<li>En vanlig m&#229;te &#229; h&#229;ndtere dataflyten mellom komponenter i React-applikasjoner er&#160;<em>props<\/em>. Dette er verdier man gir til under-komponenter som de kun kan lese - de er immutable. Props blir sendt til komponenter som argumenter.<br />\t&#160;<\/li>\t<li>En annen m&#229;te for &#229; kontrollere&#160;dataflyten i React er bruken av interfacer. De brukes til &#229; bestemme hvilke props med hvilke typer som m&#229; v&#230;re en del av propsene som blir sendt. Dette er veldig nyttig hvis f.eks. komponenten er avhengig av propsen som sendes ned og krasjer hvis den ikke har det.<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2056,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som brukes for &#229; h&#229;ndtere state. Det baserer seg p&#229; det de kaller <em>atoms<\/em>&#160;som er &#34;units of state&#34;. Disse <em>atomene<\/em>&#160;er <em>updateable and subscribable<\/em>&#160;som vil si at det er mulig &#229; oppdatere dem, men ogs&#229; &#229; koble seg til/abonnere&#160;til dem. Det vil si at hvis en komponent har abonnert til et atom og staten i atomet oppdateres vil ogs&#229; staten i komponenten oppdateres. De har ogs&#229; konseptet&#160;<em>selectors<\/em>&#160;som handler om &#229; modifisere state ved hjelp av en funksjon.<\/p><p>&#160;<\/p><p>Konseptet med&#160;<em>atoms<\/em>&#160;kan minne mye om hvordan Mobx&#160;fungerer. Der er ogs&#229; konseptet om at state skal v&#230;re&#160;<em>observable<\/em>&#160;en viktig del. Der finnes det&#160;<em>observable state<\/em>&#160;og&#160;<em>observers<\/em>&#160;som enten er state som kan &#34;lyttes&#34; til eller er komponenter som &#34;lytter&#34; til state. Dette blir det samme som at&#160;<em>atoms<\/em>&#160;i Recoil er&#160;<em>subscribable&#160;<\/em>og at komponenter kan&#160;<em>&#34;lytte&#34;&#160;<\/em>til den staten. En av fordelene med dette er at komponenter som &#34;lytter&#34; etter endring av state oppdateres automatisk. I motsetning til et bibliotek som Redux hvor man eksplisitt p&#229; hente staten som er endret vil det g&#229; automatisk i Recoil.<\/p><p>&#160;<\/p><p>En mulig ulempe ved &#229; bruke Recoil under utvikling er at det er relativt nytt. Det er derfor ikke like godt testet og utviklet som andre biblioteker som er brukt i lang tid.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2156,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST API er et design at web-api som&#160;baserer seg p&#229; HTTP foresp&#248;rsler med spesifikke URI-er for forskjellige ressurser. En spesifikk URI til en ressurs kalles et endpoint og du vet at <em>endpoint x<\/em> alltid gir <em>data x<\/em>. REST er har operasjoner som GET, POST, etc og disse brukes til &#229; overf&#248;re tilstand p&#229; ressurser.<\/p><p>&#160;<\/p><p>P&#229; den andre siden har man Grapql. Grapql handler mer om queries og tilpassede sp&#248;ringer om data. Her kan du sp&#248;rre om den dataen du trenger og ikke fulle datasett. Da kan man unng&#229; det som&#160;kalles <em>overfetchig<\/em>, hvor man sp&#248;r etter mye mer data enn det man egentlig trenger. Man kan ogs&#229; unng&#229; det som kalles <em>underfetching<\/em>, hvor man m&#229; gjennomf&#248;re flere mindre sp&#248;rringer for &#229; f&#229; ut all den dataen man vil ha. Dette fungere siden sp&#248;rringene man sender i Graphql er spesifikke og inneholder de verdiene man vil ha. Dette blir hentet gjennom Graphql som er bygget opp som en graf hvor man starter i rot-noden og beveger seg gjennom grafen for &#229; finne de ressursene man trenger. I motsetning vil REST ha x-antall endepunkter som m&#229; brukes for &#229; hente ressursene.<\/p><p>&#160;<\/p><p>Noen andre aspekter &#229; sammenligne er at&#160;REST er en web standard med h&#248;y oppslutning og som har v&#230;rt brukt i lang tid. Graphql derimot er nyere og ikke like utbredt.&#160;REST&#160;er ogs&#229; tilstandsl&#248;s som vil si at tjeneren ikke husker noe om tidligere foresp&#248;rsler som klienten har kommet med.&#160;Graphql har derimot en kolbing mellom klienten og tjeneren.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11542433,"ext_inspera_userAssessmentSetupId":7140132,"ext_inspera_userAssessmentId":4841449,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:01:00Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Dovland Eivind Syrdalen (10187)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34430267,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2057,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For React-applikasjoner brukes flere ulike mekanismer og teknikker for tilstand og dataflyt.&#160;<\/p><p>&#160;<\/p><p>De mest sentrale mekanismene i en hver React-applikasjon er state og props.<\/p><p>&#160;<\/p><p>Hovedoppgaven til state er &#229; holde dynamiske verdier som tilh&#248;rer komponenten, og n&#229;r disse endres/settes s&#229; vil komponenten re-renderes (oppdateres). Denne staten lagres lokalt i hver komponent, og vil derfor ogs&#229; bare p&#229;virke den enkelte komponenten n&#229;r den oppdateres. (lokal state) For lokal state er det vanligst &#229; bruke Hooks-mekanismen som kom med React 16.8, da dette gj&#248;r det mye enklere &#229; skrive/lese og oppdatere state. Lokal&#160;state&#160;har ogs&#229; asynkron oppf&#248;rsel.&#160;<\/p><p>&#160;<\/p><p>Props (properties) i React-applikasjoner er argumenter som sendes med komponenter, og brukes for &#229; sende informasjon mellom&#160;komponenter i React-applikasjoner. Props er immutable, som vil si at den ikke kan endres, og sendes fra foreldre (parent-components) til barne-komponenter (komponenter som arver fra en forelder). Props sendes ogs&#229; kun 1 retning, alts&#229; fra &#34;foreldre&#34; til &#34;barn&#34;-komponenter (nedover i komponenthierarkiet).&#160;&#160;<\/p><p>&#160;<\/p><p>Typisk i st&#248;rre React-applikasjoner, der det er mange komponenter og behov for at mange komponenter (som gjerne er plassert ulike steder i komponenthierarkiet) skal aksessere samme state, kan det v&#230;re gunstig &#229; ta i bruk en mekanisme for global state. Dette for &#229; slippe &#229; sende informasjonen gjennom un&#248;dvendig mange ledd, noe som medf&#248;rer mye ekstra kode/funksjonalitet.&#160;<\/p><p>Redux, MobX og Context API er eksempler p&#229; slike globale statel&#248;sninger.&#160;<\/p><p>&#160;<\/p><p>Redux er en popul&#230;r l&#248;sning for global state. Redux bruker en &#34;single source of truth&#34;, alts&#229; at den globale staten blir lagret ett sted, i en store. Store er &#34;read-only&#34;, og aksesseres vha en Provider som wrappes rundt komponenter som skal bruke den globale staten, og denne Provideren m&#229; ta inn store. For &#229; aksessere staten, kan en enkel hook som &#34;useSelector&#34; eller &#34;MapStateToProps&#34; brukes. Redux har en del &#34;boilerplate&#34;-kode som m&#229; settes opp, og er ikke det letteste &#229; sette seg inn i. Det er allikevel veldig popul&#230;rt &#229; bruke sammen med React.&#160;<\/p><p>&#160;<\/p><p>MobX er er alternativ til Redux, og gj&#248;r state management enkelt. I fohold til Redux er det mindre &#34;boilerplate&#34;, og enklere &#229; sette seg inn i. MobX gj&#248;r datastrukturer observerbare, og de komponentene som aksesserer den globale staten vil dermed v&#230;re ovservat&#248;rer. P&#229; denne m&#229;ten vil kun disse observat&#248;rene &#34;varsles&#34; n&#229;r staten endres.&#160;<\/p><p>&#160;<\/p><p>For enkle og mindre komplekse React applikasjoner kan Reacts innebygde Context API v&#230;re en fin l&#248;sning for &#229; bruke global state. Den er innbygd i React, og krever dermed ingen ekstra tillegg. Hovedform&#229;let er &#229; kunne sende date gjennom komponenttreet uten &#229; m&#229;tte sende props gjennom hver enkelt komponent. I forhold til Redux re-renderer Context p&#229; hver update av staten, og re-renderer alle komponenter uansett. Redux og MobX vil kun re-rendere de ber&#248;rte komponentene, og dermed vil disse v&#230;re bedre l&#248;sninger for store applikasjoner.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3262,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er er &#34;state managment library&#34; for React-applikasjoner.<\/p><p>Recoil best&#229;r i hovedsak av to ting: &#34;Atoms&#34; og &#34;selectors&#34;:<\/p><p>&#160;<\/p><p>&#34;Atoms&#34; er enheter av state, de kan oppdateres og &#34;subscribes&#34;. N&#229;r et atom oppdateres, s&#229; vil hver komponent som &#34;abonnerer&#34; p&#229; denne f&#229; beskjed og oppdateres (re-renderes). Atomer kan brukes i stedet for lokal state ogs&#229;, og hvis den samme staten brukes lokalt i flere komponenter, s&#229; vil alle disse dele den samme staten.&#160;<\/p><p>&#160;<\/p><p>En &#34;selector&#34; er en funksjon som aksepterer atomer eller andre selectorer som input. N&#229;r inputen oppdateres, vil funksjonen kj&#248;re p&#229; nytt med den nye verdien til atom/selector. Komponenter lytter til selectorer slik som til atomer, og vil ogs&#229; oppdateres (re-renderes) n&#229;r selektoren endres.&#160;<\/p><p>&#160;<\/p><p>B&#229;de Recoil, Redux, MobX og Context er l&#248;sninger for global state, men de l&#248;ser det alle p&#229; noe ulike m&#229;ter. Hovedform&#229;let er allikevel &#229; lage enkle l&#248;sninger for &#229; aksessere state globalt.&#160;<\/p><p>&#160;<\/p><p>Sammenliknet med Redux og MobX kan Recoil og Context i st&#248;rre grad sies &#229; likne p&#229; React i forhold til hvordan man skriver det. Disse&#160;er utviklet av Facebook for &#229; brukes med React, og vil derfor v&#230;re designet for &#229; fungere godt med React. Redux og MobX derimot er uavhengige av React, og har derfor mye egen terminologi og prinsipper. Recoil vil for eksempel likne mye mer p&#229; en global versjon av Reacts useState, og vil dermed v&#230;re enklere &#229; l&#230;re seg dersom man kan React fra f&#248;r.&#160;<\/p><p>Recoil er ogs&#229; i st&#248;rre grad enklere enn Redux og Mobx, spesielt i form av at det er mindre &#34;boilerplate&#34; som kreves, og enkelt &#229; sette opp.&#160;<\/p><p>&#160;<\/p><p>Redux og MobX bruker &#34;stores&#34; for &#229; lagre den globale staten, mens Recoil bruker ikke store i det hele tatt. I Redux oppretter man den globale staten i reducers, mens i Recoil brukes atoms for &#229; lage separate deler av state. For &#229; endre staten brukes i Redux actions som definerer handlingen som skal gj&#248;res for &#229; oppdatere staten, mens i Recoil brukes selectors for &#229; endre den globale staten. B&#229;de Redux og Recoil kan aksessere staten enkelt i hver komponent ved bruk av hooks (hhv. useSelector og useRecoilValue).&#160;<\/p><p>&#160;<\/p><p>For b&#229;de Recoil, Redux, Context og MobX brukes wrapping av komponenter for &#229; definere hvilke komponenter som skal ha tilgang til den globale staten.&#160;<\/p><p>&#160;<\/p><p>En&#160;fordel med Recoil ift de andre mekanismene&#160;er at det er nytt, og dermed helt kompatibelt og tilpasset bruken av Hooks. Redux, MobX og ContextAPI var laget tidligere enn Hooks, og kan dermed ikke sies &#229; ha fullstendig matchet hverandre enda.&#160;<\/p><p>&#160;<\/p><p>MobX og Recoil har visse likheter n&#229;r det kommer til hvordan de bruker global state, og kan sies &#229; l&#248;se et problem ikke Redux og Context l&#248;ser like bra. Ved &#229; bruke en &#34;observable&#34; mekanisme, der de aktuelle komponentene lytter til den &#34;observerte&#34; staten, komponentene som holder den globale staten effektivt varsles n&#229;r staten endres, og kun disse vil re-renderes.&#160;<\/p><p>&#160;<\/p><p>Det er flere fordeler med &#229; bruke Recoil:<\/p><p>Det er enkelt &#229; l&#230;re seg, og er laget for &#229; passe perfekt med React. Det kreves alts&#229; mye mindre &#229; l&#230;re seg Recoil enn feks Redux, gitt at du allerede kan React.&#160;<\/p><p>Effektiv re-rendering ved at kun konponenter som &#34;lytter&#34; til de vil re-renderes. Slipper dermed &#229; oppdatere hele siden ved endring i en liten del.&#160;<\/p><p>Selectoren tilbyr et veldig effektivt API som blant annet h&#229;ndterer asynkron&#160;data, slik at dette ikke p&#229;virker komponentene som bruker staten<\/p><p>&#160;<\/p><p>Ulemper:&#160;<\/p><p>Det er relativt nytt, og veldig lite brukt. Dermed er det lite dokumentasjon ute, og i forhold til mer etablerte state mekanismer er det brukt lite i praksis. Det er derfor vanskelig &#229; vite hvor godt det egentlig fungerer p&#229; ulike prosjektst&#248;rrelser osv.&#160;&#160;<\/p><p>&#160;<\/p><p>kilder:&#160;<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/&#160;<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>https://blog.logrocket.com/simple-state-management-react-recoil/<\/p><p>https://recoiljs.org<\/p><p>https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1809,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er to ulike API. APIet har et sett med ulike regler som gj&#248;r det mulig &#229; kj&#248;re deler av en programvare fra en annen programvare.&#160;<\/p><p>&#160;<\/p><p>REST (Representational state transfer) er en m&#229;te &#229; bruke APIer p&#229;, og kan brukes over stort sett de fleste protokoller. Tar i hovedsak bruk av HTTP-protokoller for &#229; bruke og aksessere data fra API.&#160;<\/p><p>&#160;<\/p><p>GraphQL er et type sp&#248;rrespr&#229;k for et API, som sender spesifikke sp&#248;rringer til en server. Her defineres b&#229;de s&#248;ket, og hva som skal returneres. Sentralt i GraphQL-setup er skjema som definerer hva som skal hentes, og typedeklarering. Dette skjemaet legger grunnlaget for hva som er gyldige sp&#248;rringer.&#160;<\/p><p>&#160;<\/p><p>Det er flere vesentlige forskjeller mellom REST API og Graphql:<\/p><p>&#160;<\/p><p>REST API bruker et endepunkt for hver oppgave, mens GraphQL kun bruker ett endepunkt for alt. For eksempel vil du ved bruk av REST ha 2 endepunkter hvis du skal ha informasjon om to ulike objekter. Dette gj&#248;r dataen enkel&#160;og lett &#229; forst&#229;/bruke, men du vil allikevel alltid f&#229; returnert et komplett datasett. Derfor vil du ofte &#34;fetche&#34; mer enn n&#248;dvendig data (overfetching). GraphQL bruker sp&#248;rrespr&#229;ket til &#229; requeste akkurat det som beh&#248;ves, og vil dermed ikke f&#229; mer enn n&#248;dvendig data. Dette m&#229; derfor defineres p&#229; forh&#229;nd. GraphQL kan dermed v&#230;re veldig kraftfullt om det brukes riktig, og man kan spare mye un&#248;dvendig prosessering.&#160;<\/p><p>&#160;<\/p><p>GraphQL har ogs&#229; et typesystem, som gj&#248;r det mulig &#229; validere at dataen som requestes har &#248;nsket type. P&#229; denne m&#229;ten vil korrekte datatyper returneres, i forhold til slik man har definert de p&#229; forh&#229;nd. Et slikt system har man ikke i REST API.&#160;<\/p><p>&#160;<\/p><p>REST API er veldig utbredt, har av mange blitt regnet som &#34;best practice&#34;, noe som f&#248;rer til mer dokumentasjon. Det kreves ogs&#229; mindre oppsett, og kan sies &#229; v&#230;re enklere &#229; sette seg inn i/forst&#229;. Det er mer oppstartskostnad ved bruk av GraphQL, men man vil ogs&#229; f&#229; mer spesifikke resultatsett med bedre typing, og GraphQL vil derfor i mange tilfeller v&#230;re mer effektiv enn REST.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11542601,"ext_inspera_userAssessmentSetupId":7139984,"ext_inspera_userAssessmentId":4841148,"dateLastModified":"2020-12-01T10:01:23Z","ext_inspera_startTime":"2020-12-01T08:01:13Z","ext_inspera_endTime":"2020-12-01T10:01:23Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Schøien Eirik (10084)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34389883,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3537,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>State<\/strong><\/p><p>React-komponenter med ikke-konstant&#160;data og innhold benytter gjerne&#160;state. Ved &#229; oppdatere en komponents state vil React automatisk oppdatere den i applikasjonen slik at endringen vises. I class-komponenter gj&#248;res dette i konstrukt&#248;ren.<\/p><p>&#160;<\/p><p><strong>Props<\/strong><\/p><p>N&#229;r man oppretter en instans av en komponent gir man ofte noen argumenter i kallet, f.eks. konstante eller&#160;basert p&#229; variabler i parent-komponentens egen state. Dette&#160;kalles i React for props (properties). Dette er egentlig bare input, og er en av de vanligste teknikkene for dataflyt i React. Komponenten f&#229;r da tilgang til et props-objekt (evt. this), med felter for de ulike verdiene man har har gitt. Disse kan kun leses, og benyttes n&#229;r komponenten opprettes. Props brukes ofte som startverdier for en komponents state. Selv om en komponent&#160;tar inn props som den benytter seg av, trenger den ikke ha noen intern state, og v&#230;re s&#229;kalt stateless. Dette egner seg for konstante komponenter, som ikke endres i kj&#248;retid.<\/p><p>&#160;<\/p><p><strong>Hooks<\/strong><\/p><p>Det finnes ogs&#229; hooks som useState, som enkelt lar en benytte seg av og oppdatere state. En variabel deklareres med useState-hooken, som gir ogs&#229; gir tilgang p&#229; setState funksjonen.<\/p><p>&#160;<\/p><p><strong>Global State Management<\/strong><\/p><p>I st&#248;rre prosjekter kan det bli uoversiktlig &#229; holde styr p&#229; all state, av m&#248;nsteret der state &#34;dyttes&#34; hierarkisk fra parent-komponenter helt ut til komponenten som benytter seg av det.&#160;Her kan man&#160;ta i bruk global state management, som ContextAPI, Redux og Mobx. Context er en enkel provider der man kan holde styr p&#229; &#233;n variabel, der alle child-komponenter f&#229;r tilgang til denne. I en Redux-l&#248;sning lagrer man state samlet&#160;i en store, med actions og reducers for &#229; benytte seg av og oppdatere. Merk at dette egner seg for state som brukes nettopp globalt i hele&#160;eller flere steder i applikasjonen. Lokal state spesifikk for en enkelt komponent b&#248;r fortsatt bevares i komponenten.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1688,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management. Det baserer seg p&#229; atoms og selectors, der state lagres som atoms og komponenter gjennom selectors kan f&#229; tilgang til slike atoms. Andre l&#248;sninger for state management blant l&#230;ringsm&#229;lene er (Context,)&#160;Redux og Mobx.&#160;<\/p><p>&#160;<\/p><p>Recoil ser ut til &#229; ha fordeler som at man f&#229;r et sofistikert m&#248;nster for&#160;state management som ligner Redux (actions og reducers - subscriptions og functions), samtidig som det er mer lightweight, alts&#229; enklere i bruk og oppsett. Det har ogs&#229; st&#248;tte under development, som integrert snapshottesting.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1836,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er en tradisjonell l&#248;sning for foresp&#248;rsler mot en backend og database. GraphQL er en ny og mer moderne l&#248;sning, der en av drivkreftene er &#229; l&#248;se problemer man opplever med nettopp REST API.<\/p><p>&#160;<\/p><p>GraphQL gir et web-api som bedre egner seg for sp&#248;rringer mot en database. Klienten definerer&#160;selv skjemaet, hvilken og hvordan&#160;dataen skal representeres. Dette l&#248;ser overfetching, der man med REST ofte vil hente for mye data. Med GraphQL f&#229;r&#160;ogs&#229; klienten all informasjon den vil ha i ett kall, der man med REST kan m&#229;tte bruke&#160;flere, som l&#248;ser s&#229;kalt underfetching.<\/p><p>&#160;<\/p><p>Rest API benytter seg derimot av HTTP-caching i nettleseren. Dette gir h&#248;yere performance (lavere lastetid)&#160;for foresp&#248;rsler klienten har gjort f&#248;r. GraphQL st&#248;tter ikke slik caching, samme sp&#248;rring m&#229; gjennomf&#248;res hver gang.<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11542507,"ext_inspera_userAssessmentSetupId":7139911,"ext_inspera_userAssessmentId":4841349,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:01:06Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Albizreh Huda Mohamad Muataz (10066)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34488387,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2188,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes mange mekanismer for tilstand&#160;og dataflyt i React. Vanligvis er det s&#229;nn at data sendes fra foreldre til barn gjennom <strong>props<\/strong>(properties) (dette kan forklares som <strong>enveis<\/strong> dataflyt).<\/p><p>&#60;Component props={someProps}&#62; Her er somePropse de verdiene jeg &#248;nsker &#229; sende til Componenten mens jeg st&#229;r i foreldre komponenten.<\/p><p>Props i komponenten kan ikke endres. Bare state i selve komponenten kan endres.<\/p><p>Hvis man trenger &#229; bruke samme variabler for tilstand(state) fra forskjellige komponenter og kan ikke bare&#160;sende dem direkte fra foreldre til barn, kan man bruke <strong>Context API<\/strong> i dette tilfellet, hvor man kan lage context som for eksampel: React.createContext(initialState), og bruke denne context med sine variabler i forskjellige komponenter ved &#229; bruke useContext(navnet_p&#229;_context)<\/p><p>&#160;<\/p><p>Det finnes ogs&#229; andre mekanismer som Redux og Mobx for state managment. De lager en hoved store og settes for eksampel som wrapper til applikasjonen. Deretter kan de&#160;oppn&#229;s hvor som helst i applikasjonen.&#160;<\/p><p><strong>Redux<\/strong> er&#160;enveis dataflyt med bare en store&#160;som trenger Reducers der kan man endre tilstandene, og Actions der kan man definere aksjonene som skal kalles ved kalling av noen endring. Hver gang man oppdaterer tilstanden kj&#248;res det rerender p&#229; hele komponenten. Denne kan brukes i store applikasjonen hvor man trenger &#229; kalle spesifikt en reducer og f&#229; kontroll over dataflyten. og tilstandene kan ikke endres utenfor reducers.<\/p><p>&#160;<\/p><p><strong>MobX<\/strong> er ganske enklere enn Redux siden den ikke trenger mye koding. Den er ogs&#229; enveis dataflyt og&#160;trenger bare Actions der kan ogs&#229; tilstandene endres. den bruker flere stores(UI state og en eller flere&#160;domain state). N&#229;r en tilstand blir endret s&#229; kaller mobux flere un&#248;dvendige funksjoner. Derfor er det bedre &#229; bruke Mobux i sm&#229; applikasjoner der man skal oppdatere&#160;komponenten etter endringen av tilstand. Det er mulig &#229; lese &#229; skrive p&#229; tilstandene i Mobux.<\/p><p>&#160;<\/p><p>React hooks har gjort det enkelt &#229; bruke React states og funksjonalitet uten &#229; trenge &#229; lage en klass komponent. For eksampel &#229; bruke useState() i funksjon komponent er det samme som this.state i klasse komponent. For &#229; endre tilstand i en komponent skal man kalle setState() funksjonen i b&#229;de klass og funksjon komponenter.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2628,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er state management mekanism som hjelper med &#229; l&#248;se&#160;problemer som kommer ved store prosjekter. Den gir mer fleksibilitet for &#229; re-render en spesifik komponent uten rerender av hele applikasjonen eller komponenten og endre ting som man ikke &#248;nsker &#229; endre som(componentDidUpdate funksjon og andre funksjonene brukes ved rerendering).&#160;<\/p><p>Hoved ide med Recoil er at den bruker noe som heter Atoms som lagrer tilstand og selectors som har funksjoner til &#229; gj&#248;re noen opperasjoner p&#229; data. Recoil p&#229; en m&#229;te lager en &#34;tredjedimensjonsgarf&#34; som best&#229;r av selve applikasjonen og av Atoms og selectors(pure functions). Hver atom kan referere til en spesifikk tilstand, og n&#229;r vi oppdaterer denne tilstanden blir det re-render bare p&#229; denne, uten &#229; gj&#248;re rerender p&#229; hele treet i komponenten og miste noen verdier.<\/p><p>&#160;<\/p><p>I Redux for eksampel var det slik at alle komponentene kj&#248;res p&#229; nytt ved oppdatering av en tilstand som disse komponentene bruker. P&#229; denne m&#229;ten ble det s&#229;nn at UpdateProps, componentDidUpdate og disse funksjonene ble kalt p&#229; nytt. Og kanskje det f&#248;rer til endring av selve data som brukes i prosjektet. Derfor er Recoil bedre p&#229; slike tilfeller. Recoil trenger ogs&#229; ikke noe store.<\/p><p>&#160;<\/p><p>Context API trenger &#229; legge til providers for hver komponent til &#229; oppn&#229; og oppdatere tilstandene som er lagret i den. Mens Recoil peker direkte p&#229; et bestemt tilsatnd uten &#229; bruke noe wrapper eller provider for den.<\/p><p>&#160;<\/p><p>Det som er negativt&#160;i Recoil er at den gir mer kompleksitet i&#160;koden, spesielt hvis den er en liten applikasjon. Fordi man trenger &#229; lage Atoms og&#160;Selectors i tillegg til selve komponeter. Som sagt, l&#248;ser Recoil problemer i store applikasjoner, men det er ikke n&#248;dvendig &#229; bruke den i sm&#229; applikasjoner der man f&#229;r kontrol ved hjelp av andre state managment mekanismer.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1828,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Rest<\/strong> er en overordnet arkitektur&#160;for web-basert&#160;kommunikasjon med fokus p&#229; lesing og skriving av ressurser. I den defineres ett eller flere endepunkter for &#229; lese data fra. For eksampel hvis man vil sp&#248;rre etter informasjon fra to objekter, trenger man &#229; sende to Rest&#160;foresp&#248;rsel. Det kan gj&#248;re ting enklere &#229; forst&#229; slik at man vet hvilken&#160;foresp&#248;rsel for hvilken data del.<\/p><p>Rest brukes for &#229; lage nye API-er.&#160;N&#229;r man bruker den til &#229; fetche data, f&#229;r man tilbake hele databasen(kan kalle dette for &#34;overfetching&#34;) og man skal selv s&#248;ke inn i den og f&#229; de bestemte data man&#160; &#248;nsker &#229; f&#229;. Den bruker&#160;&#160;HTTP foresp&#248;rslene GET, PUT, POST, DELETE for &#229; lese, endre, opprette eller slette ressurser.<\/p><p>Rest brukes i flere bedrifter fordi det finnes mange verkt&#248;y som st&#248;tter den.<\/p><p>&#160;<\/p><p><strong>GraphQl <\/strong>er en query spr&#229;k som kj&#248;res i run-time. Den kan bruke flere endepunkter for &#229; lese data fra. GraphQl&#160;brukes for &#229; optimalisere ytelse og fleksibilitet. Den fungerer slik at man bare skriver query og f&#229; de bestemte(eksakt) data fra databasen uten &#229; bruke tid til &#229; s&#248;ke gjennom hele databasen. Data kommer bare i en json objekter form. GraphQl mangeler&#160;implisitt caching i HTTP-lage og det kan v&#230;re en ulempe ogs&#229;. Man trenger &#229; lage et skjema for &#229; definere queries f&#248;rst avhengig av databasen man har. Man skal ogs&#229; koble mellom skjema og serveren som kan v&#230;re litt kompleks. Det er fortsatt begrenset antall av verkt&#248;y som st&#248;tter GrapghQl. Man som sagt den gj&#248;r applikasjoene enklere og sparer tid n&#229;r man f&#229;r tilbake bare data man trenger.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11542841,"ext_inspera_userAssessmentSetupId":7139973,"ext_inspera_userAssessmentId":4841460,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:01:40Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Vo Anh-Kha Nguyen (10048)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34116336,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1897,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>State<\/strong><\/p><p>I funksjonelle React komponenter s&#229; finnes noe som heter hooks. Hooks er funksjonelle komponenter sin m&#229;te &#229; lagre state p&#229;. Dette er grunnet at i en funksjonell komponent, s&#229; vil hele funksjonen kj&#248;res f&#248;r den returnere JSXen. Dermed vil en variabel `let counter=2` f&#248;re til at counter verdien resetes til 2 hver gang funksjonen kj&#248;rer. Derfor finnes hooks, `const [counter, setCounter] = useState(0)`, for &#229; kunne ta vare p&#229; tilstanden til en funksjonell komponent. Parameteret til useState er default verdien.<\/p><p>&#160;<\/p><p>I en klassekomponent s&#229; setter man state ved &#229; lage en klasse-variabel. Dette gj&#248;r man ved &#229; skrive `this.state = {counter: 0}` inni klassekomponenten sin konstrukt&#248;r<\/p><p>&#160;<\/p><p><strong>Props<\/strong><\/p><p>Det er mulig &#229; dele tilstand med child-komponenter. Dette gj&#248;r man gjennom props. Om man har komponenten, `const Calendar= (props) =&#62; {&#60;p&#62;{props.name}: {props.date}&#60;/p&#62;}`, s&#229; vil props.date bli delt ved &#229; skrive `&#60;Calendar name=&#34;My Calendar&#34; date=&#34;12/1/2020&#34;/&#62;`. Hver &#34;attribut&#34; p&#229; komponent vil bli mappa til props dermed. Attributten trenger ikke n&#248;dvendigvis v&#230;re en streng. Hvis vi lager staten `today` i state, s&#229; kunne vi ha skrevet `&#60;Calendar date={today}/&#62;`. Da vil Calendar komponenten v&#230;re avhengig av tilstanden til parent-komponenten, og hver gang `today` tilstanden endrer seg, s&#229; vil Calendar komponenten re-renderes og tilpasse seg endringene.<\/p><p>&#160;<\/p><p><strong>Lifecycles<\/strong><\/p><p>Lifecycles g&#229;r ut p&#229; hvilken tilstand av rendering en komponent ligger i.Dette b&#248;r ikke forvirres med state-tilstand. Dette er en egen tilstand for n&#229;r en komponent renderes, blant annet n&#229;r den mounter, unmounter, oppdatere osv. Dette brukes ofte n&#229;r man henter data asynkront, eller &#248;nsker at en rekke hendelser skal skje hvis en variabel endrer seg.<\/p><p>&#160;<\/p><p>I en klassekomponent s&#229; f&#229;r vi en rekke nyttige metoder som `componentsDidUpdate`, `componentsDidMount`, `componentsWillUnmount` osv fra &#229; extende klassen fra &#34;React.Component&#34;. Dette er lifecylces metoder<\/p><p>&#160;<\/p><p>For funksjonelle komponenter s&#229; finnes en nyttig liten metode som heter `useEffect`. Denne brukes ved &#229; skrive `useEffect(() =&#62; {...}, [var1, var2])`.&#160; useEffects brukes for &#229; kunne utf&#248;re side-effects i dette tilfellet. I en useEffect s&#229; vil funksjonen inni useEffecten kj&#248;res en gang n&#229;r komponenten renderes, og kj&#248;re hver gang variabelene i [var1, var2] oppdateres. Ofte brukes useEffect for &#229; fetche data asynkront p&#229; siden, eller andre asynkrone ting. Dette gj&#248;res ved &#229; lage en funksjon inni useEffecten som er async, som kalles p&#229; slutten av useEffecten, `useEffect(()=&#62;{const fetchData = async() =&#62; {...}: fetchData() },[])`<\/p><p>&#160;<\/p><p><strong>Context&#160; <\/strong><\/p><p>Context er en m&#229;te &#229; lagre en global state p&#229;, istendenfor &#229; ha state i Rot komponenten. Dette gj&#248;res ved &#229; wrappe rotkomponenten i en Provider, som lages gjennom &#229; lage en Context. Dette er utrolig nyttig fordi at man slipper &#229; sende data gjennom komponent treet gjennom props, som kan v&#230;re veldig ressurs krevende. Dataen kan da hentes gjennom &#229; consumere context `const {...} = useContext(...)`.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2939,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Problemer med React<\/strong><\/p><p>&#160;<\/p><p>I React s&#229; hender det ofte at man m&#229; passe tilstand til flere komponenter. Dette skjer ihvertfall om man &#248;nsker at to komponenter skal ha shared state. I dette tilfellet m&#229; man enten bruke Context, eller ha tilstanden i en felles-parent komponent. I noen tilfeller &#248;nsker vi ikke &#229; ha dette som global-tilstand, s&#229; dermed ender vi opp med felles-parent l&#248;sningen. Problemet med denne l&#248;sningen er at om en av child-komponenten passer tilstanden igjen til flere komponenter.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Dette kan bli problematisk og veldig ressurskrevende &#229; oppdatere om vi har et veldig stort React-tre tilslutt. I tillegg s&#229; kan det v&#230;re vanskelig &#229; oppdatere verdien om verdien oppdateres langt nede i treet. Ofte brukes useEffect i slike tilfeller. Dette kan raskt bli veldig kronglete<\/p><p>&#160;<\/p><p><strong>Hva er Recoil?<\/strong><\/p><p>Recoiljs er en et bibliotek for tilstands-h&#229;ndtering som &#248;nsker &#229; l&#248;se begrensingene React har for blant annet global state. Recoiljs inneholder to viktige konsepter, atomer og selectors.<\/p><p>&#160;<\/p><p>Atomer er nemlig en tilstand som kan oppdateres og subscribes til.&#160; N&#229;r en atom oppdateres, s&#229; vil alle komponenter som har subscriba til atomen ogs&#229; re-renderes med den nye oppdaterte verdien. Atomer krever en unik key, i likhet med at React krever en key hvis man &#248;nsker &#229; rendere en liste av komponenter gjennom map funksjonen. Denne keyen er nyttig og brukes for debugging, persistens osv.<\/p><p>&#160;<\/p><p>Selectors er rene (pure) funksjoner som kun aksepterer atomer eller andre selectors som input. En ren funksjon er en flittig konsept i funksjonell programmering. Dette er en funksjon der return-verdien er kune avhengig av input parameterene, og UTEN noen side-effects (den skal ikke mutere state f.eks eller andre variabler utenfor). Selectors brukes ofte for &#229; lage computed-values basert p&#229; tilstand-verdier.<\/p><p>&#160;<\/p><p><strong>Fordeler <\/strong><\/p><p>I Recoil s&#229; er dataen h&#229;ndtert som en graf. N&#229;r en atom subscribes til, s&#229; skaper man en avhengighet. F.eks. `birthday` staten subscriber til `currentPerson` atomet. Denne avhengighets-grafen er nyttig n&#229;r tilstander skal oppdateres p&#229; tvers av komponenter. Hvis currentPerson har flere subscribers, s&#229; vil alle subscribers-ene oppdateres og computes (f.eks. gjennom selectors) n&#229;r currentPerson oppdateres.<\/p><p>&#160;<\/p><p>Man kan ogs&#229; lage atomer utenfor funksjonelle komponenter, og dermed peke flere useRecoilState hooks til en atom i en atom mappe/fil. Man har alt subscribable i et organisert sted. Dette skaper en mer modul&#230;r l&#248;sning, som kan v&#230;re nyttig for debugging.<\/p><p>&#160;<\/p><p>Selectors er ogs&#229; utrolig nyttig for asynckrone hendelser. Blant annet kan vi ha en atom med en API-url og bruke en async selector som fetcher dataen fra URLen. Dette er en mye mer robust l&#248;sning grunnet at selector funksjonen kan v&#230;re async. Dette er en penere approach enn &#229; lage en async funksjon og kalle den p&#229; slutten av useEffecten.<\/p><p>&#160;<\/p><p>Selectors ser ut til &#229; v&#230;re utrloig async-kompatibelt. Blant annet inneholder recoil en rekke concurrency-helpers som waitForAll, waitForNone gj&#248;r Recoil veldig fleksibelt n&#229;r det kommer til Async dataflyt. I likhet med Apollo-Client s&#229; kan dette brukes for &#229; skape fallbacks med React sin nye Concurent mode. Blant annet kan man ha fallbacks for n&#229;r dataen loades, eller n&#229;r man f&#229;r en error.<\/p><p>&#160;<\/p><p><strong>Ulemper<\/strong><\/p><p>Noen store ulemper med Recoil er f&#248;rst og fremst at Recoil er veldig nytt, i tillegg til &#229; v&#230;re expirimental. Dette betyr ofte at Recoil ikke er prod-klar. Blant annet p&#229; github-issues pagen til Recoil s&#229; diskuteres alt fra nye features til optimaliseringsproblemer.<\/p><p>&#160;<\/p><p>Grunnet Recoil er veldig nytt, og ikke blitt tatt i stor bruk enda s&#229; hender det ofte at man har manglende dokumentasjon, tutorials og generelt l&#230;ringsmateriale. Dette er en stor fordel med ren React l&#248;sning (gjennom useEffect) der det finnes utrolig store mengder ressurser for alt fra shared-states til async-fetching.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2250,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er&#160; to m&#229;ter &#229; sende/hente data over HTTP. Begge to har sine fordeller og ulemper.<\/p><p>&#160;<\/p><p><strong>HTTP<\/strong><\/p><p>&#160;<\/p><p>REST er den tradisjonelle m&#229;ten &#229; kommunisere med et API p&#229;. Den bruker HTTP-metodene/typene for &#229; kommunisere p&#229;, alts&#229; GET, POST, PUT, PATCH, DELETE. I REST s&#229; setter man opp api-endpoints (gjennom URLer) og definere hva slags data/hva skjer n&#229;r man utf&#248;rer et REST kall til dette endepunktet. Blant annet kan man ha api.ntnu.no/studier/:id, api.ntnu.no/emner, api.ntnu.no/campuser osv. I Rest behandler man hvert endepunkt som sin egen entitet/ressurs.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>I GraphQL skjer nesten alt sammen gjennom <strong>POST <\/strong>metoden. Dette er fordi i GraphQL s&#229; &#34;poster&#34; man en beskrivelse av strukturen av dataen vi &#248;nsker &#229; ha. Om man poster `query {allBlogPost{ title }}` s&#229; f&#229;r man kun tittelen til hver blogPost. En stor fordel med GraphQL er at all dataen ligger p&#229; et endepunkt (ofte p&#229; /graphql), i forhold til flere som i REST.&#160; I tillegg, grunnet for at GraphQL ikke f&#248;lger standard HTTP-konvenskjoner s&#229; f&#229;r man ikke like mye nytte fra HTTP-status meldinger som &#34;OK&#34;, &#34;Not Found&#34; osv. GraphQL krever ogs&#229; ofte bruken av en Graphql-klient.<\/p><p>&#160;<\/p><p><strong>Caching<\/strong><\/p><p>Noen store fordeller med REST er nemelig med caching. GET metoder kan blant annet bli cacha, ligge i browser-history, bli bookmarka osv.<\/p><p>&#160;<\/p><p>GraphQL bruker et endepunkt, og det er dermed optil utvikleren &#229; utvikle caching. Ofte kan dette gj&#248;res gjennom graphql-klienter (som apollo), men ikke alle graphq-klienter har kanskje st&#248;tte for caching.<\/p><p>&#160;<\/p><p><strong>Overfetching og Underfetching<\/strong><\/p><p>Et stort problem med REST er nemlig underfetching, og ofte overfetching. Dette kan ofte bli veldig ressurskrevende. Overfetching skjer n&#229;r man &#248;nsker lite data, men m&#229; fetche all dataen selv om man bare trenger f.eks. tittel. La oss si vi har en liste av studier (som p&#229; NTNU sine sider).&#160; Selv om man kanskje trenger bare tittelen, bachlor/master og studiekode s&#229; m&#229; man hente hente masse un&#248;dvendig data som vises p&#229; la oss si detaljesiden (hvis APIet er designa p&#229; den m&#229;ten). Man kan m&#229;tte hente opptakskrav,&#160; &#34;om&#34; seksjonen,&#160; studieoppbygning osv. Dette kan fort bli ressurskrevende og un&#248;dvendig n&#229;r man skal bare hente en liste med studienavn.<\/p><p>&#160;<\/p><p>Underfetching derimot f&#248;rer ofte til at man m&#229; kj&#248;re flere runder med API-kall. Blant annet La oss si at man skal hente et &#34;fag&#34; og en &#34;person&#34;.&#160; Det kan hende at &#34;person&#34; ikke inneholder felt for &#34;fag&#34; (grunnet at det er to forskjellige ting) som f&#248;rer til at man m&#229; kj&#248;re enda et kall for &#229; hente fag.<\/p><p>&#160;<\/p><p>For Graphql er dette to problemer som GraphQl pr&#248;ver &#229; l&#248;se. I GraphQl s&#229; beskriver man hvordan dataen skal se ut, og man f&#229;r akuratt det man sp&#248;r om. GraphQL h&#229;ndterer dataen som en graf, der alt er koblet sammen. Fra Rot-noden s&#229; kan man aksesere all dataen, og velge hvilken &#34;noder&#34; man har lyst &#229; ta med i sp&#248;rringen.<\/p><p>&#160;<\/p><p><strong>Annet<\/strong><\/p><p>Den tradisjonelle REST-approachen kan ofte bli veldig kompleks og kronglete. Ihvertfall n&#229;r man har mange endepunkter. En fordel derimot er at man kan f&#229; data i en rekke formater, alt fra XML til JSON til Plain. Uansett s&#229; er det utrolig mye god dokumentasjon for REST og nesten alle API-rammeverk har st&#248;tte for REST grunnet for at REST er standaren gjennom &#229;rene.<\/p><p>&#160;<\/p><p>Det finnes noen store fordeler med Graphql n&#229;r man designer et API.&#160; Graphql er nemlig typa (med graphql-typer) som er sin egen form for dokumentasjon. Det er veldig nyttig &#229; vite at en mutasjon tar kun inn en String som input, eller at age er en integer. I tillegg fins det mange type-generators som kan lese et graphql-schema og konvertere de til spr&#229;kets typer (f.eks. graphql-codegen for typescript).&#160; En ulempe er at Graphql kun st&#248;tter JSON. Man kan ogs&#229; p&#229;st&#229; at &#229; designe et godt graphql-api kan v&#230;re vanskeligere (grunnet mange av fellene som f.eks. N+1 problemet).<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; kombinere APIer p&#229;! I Graphql kan man definere en resolver til &#229; hente data fra et REST-api (dette eliminere egentlig fordelen med over/underfetching)<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11540298,"ext_inspera_userAssessmentSetupId":7139910,"ext_inspera_userAssessmentId":4841185,"dateLastModified":"2020-12-01T10:01:25Z","ext_inspera_startTime":"2020-12-01T08:00:12Z","ext_inspera_endTime":"2020-12-01T10:01:25Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Zachariassen Oline Vikøren (10057)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34578099,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1915,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er interne variabler i komponentent og kan endes med f.eks setState(). (Vil ofte rendre komponenten p&#229; nytt)&#160;<\/p><p>&#160;<\/p><p><strong>Props:&#160;<\/strong><\/p><ul>\t<li>I React er det en innebygd funskjon for dataflyt som lar deg seg sende props = data&#160;(&#34;properties&#34;) som sendes inn&#160;til en komponent n&#229;r den opprettes og (p&#229;virker tilstanden)&#160;<\/li><\/ul><p><strong>Callback:&#160;<\/strong><\/p><ul>\t<li>Lar barn endre state i foreldre ved &#229; sende callback funskjoner.&#160;<\/li><\/ul><p>Ved komplekse applikasjoner med mange komponenter og mye dataflyt blir dette ofte veldig rotete og un&#248;dvendig mye kode hvis noe f.eks skal sendes p&#229; tvers og p&#229; kryss. Da vil vi helelr bruke cllobal state management&#160;<\/p><p>&#160;<\/p><p><strong>Global state Management (de jeg er kjent med)&#160;<\/strong><\/p><p>All data kan lagres et sted og sette opp oppdatering&#160;&#248;nskede komponeneter.<\/p><p>&#160;<\/p><ul>\t<li><strong>Context&#160;<\/strong>\t<ul>\t\t<li>Context lar deg sende dataflyt (pase props) fra foreldre til barn.&#160;<\/li>\t\t<li>Brukes som ofte til dataflyt av data som er &#34;globale for hirakiet&#34;. eks: Tema ( prosjekt 2) eller hviket spr&#229;k.&#160;<\/li>\t\t<li>Er vrient &#229; gjenbruke komponenter da Context sender dataflyt en vei (parent til child). (Kan bruke callback. (Redux og Mobux har ikke denne problematiken)&#160;<\/li>\t<\/ul>\t<\/li>\t<li><strong>Redux&#160;<\/strong>\t<ul>\t\t<li>Redux er et open source JS biblotek for &#229; h&#229;ndtere dataflyt og state management. Med Redux kan man aksessere alt &#248;nsket data fra hvor som helst i komponenthirarkiet.&#160;<\/li>\t\t<li>Redux er mye kode, og kan fort v&#230;re &#34;overkill&#34; hvis applikasjonene og dataflyten ikke er komplisert not.&#160;<\/li>\t\t<li>Har en Best&#160;<\/li>\t<\/ul>\t<\/li>\t<li><strong>Mobux<\/strong>\t<ul>\t\t<li>Mobux er mindre kode og mer automatisert, og kan ofte bli sett p&#229; som enklelre. Med mobux kan man ogs&#229; aksessere dataen fra hele komponenthirarkiet&#160;<\/li>\t\t<li>Men Mobux er mye mer uforutsigbar enn redux (bruker obeserverbare data for &#229; atomatisk oppdatere state) , s&#229; gj&#248;r det vanskligere &#229; teste&#160; enn Redux&#160;<\/li>\t<\/ul>\t<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3534,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>- Hvorfor valgt &#229; sammenligne med redux&#160;<\/p><p>Recoil er et Facebook open source bibllotek for React for &#229; h&#229;ndtere statemanagement og dataflyten, Redux er et open source JS bibllotek for react. Begge bibloteker er dekker behovet for Global state management i mer komplekse arkitekturer med mye dataflyt. Hvis applikasjoner er veldig kompleks kan bruk av Redux ofte gi un&#248;dvendig mye rerenders, og dermed minske &#34;preformance av applikasjonen&#34;. N&#229;r man skal dele data men mange komponenter &#229; opplever &#34;preformance issue&#34; kan Recoil v&#230;re en god l&#248;sning! P&#197; nettet var det mest sammenligninger mellom Redux og recall<\/p><p>&#160;<\/p><p><strong>Hvordan funker Recoil?&#160;<\/strong><\/p><ul>\t<li>Vi trenger en recoil root som m&#229; wrappe komponenter som bruker atoms( kan ofte wrappe helle rooten av appen).&#160;<\/li>\t<li>Bruker &#34;atoms&#34;&#160;\t<ul>\t\t<li>Et individuelt stykke state med unik ide og default value.&#160;<\/li>\t\t<li>Komponenter kan &#34;subcribe&#34; til atoms &#229; oppdatere n&#229;r disse endres( dersom de leser av atoms)&#160;<\/li>\t\t<li>Bruker useReacoilState()&#160; til &#229; lese &#229; skrive til atoms i likhet med useState()&#160;<\/li>\t<\/ul>\t<\/li>\t<li>Selectors\t<ul>\t\t<li>Returnerer en modifisert&#160;<\/li>\t\t<li>N&#229;r man trenger &#34;derived&#34; data kan bruke selectors som har key og get funskjon som returnerer en modifisert&#160;&#160;sate&#160;av atomet. Disse kan aksesseres p&#229; llik niv&#229; med atoms, men man brukee useRecoilValue() isteenfor&#160;useReacoilState()&#160; t<\/li>\t<\/ul>\t<\/li><\/ul><p>&#160;<\/p><p><strong><em>Fordeler<\/em><\/strong><\/p><ul>\t<li><strong>S<\/strong>iden komponeter kan subscribe til kun akkurat de attoms de trenger s&#229; vil vi kunne oppn&#229; f&#230;rre rerenders (kun komponenter som trenger &#229; rerendre rendres) &#229; dermed &#248;ke performance i store komplekse applikasjoner.<\/li>\t<li>Mindre Boilerplate kode enn Redux og enklere &#229; sette opp<\/li>\t<li>St&#248;ttes Asykron state manegement&#160;<\/li>\t<li>I likhet med Context kan en komponent endre en tilstand dirkete.&#160;<\/li><\/ul><p><strong>Ulemper:&#160;<\/strong><\/p><ul>\t<li><strong>D<\/strong>et er mulig &#229; finne veldig mange fordeler p&#229; internettet, men i likhet med mange nye bibloteker er det ofte stor begestring n&#229;r nye bibloteker kommer it spesielt fra en s&#229; stor akt&#248;r som facebook. Dette er noe en utvikler b&#248;r vurdere. Bare fordi det er nytt og interresant betyr ikke det at det er det beste valget for din applikasjon<\/li>\t<li>Dersom preformance og mange rerenders er et problem vil det ikke n&#248;dvendigvis gi mer nytte &#229; bruke recoil.&#160;<\/li>\t<li>Dersom en kun trenger reacts innebygde mekaniske for stateh&#229;ndtering og en eller to callback kan dette v&#230;re en<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1716,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p><strong>forskjeller Mellom REST API og GRaphql:&#160;<\/strong><\/p><p>&#160;<\/p><ul>\t<li>I Rest API definererer man endepunkter for &#229; lese, skrive og endre p&#229; resurrser gjennom URI og HTTP request, og definerer hvilke data som skall returneres. I Graphql sendes en sp&#248;rring til en server der du definerer hva som skal returnered&#160;<strong>og s&#248;k.&#160;<\/strong>Dermed kan man hente all data i en sp&#248;rring &#229; unng&#229;r mange kall for &#229; &#229; hente kpmpleks informasjon som man m&#229; gj&#248;re med REST API.&#160;&#160;Graphql henter ogs&#229; kun den dataen den trenger, mens med REST hentes ofte overfl&#248;dig data/overfetching (f&#229;r et komplett datasett).&#160;\t<ul>\t\t<li>Dette gj&#248;r at Graphql ofte er et bedre valg om det er n&#248;dvendig med h&#248;y ytelse og performance&#160;<\/li>\t\t<li>Men det gj&#248;r at Rest API er ofte mye enkleree &#229; forst&#229; og manipulere siden det har et x-endepunkter gir x-anatll data<\/li>\t<\/ul>\t<\/li><\/ul><p>&#160;<\/p><ul>\t<li>I motsetning til REST API kan man med Graphql validere dataen i sp&#248;rringen ved at man har en tettere server-klinet kobling siden man bruker skjema for struktur og typer. Mens i REST API er tilstandsl&#248;st.&#160;\t<ul>\t\t<li>(Graphql&#160;)ulempe med dette er at mye kompleksistet flyttes til server-siden som legger til kompleksitet for backend utviklere&#160;<\/li>\t\t<li>(Graphql&#160;)Fordel er at &#229; validere dataen og strenge typer kan f&#248;re til en lavere sjangse for kommunikasjonssvikt mellom server/client.&#160;<\/li>\t\t<li>For REST API trenger ikke serveren &#229; vite noe om clientens tilstand elller motsatt (Statelessness). Det gir mer flleksibilitet for brukergresesnittet.<\/li>\t\t<li>&#160;<\/li>\t<\/ul>\t<\/li>\t<li>Med REST har man implisitt cashing som st&#248;ttes i alle browsers. Det har man ikke med Graphql<\/li>\t<li>Graphql st&#248;tter kun JSON format, mend med&#160;REST API m&#229; man ha en ekstra linje .json() for &#229; konvertere dataen till JSON format.<\/li><\/ul><p>&#160;<\/p><p>Kort fra utviklerns perspektiv:&#160;<\/p><p>&#160;<\/p><p>Graphql har en litt brattere l&#230;ringskurve og vanskligere &#229; forst&#229;, men gir h&#248;yere ytelse og preformer bedre speiselt for komplekse applikasjoner med mange brukere. REST API er en slakere l&#230;ringskurve og er mer fleksibel.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540537,"ext_inspera_userAssessmentSetupId":7140014,"ext_inspera_userAssessmentId":4841379,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:13Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Jenssen Maja Sung Hee (10122)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330999,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3500,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Jeg er litt usikker p&#229; hva som menes med dataflyt i sp&#248;rsm&#229;let, men antar at det i hovedsak sp&#248;rres om mekanismer og teknikker slik som context-apiet, redux og mobX. Man kan i tillegg diskutere bruken av props og hooks.<\/p><p>&#160;<\/p><p>Props og hooks er kanskje ikke s&#229; relevant for denne oppgaven, men jeg tenkte &#229; bare nevne det kort fordi det brukes for &#229; h&#229;ndtere states. I klasse komponenter brukes props&#160;for &#229; h&#229;ndtere states, og for &#229; dele en state eller verdi med komponenter lengre ned i strukturen. Hooks er en annen metode man kan bruke for &#229; h&#229;ndtere state p&#229; en litt bedre m&#229;te i funksjonelle komponenter. Her kan man instansiere variabler og funksjoner med for eksempel UseState og UseEffect, som lar oss oppdatere variablene n&#229;r vi kj&#248;rer funksjonen. Et eksempel p&#229; dette er [displayPost, SetDisplayPost] = UseState(). UseEffect har et lignende bruksomr&#229;de som&#160;componentDidMount,&#160;componentDidUpdate, og componentWillUnmount. Ved &#229; bruke dette, kan vi for eksempel definere at en state skal oppdatere seg hver gang applikasjonen rendres.<\/p><p>&#160;<\/p><p>Context-api<\/p><ul>\t<li>Brukes for &#229; dele verdier mellom komponenter uten &#229; m&#229;tte eksplisitt levere verdiene som props gjennom hvert niv&#229;&#160;av strukturen. Dette er da gjerne verdier som vi &#248;nsker skal v&#230;re aksesserbare globalt, som for eksempel autentifisering og fargetema.<\/li>\t<li>Det brukes hovedsakelig n&#229;r flere komponenter (fra ulike nesting niv&#229;er) har bruk for samme data.<\/li>\t<li>Kan fint brukes&#160;i nettsider og applikasjoner hvor strukturen ikke er altfor stor. I store prosjekter&#160;vil man gjerne velge &#229; bruke Redux eller MobX i stedet.&#160;<\/li><\/ul><p>&#160;<\/p><p>Redux<\/p><ul>\t<li>Brukes i nettsider og applikasjoner hvor det er mange states som skal brukes i flere komponenter og&#160;n&#229;r man forventer at states&#160;kommer til &#229; bli oppdatert&#160;jevnlig.<\/li>\t<li>Redux er en tredjepartskomponent som hjelper &#229; h&#229;ndtere globale states.<\/li>\t<li>Statene som brukes av applikasjonen ligger i en &#34;store&#34; i tre-strukturen til applikasjonen. Det som ligger i storen er &#34;immutable&#34;.<\/li>\t<li>For p&#229;kalle&#160;endringer&#160;i storen, m&#229; man sende ut en action -&#160;et objekt som beskriver hva som har skjedd.<\/li>\t<li>For &#229; videre spesfisere hvordan actions p&#229;virker/endrer state-treet, definerer man reducers.<\/li><\/ul><p>&#160;<\/p><p>MobX<\/p><ul>\t<li>MobX er - som Redux - en tredjepartskomponent - for h&#229;ndtering av globale states.<\/li>\t<li>I MobX bruker man det som kaller for en observable. En observable lar oss gj&#248;re om enhver data struktur til en state som kan observeres, slik at andre ting kan holde rede med observerbare endringer og verdier.<\/li>\t<li>MobX bruker&#160;actions for &#229; endre states (som for eksempel verdiene som observeres). En action kan v&#230;re enhver kode som endrer p&#229; en state. Dette er mulig fordi MobX er &#34;mutable&#34;.<\/li>\t<li>I tillegg til en observable, finnes det en observer. Observeren er den som lar oss holde rede med endringer i observablen, slik at React vet n&#229;r en endring skjer og kan rendre p&#229; nytt.&#160;<\/li>\t<li>Data og funksjoner som endrer dataen, ligger i stores. MobX, i motsetning til Redux, kan ha flere stores for hver state som blir brukt.&#160;En store kan inneholde b&#229;de observables og actions.<\/li><\/ul><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://reactjs.org/docs/hooks-effect.html<\/li>\t<li>https://reactjs.org/docs/context.html<\/li>\t<li>https://redux.js.org/tutorials/essentials/part-1-overview-concepts<\/li>\t<li>https://www.npmjs.com/package/redux<\/li>\t<li>https://dev.to/rosyshrestha/build-your-first-app-with-mobx-and-react-4896<\/li>\t<li>https://blog.logrocket.com/redux-vs-mobx/<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1877,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state h&#229;ndterings bibliotek for React, slik som Redux, MobX og Context.&#160;<\/p><p>&#160;<\/p><p>Elementer brukt i Recoil<\/p><ul>\t<li>Man m&#229; definere en RecoilRoot h&#248;yere oppe i strukturen for at komponenter lengre nede i strukturen kan bruke recoil state. Dette kan man for eksempel definere i rot-komponenten app.ts.<\/li>\t<li>En state representeres av et atom. Atom kan leses fra og skrives til fra enhver komponent. Komponenter som leser verdien av et&#160;atom&#160;abonnerer implisitt til det atomet. Det vil si at endringer/oppdateringer til et atom vil f&#248;re til at alle komponentene som abonnerer p&#229; det atomet rendres p&#229; nytt.<\/li>\t<li>Komponenter som m&#229; lese fra og skrive til et atom bruker useRecoilSate(), p&#229; samme m&#229;te som man definerer en hook. For eksempel: const [text, setText] = useRecoilState(textState);<\/li>\t<li>En selector representerer en &#34;derived state&#34;. Dette er en modifikasjon av en state.<\/li><\/ul><p>Fordeler og ulemper/sammenligninger<\/p><ul>\t<li>En fordel med Recoil er at tankegangen rundt hvordan man bruker det er relativt likt m&#229;ten man bruker React p&#229;, med sin egen versjon av React sin useState. Man kan deklarere nye variabler for states, og oppdatere eksisterende.<\/li>\t<li>Atoms og selectors lar oss bruke en eksakt del av en state.<\/li>\t<li>Recoil kommer med async st&#248;tte uten &#229; m&#229;tte bruke andre tredjeparts biblioteker.<\/li>\t<li>En mulig ulempe er at Recoil er en ganske ny tredjepartskomponent, som ikke blir utnyttet (per dags dato) p&#229; like stor skala som andre state h&#229;nderings bibliotek. Det er heller ikke bygd inn like mange verkt&#248;y som i andre bibliotek som har eksistert lengre.<\/li><\/ul><p>Sammenligninger med andre state h&#229;nderings metoder<\/p><ul>\t<li>Det er mindre &#229; sette seg inn i ved &#229; l&#230;re seg Recoil, enn for eksempel Redux, som bruker en del boilerplates. Recoil, bruker minimalt med boilerplates og kan struktureres lett.<\/li>\t<li>Recoil states blir ikke lagret globalt noe sted, slik som states blir i Redux, MobX og Context. Dette muliggj&#248;r&#160;enkel&#160;&#34;code-splitting&#34;.&#160;<\/li>\t<li>Man henter bare inn det man trenger av en state.<\/li><\/ul><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://recoiljs.org/docs/introduction/getting-started<\/li>\t<li>https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1755,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API<\/p><ul>\t<li>Med REST API-et kobler man seg til flere endpoints for &#229; hente data. Dette inneb&#230;rer at man m&#229; ettersp&#248;rre data fra ulike endpoints for &#229; kunne hente inn &#248;nsket data. For eksempel, kan man ha en endpoint for &#229; hente inn en bruker ID, og en annen endpoint for &#229; hente inn bruker innlegg (i en nettside hvor man kan lage bruker og innlegg, som facebook).<\/li>\t<li>N&#229;r man ettersp&#248;r data via et REST API, oppst&#229;r &#34;overfetching&#34;. Det vil si at du f&#229;r tilbake all dataen tilnkyttet endpointet - hvorav du sannsynligvis ikke kommer til &#229; bruke all den returnerte dataen.<\/li>\t<li>Et lignende problem er &#34;underfetching&#34;, hvor endpoint ikke sender tilbake all informasjonen som vi egentlig etterspurte. I slike tilfeller m&#229; man ogs&#229; ettersp&#248;rre (fra flere endpoints) for &#229; f&#229; hentet inn all dataen man vil ha.<\/li>\t<li>I REST spesifiserer man om man vil ettersp&#248;rre data eller legge til data ved &#229; endre HTTP adressen fra GET til POST.<\/li>\t<li>En foresp&#248;rsel kaller p&#229; &#233;n route handler funksjon.<\/li><\/ul><p>&#160;<\/p><p>Gaphql<\/p><ul>\t<li>Med Graphql sender man en query til en GraphQL server, som definert i et skjema. Queryen kan inneholde spesifikke krav. For eksempel dersom du har en filmdatabase, kan du sp&#248;rre om film-titler med spesifikke attributer. Serveren sender s&#229; tilbake et JSON objekt med som oppfyller de satte kravene.&#160;<\/li>\t<li>Siden du kan sette spesifikke krav til det som hentes og returneres av serveren med Graphql queries, oppst&#229;r det ikke &#34;overfetching&#34; eller &#34;underfetching&#34; her.&#160;&#160;<\/li>\t<li>Man kan velge hvilken type operasjon man vil gj&#248;re/legge til rette for ved &#229; sende inn et av f&#248;lgende keyword: query eller mutation. Query blir brukt til &#229; ettersp&#248;rre informasjon, som nevnt ovenfor. Mutation derimot, blir brukt for &#229; legge til eller endre data. Denne typen operasjon m&#229; ogs&#229; defineres i et skjema.&#160;<\/li>\t<li>En query i Graphql kan kalle p&#229; mange s&#229;kalte &#34;resolvers&#34; for &#229; konstruere en nested response med flere ressurser som sendes tilbake.<\/li><\/ul><p>Kilder<\/p><ul>\t<li>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/li>\t<li>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/li><\/ul>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11540730,"ext_inspera_userAssessmentSetupId":7139994,"ext_inspera_userAssessmentId":4841371,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Almestad Vilde (10133)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33624042,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2544,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Redux, MobX og Context API er state management som bruker for &#229; lagre tilstander til komponentene.&#160;<\/p><p>Redux er en State Manager som lagrer alle tilstandene til komponentene og koordinere dem p&#229; tvers av komponentene b&#229;de i backend og frontend.&#160;P&#229; denne m&#229;ten kan alle komponenter &#34;n&#229;&#34; tilstandene til de andre komponentene uavhengig av komponenthierarkiet. Redux lagrer alle disse tilstandene i en Store. Redux har ogs&#229; Actions der alle funksjonene i applikasjonen ligger. I tillegg finnes det en Reducer. Dette&#160;er en EventListener som h&#229;ndterer hendelser basert p&#229; mottatt Actions. Ved &#229; bruke Redux kan komponentene,&#160;som tidligere nevnt, &#34;f&#229; tak i&#34; de andre komponentene sine tilstander. Det fjerner un&#248;dvendige re-renders, samtidig som det ogs&#229; endrer tilstanden til en komponent automatisk.&#160;<\/p><p>&#160;<\/p><p>En annen metode er MobX. Denne opererer veldig likt som Redux, da&#160;den lagrer tilstanden til komponentene og gj&#248;r det globalt slik at andre komponenter kan n&#229; disse tilstandene. MobX har man hendelser som utl&#248;ser en Actions. Disse actions oppdaterer en observable, som er en tilstand i komponenten din. P&#229; denne m&#229;ten vil komponenten din kun oppdateres dersom en observable blir modifisert. Noe som MobX har som ikke Redux har er&#160;Derivation. Dette&#160;brukes for uthenting av tilstander.&#160;Noe annet som&#160;skiller MobX fra Redux er at Redux har &#233;n Store, mens MobX tilbyr flere stores hvor man kan automatisk hente ut, ved Derivation, og oppdatere Store.&#160;MobX brukes generelt for mindre prosjekter da det ikke har like stor kompleksitet som Redux.<\/p><p>&#160;<\/p><p>Tilslutt kan Context API ogs&#229; brukes. Context API&#160;brukes hovedsakelig for &#229; slippe &#229;&#160; sende props ned i komponenthierarkiet manuelt. Context skal lagre data og gir beskjed&#160;til komponenten dersom denne dataen blir endret. Alts&#229; at komponetene f&#248;lger med direkte p&#229; Store og bruker det for &#229; f&#229; beskjed dersom det er mulige tilstandsendringer.&#160;Dette gj&#248;r de ved &#229; ha en Provider og Consumer. Det er mulig &#229; ha flere Stores med Context API. Dette er mulig fordi man har muligheten til &#229; ha flere Providers for &#229; skille mellom ulike data modeller i applikasjonen din. Da kan man fortelle Applikasjonen din hvilken store som tilh&#248;rer hvilken del av komponenthierarkiet. Dermed er det mulig &#229; ha flere stores ved Context API. I motsetning til MobX og Redux, er Context gunstig &#229; bruke i tilfeller der man skal sende Static Data enklere og mer effektivt i applikasjonen, som f.eks. et styling tema. Context API l&#248;ser ogs&#229; problemet med Props drilling, ved at komponenter slipper &#229; sende ned un&#248;dvendige props.&#160;<\/p><p>&#160;<\/p><p>React tilbyr en teknikk hvor mange bruker StateHooks. Dette er en teknikk hvor man kan gi og kontrollere tilstander ved komponentene dine. N&#229;r man skal opprette en StateHook, oppretter man en tilstand til en komponent som man kan modifisere.<em> F.eks. const [smile, setSmile] = useState(true);&#160;<\/em><\/p><p>Tilstandene blir ikke lagret i en single-object men blir lagret for seg selv. P&#229; den m&#229;ten kan man legge til og oppdatere selvstendig. Det er ogs&#229; en fordel &#229; bruke Hooks, da man slipper &#229; referer til den n&#229;v&#230;rende tilstanden til komponenten, men opprette en egen tilstand. Hooks kan man sende rundt i komponentene ved &#229; sende det som en Prop. Props muliggj&#248;r dataflyt i React applikasjoner. Det som er forskjellen mellom StateHooks og Props er at Props er immutable. Det vil si at det er read-only verdier.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3806,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er ogs&#229; en global&#160;state management akkurat som React har tilsvarende for Redux, MobX og Context. Hver tilstand til en komponenten kaller de for Atom. En komponent kan legge til og modifisere en atom. Recoil tillatter ogs&#229; at man kan lagre uendelige verdier. For at komponentene skal kunne velge abonnoment, wrapper man applikasjonen med&#160;en RecoilRoot. Dette er fordelaktig da man slipper un&#248;vendige renders men heller kun p&#229; de man abonnomerer p&#229;. En ulempe ved Recoil er at det er lite utbredt i dagens systemer. Dette gj&#248;r deet vanskelig &#229; b&#229;de finne dokumentasjon p&#229; og implementere det p&#229; systemer som allerede tar i bruk de mer etabalerte tilstandsh&#229;ndteringene. I situasjoner der man &#248;nsker et mer flytende tilstandsh&#229;ndtering ville ikke Recoil v&#230;rt gunstig da man m&#229; manuelt kontrollere alle abonnomentene.&#160;<\/p><p>&#160;<\/p><p>Som Context ogs&#229; tilbyr med sin Provider og Consumer, er det ogs&#229;&#160;mulig i Recoil for komponenter &#229;&#160;abonnere p&#229; en Atom. Dersom det skjer noen endringer vil abonnomentene f&#229; en varslet p&#229; at dette har blitt endret ved en rerender.&#160;Noe som skiller Recoil fra Context er at Recoil gir en bedre kj&#248;retid ettersom&#160;komponenter f&#229;r kun endringer fra tilstander som de abonnerer fra. Dette gj&#248;r Recoil mer effektiv. Samtidig som man i Recoil kan lagre uendelige verdier, mens i Context vil man kun lagre statisk data.&#160;<\/p><p>&#160;<\/p><p>Recoil har ogs&#229; ligende egenskaper som StateHooks. Recoil bruker ogs&#229; noe som ligner p&#229; StateHook sin useState. Dette kaller de for useRecoilState(). For &#229; kunne endre p&#229; Atom verdien brukes noe de kaller for en Selector.&#160;<\/p><p>&#160;<\/p><p>Recoil l&#248;ser det samme hovedproblemt som Redux, MobX og Context ved &#229; tilby en global state management. Etter &#229; ha analysert de ulike tilstandsh&#229;ndteringene finner jeg mange likheter ved Recoil og Context API. Begge l&#248;ser problemet ved prop drilling og muliggj&#248;r at komponentene f&#229;r tilgang p&#229; states til andre komponenter. I motsetning til Redux og MobX, kan man i Recoil og Context API&#160;abonnere&#160;p&#229; tilstandene man &#248;nsker, og f&#229; varsel p&#229; eventuelle endringer. Dette kan v&#230;re mer gunstig i mindre systemer da man ikke trenger &#229; ha muligheten til &#229; n&#229; alle mulige tilstander, som man f&#229;r ved Redux og MobX. Men dersom man har mer st&#248;rre og mer komplekse systemer er det mer &#248;nskelig med flytende tilstandsh&#229;ndtering.<\/p><p>&#160;<\/p><p>Samtidig kan man ogs&#229; trekke likhet mellom MobX og Recoil hvor begge har stores som er mutable.Dette gj&#248;r at endringer ved data erstatter tidligere data som ligger der fra f&#248;r av. &#160;I motsetning til Redux som har &#233;n enkel store som er immutable.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":769,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er en arkitektur for &#229; sette opp API. APIet er klienten til databasen men operere som en server for React. REST API sender GET foresp&#248;rsler med en rekke API endepunkt til serveren. Men GraphQL sender kun &#233;n POST foresp&#248;rsel til serveren. Denne PUT foresp&#248;rselen inneholder en sp&#248;rring som skal tolkes og oppfylles av serveren. Serveren skal da&#160;sende det etterspurte JSON objekt tilbake til klienten. I stedet for &#229; kalle forskjellige API-kall til forskjellige endepunkter oppretter vi kun en sp&#248;rring til et endepunkt som returnerer et JSON objekt basert p&#229; dette. &#160;stedet for &#229; &#34;GET&#34; en ressurs, &#34;POST&#34; en sp&#248;rring som beskriver hvilke data du vil ha. Hvor RestAPI ville etterspurt flere Round Trip Times eller Joins i SQL, har GraphQL mindre Round Trip Time&#160;da man kun sender ett API kall. En annen forskjell er at i&#160;GraphQL bruker man skjemaer med definerte felt som skal beskrive hvilke type data man skal hente. Dette skjemaet er et slags avtale mellom backend og frontend for hvilke data man skal returnere. P&#229; denne m&#229;ten muliggj&#248;r det at utviklere kan jobbe uavhengig i backend og frontend.&#160;<\/p><p>En fordel ved Rest API er at det gj&#248;r applikasjonen mer skalerbart fordi du kan sende flere API kall.&#160;<\/p><p>I tillegg er ogs&#229; Rest API mer etablert enn GraphQL og dermed vil det ogs&#229; v&#230;re enklere &#229; finne dokumentasjon p&#229; bruken. I tillegg til at det blir enklere &#229; samkj&#248;re systemer som allerede har dette implementert.&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11540758,"ext_inspera_userAssessmentSetupId":7140122,"ext_inspera_userAssessmentId":4841528,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:12Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Fosså Ingrid (10006)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33113896,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3427,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Tilstand<\/strong><\/p><p>State er det vi kaller tilstanden til eit komponent i React. State vert sett for fyrste gong ved opprettinga av komponentet, og kan endrast&#160;gjennom levetida til komponentet. State kan berre endrast fr&#229; inne i komponentet, og endringar p&#229;verka utanfr&#229; m&#229; handterast hos komponentet. Dette skil seg fr&#229; Props som er ting som skildrar val i komponentet, som ogs&#229; vert sett ved opprettinga av komponentet men ikkje kan endrast gjennom levetida. (Om ein endrar props vert det laga eit nytt komponent.)<\/p><p>&#160;<\/p><p>M&#229;ten state fungerer p&#229; er litt ulik i klassebaserte og funksjonelle komponentar.<\/p><p>&#160;<\/p><p>I klassekomponentar:<\/p><p>(Props og State er interfaces, state har element examState. Props har element weekday)<\/p><p>&#160;<\/p><p>class ExamComponent extends Component&#60;Props, State&#62;<\/p><p>&#160;<\/p><p>B&#229;de argumenta for props og state vert implementert ved at komponentet utvidar klassen Component. Denne gjev oss livssykelmetodar, samt gjer at vi kan bruke this.props.weekday&#160;og this.state.examState for &#229; f&#229; tak i tilstandane til komponentet.<\/p><p>&#160;<\/p><p>I funksjonelle komponentar:<\/p><p>Props vert sendt med som argument i funksjonen, medan handtering av state vert gjort ved hooks. useState gjer at vi stort sett kan behandle examState som i klassekomponenten. Her bruker vi setExamState til &#229; endre tilstanden, og examState til &#229; hente den ut.<\/p><p>&#160;<\/p><p>const ExamComponent = (props: Props) =&#62; {<\/p><p>&#160; &#160; const [examState, setExamState] = useState&#60;string&#62;(&#34;Good&#34;);<\/p><p>}<\/p><p>&#160;<\/p><p>Dersom komponentet t.d. inneheld eit skjema kan det vere lurt &#229; gjere det om til eit ControlledComponent, dette er &#229; innkapsle skjemaet (form) slik at state og input i skjemaet altid er like. Her legg ein til t.d. handleInputChange p&#229; eit inputfelt, denne endrar state i komponentet, og set derretter teksten i inputfeltet til &#229; vere state.&#160;<\/p><p>&#160;<\/p><p><strong>Dataflyt<\/strong><br />Den mest grunnleggande forma for dataflyt er n&#229;r eit forelderkomponent sender props til bornet sitt.<\/p><p>(i InsperaComponent, forelder til ExamComponent)&#160;<\/p><p>&#160;<\/p><p>&#60;ExamComponent weekday=&#34;tuesday&#34;/&#62;<\/p><p>&#160;<\/p><p>Eit borne-komponent kan gje informasjon til forelderen sin ved &#229; f&#229; sendt ned ein funksjon fr&#229; forelderen som prop, og kalle denne n&#229;r forelderen skal ha informasjonen.<\/p><p>&#160;<\/p><p>Ei av utfordringane i React er dataflyt over st&#248;rre avstandar, spesielt mellom syskjen/syskjenborn. Om ein skal gjere det p&#229; m&#229;ten over m&#229; felles informasjon vere lagra hos fyrste felles &#34;slektning&#34;. Dette gjer at mykje informasjon m&#229; sendast opp og ned gjennom mange komponent i &#34;slektstreet&#34; (prop drilling), som auker risikoen for manuelle feil. Dersom ein t.d. skal leggje til fleire props m&#229; dette oppdaterast manuelt i alle komponent informasjonen vert sendt gjennom.<\/p><p>&#160;<\/p><p>Ein kan sende heile komponent som props gjennom andre komponent, og bruke children-funksjonaliteten til React. Dette gjer at meir av informasjonen kan endrast direkte hos forelderkomponentet.<\/p><p>Sendinga vert gjort slik:<\/p><p>&#60;InsperaComponent&#62;&#60;ExamComponent weekday==&#34;tuesday&#34;/&#62;&#60;/InsperaComponent&#62;<\/p><p>&#160;<\/p><p>I st&#248;rre prosjekt kan ei betre l&#248;ysing vere &#229; introdusere ei ekstern lagring av tilstandar/verdiar.<\/p><p>Eg skal sj&#229; p&#229; React sin innebygga Context og l&#248;ysinga Redux.<\/p><p>&#160;<\/p><p>Context er eit API som&#160;gjer det mogleg &#229; lagre verdiar som kan n&#229;ast av alle komponent i applikasjonen. Dei vert oppretta gjennom React.createContext({default-value}) og kan for eksempel inkluderast i komponenta gjennom<\/p><p>static contextType = ExamContext;<\/p><p>D&#229; kan komponentet bruke (this.)context.[verdi i context]&#160;til &#229; hente ut eller endre context.&#160;<\/p><p>P&#229; denne m&#229;ten slepp ein &#229; (manuelt) sende props rundt i systemet, og alle states som bruker context vil oppdaterast samtidig som context-verdien vert endra.<\/p><p>&#160;<\/p><p>Redux er ein State Container som bruker ContextAPI-et til &#229; lagre verdiar (states) i eit Store. Store vert gjort tilgjengeleg for alle komponentane i applikasjonen ved &#229; pakke dei inn i ein Provider med value=Store (wrappe dei), der Store er oppretta med Redux sin createStore().<\/p><p>&#160;<\/p><p>State hos Redux har berre lese-tilgang, endringar m&#229; gjerast gjennom Actions. Endringane m&#229; f&#248;lgje m&#248;nsteret dispatch(action) -&#62; reducer -&#62; ny tilstand (state)<\/p><p>Ein reducer er ein funksjon som tek eit argument og ein starttilstand, og basert p&#229; argumentet utf&#248;rer handlingar p&#229; starttilstanden.&#160;Denne vert returnert som ein ny tilstand. Reducer-ar endrar ikkje state i Store direkte.<\/p><p>Dispatch(action) sender action (ein verdi eller ein funksjon, avhengig av kva abstraksjonsniv&#229; ein har lagt implementasjonen sin p&#229;) til ein reducer.<\/p><p>&#160;<\/p><p>Resultatet er at komponentane i applikasjonen kan bruke felles verdiar til &#229; oppdatere eigen tilstand, og til &#229; trigge hendingar i andre komponent.&#160;<\/p><p>&#160;<\/p><p>Context vs Redux:<\/p><p>I st&#248;rre system kan Redux vere praktisk, d&#229; ein kan leggje opp til fleir Reducers og slik &#34;dele inn Store&#34; i ulike delar. (Store vert ikkje faktisk dela opp, det kan berre vere ein Store per applikasjon, men ein kan skilje relevant funksjonalitet for f.eks. Login og Form fr&#229; kvarandre slik at programmeraren oppfattar dei som uavhengige delar.)<\/p><p>Ein fordel med Redux er at state ikkje vert endra direkte i motsetnad til Context, og slik i st&#248;rre grad kan beskyttast fr&#229; feil.&#160;<\/p><p>&#160;<\/p><p>I enkle applikasjonar vil Redux vere overfl&#248;dig, d&#229; det har mange niv&#229; av abstraksjonar og fort gjer prosjektet unaudsynt kompleks. Ein b&#248;r alltid tenke seg om p&#229; om det er naudsynt &#229; bruke tilstandshandsamarar (State Managers) f&#248;r ein implementerar dei. (Med mindre det er eit skuleprosjekt og ein obligatorisk del av oppg&#229;va, der alts&#229;.)<\/p><p>&#160;<\/p><p>Kjelde/her har eg l&#230;rt ting fr&#229;:<br />https://daveceddia.com/redux-tutorial/&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1741,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er eit state management-bibliotek for React, utvikla av Facebook (som ogs&#229; har utvikla sj&#248;lve React). Det er enno i starfasen, fyrste versjon kom i juni i &#229;r. Versjonstalet er enno p&#229; 0.1.2, som indikerar at det enno ikkje er fullstendig ferdigutvikla (sj&#248;lv om det er tilgjengeleg til bruk). Fyrste offisielle versjon av programvare pleier &#229; vere versjon 1.0(.0).<\/p><p>&#160;<\/p><p>State i Recoil best&#229;r av to hovuddelar:<\/p><p>&#160;<\/p><p><strong>Atoms<\/strong><\/p><p>Tilstandseiningar. Desse kan oppdaterast, og komponentar kan &#34;abonnere&#34; p&#229; dei&#160;(subscribe). Alle abonnerande komponent vert re-rendra ved endringar i Atom&#39;et som dei f&#248;lgjer med p&#229;.&#160;<\/p><p>Ein kan bruke Atoms i staden for lokal State i komponenta, og dersom fleir komponent bruker same Atom som sin state har dei delt tilstand.<\/p><p>&#160;<\/p><p><strong>Selectors<\/strong><\/p><p>Funksjonar som tek inn atoms eller andre selectorar som input. Dersom dette vert oppdatert vil funksjonen gjere greiene sine p&#229; nytt (alts&#229; rekne ut/utf&#248;re det&#160;den skal gjere), og varsle dei som lytter p&#229; den (subscribers). Selectors kan brukast til &#229; utleie data basert p&#229; states.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Samanlikna med context og redux<\/p><p>Context vart ikkje optimalisert for &#229; endrast ofte [3], men&#160;for &#229; halde p&#229; t.d. brukarnamn og andre relativt statiske verdiar. Redux er utvikla uavhengig av React, men ein bruker eit tillegg (react-redux) for &#229; f&#229; det til &#229; samhandle med komponentar.&#160;<\/p><p>Recoil er utvikla med React i fokus. I motsetning til Redux st&#248;ttar Recail asynkrone kall, som gjer at ein t.d. lettare kan lagre resultat fr&#229; databasekall i state.&#160;<\/p><p>&#160;<\/p><p>Eg trur Recoil kan verte popul&#230;rt etter kvart som dei er ute av &#34;eksperimentell&#34; fase, fordi det verker som om systemet er mindre kompleks &#229; setje seg inn i enn redux. Eg trur ogs&#229; det vil verte ein fordel at det vert utvikla av dei same som utvikler React, med tanke p&#229; implementeringar/tilpassing til ny funksjonalitet. Eg har ogs&#229; ein mistanke om at Recoil vil verte sett p&#229; som mindre drastisk &#229; implementere i eit prosjekt enn Redux, sidan redux har ganske mykje struktur og filer som skal til for &#229; f&#229; det til &#229; fungere.&#160;<\/p><p>Context kan berre lagre ein enkelt verdi, og eg trur Recoil vil kunne verte ein mellomting mellom &#229; bruke einverdi-state-management Context, og det komplekse Redux.&#160;<\/p><p>Recoil ser ut til &#229; g&#229; raskare &#229; l&#230;re seg enn Redux.<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>[1]&#160;https://recoiljs.org/docs/introduction/getting-started<\/p><p>[2]&#160;https://github.com/facebookexperimental/Recoil<\/p><p>[3]&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1892,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><u>Specification<\/u><\/p><p>REST er ein arkitektur, gjerne bygga p&#229; allereide eksisterande arkitekturar (t.d. HTTP). REST vert i stor grad tilpassa av utviklaren.<\/p><p>GraphQL har eit spesifiseringsutkast, sitt eige &#34;sp&#248;rjespr&#229;k&#34; (query language) og eit definert sett med verkt&#248;y.&#160;<\/p><p>Det er fordelar og ulempar for begge med dette: i Rest har ein stor valfridom, men m&#229; ogs&#229; ta mange val p&#229; korleis ein skal setje opp systemet. Det finnes malar og uoffisielle definisjonar, men ingen spesifikasjon. Hos Graph er rammene i st&#248;rre grad sett p&#229; f&#248;rehand, men det er ogs&#229; fleire ting ein er n&#248;dt til &#229; l&#230;re og setje seg inn i for at det skal kunne brukast.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><u>Henting av data<\/u><\/p><p>GraphQL henter berre akkuratt dei dataa ein treng/bed om, det er lett &#229; avgrense kor mange resultat ein har lyst p&#229;, og kva felt ein vil ha med fr&#229; databasen.&#160;<\/p><p>&#160;<\/p><p>Med ein REST API vil ein f&#229; tilbake eit fullstendig datasett fr&#229; eit endepunkt i s&#248;ket, alts&#229; alle feltene per linje i databasen. Dersom ikkje alle felta trengs vert dette kalla &#34;over fetching&#34;.<\/p><p>&#160;<\/p><p>Ein av fordelane med GraphQL er at ein berre hentar dei dataa ein treng i kvar enkelt sp&#248;rjing. Dette gjer h&#248;gare performace, og mindre unaudsynt ressursbruk. Om ein sp&#248;r etter filmar fr&#229; eit &#229;rstal kan ein velje &#229; berre f&#229; id og namn om dei hos GraphQL, medan ein hos REST f&#229;r all informasjonen som er lagra om filmane.<\/p><p>&#160;<\/p><p>Noko av dette vil eg tru kan forenklast ved &#229; dele opp data i ulike tabellar hos eit REST API slik at ein ved vanlege sp&#248;rjingar berre f&#229;r ut informasjonen ein treng, og heller kan gjere eit ekstra kall om ein treng all informasjonen.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><u>Endpoints<\/u><\/p><p>GraphQL har eitt endepunkt, og ut i fr&#229; dette hentar det dei felta som sp&#248;rjinga ber om.<\/p><p>REST har ofte fleire endepunkt, gjerne basert p&#229; HTTP-verb som skil mellom lesing og manipulering av databasen. (GET, POST, PUT, DELETE)<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p><u>Bruk/popularitet/l&#230;ringskurve<\/u><\/p><p>L&#230;ringskurva hor GraphQL er brattare enn ved REST API, og det er betre og fleire oppl&#230;ringsopplegg p&#229; nettet for sistnevnte. REST har ei stund vore meir popul&#230;rt i bruk, og er i f&#248;lge kjelde 1 i stor grad rekna som brasjestandard.<\/p><p>&#160;<\/p><p>I prosjektet eg var p&#229; var dette ein av hovudgrunnane til at vi utvikla eit REST API i staden for &#229; l&#230;re GraphQL. Vi s&#229;g styrker hos begge, men kor raskt det var &#229; komme i gang med utviklinga vart eit hovudargument.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kjelder:<\/p><p>[1] https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>[2]&#160;https://flaviocopes.com/graphql-vs-rest/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11545829,"ext_inspera_userAssessmentSetupId":7140126,"ext_inspera_userAssessmentId":4841276,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:43:57Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Skurtveit Martin (10080)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":26455268,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2365,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":1,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r man lager en React-applikasjon bruker man en sammensetting av komponenter til &#229; lage et webview. Alle komponentene er satt i et komponenthierarki med &#233;n toppnode, sett bort i fra denne s&#229; har alle komponenter en parent mens de kan ha s&#229; mange siblings og children som de vil.<\/p><p>&#160;<\/p><p>For &#229; h&#229;ndtere dataflyt har komponentene states og props. States kan settes i komponenten mens props er satt i parent og kan dermed ikke endres. Det er mulig for en child &#229; aksessere data i staten til en parent ved at parent sender staten som en prop. Det finnes ogs&#229; biblioteker som lar deg h&#229;ndtere states globalt.<\/p><p>&#160;<\/p><p>I en React komponent er det flere lifecycles og f&#248;rst n&#229;r en komponent blir rendret (eller mountet) s&#229; blir state og props lest. Etter rendring s&#229; vil en hver endring i en state eller en prop trigger en re-render av komponenten.<\/p><p>&#160;<\/p><p>Eksempler p&#229; hva states og props lar deg gj&#248;re:<\/p><ul>\t<li>Dynamisk visning av data<\/li>\t<li>Toggling av komponenter<\/li>\t<li>Avansert logikk til &#229; skreddersy brukergrensesnittet<\/li><\/ul><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1502,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek som lar utvikleren opprette shared states p&#229; en effektiv m&#229;te. Redux og MobX er begge ganske tungvint &#229; komme i gang med, og det ser ut som Recoil er lettere. En vesentlig detalje for Recoil er at den kun er tilegnet bruk p&#229; funksjonelle komponenter.<\/p><p>Fordeler ved Recoil er at det tillater en mer effektiv shared state og at endringer ikke krever fullstenidng re-rendering av App-komponenttreet, noe som gj&#248;r Recoil mer egnet for lightweight applikasjoner.<\/p><p>En av ulempene med Recoil er at man ikke har tilgang til de samme handlingene som Redux kan gi gjennom actions og reducers, som lar en applikasjon skalere effektivt.<\/p><p>&#160;<\/p><p>Hovudforskjellen mellom MobX og Recoil er at MobX ikke er skrevet kun for React, og dermed krever litt mer oppsett, mens Recoil er skrevet for React og f&#229;r en liten fordel. Ulempen her er at dersom man noen gang skal g&#229; over til et annet UI-rammeverk enn React s&#229; er Recoil bortkastet, mens MobX fortsatt kan brukes.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":621,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I et REST API har et hvert endepunkt kun &#233;n jobb, du kan ikke gj&#248;re no mer (eller mindre) enn det endepunktet er satt til &#229; gj&#248;re. Graphql er sp&#248;rringbasert, slik at man kan gj&#248;re alt man &#248;nsker &#229; gj&#248;re, presist og effektivt i et kall. Fordelen med REST API er at det kan enkelt og oversiktlig dokumenteres, ettersom endepunktene er faste. Graphql er litt verre, siden alt er i en og samme sm&#248;rje. Fordelen med Graphql er at du aldri trenger &#229; utf&#248;re mer enn et kall per handling, og at man aldri har overfl&#248;dig data, ikke noe underfetching eller overfetching. Graphql har en brattere l&#230;ringskurve, men kan v&#230;re verdt investering i det lange l&#248;p.<\/p>"}]}],"ext_inspera_totalScore":5,"score":5}},{"result":{"sourcedId":11541222,"ext_inspera_userAssessmentSetupId":7140035,"ext_inspera_userAssessmentId":4841452,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:00:22Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sundt Jonas Hvidsten (10050)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443813,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2447,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>&#160;<\/p><p>I react-applikasjoner er det viktig &#229; h&#229;ndtere dataflyt og tilstand til og mellom de ulike komponentene, og dette gj&#248;res ofte separat for hver komponent.&#160;Dette gj&#248;res ofte med useState-hooken som man importerer fra react, som gir mulighet for read/write av state innad i komponenten. Man skal f.eks aldri endre p&#229; state p&#229; en variabel direkte, men heller ved &#229; bruke setState() metoden.<\/p><p>&#160;<\/p><p>For at komponentene skal kunne snakke sammen kan state passes som props til andre komponenter, i en enrettet vei, slik at subkomponenten kan ta nytte av staten for &#229; rendere seg selv. Enhver komponent bruker kun de props og state som den selv har tilgang p&#229; for &#229; rendere.&#160;Typescript gj&#248;r for det meste at man ikke skal kunne sende feil type av props til enhver komponent, som omtales som en veldig vanlig feil ved utvikling.<\/p><p>&#160;<\/p><p>Redux er et stateh&#229;ndteringsverkt&#248;y som gj&#248;r at komponentene slipper &#229; sende props opp fra komponentene som ved st&#248;rre applikasjoner gj&#248;r det veldig uoversiktlig + un&#248;dvendig for noen av komponentene &#229; lagre states de selv ikke skal bruke, kun passe ned. Isteden ligger staten til applikasjonen i en store som komponentene kan benytte seg av. Dette gj&#248;r det mer oversiktlig under utvikling. Redux bruker actions, selectors, reducers og store. Actions er handlingene som sendes fra applikasjonen til store, selectors returnerer data fra en input-state, reducers bruker action-input til &#229; bestemme endringer til en state, store lagrer dataen som senere kan provides til appen.<br /><br />Context er ogs&#229; en m&#229;te &#229; dele state globalt i applikasjonen, og gj&#248;r mye av samme arbeid som Redux gj&#248;r med forskjeller som forskjellig re-rendering, begrenset devtools ift redux.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2442,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>Recoil er et bibliotek for h&#229;ndtering av state, litt som Redux /Mobx/Context.<\/p><p>Vanligvis har man ulempen med h&#229;ndtering av state i st&#248;rre prosjekt som gj&#248;r at props m&#229; sendes oppover fra komponenter for &#229; kunne dele de med hverandre, men dette tar etterhvert mye plass.<\/p><p>Recoil definerer en direkte rettet graf til React-treet som gj&#248;r at state-endringer g&#229;r fra r&#248;ttene (atomene) gjennom funksjoner (selectors) til komponentene. Gj&#248;r at state kan byttes ut med &#34;derived&#34; data uten &#229; endre p&#229; komponentene som bruker det.<\/p><p>&#160;<\/p><p>Noe enklere &#229; sette opp enn Redux, ingen boilerplate, og med mye av samme funksjonaliteten som Redux gj&#248;r for deg. Istedenfor en store har recoil flere atoms som komponentene &#34;abonnerer p&#229;&#34;, kan v&#230;re en god l&#248;sning i st&#248;rre prosjekt. Fordel med Recoil er at kun de komponentene som er abonnert p&#229; et&#160;endrende atom vil oppdatere seg, og dermed senke kj&#248;retiden p&#229; updaten. I Redux fungerer det greit &#229; skape lignende funksjonalitet vha selectors.<\/p><p>&#160;<\/p><p>Synes likevel Redux virker hensiktsmessig &#229; bruke for egen del og ved st&#248;rre prosjekt, men man kan selvf&#248;lgelig vurdere &#229; g&#229; over til recoil pga ytelsesforbedringer. Vil tro at Redux er godt etablert med&#160;s&#229;pass&#160;gode devtools at det antas som det beste &#229; bruke i de fleste sammenhenger.<\/p><p>&#160;<\/p><p>https://recoiljs.org<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2242,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Begge tar nytte av &#229; sende HTTP requests for &#229; f&#229; tilbake data. Begge har struktur for resources men p&#229; forskjellig m&#229;te. Man kan spesifisere quiries for &#229; f&#229; disse, og begge kan returnere JSON data.<\/p><p>&#160;<\/p><p>REST - hver&#160;resource identifiseres med en URL og man m&#229; sende en GET request for &#229; f&#229; den dataen.<\/p><p>GraphQL har forskjellig struktur p&#229; datatypene enn REST.<\/p><p>&#160;<\/p><p>Endepunktet man kaller p&#229; i REST er identiteten til det spesifikke objektet, mens i Graphql&#160;er identiteten separat fra det man fetcher&#160;fra. Graphql sender kun det klienten sp&#248;r om p&#229; et visst tidspunkt, mens REST sender hele objektet og alle attributtene (dette kan v&#230;re un&#248;dvendige i tilfeller der man f.eks kun vil ha navn p&#229; en person, og ikke bosted, f&#248;dselsdato etc..). Man har med REST ingen m&#229;te &#229; begrense dette p&#229;. Problem med REST er vanligvis at det kan v&#230;re tregt n&#229;r man m&#229; gj&#248;re flere un&#248;dvendige round-trips for &#229; f&#229; tak i relaterte data som ikke er i samme resource. Graphql kan p&#229; mange m&#229;ter sees p&#229; som en stor graf der ting er koblet til hverandre, ikke separate resources slik som med&#160;REST. S&#229; man kan gj&#248;re presise kall som gir den dataen man vil ha tak i uten &#229; f&#229; masse overfl&#248;dig informasjon i tillegg til &#229; skaffe denne dataen raskt.<\/p><p>&#160;<\/p><p>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11542627,"ext_inspera_userAssessmentSetupId":7140082,"ext_inspera_userAssessmentId":4841391,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:01:16Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Saugestad Aksel (10205)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35240985,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3423,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React bruker det som kalles &#34;top-down&#34; eller &#34; unidirectional&#34; dataflyt hvor data eller UI bare kan p&#229;virke barna deres, alts&#229; komponentene under dem i hierarkitreet(det er ogs&#229; mulig med call-back funksjoner som gj&#248;r at barnekomponenter kan endre tilstand/state til foreldere(data blir sendt oppover)).<\/p><p>&#160;<\/p><p>Komponenter vet ikke om andre komponenter inneholder objekter med state, s&#229; tilstanden til objekter er da satt lokalt og innkapslet og n&#229;r en komponent f&#229;r data i f.eks formen this.state.test s&#229; vil den se p&#229; den likt som noe som er skrevet: test=1.<\/p><p>&#160;<\/p><p>React sine mekanismer for tilstand og dataflyt p&#229; at du har state/tilstand som er komponentenes data som kan endres i kj&#248;retiden og &#34;properties&#34; som er data som sendes til komponenter n&#229;r de blir opprettet.<\/p><p>&#160;<\/p><p>P&#229; grunn av at samme data kan trenges flere steder og p&#229; tvers av hierakriet s&#229; brukes ofte global state management for st&#248;rre prosjekter(eks. redux eller mobx). Global state management gj&#248;r at det er et sted hvor dataene blir lagret og hvor man kan lagre automatisk oppdatering n&#229;r dataen endres for alle komponenter som bruker dataen.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2270,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil bruker &#34;atom&#34; og &#34;selector&#34;.<\/p><p>Atom er en state/tilstand som komponenter som bruker blir &#34;subscribed&#34; til. Atom kan oppdateres og vil da endre verdien til alle komponenter som er &#34;subscribed&#34;.<\/p><p>&#160;<\/p><p>Selector er en funksjon som kan bruke atoms og andre selectorer og returnere noe fra den, den &#34;transformerer&#34; tilstanden til atoms.<\/p><p>&#160;<\/p><p>Den mest &#229;penbare forskjellen fra recoil mot <span>Context<\/span><span>, <\/span><span>Redux<\/span><span>, <\/span><span>MobX er at det er mye mindre oppsett for &#229; sette det opp og bruken av recoil krever ikke en omskriving av koden for &#229; implementeres. Det er mindre &#34;boilerplate&#34; kode, hvor det ikke trengs &#229; lage reducers og actions, men heller fungerer p&#229; linje med setState som er vanlig React.<\/span><\/p><p>&#160;<\/p><p>En fordel med recoil er at oppdatering i tilstand ikke krever at hele App komponent treet m&#229; bli re-renderet, men bare de komponentene som er &#34;subscribed&#34;.<\/p><p>En annen fordel er at recoil ble laget etter at React hooks ble laget, mens de andre ble laget f&#248;r hooks og mangler noe av <span>kompatibilitet.<\/span><\/p><p>En ulempe er at recoil er mye nyere og dermed vil ikke ha like mye st&#248;tte for debugging og andre biblioteker rundt seg.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1275,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En forskjell er at ved REST API s&#229; lager du request som gir den fullstendige informasjonen til ojektet du s&#248;ker p&#229;, mens med Graphql kan du modifisere hva du &#248;nsker &#229; f&#229; tilbake p&#229; requests. Dette er som f&#248;lge av at requests med REST API bruker en fixed fetch struktur, noe Graphql ikke gj&#248;r. Graphql bruker et enkelt &#34;endpoint&#34;/URL hvor alt er definert innad i den ene URL-en, mens REST API bruker forskjellig &#34;URL/&#34;endpoint&#34; for hver request.<\/p><p>&#160;<\/p><p>Graphql kan bare ta in JSON-data, som ikke er sant for REST API.<\/p><p>&#160;<\/p><p>Koblingen for server og klient skjer p&#229; server siden i REST API, men p&#229; klient siden for Graphql.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11542819,"ext_inspera_userAssessmentSetupId":7140140,"ext_inspera_userAssessmentId":4841189,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:01:37Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Moen Andreas Winther (10098)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":23833979,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2023,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React er det flere m&#229;ter &#229; holde p&#229; verdier. Klassekomponenter har en state som aksesseres med this.state og oppdateres med this.setState. Funksjonelle komponenter har i utgangspunktet ikke state, men dette kan simuleres med en hook som heter useState som returnerer en variabel og en funksjon for &#229; oppdatere variabelen. B&#229;de klassekomponenters state og funksjonelle komponenters useState lagrer data kun lokalt i komponenten.<\/p><p>&#160;<\/p><p>Data kan ogs&#229; sendes mellom ulike komponenter. Dette kan ogs&#229; gj&#248;res p&#229; ulike m&#229;ter. Det enkleste er &#229; bruke props. Da kan variabler deklareres i parent-komponenten og bli aksessert av child-komponenten. Dette fungerer greit for enkel deling av data mellom komponenter. Hvis man derimot skal dele variabler med flere komponenter, og spesielt hvis data skal sendes mange steg ned i komponent-hierarkiet, er det lettere &#229; bruke sentralisert state management. Det finnes mange ulike biblioteker for dette, men de vi har brukt i faget er Redux og Context. Redux bruker en store som holder p&#229; data. Data kan aksesseres med getState og oppdateres med en reducer. Dette kan gj&#248;res fra alle komponenter i applikasjonen. I Context API-et bruker man en context provider som deklarerer variabler. Alle child-komponenter kan aksessere og sette data som en context consumer. En provider kan alts&#229; v&#230;re koblet med flere consumers. Redux og Context oppn&#229;r det samme, men er ganske ulike i implementasjonen. Generelt sett er Context litt lettere &#229; sette opp og &#248;ker ikke bundle size (dependencies), men for data som oppdateres veldig ofte og for store applikasjoner kan Redux v&#230;re bedre.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3559,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for deling av data mellom komponenter (state management), tilsvarende Redux og Context. I motsetning til Redux og Context har man ikke &#233;n sentralisert state, men i stedet et atom for hver variabel. Dette gj&#248;r at m&#229;ten man skriver koden p&#229; blir litt tilsvarende en useState-hook. Et atom har en key og en default verdi. Data kan leses med useRecoilValue og settes med useSetRecoilState og sende inn det gitte atomet som parameter. I Recoil finnes ogs&#229; selectors, som representerer en &#34;derived&#34; state. Selectors har ogs&#229; en key. I tillegg har de en get-funksjon som returnerer en verdi, og en valgfri set-funksjon som returnerer en ny state.<\/p><p>&#160;<\/p><p>En forskjell mellom Redux/Context og Recoil er at Recoil bruker kun hooks, og kan derfor bare brukes i funksjonelle komponenter. P&#229; samme m&#229;te som Context og Redux trenger man i Recoil en provider og en eller flere consumers. I Recoil heter provider RecoilRoot.<\/p><p>&#160;<\/p><p>I tillegg til dokumentasjonen til Recoil har jeg brukt en artikkel fra medium for &#229; sammenligne Recoil og Redux: https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1488,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST API baserer seg p&#229; HTTP requests, og er den tradisjonelle m&#229;ten &#229; lage en web-server p&#229;. REST tar utgangspunkt i CRUD (Create, Read, Update, Delete) med henholdsvis HTTP-metodene POST, GET, PUT, DELETE. I en web-server setter man opp ulike endpoints med ulike HTTP-metoder, som kan aksesseres fra en klient. Klienten sender en HTTP request og f&#229;r en response fra serveren med en gitt statuskode. Funksjonen som kalles ved det gitte endepunktet p&#229; serveren styrer hva som sendes i responsen.<\/p><p>&#160;<\/p><p>GraphQL er et Query-spr&#229;k. I stedet for CRUD bruker GraphQL query for &#229; hente data og mutation for &#229; endre data. Alt gj&#248;res fortsatt via HTTP requests, med GET request for query og POST for mutation, men dette gj&#248;res automatisk av GraphQL, og som programmerer trenger man ikke &#229; bekymre seg for dette. I GraphQL angir man hvilke data man &#248;nsker i stedet for &#229; bruke spesifikke endepunkter. Dette gj&#248;r det mye enklere &#229; forst&#229; koden, spesielt for noen som skal sette seg inn i en eksisterende kodebase, fordi det st&#229;r spesifisert i klientkoden hvilke data man henter ut eller endrer p&#229;. I REST m&#229; man inn i serverkoden for &#229; se hva som faktisk skjer.<\/p><p>&#160;<\/p><p>En annen fordel med GraphQL oppst&#229;r hvis man skal hente mye ulik data. Med et REST API ender man ofte opp med flere API-kall, fordi man f&#248;rst henter ut noe data og s&#229; henter ut mer data basert p&#229; responsen til det f&#248;rste kallet. I GraphQL sendes &#233;n request og &#233;n respons.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11543365,"ext_inspera_userAssessmentSetupId":7139970,"ext_inspera_userAssessmentId":4841358,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:03:59Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Kristiansen Snorre Skjellestad (10136)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443581,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2517,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For &#229; h&#229;ndtere tilstand og dataflyt kan man blant annet&#160;ta i bruk:<\/p><ul style=\"list-style-type:disc\">\t<li>props &#38; state<\/li>\t<li>context<\/li>\t<li>redux &#38; mobX<\/li><\/ul><p>Props &#38; state:<\/p><p>Props og state er React sin innebygde funksjonalitet for &#229; behandle tilstand/variabler og dataflyt. Props brukes til &#229; sende data mellom komponenter, hvor det kun kan g&#229; fra forelder og nedover til barn-komponentene. State brukes lokalt i komponentene til &#229; lage og &#229; kontrollere tilstand, siden det er lokalt kan ikke states sendes til andre komponenter.&#160;<\/p><p>&#160;<\/p><p>Context:&#160;<\/p><p>For &#229; h&#229;ndtere dataflyt m&#229; man sende props gjennom alle kompontene hvor dataen er n&#248;dvendig. Problemer blir da hvis data sendes fra &#248;verste forelder komponent til siste-barn komponent m&#229; dataen sendes nedover hele komponent treet.&#160;Hvis det er data som er relevant for alle komponenter eller et stort flertall, som for eksempel UI-tema, hadde det v&#230;rt gunstig &#229; kunne lagre dataen globalt uten &#229; m&#229;tte sende med props til alle komponentene. Det er dette context-apiet l&#248;ser for oss, slik at man kan lagra dataen over et komponent tre slik at det er tilgjengelig nedover i treet uten &#229; bli sendt med props.&#160;<\/p><p>&#160;<\/p><p>Redux &#38; mobX:&#160;<\/p><p>Redux og mobX h&#229;ndterer dataflyt ved &#229; muligheten til &#229; lagre state i et objekt, en &#34;store&#34; (Redux har kun en, men mobX har muligheten for flere). Ved &#229; lagre states i en store kan komponentene i appen aksessere, endre og f&#248;lge med p&#229; states og endringer. Dette&#160;gj&#248;r de&#160;lignende Context i form av &#229; lagre data globalt slik at flere komponentert har tilgang uten &#229; m&#229;tte sende ned gjennom props, men med utvidet funksjonalitet.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p><p>https://mobx.js.org/the-gist-of-mobx.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2985,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et biblotek som skal l&#248;se noen av problemene/limitasjonene som kommer med &#34;default&#34; React state managment, men samtidig beholdet det &#34;Reactish&#34;. Dette gj&#248;res ved &#229; lage &#34;atoms&#34; som holder tilstander, det er mulig &#229; oppdatere tilstanden som lagres og &#229; f&#248;lge den. &#197; f&#248;lge et atom vil si at komponenten re-rendres hvis staten endre.&#160;Dataflyten f&#248;lger&#160;atomer som er best&#229;r av de states man &#248;nsker og dele mellom flere komponenter. Recoil har ogs&#229; selectors som er funksjoner som tar inn atoms eller selctorer som input og kan returner endring av data slik at logikk som skal utf&#248;res ofte p&#229; en state kan gj&#248;res i selector og ikke i komponentene.&#160;<\/p><p>&#160;<\/p><p>P&#229; listen over l&#230;rem&#229;l st&#229;r blant annet Redux, som ogs&#229; &#248;nsker &#229; forbedre state managment i React. Redux fungerer ved at det lages et &#34;store&#34; objekt som data lagres i og s&#229; aksesserer komponentene &#34;storen&#34; for &#229; lese, endre eller lytte p&#229; states. Fordelene med Recoil er da at man ikke har behov for &#229; lage et &#34;store&#34; objekt og komponenten &#34;subscriber&#34; til atomene de trenger.&#160;<\/p><p>I forhold til Context har Recoil den fordelen at siden komponenter ikke har alle states, men kun til de atomene de trenger re-rendres ikke hele applikasjonen p&#229; endring av states.<\/p><p>Negative sider med atoms er at det fortsatt er tidlig i utviklingsfasen, som kan f&#248;re til at det er bugs, men ogs&#229; at det ikke enda er mye informasjon p&#229; nettet til hvordan man bruker det.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1385,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest api fungerer ved at man lager enderpunkter for &#229; hente ut data fra databasen. Her kan filtrering og endring av dataen gj&#248;res i kallet til endpunktet. I Rest m&#229; man v&#230;re helt spesefik p&#229; kallene sine, dette kan f&#248;re til at man m&#229; gj&#248;re fler kall og det kan forkomme overfetching.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>GrapQL&#160;slipper &#229; definere endepunkter, og kan v&#230;re mindre konkret i kallene sine. Gr<\/p><p>&#160;<\/p><p>Forskjeller er at i Rest m&#229; du definere objektet f&#248;r du kaller og GraphQl etter. Dvs, Rest definerer du objektet i backend og graqQl i frontend.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://graphql.org/learn/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11532835,"ext_inspera_userAssessmentSetupId":7140027,"ext_inspera_userAssessmentId":4841383,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Mikalsen Morten André Stenhaug (10235)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35199467,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1491,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React st&#248;tter en form for lokal state som brukes til &#229; lagre og behandle dynamisk data i den gjeldende komponenten. Denne typen state kan kun brukes eller endres i den gitte komponenten. Det finnes derimot en annen dataflyt metode, props, som s&#248;rger for at den lokale staten kan brukes i &#34;lavere&#34; komponenter. Props kan bli sendt ned til en komponent lenger nede i hierarkiet, og kan v&#230;re b&#229;de variabler og funksjoner. I praksis fungerer props og state likt i at de begge kan bli&#160;forandret, lest&#160;og dynamisk endret p&#229; akkurat samme m&#229;te. Props kan bli sett p&#229; som en type &#34;ekstern&#34; state, eller en form for videresending av en lokal state. Det finnes ogs&#229; en annen state management bygd inn i React App, context APIet. Dette lager en global state som kan bli &#34;consumed&#34; av hvilken som helst komponent som trenger det. Disse tre typene er innebygd i React, men det finnes ogs&#229; andre tredjeparts muligheter, hovedsakelig Redux og MobX. Begge disse fungerer b&#229;de med vanlig JavaScript, i tillegg til React. Disse fungerer begge ogs&#229; som en global state management, likt som Context APIet.&#160;<\/p><p>&#160;<\/p><p>React tilbyr ogs&#229; egne funksjoner som ComponentDidMount for klassekomponenter, og useEffect for funksjonelle komponenter. Disse funksjonene sjekkes hver gang en komponent re-rendrer og brukes til &#229; interagere med staten, enten ved &#229; oppdatere den eller lese den. I tillegg kan all data bli brukt direkte i tsx-koden og bli dynamisk endret. For eksempel vil:<\/p><p>return&#160;(<\/p><p>&#160;&#160;&#160;&#160;&#60;div&#62;<\/p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#60;p&#62;{data}&#60;/p&#62;<\/p><p>&#160;&#160;&#160;&#160;&#60;/div&#62;<\/p><p>)<\/p><p>Oppdateres automatisk p&#229; applikasjonen hvis data endres.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2449,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et Global State Management bibliotek. I pensum har vi g&#229;tt over tre andre Global State Management l&#248;sninger, Redux, MobX og Context APIet (Teknisk sett ikke et bibliotek, men er i l&#230;ringsm&#229;let). Det f&#248;rste vi legger merke til med Recoil er at det er lagd til React, og st&#248;tter bare React. Dette er i motsetningen til Redux og MobX som er lagd for JS og har tillagt st&#248;tte for React. Dette vises tydelig i dokumentasjonen til Recoil. Oppsettet av den globale staten med RecoilRoot er akkurat lik som vi har sett p&#229; med de andre l&#248;sningene. Men, i henting og endring av den globale staten ser vi at RecoilRoot har en mer React orientert l&#248;sning, med &#229; &#34;herm&#34; etter React. Vi kan se at metoden for &#229; lage et &#34;atom&#34; er:&#160;<\/p><p>const [todoList, setTodoList] = useRecoilState(todoListState);<\/p><p>og vi vet at dette f&#248;lger det samme oppsettet som React, for eksempel koden for &#229; bruke&#160;state i funksjonelle komponenter:<\/p><p>const [input, setInput] = useState() (Uten typescript for &#229; ligne Recoil)<\/p><p>&#160;<\/p><p>Recoil har ogs&#229; en&#160;funksjonalitet &#34;Selector&#34; som kan hente ut spesifikk data fra en eller flere states. Dette er veldig praktisk og effektivt for koding med en global state som modifiseres mye eller interagerer i flere forskjellige m&#229;ter.<\/p><p>En ting Recoil mangler som finnes i de andre l&#248;sningene, er &#34;actions&#34;. I MobX og Redux brukes actions til &#229; endre state p&#229;, dette s&#248;rger for to viktige ting.&#160;For det f&#248;rst s&#248;rger det for at all mutasjon/endring av state behandles p&#229; riktig m&#229;te. For det andre gj&#248;r det at state kan bli endret utenfor en komponent.&#160;<\/p><p>&#160;<\/p><p>I tillegg til alt dette st&#248;tter ogs&#229; Recoil&#160;asynchronous funksjoner, med &#229; vente p&#229; promises. Dette s&#248;rger for at staten ikke oppdateres f&#248;r all dataen er hentet. I tillegg st&#248;tter Recoil Suspense funksjonaliteten til React, som gj&#248;r at man kan vise noe annet til brukeren mens all dataen hentes. Det er ogs&#229; mulig &#229; bare ha en default verdi, og s&#229; vil Recoil re-rendre applikasjonen etter den har hentet dataen.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3016,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er forskjellige typer backend arkitekturer. De blir begge mye brukt i utviklingen av nettsider og er begge effektive valg. REST brukes ved &#229; hente data fra en spesifikk URL etter domenet til backend serveren for eksempel:<\/p><p>ip-adresse:port/land/1<\/p><p>Dette vil hente landet med id 1 hvis man bruker get metoden.&#160;<\/p><p>I Graphql henter man ikke ved hjelp av URL, men ber heller om den n&#248;yaktige dataen man vil ha. For eksempel kunne man sende queryen:<\/p><p>query{<br />&#160;&#160;&#160;&#160;land(id: &#34;1&#34;) {<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hovedstad<br />&#160;&#160; &#160;&#160;&#160; &#160;populasjon<br />&#160;&#160; &#160;&#160;&#160; &#160;spr&#229;k<br />&#160;&#160; &#160;&#160;&#160; &#160;valuta {<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;symbol<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;}<br />}<\/p><p>For &#229; hente det samme som i REST eksemplet. Forskjellen mellom disse eksemplene er at vi for eksempel ikke henter navnet til valutaen i Graphql eksemplet, men henter det i REST eksemplet. Dette er en av fordelene til Graphql, at det ung&#229;r overfetching. Av samme grunn s&#248;rger den ogs&#229; for at det ikke blir underfetching, det er henting av for lite data med en sp&#248;rring. Men, i motsetning til REST, st&#248;tter Graphql bare JSON, og kan dermed ikke sende andre typer data, som for eksempel bilder, man m&#229;&#160;heller sende en URL&#160;til bildet (Dette er en mer optimal l&#248;sning, men ogs&#229; en&#160;restriksjon i Graphql). I tillegg er det en st&#248;rre sikkerhetstrussel ved Graphql fordi det er ikke ferdigdefinerte &#34;endpoints&#34; som bestemmer all dataen som man skal motta. Dette gj&#248;r at det er mulig &#229; sp&#248;rre om hva som helst, og man m&#229; implementere ekstra sikkerhetslag for &#229; unng&#229; dette. Og p&#229; grunn av at man ikke henter fra spesifikke URLer foreg&#229;r ikke caching av dataen automatisk i HTTP-laget, slik som det gj&#248;r i REST.<\/p><p>&#160;<\/p><p>Alt i alt kan man si at Graphql er en mer effektiv l&#248;sning enn REST, men trenger veldig mye mer oppsett og arbeid for &#229; komme i gang. I sm&#229; eller medium store backender er det veldig mulig at alle godene til Graphql ikke blir brukt, og vil fungere p&#229; nesten lik m&#229;te som REST. Men i slike tilfeller vil Graphql l&#248;sningen ha f&#248;rt til mer arbeid og kode, b&#229;de p&#229; selve backenden, men ogs&#229; p&#229; frontenden. Men ettersom databasen utvides med nye tables og fields vil nytten til Graphql vise seg.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11532868,"ext_inspera_userAssessmentSetupId":7140033,"ext_inspera_userAssessmentId":4841305,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ek Ronja Linnéa Bævre (10089)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303482,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2745,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har man b&#229;de elementer som representerer DOM tags, samt elementer som representere brukerdefinerte komponenter.&#160;&#160;N&#229;r React oppdager elmenter som representerer brukerdefinerte komponenter, sendes JSX atributter og barn til denne komponenten som et enkelt objekt. Dette objektet kalles &#34;props&#34;. Props kan ses p&#229; som en m&#229;te &#229; sende data mellom komponenter p&#229;. N&#229;r det kommer til brukerdefinerte komponenter skiller man mellom klassekomponenter og funksjonelle komponenter. Klassekomponenter kalles ogs&#229; &#34;stateful&#34; fordi de implementerer logikk og tilstand, mens funksjonelle komponenter kalles derimot &#34;stateless&#34;, ettersom de tar inn input data og returnerer samme resultat for samme type input.<\/p><p>&#160;<\/p><p>Hooks er en m&#229;te &#229; h&#229;ntere tilstand uten &#229; ta i bruk klassekomponenter.&#160;UseState er et eksempel p&#229; en tilstands Hook. UseState inneholder n&#229;v&#230;rende tilstand, samt en funksjon som lar en oppdatere tilstanden. Denne funksjonen kan kalles inni en funksjonell komponent for &#229; oppdatere den n&#229;v&#230;rende tilstanden. React vil da kunne bevare denne tilstanden mellom rerendringene. UseState likner &#34;this.setState&#34; i en klasse, men den sl&#229;r ikke sammen tidligere og n&#229;v&#230;rende tilstander som derimot this.setState gj&#248;r.&#160;<\/p><p>UseEffect er et annet eksempel p&#229; Hook. Operasjoner som data fetching, subsscriptions eller manuell endring av DOM fra React komponenter kan kalles &#34;side effects&#34;. Grunnen til dette er fordi de kan p&#229;virke andre komponenter og kan ikke gj&#248;res mens det rendres. Ved bruk av metoden useEffect kan man utf&#248;re side effects fra en funksjonell komponent. UseEffect har samme form&#229;l som componentDidMount, componentDidUpdate og componentWillUnmount, som alle er&#160;&#160;livssykel metoder for klassekomponenter. UseEffect kj&#248;res automatisk etter f&#248;rste render og etter hver oppdatering.<\/p><p>&#160;<\/p><p>Tilstandsh&#229;ndtering kan v&#230;re en utfordring med React. Tre mulige m&#229;ter &#229; h&#229;ndtere tilstand p&#229; er Context, Redux, og MobX. Hver av de tre teknologiene har fordeler og ulemper, og dermed ogs&#229; noe forskjellig bruksomr&#229;der.&#160;Uten noen form for state management er man for eksempel n&#248;dt til &#229; sjekke p&#229; hver komponent i et prosjekt&#160;om en bruker er autentifisert eller ikke. For &#229; kunne f&#229; til dette er man n&#248;dt til &#229; sende props ned til hver komponent i komponenthierarkiet ved hver endring. Det kan anses som en umulig oppgave ved st&#248;rre applikasjoner. Det er dermed et behov for en form for tilstandsh&#229;ntering.&#160;<\/p><p>&#160;<\/p><p>Context er designet for &#229; dele data som kan betraktes som &#34;globale&#34; for et hierarki av React-komponenter. M&#229;let med Context er &#229; slippe &#229; sende samme data som props gjennom flere niv&#229;er i komponenthierarkiet. Context brukes derfor prim&#230;rt n&#229;r noe data m&#229; v&#230;re tilgjengelig for flere komponenter p&#229; forskjellige niv&#229;er i hierarkiet. Baksiden med &#229; ta i bruk Context er at det gj&#248;r gjenbruk av komponenter vanskeligere, og burde derfor kun brukes dersom det er n&#248;dvendig. Context fungerer ved at man wrapper en provider rundt en komponent som ligger h&#248;yt opp i komponenthierarkiet. Alle&#160;barn som ligger under denne komponenten i hierakiet har da tilgang p&#229; Contexten.&#160;Innf&#248;ringen av Hooks har gjort Context enda mer verdifult. Det kan til tider v&#230;re nyttig &#229; oppdatere Contexten fra et lavere niv&#229; i komponenthierarkiet. For &#229; kunne gj&#248;re dette kan man legge til en funksjon i Contexten. Dersom man endrer p&#229; noe i context funksjonen&#160;vil koden renderes og oppdateres. Ved endring av tilstanden p&#229; et lavere niv&#229; vil derfor alt innni alle consumers innenfor provider, rerendres n&#229;r en prop endres.<\/p><p>&#160;<\/p><p>For variabler som ikke oppdateres s&#229; ofte, s&#229;nn som for eksempel en&#160;n&#229;v&#230;rende autentisert&#160;bruker&#160;eller fargetema&#160;p&#229; websiden, fungerer Context optimalt. Context har mindre boilerplate og er generelt enklere &#229; implmentere enn b&#229;de Redux og MobX, og ved bruk av Context APIet sammen med hooks kan man oppn&#229; mye av det samme som med b&#229;de&#160;Redux og MobX. Om man derimot &#248;nsker &#229; h&#229;ndtere mer komplekse tilstander som oppdateres ofte, er ikke Context et optimalt valg. React Context vil for&#229;rsake en rerender p&#229; hver oppdatering, noe som ikke er heldig i denne sammenhengen. Redux og MobX&#160;er dermed bedre l&#248;sninger ved h&#229;ntering&#160;av komplekse tilstander som oppdateres ofte. Redux og MobX er to bibliotek for&#160;global tilstandsh&#229;ndtering.&#160;<\/p><p>&#160;<\/p><p>Redux er et alenest&#229;ende bibliotek, som kan brukes enten sammen med andre rammeverk, eller kun med vanilla JavaScript. Vanilla JavaScript vil si &#229; ta i bruk JavaScript uten noen tilleggs biblioteker, som for eksempel jQuery. Ved bruk av Redux gir man alle komponentene i hierarkiet tilgang p&#229; &#248;nskede tilstander ved bruk av sentrallagring. Redux lagrer tilstanden til applikasjonen i et uforanderlig objekttre.&#160;&#34;Store&#34; i Redux har som rolle &#229; bevare tilstandstreet til React applikasjonen. Med andre ord&#160;vil det si at den inneholder hele tilstanden til applikasjonen. Store inneholder en eller flere kombinerte reducere, og legges i en provider som wrappes rundt App. P&#229; denne m&#229;ten vil App og alle komponentene som ligger i komponenthierarkiet ha tilgang p&#229; storen. Med dette kan da alle komponenter hente ut tilstanden til storen, men ogs&#229; endre tilstand ved &#229; dispatche action creators, som vil si &#229; dispatche en action. Denne actionen vil da &#34;sendes&#34; til en reducer som oppdaterer Redux tilstanden.&#160;&#160;<\/p><p>&#160;<\/p><p>Mens det i Redux er vanlig &#229; ha &#233;n store,&#160;inneholder MobX derimot&#160;minst 2 stores. MobX har&#160;en store for UI state og en,&#160;eller flere,&#160;for domian state. MobX har sammenliknet med Redux generelt mindre boilerplate kode. Automatisering i MobX forenkler utviklingen og medf&#248;rer at dette kan v&#230;re en enklere tilstandsh&#229;ntering enn Redux.&#160;MobX tar i bruk merkbare eller observerbare data for &#229; kunne&#160;automatisk&#160;spore endringer gjennom subscriptions. I mindre prosjekter som ikke har s&#229; avansert tilstandsh&#229;ndtering vil MobX v&#230;re best der Redux kan f&#248;re til mye boilerplate.&#160;Redux bruker en uforanderlig kilde&#160;for den lagrede tilstanden. Dette betyr at tilstander kan kun leses, og en reducer kan kun overskrive en tilstand n&#229;r en action p&#229;beropes (dispatches).&#160;Med dette kan man se p&#229; Reducere som rene funksjoner, ettersom de mottar en tilstand&#160;og action, og returnerer en ny tilstand. MobX derimot tillater at tilstander lett kan oppdateres og bli overskrevet med nye verdier. MobX kan derfor ses p&#229; som&#160;&#34;inpure&#34;. Redux er med andre ord&#160;mer forutsigbart enn MobX, men&#160;MobX er til gjengjeld enklere &#229;&#160;implementere. Det at MobX er mer uforutsigbart kan ogs&#229;&#160;f&#248;re&#160;til at testing og vedlikehold kan bli vanskeligere som et resultat av&#160;mulig uforutsett output.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2451,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en tilstandsh&#229;nterings bibliotek for React. Som nevnt tidligere er det noen begrensninger ved bruk av Context. Det fungerer godt for tilstander som endres sjeldent, men er derimot ikke optimalt dersom en tilstand endres hyppigere. Som nevnt er&#160;Redux og MobX globale tilstandsh&#229;ndterings bibliotek&#160;som kan utfylle Context sine &#34;hull&#34;. P&#229; lik linje med Redux og MobX er ogs&#229; Recoil et bibliotek som kan brukes der Context ikke strekker til. Recoil omfatter hovedsakelig to ting: Atoms og Selectors.<\/p><p>&#160;<\/p><p>Atoms kan ses p&#229; som enheter av en tilstand som komponenter kan &#34;subscribe&#34; eller abonnere p&#229;. Ved at flere komponenter subscriber p&#229; samme atom&#160;deler dermed disse komponentene de samme tilstandene.&#160;Atoms er mulig &#229; oppdatere.<\/p><p>&#160;<\/p><p>En &#34;selector&#34; er en enkel funksjon som aksepterer enten&#160;atoms eller andre selectors som input. Hver gang en atom eller selector oppdateres, vil slector funksjonen reevalueres. P&#229; samme m&#229;te som komponenter kan subscribe p&#229; atoms, kan de ogs&#229; subscribe p&#229; selectors. Dersom en selector endres vil alle komponenter som subscriber p&#229; denne oppdateres. Selectors kan ogs&#229; brukes til &#229; kalkulere data som baseres p&#229; tilstanden. En selector kan omforme atom tilstanden enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Som nevnt i tidligere oppgave lager man med Redux en store som fungerer som en global variabel. Med Recoil kan denne storen gjenbrukes. I Redux inneholder store en eller kombinerte reducere. I Recoil tar man derimot i bruk atoms, hvor hvert atom kan anses som en delt bit&#160;av en tilstand. I Redux kan alle komponenter hente ut tilstanden til storen, men ogs&#229; endre tilstand ved &#229; dispatche action creators, som vil si &#229; dispatche en action. Denne actionen vil da &#34;sendes&#34; til en reducer som oppdaterer Redux tilstanden. Mens man i Redux bruker dispatch kan med&#160;Recoil endre p&#229; en delt atom tilstand&#160;ved bruk av&#160;selectors.&#160;<\/p><p>&#160;<\/p><p>Som beskrevet i oppgaveteksten er Recoil et Facebook open source bibliotek for React.&#160;At Facebook har laget biblioteket&#160;medf&#248;rer&#160;at likner mye p&#229;&#160;m&#229;ten Facebook&#160;vanligvis skriver React. S&#229; dersom man for eksempel skal bruke et&#160;atom s&#229; bytter man bare ut useState,&#160;som man vanligvis skriver i React,&#160;med useRecoilState der man tar inn et&#160;atom.&#160;<\/p><p>&#160;<\/p><p>Fordelen med Recoil er at det er enkelt og skalerer relativt bra. Recoil fungerer derfor som sagt godt der Context ikke strekker til. Om Recoil vil erstatte Redux er vanskelig &#229; si. Recoil gj&#248;r det mulig &#229; lage en dataflyt fra atoms, som tilsvarer delte tilstander, gjennom selectors, som er funksjoner, og ned til komponentene i komponenthierarkiet. Recoil gj&#248;r dette uten at man er n&#248;dt til &#229; rerendre hele applikasjonens komponenttre n&#229;r tilstanden oppdateres.&#160;&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1976,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Backend omfatter API og database, og APIet brukes som mellomleddet mellom frontend og database. Viktig &#229; skille mellom API og REST API, ettersom REST API er en spesifikk type API.&#160;<\/p><p>&#160;<\/p><p>REST st&#229;r for Representational state transfer, og er et&#160;arkitektonisk konsept&#160;for &#229; skape standarder mellom computer systems p&#229; web. Dette&#160;gj&#248;r det enklere for systemer &#229; kommunisere med hverandre. RESTful systemer karakteriseres ut ifra hvordan de er tilstandsl&#248;se og skiller mellom klient og server. Ved &#229; skille mellom klient og server er det mulig &#229; implementere hver av disse uavhengig av hverandre, s&#229; lenge begge sider er inneforst&#229;tt med formatet p&#229; meldinger som sendes mellom de. Separeringen mellom klient og server medf&#248;rer mer felksibilitet p&#229; brukergrensesnittet p&#229; tvers av ulike plattformer, og forbedrer skalerbarhet ved &#229; forenkle server komponentene. Systemer som f&#248;lger REST paradigmet er tilstandsl&#248;se. Det vil si at serveren ikke trenger &#229; ha noen som helst informasjon om klientens tilstand, eller motsatt. P&#229; denne m&#229;ten kan server og klient forst&#229; alle meldinger som blir sendt, selv uten &#229; se p&#229; tidligere meldinger. REST krever at klienten lagen en request til serveren for &#229; hente eller endre p&#229; data p&#229; serveren. En request best&#229;r som oftest av et HTTP verd som beskriver hva som skal utf&#248;res. Eksempler p&#229; HTTP verb er GET, PUT, POST og DELETE. I tillegg inneholder den en header som tillater klienten &#229; sende videre informasjon om requesten. En request er ogs&#229; n&#248;dt til &#229; best&#229; av &#34;pathen&#34; eller stien til ressursen og kan ogs&#229; inneholde en valgfri meldings body som kan inneholde data.&#160;<\/p><p>&#160;<\/p><p>GraphQL er et query spr&#229;k for API. GraphQL er utviklet med et form&#229;l om &#229; lage API raskt, fleksibelt og utviklervennlig. Det har ingen regler p&#229; hvordan data skal lagres, eller hvilket programmeringssp&#229;k som brukes.&#160;Som et alternativ til REST kan man med GraphQL konstruere requester som henter data fra flere datakilder i et enkelt API kall. API utviklere bruker GraphQL for &#229; lage schema for &#229; beskrive all mulig data som klienten kan query. GraphQL schema er laget av objekttyper som definerer hvilke objekter som requestes og hvilke felter de har. GraphQL validerer query mot schema, for s&#229; &#229; utf&#248;re den validerte queryen. Ved bruk av schema f&#229;r man en&#160;&#34;single source of truth&#34; og setter standarden for hvordan ting skal skrives. Ved &#229; tydelig definere datatyper kan man ogs&#229; redusere sjanse for kommunikasjonssvikt mellom klient og server.&#160;&#160;Fra klientens perspektiv skiller man mellom &#34;queries&#34; og &#34;mutations&#34;. CRUD model st&#229;r for &#34;create&#34;, &#34;read&#34;, &#34;update&#34; og &#34;delete&#34;. Create, read og update tilh&#248;rer queries, mens delete h&#248;rer sammen med mutations.&#160;GraphQL krever ingen spesiell applikasjonsarkitektur. GraphQL tillater ogs&#229; at applikasjons APIet &#34;evolver&#34; uten &#229; bryte eksisterende query.&#160;Ulemper med GraphQL er at for de som er vandt til &#229; bruke REST API er det litt &#229; sette seg inn i for &#229; gj&#248;re seg kjent med query spr&#229;ket. GraphQL flytter mesteparten av arbeidet med dataquery over til serversiden. Dette kan medf&#248;re mer kompleksitet for serverutviklere.&#160;<\/p><p>&#160;<\/p><p>Mens GraphQL er et query spr&#229;k er derimot REST API et arkitekonisk konsept for nettverksbasert utvikling.&#160;REST har de siste &#229;rene blitt brukt til &#229; lage nye APIer, mens GraphQL har blitt mye brukt til &#229; optimalisere for ytelse og fleksibilitet. Ved bruk av REST API til &#229; fetche informasjon f&#229;r man alltid et komplett dataset i retur. Dersom man &#248;nsker informasjon om to objekter, er man med REST API n&#248;dt til &#229; utf&#248;re to requester. Dette er derimot ikke tilfellet med GraphQL. GraphQL kan spesifisere requesten til &#229; returnere akkurat det man &#248;nsker seg. P&#229; denne m&#229;ten kan man query flere objekter samtidig, og ogs&#229; query spesifikke felter i en enhet. REST API har flere endepunkter, mens GraphQL kun har ett.&#160;REST API kan ses p&#229; som bedriftsstandard, og er generelt enkelt&#160;&#229; forst&#229; ved at man har et endepunkt som gj&#248;r en oppgave.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11532960,"ext_inspera_userAssessmentSetupId":7140006,"ext_inspera_userAssessmentId":4841157,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ommundsen Emil (10075)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331054,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1521,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er flere metoder og teknikker brukt for tistand og dataflyt i react. Om man bruker class-based components ligger state lagred i this.state. Her kan man sette den initielle staten i konstrukt&#248;ren med this.state = {}. For eksempel this.state = {verdi: 0}. Vi kan s&#229; bruke denne staten med this.state.verdi andre steder i komponentet. For &#229; endre state benytter man seg av this.setState().<\/p><p>(https://reactjs.org/docs/state-and-lifecycle.html)<\/p><p>&#160;<\/p><p>I funksjonelle komponenter er man n&#248;dt til &#229; bruke hooks. React 1.6 og oppover&#160;har den innebgyde hooken &#34;useState&#34; som kan importeres (https://reactjs.org/docs/hooks-state.html). Da kan s&#229; deklarere en state variabel med const [state, setState] = useState(&#34;startverdi&#34;). Her er state variabelen til n&#229;v&#230;rende state, og vi kan bruke funksjonen setState i dette tilfellet for &#229; endre denne.&#160;<\/p><p>(https://reactjs.org/docs/state-and-lifecycle.html)<\/p><p>&#160;<\/p><p>For dataflyt bruker react properties (props) som er data som kan sendes inn til et komponent n&#229;r det opprettes. Man kan alts&#229; gi data til&#160;komponentets child-components. Dersom man bruker state til props vil komponentet rendre p&#229; nytt n&#229;r state endrer seg, og alle child koponenter blir oppdatert med ny verdi. Det er ogs&#229; mulig &#229; sende call-back funkjsoner oppover fra child til parent. Dette gj&#248;r det mulig for childs &#229; endre state til parent.<\/p><p>(https://reactjs.org/docs/state-and-lifecycle.html) (LF 2018)<\/p><p>&#160;<\/p><p>I tillegg til dette kan vi benytte oss av Context, Redux, MobX osv for en global state. Om vi har mangle lag med komponenter, og de fleste er avhengig av en state vil det v&#230;re upraktisk &#229; sende props nedover hele treet eller p&#229; tvers av hiarakiet. Da kan det v&#230;re gunstig &#229; bruke et state management tool. Da f&#229;r vi en global state som oppdaterer alle avhengige komponenter n&#229;r den oppdateres. Dette blir normalt gjort med en provider &#248;verst i treet, slik at alle childs har tilgang til staten.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3586,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management libary for React som benytter seg av data-flow graphs. Recoil er utviklet for &#229; l&#248;se et par ting som er utfordrende i react, som for eksempel delt state og cross-app observation som gj&#248;r det mulig &#229; observere alle state endringer i hele applikasjonen uten &#229; svekke applikasjonen ved &#229; splitte opp koden.<\/p><p>&#160;<\/p><p>Atoms:<\/p><p>Unit for state. Kan oppdateres og aboneres (subscribe) p&#229;. N&#229;r et atom oppdateres vil alle komponenter som abonerer re-render med den nye verdien.<\/p><p>&#160;<\/p><p>Man kan opprette atoms ved &#229; bruke atom funksjonen.<\/p><p>const fontSizeState = atom({<\/p><p>key: &#39;fontSizeState&#39;,<\/p><p>default: 14,<\/p><p>});<\/p><p>&#160;<\/p><p>Alle atoms trenger en unik n&#248;kkel.<br />For &#229; lese eller skrive til et atom fra et komponent brukes hooken useRecoilState. Denne fungerer som useState, men kan deles mellom komponenter.&#160;<\/p><p>(https://recoiljs.org/docs/introduction/core-concepts)<\/p><p>&#160;<\/p><p>Selectors:<\/p><p>Dette er funksjoner som kan ses p&#229; som en &#34;pure function&#34; uten &#34;side-effects&#34; som alltid&#160;returnerer samme verdi for et gitt sett med dependency values.&#160;<\/p><p>&#160;<\/p><p>Si at vi har brukt&#160;const<\/p><p>[fontSize, setFontSize] = useRecoilState(fontSizeState);<\/p><p>som nevnt over.&#160;<\/p><p>&#160;<\/p><p>Da kan vi for eksempel lage en&#160;fontSizeDoubleSelector&#160;<\/p><p>&#160;<\/p><p>const fontSizeDoubleSelector = selector({<\/p><p>key: &#34;eksempel&#34;<\/p><p>get: ({ get}) =&#62; {<\/p><p>return get(fontSize) * 2;<\/p><p>}<\/p><p>});<\/p><p>&#160;<\/p><p>denne kan s&#229; brukes globalt og gi oss den doble veriden av fontSize (dependenzy). Om fontSize endres vil ogs&#229; resultatet fra selectoren endres.<\/p><p>&#160;<\/p><p>Man kan ogs&#229; legge til flere funkjsoner enn get, for eksempel set og reset.<\/p><p>(https://recoiljs.org/docs/api-reference/core/selector/)<\/p><p>&#160;<\/p><p>Recoil kan p&#229; mange m&#229;ter sammenlignes med andre state management systems som for eksempel Redux. I motsetning til Redux som bruker actions og reducers bruker Recoil kun storage for delt state (atoms) (https://medium.com/swlh/a-quick-glance-at-recoil-d276c22c7efe). Ved bruk av Redux har man en delt global state i hele applikasjonen. Problemet med dette kan v&#230;re un&#248;dvendige re-renders, ved at hele applikasjonen re-rendrer om veldig mange komponenter er barn av konteiner komponentet. Dette kan fungere bra i mange tilfeller, men i noen tilfeller ikke. Om det er mange individuelle deler p&#229; som er rendret og man har noen states som kun deler av siden trenger, kan recoil s&#248;rge for at kun disse re-rendrer ved endring. (https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10).&#160;<\/p><p>&#160;<\/p><p>En ulempe med Recoil er at det er relativt nytt, og det kan v&#230;re ferre ressureser dersom det oppst&#229;r problemer. Dersom man ikke har problemer med ytelse og for mange re-renders er det ikke n&#248;dvendig &#229; bruke det.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2040,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest er et API som lar to ulike applikasjoner kommunisere gjennom et felles spr&#229;k.&#160;<\/p><p>&#160;<\/p><p>I rest benyttes HTTP-protokollen der man&#160;sender man en read, write eller delite kommando, hvor det er&#160;definerer hvilke data som skal returneres for en enitiet/resures,&#160;med en http request til en URI.<\/p><p>Det er et tydelig skille p&#229; hva som er klient og serverens ansvar.<\/p><p>(Forelesning, Intro prosjekt 3).<\/p><p>&#160;<\/p><p>Fordelen med rest er at man kan benytte seg av caching mekansimen til weblesere. (LF kont 2019)<\/p><p>Endepunktene er velidg tydlige, dette gj&#248;r det enkelt &#229; forst&#229; hva endepunkte gj&#248;r/tilbyt.<\/p><p>&#160;<\/p><p>Ulempen med Rest er at i st&#248;rre systemer kan det v&#230;re mange endepunkter og hvor man m&#229; gj&#248;re mange kall&#160;for &#229; hente data. I tilleg kan det v&#230;re tilfeller med overfetching der man henter mer data enn n&#248;dvendig. (LF kont 2019)<\/p><p>&#160;<\/p><p>I GraphQl sender man en sp&#248;rring til en server hvor man definerer b&#229;de s&#248;k og hvilke data som skal returneres. I graphQl kan alll data hentes i en request og man unng&#229;r derfor lasting av for mye data (overfetching).<\/p><p>I tillegg har graphQl et typesystem som dokumenterer og validerer.<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>GraphQl st&#248;tter kun jSon data.<\/p><p>M&#229; v&#230;re en kobling mellom klient og tjener<\/p><p>Ikke implisitt caching i HTTP-laget<\/p><p>(Forelesning, Intro prosjekt 3)<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533259,"ext_inspera_userAssessmentSetupId":7139947,"ext_inspera_userAssessmentId":4841280,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Aurud Lars Murud (10056)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":24857698,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1975,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har flere ulike mekanismer og teknikker for &#229; h&#229;ndtere dataflyt og tilstand i applikasjonen. Det er viktig &#229; p&#229;peke at disse teknikkene varierer litt avhengig av om man bruker funksjonelle&#160;eller klasse komponenter.<\/p><p>&#160;<\/p><p>En av de viktigste konseptene i React er state. I klasse komponenter er state et unikt objekt i hver instans av en komponent. State skal behandles som immutable, og kan defor bare leses. Dersom man &#248;nsker &#229; endre p&#229; state, m&#229; man bruke this.setState({...}) som vil lage en ny state. Dersom den nye tilstanden er forskjellig, vil komponenten og dens barn oppdateres og rendres p&#229; nytt og kalle componentDidUpdate(). Fordelen med denne m&#229;ten &#229; h&#229;ndtere state er at man kun trenger &#229; rendre p&#229; nytt n&#229;r det er n&#248;dvendig.&#160;<\/p><p>&#160;<\/p><p>I en funksjonell komponent, vil man bruke useState(defaultState) som vil returnere en variabel og en funksjon&#160;for &#229; oppdatere state variabelen. Man kan ogs&#229; bruke hooken useEffect() hvor man kan kj&#248;re kode n&#229;r spesifike deler av state endres, siden man ikke kan bruke for eksempel componentDidMount().<\/p><p>&#160;<\/p><p>Et annet viktig konsept i React er props, for &#229; kunne ha dataflyt mellom komponentene. Hovedsaklig er props ment for &#229; sende data til barne-komponenter, da props fungerer som input til en komponent. Det er ogs&#229; mulig &#229; oppn&#229; dataflyt fra et barnekomponent til forelder-komponenten, gjennom en callbackfunksjon som kan sendes til barnet som en prop. P&#229; denne m&#229;ten kan barnet kalle funksjonen n&#229;r en datavariabel endres. Det er viktig &#229; p&#229;peke at props ikke kan endres, uten at komponenten m&#229;&#160;initialiseres p&#229; nytt.<\/p><p>&#160;<\/p><p>Prop mekansimen har desverre ett problem, nemmelig at det er tungvindt &#229; bruke dersom applikasjonen har data som enten skal sendes langt nedover komponent hierarkiet, eller om dataen skal v&#230;re tilgjengelig i alle komponentene. Dette er fordi man er n&#248;dt til &#229; manuelt sende dataen nedover gjennom props. React har en l&#248;sning p&#229; dette problemet: Context. Context gj&#248;r det mulig &#229; sette opp en provider rundt applikasjonen eller enkeltelementer som gj&#248;r at alle barna vil ha tilgang p&#229; context. Det finnes ogs&#229; andre eksterne pakker som hjelper med &#229; l&#248;se dette problemt, for eksempel redux.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3022,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibeliotek for &#229; h&#229;ndtere en global state for React. Det finnes ogs&#229; andre eksterne&#160;pakker/bibelioteker for &#229; h&#229;ndtere dette, for eksempel: Redux og MobX. Jeg kommer hovedsaklig til &#229; sammenlikne med Redux da det er dette bibelioteket jeg har mest erfaring med og innsikt I.<\/p><p>&#160;<\/p><p>B&#229;de n&#229;r man bruker&#160;Recoil og n&#229;r man bruker&#160;Redux er man n&#248;dt til &#229; sette opp en provider rundt applikasjonen, denne vil gi tilgang p&#229; den globale staten til alle barne-komponenter.<\/p><p>&#160;<\/p><p>I Redux setter man opp en immutable store, med reducers som tar inn forskjellige actions. N&#229;r man skal endre p&#229; tilstanden m&#229; man da dispatche (store.dispatch(action)) en action som deretter kan valideres av reduceren. Reduceren vil s&#229;&#160;vil returnere en ny tilstand bassert p&#229; actionen. En action har en type, og kan ha en payload som videre beskriver data&#39;en som skal brukes for &#229; endre p&#229; tilstanden. Fordelen med denne m&#229;ten &#229; gj&#248;re det p&#229; er at man kan gj&#248;re validering av state, slik at man ikke vil oppn&#229; en ulovlig tilstand. I tillegg begrenser man mulighetene for endring gjennom et sett med actiontyper.<\/p><p>&#160;<\/p><p>M&#229;ten man setter state i Recoil er mye mindre omfattende. I Recoil oppretter man atoms som fungerer som en global tilstand for en variabel med en&#160;key og en default verdi. Deretter kan&#160;man bruke hooken useRecoilState() som vil gi en funksjon for &#229; lese og skrive til tilstanden. Det virker derfor som at det ikke eksisterer noen m&#229;te &#229; validere den globale staten n&#229;r den oppdateres. (Utenom &#229; gj&#248;re det alle steder man setter state).&#160;<\/p><p>&#160;<\/p><p>Recoil virker slik at en komponent som leser fra et atom implisitt er subscribed til atomet, dette skiller seg fra Redux, hvor man enten subscriber til hele storen og m&#229; implementere en egen changeHandler, eller man&#160;m&#229; bruke connect med mapStateToProps for &#229; avgj&#248;re om tilstanden har endret seg slik at det skal resultere i en komponent oppdatering.<\/p><p>&#160;<\/p><p>Fordi man kan subscribe til enkeltvariabler, men at det ikke er noen validering av state virker det som at Recoil vil v&#230;re nyttig dersom den globale tilstanden ikke er s&#229; stor. I tillegg kan man dra nytte av at det krever lite kode for &#229; sette opp Recoil. Redux derimot er nok mer skalerbar p&#229; grunn av valideringen og begrensingen av funksjonalitet gjennom actions. Nedsiden med dette er at det krever noe mer kode for &#229; sette opp, i tillegg til at man m&#229; bruke connect og mapStateToProps for &#229; wrappe componenter som skal lytte til endringer i tilstanden.<\/p><p>&#160;<\/p><p>Virker ikke som om at det er mulig &#229; bruke Recoil med klasse komponenter, da man er avhengig av &#229; bruke hooks for &#229; ha tilgang p&#229; atoms. Dersom man &#248;nsker &#229; bruke klasse komponenter, er man derfor n&#248;dt til &#229; bruke Redux.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2063,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og Graphql&#160;er to mye brukt metoder for &#229; sende foresp&#248;rsler til en server.<\/p><p>REST (Representational state transfer) basserer seg p&#229; endpoints, hvor man kan sende HTTP foresp&#248;rseler til serveren. Graphql bruker ogs&#229; http, men oppererer med ett endepunkt. Fordi REST har en unik URL, for hver resurs,&#160;kan REST benytte seg av cache funksjonaliteten i HTTP. Graphql kan ikke bruke denne funksjonaliteten fordi endepunktet ikke er unikt for hver resurs.<\/p><p>&#160;<\/p><p>Graphql basserer seg p&#229; queries som minner om database-queries. Fordelen med dette er at frontend kan formulere akkurat hvordan resultatet skal se ut, for eksempel kan man si at man &#248;nsker alle navn p&#229; alle brukere med: {user: {name}}. Denne typen presisering kan man ikke oppn&#229; med REST api, uten &#229; eksplisitt lage endepunkter eller query-parametere, hvor man kan velge et sett med parametere. En annen fordel som&#160;med denne typen queries, er at man sammen med Graphqls typesystem kan ha gj&#248;re validering av foresp&#248;rselen f&#248;r den sendes. Dette er ikke mulig med REST.<\/p><p>&#160;<\/p><p>REST har ingen begrensninger for hvilken type data som kan sendes. Derimot er Graphql begrenset til JSON. Selvom man kan sende all type data over JSON, kan det f&#248;re til noe ekstra overhead og kode for &#229; h&#229;ndtere det.<\/p><p>&#160;<\/p><p>REST har den fordelen at den krever minimalt med oppsett av eksterne pakker for &#229; fungere. P&#229; frontend kan det gj&#248;res s&#229; enkelt som &#229; bruke det&#160;innebygde fetch API&#39;et i javaScript&#160;for &#229; sende HTTP foresp&#248;rseler, P&#229; serveren holder det &#229; installere en webserver som express. For &#229; sette opp Graphql m&#229; man installere Graphql p&#229; b&#229;de frontend og backend, i tillegg til at man m&#229; ha en webserver.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534200,"ext_inspera_userAssessmentSetupId":7140127,"ext_inspera_userAssessmentId":4841257,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Espen Peder Hanch-Hansen (10113)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37760805,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":642,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<ul>\t<li>State representerer den delen av en applikasjon som kan endres, og hver komponent vil ha sin egen state. Den settes som regel ved hjelp av setState(). Endring av state vil som regel rendre komponenter og deres children p&#229; nytt.<\/li>\t<li>React bruker ogs&#229; props for &#229; sende med informasjon mellom komponenter. Props sendes alltid nedover i hierarkiet, og er immutable (dvs, kan ikke endres).<\/li>\t<li>State kan settes oppover i hierarkiet ved hjelp av callbacks. Disse sendes som regel som props inn til children og kan der brukes for &#229; sette state i foreldre.<\/li>\t<li>Det finnes ogs&#229; biblioteker som Redux og MobX som innf&#248;rer global state management. Hvis man har en stor applikasjon som inneholder mange komponenter som alle skal ha tilgang p&#229; samme dataen kan dette f&#248;re til mange un&#248;dvendige callbacks og lignende. Dette kan l&#248;ses ved &#229; bruke disse bibliotekene, hvor man heller har en global state som kan settes p&#229; forskjellige m&#229;ter (i redux brukes store, reducers og actions, mens i MobX&#160;skjer det mye i bakgrunnen.<\/li>\t<li>Man kan ogs&#229; gj&#248;re testing av dataflyten i React-applikasjoner ved hjelp av end-to-end testing. Biblioteker som Cypress gj&#248;r at man kan automatisk teste brukeropplevelsen, som n&#248;dvendigvis sjekker at data blir oppdatert og sendt der hvor det skal.<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2926,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<ul>\t<li>Recoil er et bibliotek som brukes for state management i React. Biblioteket skal gj&#248;re det lettere &#229; bedrive state management i React, som kan bli problematisk om man har mange komponenter som vil ha tilgang til samme ressursene.<\/li>\t<li>Den benytter seg av &#34;atoms&#34; for state management. De kan oppdateres og komponenter kan&#160;&#34;subscribe&#34; til de, som gj&#248;r at disse komponentene vil rendres p&#229; nytt om atomet oppdateres. Atomet trenger en unik ID for &#229; kunne differensieres fra hverandre.<\/li>\t<li>For mer avansert state management bruker Recoil <strong>selectors.&#160;<\/strong>Atoms inneholder en minimal form for state, mens selectors kan ta enten andre selectors eller atoms som input og f.eks gj&#248;re utregninger. Komponenter kan n&#248;dvendigvis ogs&#229; &#34;subscribe&#34; til disse og oppdateres om n&#248;dvendig.<\/li><\/ul><p>&#160;<\/p><ul>\t<li>Dette er forskjellig fra Redux, hvor man benytter seg av <em>store<\/em>, <em>reducers<\/em> og <em>actions <\/em>for &#229; lagre global state. Man&#160;<strong>dispatch-er<\/strong>&#160;actions for &#229; endre p&#229; state&#160;som settes via reducer-funksjoner (som igjen vil blir lagret i store). Dette er en veldig effektiv og modul&#230;r metode, men krever en del set-up og m&#229; utf&#248;res p&#229; riktig m&#229;te for &#229; v&#230;re effektiv.<\/li><\/ul><p>&#160;<\/p><ul>\t<li>I MobX skjer mye av dette &#34;automatisk&#34;, uten at bruker trenger &#229; konfigurere for mye. Alle <em>events <\/em>(trykke p&#229; en knapp etc) f&#248;rer til en <em>action<\/em>, som oppdaterer den <em>observerbare staten.<\/em>&#160;Endringer her blir formidlet til <em>computations<\/em> (utregninger) og <em>side-effects<\/em> (f.eks rendering).<\/li><\/ul><p>Personlig syntes jeg Recoil virker interessant, og som et slags &#34;midtpunkt&#34; mellom MobX og Redux. MobX gj&#248;r som nevnt mye &#34;automatisk&#34;, og gir p&#229; den m&#229;ten ikke brukeren like mye frihet og forst&#229;else for hvordan staten endres i applikasjonen sin. Redux er mer modul&#230;rt men mer komplisert &#229; sette opp, og kanskje mindre tilgivende hvis man ikke gj&#248;r ting skikkelig. Recoil virker som det tilbyr en mellomting; state skal v&#230;re enkelt &#229; sette generelt (uten for mye oppsett), men man har ogs&#229; tilgang til mer funksjonalitet om man skulle trenge/&#248;nske det. Vanlig React-state, Redux og MobX kan alle f&#248;re til un&#248;dvendig re-renders om man har mye under en enkelt container-komponent. Recoil kan l&#248;se dette ved bruken av atoms, s&#229; man kan bare subscribe de forskjellige under-komponentene uavhengig av deres foreldre-komponenter. S&#229; Recoil kan v&#230;re nyttig om man sliter med ytelsen av applikasjonen sin (er som regel ikke et problem med dagens kraftige hardware).<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://recoiljs.org<\/li>\t<li>https://redux.js.org/introduction/core-concepts<\/li>\t<li>https://mobx.js.org/README.html<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1111,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<ul>\t<li>REST API bruker &#34;resources&#34;, og om man gj&#248;r et GET-kall vil man f&#229; tak i disse resourcene. Som regel kommer denne dataen p&#229; et JSON-format, og man m&#229; kj&#248;re flere kall for &#229; f&#229; tilgang p&#229; relaterte ressurser. I GraphQL separerer man informasjonen man skal hente inn i &#34;types&#34;, som man kan f&#229; direkte tilgang til, dvs. at man spesifiserer i kallet n&#248;yaktig hva slags informasjon man vil ha. Dette betyr at man kan kj&#248;re kun ett kall, men f&#229; tilgang p&#229; n&#248;stede ressurser og mer strukturert data (ved hjelp av mutations). P&#229; denne m&#229;ten har Graphql et overtak p&#229; REST, siden den reduserer antall kall man potensielt m&#229; gj&#248;re. Dette reduserer ogs&#229; mengen overfetching og underfetching som skjer.<\/li>\t<li>Der hvor REST har overtaket er i sin enkelhet. Graphql forlanger mer struktur, og m&#229; settes opp p&#229; en mer avansert m&#229;te for &#229; fungere bra. REST derimot har blitt en industri-standard som finnes overalt.<\/li>\t<li>En annen forskjell er hvordan man spesifiserer writes. I REST vil man endre verbet som brukes (f.eks fra GET til POST), mens i GraphQL trenger man kun &#229; endre et n&#248;kkelord i sp&#248;rringen.<\/li>\t<li>REST bruker endepunkter, som f.eks GET /company/employee:id, hvor en employee med spesifikk ID hentes. I Graphql gj&#248;res dette ved bruk av Schemas, hvor man kombinerer forskjellige kall til ett enkelt.<\/li><\/ul>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11532876,"ext_inspera_userAssessmentSetupId":7139906,"ext_inspera_userAssessmentId":4841262,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Syslak Tiril Sandaker (10142)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34414858,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2523,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er bygget opp av komponenter, og vi ser p&#229; strukturen som et komponenttre med rot-komponenten &#248;verst. I react brukes props for &#229; sende data nedover i dette treet. Alts&#229; kan en barnkomponent f&#229; data fra en &#34;forelderkomponent&#34; ved &#229; sende den med komponenten som rendres. F.eks. komponent Parent og Child, med &#60;Child name = &#39;Testname&#39;/&#62; i Parent. Her er name en prop i Child, som blir sendt ned av forelederen. Slike props er immutable, alts&#229; de kan ikke endres.&#160;<\/p><p>For &#229; sende data oppover i komponentreet kan vi bruke callback. Dette er funksjoner som sendes med som props nedover (alts&#229; fra Parent til Child), som brukes i Child for &#229; endre noe i Parent. I Child kan vi da ha en funksjon som kaller p&#229; props-funksjonen som er sendt med fra Parent. Vi kan f.eks. bruke useState i Parent, og endre staten ved &#229; bruke&#160;setState i en funksjon som blir sendt med som prop i Child.&#160;<\/p><p>&#160;<\/p><p>Eksempel p&#229; en rask l&#248;sning med bruk av props og callbacks:&#160;<\/p><p>&#160;<\/p><p>const Parent = () =&#62; {<\/p><p>const [age, setAge] = useState(0);<\/p><p>const increaseAge = () =&#62; {<\/p><p>setAge((age) =&#62; age + 1);<\/p><p>};<\/p><p>return (<\/p><p>&#60;div&#62;<\/p><p>&#60;h1&#62;My children:&#60;/h1&#62;<\/p><p>&#60;Child name=&#39;Testname&#39; age={age} increaseAge={increaseAge} /&#62;<\/p><p>&#60;/div&#62;<\/p><p>);<\/p><p>};<\/p><p>&#160;<\/p><p>export default Parent;<\/p><p>&#160;<\/p><p>const Child = (props) =&#62; {<\/p><p>const handleIncreaseAge = () =&#62; {<\/p><p>props.increaseAge();<\/p><p>};<\/p><p>return (<\/p><p>&#60;div&#62;<\/p><p>&#60;h3&#62;<\/p><p>{&#39; &#39;}<\/p><p>My name is {props.name} and my age is {props.age}{&#39; &#39;}<\/p><p>&#60;/h3&#62;<\/p><p>&#60;button onClick={() =&#62; handleIncreaseAge()}&#62;&#60;/button&#62;<\/p><p>&#60;/div&#62;<\/p><p>);<\/p><p>};<\/p><p>export default Child;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3054,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en m&#229;te &#229; h&#229;ndtere states i React. Den innebygde funksjonalitet&#160;for state-h&#229;ndtering&#160;i React medf&#248;rer at hver endring av states f&#248;rer til en re-rendering av hver enkelt komponent i komponenttreet. Med en kompleks kode og mange komponenter som kan endre/bruke samme state, vil dette bli un&#248;dvendig komplisert, og man &#248;nsker en m&#229;te &#229; h&#229;ndtere states globalt. P&#229; denne m&#229;ten er det kun komponenter som er avhengig av den endra staten som rerendres.&#160;<\/p><p>I recoil blir roten av treet kalt &#34;atom&#34;, og statene blir sendt fra atom gjennom &#34;selectors&#34; (funksjoner) til de ulike komponentene. Det gj&#248;res ved &#229; &#34;wrappe&#34; rot-komponenten med RecoilRoot, slik at hver komponent i treet har tilgang til statene i recoil. For &#229; bruke staten i komponenten brukes da useRecoilState, som&#160;brukes likt som useState i React.&#160;<\/p><p><span>Vi kan l&#248;se tilsvarende&#160;tilstandsh&#229;ndtering med blant annet Redux, som er en l&#248;sning blant v&#229;re l&#230;ringsm&#229;l (I&#160; tillegg til l&#248;sninger som Context API, og MobX). Med Redux m&#229; man lage en egen&#160;store for alle tilstandene, noe man ikke trenger med Recoil. I tillegg m&#229; man ha reducers og actions i Redux, som l&#248;ses ved hjelp av atoms og selectors i Recoil. Vi kan koble komponenten til storen i redux f.eks. vha. connect(). I Recoil gj&#248;res dette bare ved &#229; bruke useRecoilValue&#160;<\/span><span>og useRecoilState.&#160;<\/span><\/p><p>&#160;<\/p><p><span>Recoil er noe enklere da mye er basert p&#229; hooks fra React, som er kjent for de fleste. I tillegg er det at det er basert p&#229; React&#160;ogs&#229; en fordel i seg selv. Recoil vil ogs&#229; bare rendre komponenter som bruker verdien som endres, som er fint for applikasjoner som har hyppig endring av globale tilstander.&#160;<\/span>I motsetning til Redux fungerer Recoil kun p&#229; klassekomponenter.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1570,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;dre REST API og graphql andler om henting/endring av data. Ved REST gj&#248;res dette ved &#229; ha (ofte mange) forskjellige endepunkter, som bestemmes av dem som lager API-et. Vi kan ha ulike URL-er for b&#229;de get, post, put, patch og delete, der hver URL ofte er beskrivende for hva som skal hentes ut. Eksempel p&#229; bruk av&#160;REST API er get(&#39;user/:id&#39;), eller post(&#39;user/register&#39;). Post&#160;har med en body som er det som blir lagt til, der typen er spesifisert av content-type, og kan ofte v&#230;re JSON.&#160;<\/p><p>Med Graphql er det kun ett endepunkt, nemlig post /graphql. Det du &#248;nsker &#229; hente ut/endre e.l. vil v&#230;re spesifisert i bodyen som en query/sp&#248;rring, og ikke i pathen som i REST. Det som tilsvarer endepunktet&#160;til requesten er da gitt i sp&#248;rringen. Graphql kan kun brukes med JSON data.&#160;<\/p><p>I graphql kan du, i motsetning til REST, begrense s&#248;ket mye mer. Du kan hente mer eller mindre informasjon (avhengig av hva du &#248;nsker) i &#233;n sp&#248;rring, i motsetning til i en path. Graphql kan derimot ikke benytte seg av HTTP caching, som REST kan.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11533186,"ext_inspera_userAssessmentSetupId":7139937,"ext_inspera_userAssessmentId":4841278,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Skrivarhaug-Boudier Jarl Christophe (10236)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33641729,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2873,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React sin lokale tilstand<\/p><p>&#160;<\/p><p>React har en komponentbasert arkitektur. I hver komponent kan man lagre tilstanden for den gitte komponenten n&#229;r applikasjonen starter i variabler. Avhengig av om man bruker funksjonelle komponenter eller klassekomponenter vil oppsett og oppdatering av disse &#34;lokale komponent tilstandene&#34; se litt annerledes ut. Det er fordi&#160;klassekomponenter har innebygde tilstander, mens&#160;funksjonelle komponenter m&#229; ta i bruk hooks for &#229; kunne lagre tilstanden.&#160;Likevel,&#160;vil disse tilstandene alltid inisialiserers n&#229;r komponenten opprettes i React og f&#229; en startsverdi:<\/p><p>For funksjonelle&#160;komponenter kan en tilstands variabel&#160;se slik&#160;ut:&#160;<\/p><p>const [count, setCount] = useState(0);<\/p><p>Her bruker vi useState som er en importert hook til &#229; opprette en tilstand count som f&#229;r startsverdien 0 og som skal endres kun ved &#229; kalle p&#229; setCount funskjonen.<\/p><p>Dersom vi &#248;nsker &#229; inkrementere count med 1 ved trykk av en knapp, kunne man skrevet f&#248;lgende kode:<\/p><p>&#60;button onClick={() =&#62; setCount(count + 1)}&#62;<\/p><p>Denne l&#248;sningen er sv&#230;rt forskjellig fra den tradisjonelle&#160;&#34;plain&#34; javascript l&#248;sningen hvor data blir lagret i Document Object Model, og&#160;m&#229; hentes fra DOM for &#229; brukes (document.getelementbyId())<\/p><p>&#160;<\/p><p>React sin tradisjonelle dataflyt<\/p><p>I react &#248;nsker vi ofte at flere komponenter skal bruke samme tilstand, og at n&#229;r &#233;n tilstand endres p&#229; i en komponent&#160;s&#229; endres ogs&#229; alle andre tilstander. I React gj&#248;res denne dataflyten f&#248;rst og fremst&#160;ved hjelp av &#229; sende properties fra en parent komponent til respektive children komponenter.&#160;<\/p><p>En properties (ofte kalt prop)&#160;er ikke annet enn et argument som legges til i et kall p&#229; en komponent slik:&#160;<\/p><p>&#60;Poem theme=count&#62;&#160;<\/p><p>Her spesifisere man at i en parent komponent at child komponenten musikk skal ta inn argument theme &#160;som er veridene til count.&#160;Ofte &#248;nsker man &#229;&#160;sende den samme tilstanden langt nedover komponent hierarkiet som lages i React, dette gj&#248;res ved &#229; sende den samme&#160;prop&#39;en videre i hver komponent p&#229; veien: prop-passing.<\/p><p>&#160;<\/p><p>Man kan ogs&#229; sende data oppover hierarkiet. Dette gj&#248;res med &#229; sende callback funskjoner fra en parent komponent til en childkomponent. Denne funksjonen gj&#248;&#248;r det mulig for child komponenten &#229; endre tilstand til parent komponenten.&#160;<\/p><p>&#160;<\/p><p>React med global tilstand : Context API<\/p><p>&#160;<\/p><p>I tillegg til react sin lokale tilstand er det ogs&#229; &#229; generere global tilstander ved hjelp React sitt&#160;Context API.<\/p><p>Context API er hensitksmessig &#229; ta i bruke n&#229;r man trenger &#229; ha tilgang til en tilstand i mange komponenter som ligger langt fra hverandre i komponenthiearkiet.&#160; (gjerne komponenter som ikker er barn av samme foreldre osv.). Heller enn &#229; t&#229; i bruk&#160;lange kjeder av prop-passing kan man da n&#229; tilstanden direkte fra hvor som helst i applikasjonen.&#160;<\/p><p>&#160;<\/p><p>Local og session storage<\/p><p>Tilleggsvis har man ogs&#229; muligheten til &#229; bruke local storage og session storage for &#229; lagre data p&#229; sin lokal enhet. Session storage holder data lagret kun s&#229; lenge fanen er oppe, mens local storage beholder den lagrede dataen p&#229; enhetene din for alltid.&#160; Denne dataen kan du hente ut hvor som helst i komponenten dine da den er lagret p&#229; enheten din.<\/p><p>&#160;<\/p><p>Eksterne &#34;state managment&#34; biblioteker<\/p><p>Tillggsvis kan man importere eksterme&#160;bilblioteker for &#229; ta vare p&#229; globale tilstander, ved bruk av state management biblioeteker. Slike biblioteker er MobX og Redux og de fungerer som globale tilstandsbeholdere.&#160;<\/p><p>Context API er React sin l&#248;sning p&#229; state management<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2580,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et&#160;state managemenent biblioetek utviklet av Facebook.<\/p><p>Recoil brukes sammen med react for &#229; lage global tilstander som kan hentes ut direkte hvor som helst i React komponent hierarkiet uten &#229; m&#229;te&#160;bruke lange kjeder av prop-passing.<\/p><p>React har allerede en slik l&#248;sning: Context API og det finnes mange eksterne slike l&#248;sninger som Redux og MobX diksutert i dette faget.&#160;<\/p><p>Likevel er logikken og oppsettet av state managments forskjellig fra&#160;biblioetek til bibliotek.&#160;<\/p><p>Recoil er bygget opp av two n&#248;kkelelementer: atomer og selectors.<\/p><ul>\t<li>En atom er en global&#160;tilstands variabel som komponenter i applikasjonen kan abonnere p&#229;. Atomene kan endres og da vil&#160;alle komponentene som abonnerer til denne atomen oppdateres (rerendre), men kunne disse.&#160;<\/li>\t<li>En Selector er en funksjon som tar inn atomer og returnerer et transformert resultat av atomen. I likhet med atomer kan komponenter abonnere p&#229; selectors og vil da oppdateres n&#229;r disse selectoren blir kj&#248;rt.<\/li><\/ul><p>SAMMNELIGNE<\/p><p>&#160;<\/p><p>REDUX intro&#160;<\/p><p>Dette er sv&#230;rt ulikt oppsette til&#160;Redux, som baserer seg p&#229; &#229; samle all tilstand i en felles &#34;store&#34; som er immutable. Deretter m&#229; man bruke&#160;&#34;actions&#34; til &#229; oppdatere tilstanden, udirekte ved &#229; g&#229; via reducers som er elementene&#160;som faktsik endrer p&#229; tilstanden .<\/p><p>&#160;<\/p><p>CONTEXT API into<\/p><p>Vi kan ogs&#229; sammenligne Recoil med context API, som er&#160;mye enklere &#229; bruke&#160;enn Redux, da den krever mye mindre kode og har enklere syntakse.&#160;<\/p><p>&#160;<\/p><p>Hvorfor Atomer&#160;l&#248;sningen til Recoil er smart:<\/p><p>Den store fordelen som Context APiet har over Redux er at det er enklere &#229; ta i bruk, krever mindre &#34;boiler plate&#34; kode og er raskere &#229; f&#229; opp.&#160;<\/p><p>Den store ulempen er at at hver gang det skjer en endring i en av tilstandene i Context APIet vil hele applikasjonen oppdateres, noe som kan f&#248;re til un&#248;dvendig mange oppdateringer.<\/p><p>&#160;<\/p><p>Recoil kan fikse&#160;begge disse problemene<\/p><p>P&#229; den ene siden h&#229;ndterer&#160;recoil hver global&#160;tilstand som en Atom, som komponenter kan abonnere p&#229;. Dermed,&#160;n&#229;r en &#34;atom&#34; oppdateres s&#229; vil recoil s&#248;rge for at kun de komponentene som abonnerer p&#229; den atomen oppdateres. = vi ung&#229;r dermed un&#248;dvendige &#34;rerenders&#34;.<\/p><p>Tilleggsvis er syntaksen og oppsette til recoil enklere og mindre komplekst &#229; sette seg inn i som det Redux tilbyr, noe som er med p&#229; &#229; skape et&#160;mer oversiktlig sluttprodukt.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>https://dev.to/chandan/recoil-vs-redux-the-ultimate-react-state-management-face-off-35b<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1672,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en overordnet arkitektur&#160;for webbaserte klient - tjener kommunikasjon med fokus p&#229; lesing og skriving, mens graphQL et&#160;&#34;query&#34; spr&#229;k (sp&#248;rrespr&#229;k).&#160;<\/p><p>&#160;<\/p><p>N&#229;r man lager et REST API lager man flere endepunkter med ressurser som kan hendtes ut med forskjellige HTTP foresp&#248;rseler (GET, POST, PUT, DELETE)&#160;til ulike URLer som hver identifiserer en ressurs.&#160;<\/p><p>&#160;<\/p><p>Dersom du vil hente informasjon om en <strong>forfatter (hans navn, alder og hvor han studerte)<\/strong>&#160;og detaljer om alle&#160;<strong>b&#248;kene&#160;<\/strong>han er skrevet (publisher, og antall solgte enheter)&#160;kan du tenke deg at du f&#248;rst m&#229; gjennomf&#248;re et kall (GET) p&#229; den bestemte&#160;forfatteren og tillggsvis&#160;et kall p&#229; den spesifikke boken, for &#229; f&#229; all informasjonen du er ute etter.<\/p><p>&#160;<\/p><p>N&#229;r man lager et&#160;QraphQL, har man derimot ikke flere URL&#39;er med hver sin ressurs. Man har derimot en eneste URL som man sender all foresp&#248;rseler til.&#160; Dermed heller enn &#229; sende et GET kall til en viss type ressurs, s&#229; sender man en &#34;query&#34; skrevet i JSON&#160;, hvor man spesifiserer akkurat hva man &#248;nsker &#229; f&#229; tilbake og hvordan man &#248;nsker at det skal bli returnert.<br />I eksemplet over, vil man dermed sende en lignende query:<\/p><p>query{&#160;<\/p><p>&#160; &#160; forfatter (navn= &#34;markus kl&#229;rt&#34;){<\/p><p>&#160; &#160; &#160; &#160; &#160; navn<\/p><p>&#160; &#160; &#160; &#160; &#160; alder<\/p><p>&#160; &#160; &#160; &#160; &#160; studiested<\/p><p>&#160; &#160; &#160; &#160; &#160; b&#248;ker {<\/p><p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;publisher<\/p><p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; antallenhetersolgt&#160;<\/p><p>&#160; &#160; &#160; &#160; }<\/p><p>}}<\/p><p>&#160;<\/p><p>Man vili f&#229; returnert en query p&#229; samme format JSON format med hver ligne fylt inn.<\/p><p>Man vil derfor alltid kun sende 1 API kall, noe som betyr at GraqhQL reduserer kraftig antall API kall n&#248;dvendig. Grunnen til at man kun trenger et API kall er fordi at dataen i API er relasjonell , som en graf med kanter mellom ressursene som er relaterte ( i tilfelle over Forfatter og hans respektive B&#248;ker).<\/p><p>Her er det viktig &#229; merke seg at med REST APIet vil man f&#229; tilbake alt som er i ressursene man kaller p&#229;, mens med GraphQL kan man sp&#248;rre om &#229; f&#229; akkurat det man trenger. &#197; f&#229; overfl&#248;dig informasjon kalles overfetching: dette unng&#229;r man ogs&#229; med GraqhQL.<\/p><p>Tilleggsvis er graphQL strong typet og man m&#229; spesifiereret schema og typesystem som ger med p&#229; &#229; dokumentere koden og gj&#248;re den ryddigere enn REST APIet.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537478,"ext_inspera_userAssessmentSetupId":7139990,"ext_inspera_userAssessmentId":4841224,"dateLastModified":"2020-12-01T10:01:28Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:28Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Dahl Sondre Olav (10189)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35267728,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1932,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I klassebaserte komponenter setter man tilstanden i konstrukt&#248;ren med this.state =&#160; {someState: defaultState}. Denne oppdateres ved &#229; bruke this.setState() funksjonen fra React. Tilstanden kan ikke oppdateres uten setState funksjonen. I funksjonelle komponenter bruker man hooks og da mer spesifikt useState(). useState() returnerer en tilstand og en funksjon til &#229; oppdatere tilstanden. I tillegg kan man sette en default state.<\/p><p>&#160;<\/p><p>B&#229;de klassekomponenter og funksjonelle komponenter oppdateres n&#229;r tilstanden deres endres. Alts&#229; vil en endring i tilstanden trigge en rerender av komponenten. I tillegg kan verken barnekomponenter eller foreldrekomponenter vite om en komponent har tilstand. Tilstand er lokalt til hver enkelt komponent i React.<\/p><p>&#160;<\/p><p>Dataflyt i React-applikasjoner er f&#248;lger en topp-til-bunn tiln&#230;rming. Data sendes fra en foreldrekomponent til en barnekomponent som &#232;n &#39;prop&#39; eller flere &#39;props&#39;.&#160; Props kan sendes ned gjennom hele komponent treet, men kan v&#230;re upraktisk n&#229;r det er mange komponenter som skal ha tilgang til samme dataen. S&#230;rlig hvis komponentene er p&#229; helt forskjellige stier i komponent-treet. Da vil en endring i dataen tvinge un&#248;dvendig mange komponenter til &#229; gjennomf&#248;re en rerender. Dette er ikke bra for ytelsen og det blir i tillegg kaotisk &#229; sende props opp og ned i komponenttreet.<\/p><p>&#160;<\/p><p>Context APIet til React l&#248;ser dette problemet til en viss grad. Det er laget for &#229; ha en global tilstand som deles mellom alle komponentene. Ulempen med Context er d&#229;rlig skalering. Per kontekst kan man kun lagre en verdi som gj&#248;r at man trenger flere kontekster for &#229; holde styr p&#229; forskjellige states. For hver kontekst m&#229; man ha en ny wrapper komponent som gj&#248;r at koden etterhvert kan drukne i wrappers n&#229;r man inspiserer applikasjonen i DevTools.<\/p><p>&#160;<\/p><p>Dersom man &#248;nsker mer avansert h&#229;ndtering av state i React finnes det flere tredjepartsbiblioteker, blant annet Redux og MobX, som gir mulighet til det.<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://reactjs.org/docs/context.html<\/li>\t<li>https://reactjs.org/docs/hooks-intro.html<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p><p><br />&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2379,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state-management bibliotek for React. Det er laget for &#229; gj&#248;re det enklere &#229; dele state mellom komponenter uavhengig av hvor langt de er fra hverandre i komponent-treet. Recoil bygger staten sin p&#229; &#39;atomer&#39; som kan sammenlignes med vanlige state i React. Forskjellen er at atomer er globalt tilgjengelig i alle komponenter. I tillegg har Recoil selectors som representerer en state avledet fra annen state.<\/p><p>&#160;<\/p><p>Sammenlignet med Redux er Recoil enklere &#229; sette seg inn i. Det er mye mindre &#39;boiler-plate&#39; code som kreves for &#229; h&#229;ndtere state og det gj&#248;r at Recoil skalerer bedre n&#229;r det blir mer state &#229; holde oversikt over. I tillegg kan man oppdatere state asynkront i Recoil uten tredjepartsbiblioteker. I redux m&#229; man bruke tredjepartsbiblioteker som redux-thunk til &#229; h&#229;ndtere asynkron funksjonalitet.<\/p><p>&#160;<\/p><p>Et annet viktig punkt er at Recoil er mye likere React i tiln&#230;rmingen sin til state. Redux minner ikke noe s&#230;rlig om state i React og dette gj&#248;r at l&#230;ringskurven for Redux blir veldig bratt i tillegg til at man m&#229; gj&#248;re mye endringer p&#229; prosjektet sitt for &#229; implementere Redux. Siden Recoil initaliserer state p&#229; en veldig lik m&#229;te som i React er det mye enklere &#229; konvertere prosjektet sitt til Recoil.<\/p><p>&#160;<\/p><p>En ulempe med Recoil er at det er et veldig ungt prosjekt med mindre dokumentasjon enn Redux. Dette kan gj&#248;re det noe krevende &#229; bruke fordi det fortsatt er i startfasen. I tillegg fungerer det kun for funksjonelle komponenter og krever derfor at man skriver om eldre prosjekter til funksjonelle komponenter f&#248;r man kan bruke det.<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://recoiljs.org/<\/li>\t<li>https://redux.js.org/<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2442,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er basert p&#229; at man har flere endepunkter der en klient eller server kan hente data. Dette vil v&#230;re endepunkter som for eksempel denne urlen: https://exampleapi.com/api/users. Fra denne urlen kan man hente data om brukere og f&#229; returnert alle brukerne. En ulempe med REST APIet er at man kan ende opp med &#229; hente for mye data, ogs&#229; kjent som overfetching. Dersom man eksempelvis kun &#248;nsker brukernavnet p&#229; alle brukerne vil man ikke trenge alderen til alle brukerne. Med et REST API vil en request til .../api/users returnere alle brukerne med all dataen knyttet til en bruker.<\/p><p>&#160;<\/p><p>I Graphql kan man spesifisere hvilke felter man &#248;nsker &#229; f&#229; returnert som leder til &#248;kt ytelse. Dette gir ogs&#229; &#248;kt fleksibilitet til klientene som kan velge hvilken data de &#248;nsker &#229; hente. Et annet problem med REST er underfetching der det blir hentet for lite data ved f&#248;rste kall og man m&#229; kalle p&#229; et endepunkt til for &#229; hente all dataen man trenger. Dette leder til d&#229;rligere ytelse. Graphql har ikke samme problemet.<\/p><p>&#160;<\/p><p>En fordel med REST er at man kan bruke HTTP caching til &#229; unng&#229; refetching av ressurser (&#229; hente de samme ressursene p&#229; nytt). Graphql har ingen slik innebygd funksjonalitet for caching selv om det finnes l&#248;sninger for caching i graphql ogs&#229;. Samtidig har REST en annen ulempe som er at det kan v&#230;re vanskelig &#229; vite hvilke operasjoner som er st&#248;ttet av API&#39;et man kommuniserer med og hvordan man bruker disse. I Graphql definerer man et schema som fungerer som en kontrakt der all funksjonalitet er spesifisert. Det gj&#248;r det lettere &#229; jobbe med Graphql APIer siden alle operasjoner mot apiet er tydelig definert.<\/p><p>&#160;<\/p><p>Til oppsummering l&#248;ser Graphql problemet med underfetching og overfetching som REST har. Samtidig er det fortsatt fordeler med REST og caching er lettere &#229; f&#229; til i REST.<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://graphql.org/learn/caching/<\/li>\t<li>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/li><\/ul><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11543847,"ext_inspera_userAssessmentSetupId":7139943,"ext_inspera_userAssessmentId":4841356,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:13:35Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sølvberg Niklas (10096)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":16431715,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":108,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":0,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":null}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1594,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React.<\/p><p>Recoil lar en bruke states noe annerledes enn om en bruker standard&#160;useState&#39;s. Recoil kommer godt til nytte n&#229;r en &#248;nsker &#229; dele states mellom ulike komponenter. Recoil&#39;s states, Atom&#39;s, lar en ha states som, ved endring, kun re-rendrer de komponentene som subscriber til akkurat denne Atom&#39;en. Dette er ulikt fra Redux (fra listen over l&#230;ringsm&#229;l), da Redux vil ende opp med &#229; re-rendre komponenter som ikke benytter en spesifikk state, fordi Redux bruker en global, delt state. I noen situasjoner kan bruk av Redux f&#248;re med seg at store deler av en side m&#229; re-rendres, og i noen tilfeller kan dette v&#230;re for ressurskrevende. Slike situasjoner er perfekt for Recoil, da s&#229; f&#229; komponenter som mulig blir re-rendret.<\/p><p>I de fleste situasjoner vil Redux,&#160;Recoil, og andre l&#248;sninger ha essensielt lik ytelse, og hvilken av de du kan/b&#248;r benytte i&#160;utvikling kommer an p&#229; om man en eller annen gang kommer til &#229; dra spesiell nytte av Recoil&#39;s ytelse. Dette er dog et sp&#248;rsm&#229;l som b&#248;r besvarer tidlig i utviklingen, da en stor refactor til Recoil fra &#229; ha benyttet en annen l&#248;sning kan v&#230;re kostbart.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2637,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":0,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":null}]}],"ext_inspera_totalScore":3,"score":3}},{"result":{"sourcedId":11533766,"ext_inspera_userAssessmentSetupId":7139952,"ext_inspera_userAssessmentId":4841267,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sæther Runar (10179)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34820806,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1952,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Antar her at det menes mekanismer og teknikker som er innebygd i React.<\/p><p>&#160;<\/p><p>Innebygd i React finnes props og state, som legger selve grunnmuren for hvordan en React-applikasjon fungerer.<\/p><p>&#160;<\/p><p>State er intern tilstand (variabler) i en komponent, og&#160;kan endres med&#160;<em>setState<\/em>&#160;i klasse-komponenter&#160;eller med en funksjon som returneres av&#160;<em>useState<\/em>&#160;i funksjonelle komponenter. State til en komponent kan ikke endres direkte fra en annen komponent.&#160;<\/p><p>&#160;<\/p><p>Props er variabler en komponent tar inn fra en forelder-komponent ved opprettelse og oppdatering. Slik sett er dataflyten i React nedovervendt (fra toppen av komponenthierarkiet og nedover). Props er read-only. Det er ogs&#229; mulig &#229; sende ned funksjoner som props (callbacks), som da vil utf&#248;res i forelder-komponenten. Slik kan en barne-komponent kj&#248;re funksjoner i forelder-komponenten (og for eksempel oppdatere state der).&#160;<\/p><p>&#160;<\/p><p>N&#229;r en state i en komponent skal brukes og oppdateres i andre komponenter i applikasjonen, ofte p&#229; helt andre steder i komponenthierarkiet (ikke bare i barn-komponenter, som kan l&#248;ses ved &#229; sende ned staten som prop og en callback-funksjon for &#229; endre den), kan dette fort bli veldig rotete. En ulempe er hvis komponenter p&#229; samme niv&#229; eller over skal ha tilgang til en state, s&#229; m&#229; den flyttes oppover i hierarkiet. Dette f&#248;rer til at state ikke n&#248;dvendigvis er plassert der den h&#248;rer hjemme, og det vil v&#230;re uoversiktlige kjeder av callbacks og props nedover i hierarkiet. Derfor er det nyttig &#229; ta i bruk&#160;<strong>state management<\/strong>; &#229; kunne ta staten helt ut av konsteksten den opprinnelig var plassert i, og bruke den der det er n&#248;dvendig. Her har man l&#248;sninger som context (innebygd i React), og andre tredjepartsl&#248;sninger som Redux, MobX,&#160;Apollo og Recoil.<\/p><p>&#160;<\/p><p>Context muliggj&#248;r lagring av data p&#229; et overordnet niv&#229; i komponenthierarkiet. Man kan lagre og endre data direkte i context fra hvilken som helst komponent under en s&#229;kalt context provider. Dette forenkler koden betraktelig hvis samme data brukes av mange komponenter, p&#229; forskjellige steder i hierarkiet. Komponenter kan ogs&#229; lytte p&#229; context-data, og rendre p&#229; nytt ut ifra endringene, ved hjelp av en context consumer. Eksempler p&#229; bruk av context er ved lagring av fargetema for hele applikasjonen, foretrukket spr&#229;k eller data om den innloggede brukeren.<\/p><p>&#160;<\/p><p>I React finnes ogs&#229; livssykelmetoder, som er funksjoner som kj&#248;rer til ulike tidspunkt i en livssykel til en komponent. Eksempelvis n&#229;r en komponent opprettes, n&#229;r den oppdateres eller n&#229;r den fjernes. Disse metodene brukes ofte til &#229; oppdatere state.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3555,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management-bibliotek og&#160;fungerer ved &#229; lage enheter av tilstand, s&#229;kalte atoms, som kan deles og endres av flere komponenter. N&#229;r et atom blir endret p&#229;, vil alle komponentene som abonnerer p&#229; atomet rerendre basert p&#229; den nye tilstanden. Recoil introduserer&#160;<em>useRecoilState<\/em>, som fungerer skremmende likt som&#160;<em>useState<\/em>&#160;innebygd i React, bare at tilstanden er delt.<\/p><p>&#160;<\/p><p>Recoil introduserer ogs&#229; selectors, som utleder ny data basert p&#229; atoms eller andre selectorer. P&#229; denne m&#229;ten er det bare de minste enhetene av data som lagres i atoms (som navnet ogs&#229; tilsier), mens selectors bruker disse for&#160;&#229; utlede sammensatte data. N&#229;r en selector eller atom oppdateres, vil selectorene som bruker disse kalkuleres&#160;p&#229; nytt. Selectors leses med&#160;<em>useRecoilValue<\/em>.<\/p><p>&#160;<\/p><p>P&#229; et overordnet niv&#229; kan Recoil sees p&#229; som en flyt av data fra atoms, gjennom selectors&#160;og ned til React-komponenter.&#160;<\/p><p>&#160;<\/p><p>Den store forskjellen mellom Recoil og andre state management-l&#248;sninger, eksempelvis Redux og context,&#160;er at i Redux og context lagres hele staten&#160;&#248;verst i komponenthierarkiet (og distribueres av en provider). Alts&#229; er state sentralisert.&#160;Dette f&#248;rer til at hele hierarkiet rerendres ved oppdatering av state. Recoil derimot, er ikke distribuert fra toppen av, men kan tas i bruk direkte, hvor som helst i applikasjonen (desentralisert). P&#229; dette omr&#229;det&#160;oppf&#248;rer Recoil og MobX seg likt.<\/p><p>&#160;<\/p><p>Observables i MobX er direkte sammenlignbart med atoms i Recoil, da begge inneholder state, og brukes p&#229; like m&#229;ter, med tanke p&#229; oppdatering og distribuering i applikasjonen.<\/p><p>&#160;<\/p><p>Selectors i Recoil kan sammenlignes med reducers i Redux, da begge forteller hvordan en state transformeres til en annen state, og dette kan gj&#248;res p&#229; mange m&#229;ter for samme state, i begge bibliotekene (ved &#229; ha flere selectors/reducers). Selectors kan ogs&#229; sammenlignes med computeds i MobX, da begge utleder ny data basert p&#229; state (alts&#229; atoms/selectors i Recoil og observable i MobX).&#160;<\/p><p>&#160;<\/p><p>Fordeler:<\/p><ul>\t<li>Lett &#229; sette seg inn i (i motsetning til Redux), da det er minimalistisk og sv&#230;rt likt state-mekansimen innebygd i React<\/li>\t<li>Samme state&#160;kan brukes p&#229; forskjellige m&#229;ter (ved &#229; implementere flere selectors, likt som reducers i Redux)<\/li>\t<li>Kan bruke og oppdatere state direkte i hvert niv&#229; i komponenthierarkiet (ikke en provider i toppen)<\/li><\/ul><p>&#160;<\/p><p>Ulemper:<\/p><ul>\t<li>Ytelse er muligens bedre i Redux og MobX, men Recoil har tydelige fordeler n&#229;r det kommer til enkelhet<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1329,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en arkitektur der man definerer en mengde endepunkter som kan hente, endre og slette ressurser. Dette gj&#248;res med HTTP-sp&#248;rringer mellom &#34;loosely coupled&#34; applikasjoner (typisk en klient-server-arkitektur). Endepunktene er begrenset til det som settes opp av utvikleren, med tanke p&#229; data som tas inn og returneres, og m&#229; f&#248;lges strengt for at de skal fungere. REST er tilstandsl&#248;s, som vil si at ingenting lagres p&#229; serveren om sp&#248;rringene som gj&#248;res (eksempelvis m&#229; autentiseringsn&#248;kkel sendes med for hver sp&#248;rring, hvis applikasjonen har et brukersystem). Siden sp&#248;rringene gj&#248;res over HTTP kan dataen som returneres lagres i cache, noe som gir kjappere innlasting neste gang den samme sp&#248;rringen utf&#248;res. N&#229;r mye informasjon skal h&#229;ndteres vil&#160;dette fort f&#248;re til mange endepunkter. Da&#160;blir det&#160;vanskelig &#229; hente akkurat den dataen man trenger med f&#229; sp&#248;rringer og alle endepunktene vil gj&#248;re det uoversiktlig. I noen tilfeller vil det ogs&#229; bli hentet for mye data enn det man trenger.<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k mellom klient og server, hvor klienten gj&#248;r tilpassede sp&#248;rringer (alts&#229; hvilke spesifikke data man vil ha) mot serveren (over samme &#34;endepunkt&#34;). P&#229; serveren defineres hvilke sp&#248;rringer som kan gj&#248;res og hvilke data de <em>kan<\/em> returnere. Slik henter man dataen man trenger med f&#229; sp&#248;rringer (ofte bare &#233;n), og man unng&#229;r &#229; hente for mye data. GraphQL har et innebygd typesystem, som fungerer ved at hvert felt i en sp&#248;rring har en tilordnet type (gj&#248;res p&#229; serversiden). Dette gj&#248;r at man enkelt kan sjekke om verdier som tas inn som argumenter og som returneres har &#248;nsket type (validering). Typesystemet kan ogs&#229; f&#248;re til at klienten og serveren blir knyttet sammen i st&#248;rre grad enn i en REST-arkitektur, da typene p&#229; serversiden ogs&#229; brukes p&#229; klientsiden. I motsetning til REST st&#248;tter GraphQL kun JSON-data og det har heller ingen innebygd caching-mekanisme.<\/p><p>&#160;<\/p><p>REST har blitt en standard i industrien n&#229;r det kommer til definering av API, men GraphQL har blitt stadig mer popul&#230;rt de siste &#229;rene.&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533768,"ext_inspera_userAssessmentSetupId":7139936,"ext_inspera_userAssessmentId":4841337,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Freberg Giske Naper (10227)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":44314813,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3119,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Innebygd i React finnes det mekanismer for state management og dataflyt som er basert p&#229; state og properties. State er er komponentens tilstandsdata som kan endres i kj&#248;retid. Properties er er data man sender inn i en komponent idet den opprettes. For &#229; sende properties til andre komponenter i komponenthieriakiet, baserer React seg p&#229; en &#34;parent-child&#34;-oppbyggning. Dvs. at det er mulig for en &#34;parent&#34;-komponent, &#229; sende properties ned til sine &#34;child&#34;-koponenter. Det g&#229;r ikke ann for &#229; en &#34;child&#34;-kompoennt &#229; sende properties direkte til en &#34;parent&#34;-komponent. Likevel er det mulig &#229; sende &#34;call-back&#34;-funksjoner, som gj&#248;r at &#34;child&#34;-komponenter kan endre states hos &#34;parent-komponenter&#34;.&#160;<\/p><p>&#160;<\/p><p>I st&#248;rre applikasjoner med utvidet og komplisert komponenthieriaki, kan det&#160;fort bil un&#248;dvendig komplisert kode ved &#229; bruke den innebygde &#34;parent-child&#34;-strukturen. Da finnes det andre teknikker for &#229; opprette en form for &#34;Global State Management&#34;. En l&#248;sning med global state vil ha all data lagret ett sted og komponenter&#160;blir automatisk oppdatert n&#229;r data endres.&#160;Jeg har valgt &#229; fokusere p&#229; Redux, Mobx og Context.&#160;<\/p><p>&#160;<\/p><p>Redux er et tredjeparts biblotek for state management i React. Hovedkomponentene i Redux best&#229;r av en store, actions, reducers og en dispatch. Grunnprinsippet g&#229;r ut p&#229; at det kun finnes ett sted hvor dataen er lagret, alts&#229; i Store. Dette er den s&#229;kalte &#34;Single Source of Truth&#34;, og her holdes hele appliksjonens state. Videre har man Actions objekter, som beskriver noe som har skjedd i applikasjonen. En Reducer er en funksjon som tar inn den n&#229;v&#230;rende&#160;staten og en action objekt, og oppdaterer staten hvis det er n&#248;dvendig. En reducer er en slags &#34;Event Listener&#34;, som h&#229;nderer hendelser basert p&#229; typen av action-objektet.&#160; Redux store har ogs&#229; en Dispatch-funksjon. Dette er en slags &#34;triggering event&#34;-funksjon. N&#229;r dispatch-funksjonen blir kalt, vil store kj&#248;re sin reducer-funksjon og oppdatere staten.&#160;<\/p><p>&#160;<\/p><p>Mobx skiller seg fra Redux ved at den kan innholde flere stores. Mobx best&#229;r av en application state, derivations, reactions and actions. Det er mer automatikk knyttet til Mobx. Actions endrer staten, og de blir prosessert av derivations og reactions. Mobx bruker en form for oberserver/observable teknikk, som gj&#248;r at alle relevante komponenter blir varslet og oppdatert n&#229;r det skjer en endring. Ift. Redux er Mobx mindre skalerbart.&#160;<\/p><p>&#160;<\/p><p>Context er en enklere form for global state management, og bidrar med mye mindre &#34;broiler plate&#34;-kode enn feks. Redux gj&#248;r. Her har man en Global Provider som man wrapper rundt komponent-hieriaktiet, og man kan s&#229; ha flere providers p&#229; ulike sub-deler av hieriakiet. Med Context kan man dele data og states p&#229; tvers av koponent-hieriakiet. Context er ikke like skalerbart som Redux og egner seg best for mindre applikasjoner som ikke har mye kompleksitet.&#160;<\/p><p>&#160;<\/p><p>Kilder: Forelesningsnotater og tidligere eksamensoppgaver<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2642,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et &#34;up and comping&#34; global state management bibliotek for React. Kjernekonspetet med Recoil er at det best&#229;r av &#34;atoms&#34; og &#34;selectors&#34;.&#160;Atomer fungerer som state-enheter som komponter kan knytte seg til og updatere. Hvert atom har en unik, global key. Verdien til et atom kan v&#230;re en statisk verdi, en funksjon eller en async funksjon. Et atom er som en &#34;vanlig&#34; state i React, bare at det er mulig for alle komponenter i hieriakiet &#229; knytte seg til den. Dersom verdier i atomet endres, vil alle komponenter som er knyttet til atomet, re-rendres.&#160;<\/p><p>&#160;<\/p><p>En selector er en funksjon som tar atomer eller andre selectorer som input, og endrer dens state. Den har en get()- og en set()-funksjon som gj&#248;r det mulig &#229; endre en states verdi.&#160;<\/p><p>&#160;<\/p><p>B&#229;de Redux, Mobx, Context API og Recoil gir alle et sted for &#229; lagre delt data, og mulighet for &#229; kun re-rendre n&#248;dvendige komponenter. Recoil er ment for &#229; v&#230;re enklere &#229; ta i bruk enn Redux og Mobx, samtidig som den l&#248;ser to problemer som Context APIet har:<\/p><p>&#160;<\/p><ol>\t<li>Context kan bare lagre en enkelt verdi. Med Recoil kan man lagre et sett med verdier som hver har sine egne forbrukere.&#160;<\/li>\t<li>I Contex vil en komponent state kun bli delt ved &#229; pushe staten til alle&#160;&#34;ancestors&#34;, som kan f&#248;re til un&#248;dvenige re-rendering av komponenter. Med Recoil vil kun komponenter som knyttet til den staten bli oppdatert.&#160;<\/li><\/ol><p>En ulempe med Recoil er at det fortsatt er et relativt nytt og upr&#248;vd state management biblotek. Redux, Mobx og Context er velutpr&#248;vd, og det finnes mye god dokumentasjon &#229; finne om disse tre. Ved &#229; ta i bruk Recoil p&#229; et tidlig tidspunkt, vil det kunne bli vanskelig &#229; finne l&#248;sninger p&#229; problemer som&#160;kan oppst&#229; underveis i utviklingen.&#160;<\/p><p>Kilder:<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p><p>https://medium.com/@rphansen91/react-context-vs-recoil-vs-hawk-dfe1be9e8372<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1354,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I et REST API kan man ha ett eller flere endepunkter. REST er basert p&#229; bruk av URI og HTTP for &#229; identifisere og endre/lese/slette/skrive ressursene. Ved bruk at REST vil man ogs&#229; ha mulighet for bruk av caching-mekanismen som finnes i web-browser. En ulempe ved REST er at man riskirer s&#229;kalt &#34;over-fetching&#34;, n&#229;r API bruker endepunker. &#34;Over-fetching&#34; vil si at man henter mer data enn man egentlig har bruk for. Dette vil s&#230;rlig kunne bli et problem dersom man har mange endepunkter.&#160;<\/p><p>&#160;<\/p><p>Problemet med &#34;Over-fetching&#34; forsvinner ved bruk at et API basert p&#229; GraphQL. Med GraphQL sender man en sp&#248;rring til databasen som innholder b&#229;de s&#248;k og hvilke data som skal returneres. P&#229; denne m&#229;ten vil man kunne hente ut n&#248;yaktig den dataen man er ute etter, og unng&#229;r &#34;over-fetching&#34;. GraphQL har ogs&#229; en mulighet for validering av dataen den henter ut, gjennom et type-system. I motsetning til REST mangler GraphQL mulighet for caching av data i HTTP-laget. Det baserer seg ogs&#229; kun p&#229; JSON som markup-language. I REST kan dataen ha andre markup-languages.&#160;<\/p><p>&#160;<\/p><p>Kilder: Forelesningsnotater og tidligere eksamensoppgaver<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534017,"ext_inspera_userAssessmentSetupId":7140100,"ext_inspera_userAssessmentId":4841190,"dateLastModified":"2020-12-01T10:01:26Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:26Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Årøe Alfred Lieth (10078)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":12182327,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2376,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er mange mulige m&#229;ter &#229; h&#229;ndtere state p&#229; i React.<\/p><p>For state som brukes og kontrolleres innad i en komponent er det mest vanlig &#229; bruke de innebygde mekanismene som React tilbyr.<\/p><p>For funksjonelle komponenter&#160;er useState hooken den mest brukte. Den lar deg lagre en variabel og gir deg en egen funksjon til &#229; oppdatere denne.<\/p><p>I klasse komponenter tilsvarer&#160;state variabelen dette. Der bruker man setState() funksjonen for &#229; oppdatere variablene man har deklarert til &#229; v&#230;re i staten.<\/p><p>Funksjonelle komponenter har ogs&#229; en nyttig hook for &#229; lagre state som heter useReducer. Den gir deg muligheten til &#229; lagre flere variabler p&#229; en gang og er nyttig &#229; bruke dersom man ikke vil bruke mange useState i en komponent. Et godt eksempel p&#229; n&#229;r man brude bruke useReducer over useState er hvis man har det stort form med mange inputfelter som man skal behandle som kontrolerte komponenter og lagre verdiene deres.<\/p><p>&#160;<\/p><p>For &#229; h&#229;ndtere dataflyt i en React applikasjon s&#229; er den mest vanlige metoden for dette &#229; bruke props. Props er navngitte variabler som sendes med inn i en komponent n&#229;r den blir laget/rendret. Det fungerer ganske likt&#160;som input til en vanlig funksjon. Props som en child komponent f&#229;r fra sin parent komponent er derimot immutable og kan ikke endres fra child komponenten.<\/p><p>&#160;<\/p><p>Har man splittet opp koden i mange nestede komponenter, der flere av komponentene trenger tilgang til den samme staten kan man komme over det som kalles prop-drilldown. Det vil si at man har blitt n&#248;dt til &#229; &#34;l&#248;fte&#34; staten opp til den &#248;verste parent komponenten av de kompnentene som trenger staten, og m&#229; sende denne staten ned gjennom flere lag med komponenter ned&#160;i komponent-treet for at verdien skal ende opp i riktig child komponent.<\/p><p>Dette blir etter hvert uryddig og slitsomt &#229; forholde seg til som utvikler, og er grunnen til at det er laget state-management biblioteker. Context er React sin egen versjon av dette, mens Redux og MobX er to tredjeparts biblioteker som h&#229;ndterer dette. Sentralt for alle de er at staten abstraheres vekk fra komponentene, og kan hentes ut direkte i kun de komponentene som trenger de. De tilbyr ogs&#229;, i motsetning til props,&#160;mulighet for &#229; oppdatere staten fra komponentene som bruker de. Disse bibliotekene blir derfor en l&#248;sning b&#229;de for &#229; h&#229;ndtere state og for &#229; h&#229;ndtere dataflyt i en React-applikasjon.&#160;<\/p><p>&#160;<\/p><p>Det er ikke uvanlig &#229; benytte seg av flere av de forskjellige mekanismene i en applikasjon. Hvor man burde bruke hva kommer an p&#229; strukturen av prosjektet, og hensikten til staten.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3671,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt bibliotek for &#229; h&#229;ndtere state management. Det kan derfor bli sammenliknet med andre statemanagement l&#248;sninger som Context, Redux eller MobX. I praksis&#160;s&#229; er meningen at &#229; bruke Recoil skal f&#248;les ganske likt ut som React sine innebygde mekanismer som useState hooken.<\/p><p>&#160;<\/p><p>Recoil gir deg tilgang til en rekke hooks. De vanligste er:<\/p><p>* atom, for &#229; sette opp strukturen til en by variabel i staten<\/p><p>*&#160;useRecoilState, for &#229; f&#229; tilgang til lese og skrive muligheter p&#229; en del av staten<\/p><p>* useRecoilValue, for &#229; f&#229; kun lesetilgang til en del av staten<\/p><p>* useSerRecoilState, for &#229; kun oppdatere state<\/p><p>* useResetRecoilState, for &#229; resette en state til sin default verdi<\/p><p>* selector, for &#229; avlede en state fra en annen atom eller selector<\/p><p>&#160;<\/p><p>Komponenter som bruker en del av staten vil bli re-rendered om den delen av staten oppdaterer seg. I motsettning til Context og props er det derimot&#160;<em>kun<\/em> den ene komponenten som re-rendrer, og ikke alle komponenetne som har mulighet til &#229; f&#229; tak i den staten.<\/p><p>&#160;<\/p><p>Fordeler:<\/p><p>Lagd for &#229; ligne&#160;p&#229; react. Gj&#248;r det lettere &#229; sette seg inn i enn andre lignende biblioteker.<\/p><p>Enkelt &#229; kunne sette opp variabler som lese/skrive eller kun lese.<\/p><p>Minimalt, hvis ingen boilerplate kode.<\/p><p>Baserer seg p&#229; &#229; bruke rene funksjoner (pure functions), som betyr at det er enkelt &#229; teste med rammeverk som Jest.<\/p><p>God ytelse. Ble hovedsaklig laget av Facebook p&#229; grunn av ytelsesproblemer med de andre state management l&#248;sningene.<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>Et nytt bibliotek vil gj&#248;re nettsiden in st&#248;rre.<\/p><p>Det er et nytt bibliotek som ikke s&#229; mange kan. Selv om det er lett &#229; sette seg inn i s&#229; blir det uansett automatisk mer for andre utviklere &#229; sette seg inn i prosjektet ditt.<\/p><p>Lider litt av at det er et nytt bibliotek, og fortsatt er i utviklingsfasen:<\/p><p>* Siden det er nytt har det ingen debugging tools, s&#229;nn som Redux har med&#160;sin &#34;Redux DevTools&#34;.<\/p><p>* Ikke offisielt st&#248;ttet for servers-side rendering. Mange React sider er single-page applications, men server-side rendering blir mer og mer popul&#230;rt s&#229; det er dumt &#229; ikke st&#248;tte det.<\/p><p>* Ikke offisielt st&#248;ttet for React Native. Dette er dumt siden state management er en av de tingene som man burde v&#230;re overf&#248;rbart mellom React og React-Native prosjekter.<\/p><p>* St&#248;tter ikke middleware enda.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org<\/p><p>https://www.youtube.com/watch?v=BchtCWxs7sA&#38;ab_channel=Bytesized<\/p><p>https://bigcheeseapp.com/2020/07/12/recoil-vs-redux-react-state-management-2020/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1042,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er et &#171;design pattern&#187;, som er velpr&#248;vd og tatt i bruk i stor grad for &#229; lage API-er. REST baserer seg p&#229; lage en rekke med endepunkter som f&#248;lger et fast m&#248;nster, og er en tilstandsl&#248;s l&#248;sniong som ikke husker klientens foresp&#248;rsler. Hvert endepunkt kan st&#248;tte &#233;n eller flere HTTP metoder, for &#229; lese, skrive, endre, slette eller opprette data.&#160;Endepunktene har en definert datatype som skal returneres. Dette gj&#248;r det forutsigbart og enkelt &#229; analysere bruk siden endepunktene er adskilt. I tillegg gj&#248;r det at man kan lage s&#229; effektive sp&#248;rringer i backend som mulig, fordi man vet alle kombinasjoner av data som det kan sp&#248;rres om. Man drar ogs&#229; nytte av Cashing-mekanismen som default er innebygd i moderne nettlesere.&#160;<\/p><p>&#160;<\/p><p>GraphQL er &#8220;up and coming&#8221; og er et faktisk sp&#248;rrespr&#229;k. GraphQL har kun ett endepunkt og i en request s&#229; bestemmer klienten selv hvilke data den vil ha. Dette gj&#248;r at klienten f&#229;r akkurat den dataen den vil ha, og GraphQL sitt typesystem sikrer at dataen kommer p&#229; riktig format. Man slipper &#229; f&#229; for mye data (overfetching) og man slipper &#229; m&#229;tte ha flere requests for &#229; f&#229; all dataen man trenger (underfetching). Begge disse kan v&#230;re problemer med REST l&#248;sninger.&#160;Som utvikler f&#229;r man ogs&#229; en bedre opplevelse n&#229;r man skal skrive queries, da de blir mer prorammerings-sentrert, kontra &#229; konkatinere variabler i strenger som man m&#229; gj&#248;re for &#229; skrive REST endepunktene. GraphQL st&#248;tter kun JSON data mens REST kan st&#248;tte det dataformatet man m&#229;tte &#248;nske, og GraphQL kan i motsetning til REST ikke default dra nytte av noe cashing-system.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534048,"ext_inspera_userAssessmentSetupId":7140002,"ext_inspera_userAssessmentId":4841526,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bendiksen David Ferenc (10027)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303589,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2547,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere mekanismer og teknikker for h&#229;ndtering av tilstand og dataflyt i React.<em>&#160;<\/em><em>By default<\/em> kan man bruke props og callbackfunksjoner (som p&#229; sett og vis er den &#34;gode gamle&#34; React-m&#229;ten) eller React Context API-et.<\/p><p>&#160;<\/p><p>&#197; implementere tilstandsh&#229;ndtering ved hjelp av props, gj&#248;r man ved &#229; ha states lengre opp i komponenthierarkiet som passeres som props ned til children, som kan gj&#248;re nytte av tilstanden de f&#229;r. Tanken her er &#229; legge state i en komponent som er h&#248;yt nok i hierarket til at den har alle relevante komponenter som children, men som ogs&#229; ikke er un&#248;dvendig h&#248;yt i hierarket (slik at en ikke har masse komponenter som f&#229;r props kun for &#229; passere de videre til sine children) &#8211; dette for &#229; forhindre redundans. Siden props er <em>immutable<\/em>, m&#229; man ogs&#229; passere callbackfunksjoner til komponenter som ogs&#229; trenger &#229; endre p&#229; tilstanden.<\/p><p>&#160;<\/p><p>React Context API-et er en m&#229;te &#229; gj&#248;re tilstandsh&#229;ndtering lettere i React n&#229;r det er mange komponenter som har behov for &#229; ha tilgang til samme state. Det fungerer i korte trekk ved &#229; definere en state for s&#229; &#229; <em>wrappe<\/em> komponentene som har behov for det, i en s&#229;kalt <em>context provider<\/em>, som gir alle komponentene den <em>wrapper<\/em> tilgang til tilstanden i Contex-et.<\/p><p>&#160;<\/p><p>Man kan ogs&#229; benytte en rekke biblioteker for &#229; h&#229;ndtere global tilstandsh&#229;ndtering og dataflyt; Redux og MobX er eksempler her. Disse tilbyr metoder for &#229; implementere <em>global state<\/em> som er tilgjengelig for alle komponenter.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2409,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tilstandsh&#229;ndteringsbibliotek for React &#224; la Redux og MobX. Det baserer seg p&#229; s&#229;kalte <em>atoms<\/em> og <em>selectors<\/em>. Atoms er i bunn og grunn tilstandsenheter som er oppdaterbar og <em>subscribable<\/em> (at komponenter kan gj&#248;re slik at de holder seg oppdatert om tilstanden). Selectors er rene funksjoner (output er kun bestemt av input) som tar atoms eller andre selectors som input. De er ogs&#229; subscribable, re-evalueres ved oppdatering av input-atoms/-selectors og kan beregne s&#229;kalte <em>derived data<\/em> (f.eks. beregne alder n&#229;r f&#248;dselsdato er kjent).<\/p><p>&#160;<\/p><p>Motivasjonen til Recoil fra nettsiden dems (https://recoiljs.org/docs/introduction/motivation):<\/p><ul>\t<li>We get a boilerplate-free API where shared state has the same simple get/set interface as React local state (yet can be encapsulated with reducers etc. if needed).<\/li>\t<li>We have the possibility of compatibility with Concurrent Mode and other new React features as they become available.<\/li>\t<li>The state definition is incremental and distributed, making code-splitting possible.<\/li>\t<li>State can be replaced with derived data without modifying the components that use it.<\/li>\t<li>Derived data can move between being synchronous and asynchronous without modifying the components that use it.<\/li>\t<li>We can treat navigation as a first-class concept, even encoding state transitions in links.<\/li>\t<li>It&#39;s easy to persist the entire application state in a way that is backwards-compatible, so persisted states can survive application changes<\/li><\/ul><p>For &#229; sammenligne med Redux: Det virker som at Recoil har en mye mer React-aktig m&#229;te &#229; gj&#248;re ting p&#229;. Recoil har betraktelig mindre <em>boilerplate code<\/em> og oppsett. Fra det jeg kan se virker Recoil egentlig bedre(?). Redux krever som sagt en god del oppsett, man m&#229; sette opp reducers, actions, types, RootReducer, store... og subscribing kan bli veldig rotete i Redux (dette har dog blitt bedre med useDispatch- og useSelector-<em>hooksene<\/em>). En stor ting er at Recoil st&#248;tter async <em>by default<\/em>. Async funker ogs&#229; med Redux, men det er mye mer kn&#248;dd.<\/p><p>&#160;<\/p><p>MobX har jeg ikke jobbet mye med, men jeg vet at mye av det plagsomme man selv m&#229; holde styr p&#229; i Redux, er skjult i MobX. (https://mobx.js.org/the-gist-of-mobx.html) MobX baserer seg p&#229; state, actions og derivations og virker i grunn ganske likt Recoil. Det virker som at MobX sin tiln&#230;rming er mer &#229; <em>gj&#248;re<\/em> tilstand og data i komponenter global med makeObservable, mens Recoil definerer egne atoms for state. I min formening virker Recoil mer oversiktlig. Selv om MobX fremst&#229;r som veldig lavterskel, virker det som at det ogs&#229; &#229;pner for at det lettere blir rot i koden.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2079,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en m&#229;te &#229; knytte klient og server sammen p&#229; ved &#229; definere en mengde endepunkter for &#229; gi tilgang til server-ressursene via <em>HTTP requests<\/em> og URL. For hvert element / hver ressurs p&#229; serveren, m&#229; det defineres et nytt endepunkt i REST; det m&#229; defineres hva som skal returneres fra hver av ressursene. At dette m&#229; defineres p&#229; forh&#229;nd kan lede til problemer som <em>overfetching<\/em> eller <em>underfetching<\/em>: Kanskje du egentlig kun er interessert i en spesifikk undermengde av informasjonen til en ressurs, men i REST returneres uansett hele datasettet til ressursen, og hvis du vil ha data som kommer fra X antall ressurser, s&#229; m&#229; du gj&#248;re X antall requests. P&#229; den positive siden er REST et enkelt nok konsept som gir god kontroll p&#229; hva som skjer, og det gir en mulighet til &#229; benytte seg av caching.<\/p><p>&#160;<\/p><p>Hvorav REST er et konsept, er GraphQL en spesifikk l&#248;sning, et sp&#248;rrespr&#229;k med en mengde verkt&#248;y. I GraphQL benytter man seg bare av et endepunkt, og man utf&#248;rer SQL-aktige sp&#248;rringer til serveren igjennom dette. Denne h&#229;ndteringen gj&#248;r at man unng&#229;r <em>overfetching<\/em> eller <em>underfetching<\/em> siden man spesifiserer hva man s&#248;ker etter og hva man vil skal returneres. I tillegg har man i GraphQL et typesystem &#229; forholde seg til, som gj&#248;r det lettere og sikrere &#229; kode til da det &#229;pner for validering. GraphQL st&#248;tter dog kun JSON, og gir ikke mulighet til implisitt <em>HTTP Caching<\/em>.<\/p><p>&#160;<\/p><p>Som et n&#248;ytralt punkt kan jeg nevne at bruken av GraphQL f&#248;rer til en noe tettere sammenkobling av klient og server i forhold til REST-tiln&#230;rmingen. Dette kritiseres av mange p&#229; grunnlag av skalerings-problematikk og konvensjoner, men samtidig har man som sagt mulighet til &#229; gj&#248;re validering p&#229; klientsiden ved denne tettere tilknytningen.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11534073,"ext_inspera_userAssessmentSetupId":7139976,"ext_inspera_userAssessmentId":4841405,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rebner Anders Hoelseth (10038)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22077967,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1854,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State brukes til &#229; lagre data lokalt i komponenter. State oppdateres i klassekomponenter med setState-funksjonen, og med en hook i funksjonelle komponenter. N&#229;r state oppdateres, vil ogs&#229; komponenten rerendres, og state brukes derfor gjerne til lagring av data som komponenten viser frem, eller data som komponenten bruker til &#229; rendre seg p&#229; ulike m&#229;ter.<\/p><p>&#160;<\/p><p>React-applikasjoner er delt&#160;inn i flere komponenter, og ofte trenger en child-komponent informasjon fra sin parent. Det kan for eksempel dreie seg om en bildekomponent som trenger URI til et bilde, eller en listekomponent som trenger elementer. For &#229; sende data nedover i hierarkiet til underkomponenter, brukes props. Dette er en veldig god React-mekanisme fordi det gj&#248;r at komponenter kan gjenbrukes i applikasjonen, men ogs&#229; i andre applikasjoner.<\/p><p>&#160;<\/p><p>Noen ganger kan det v&#230;re relevant at mange komponenter mottar, bruker og videresender samme props. Dette vil v&#230;re litt knotete og kan f&#248;re til diverse problemer som det er vanskelig &#229; finne ut av. Dette konseptet kalles prop drilling. Det finnes mekanismer for &#229; unng&#229; dette, eksempler er Context (med provider og consumer), Redux og MobX. Disse vil gj&#248;re variabler (state) og evt. set-funksjoner tilgjengelig globalt gjennom en data-store. Alle komponenter som trenger &#229; bruke disse kan dermed selv aksessere storen. I enkelte prosjekter kan et&#160;mulig &#34;problem&#34; med props v&#230;re at props kun endres lokalt i komponenten, og ikke hos parent/child-komponenter&#160;ogs&#229;.&#160;Et typisk eksempel er light/dark mode-funksjonalitet - dersom en komponent bytter mode, er det som regel &#248;nskelig at resten av applikasjonen gj&#248;r det samme.&#160;Dette l&#248;ses ogs&#229; ved bruk av state management-biblioteker. For at andre komponenter skal rerendre n&#229;r store-variabler endres, m&#229; storen v&#230;re observable og de aktuelle komponentene v&#230;re observers. En observer-komponent rerendrer bare hvis en store-variabel den bruker endres.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2341,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management-bibliotek slik som Redux og MobX (som nevnt i forrige oppgave).<\/p><p>&#160;<\/p><p>Recoil best&#229;r hovedsaklig av atoms og selectors. Atoms inneholder state, og komponenter kan subscribe p&#229; disse slik at de re-rendrer (samme tankegang som observable og observer nevnt i forrige oppgave). Flere komponenter kan subscribe p&#229; samme atom, og p&#229; den m&#229;ten dele state. Selectors brukes for &#229; oppdatere atom-state.<\/p><p>&#160;<\/p><p>En av fordelene med Recoil er at man&#160;ikke trenger &#229; skrive mye kode for &#229; komme i gang (boilerplate-kode), i motsetning til Redux. En st&#248;rre fordel med Recoil er at applikasjonen f&#229;r bedre performance ved at man unng&#229;r un&#248;dvendige re-renders.<\/p><p>&#160;<\/p><p><u>Kilder<\/u><\/p><p>https://recoiljs.org (video + basic tutorial)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2753,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I denne oppgaven diskuterer jeg forskjellene overordnet, uten &#229; g&#229; inn i kodedetaljer o.l.<\/p><p>&#160;<\/p><p>GraphQL er i all hovedsak et query-spr&#229;k med ett enkelt endepunkt. Schema brukes til &#229; definere data, og resolvers brukes til &#229; aksessere data.<\/p><p>&#160;<\/p><p>REST (<strong>RE<\/strong>presentational <strong>S<\/strong>tate <strong>T<\/strong>ransfer) er basert p&#229; ressurser som gj&#248;res tilgjengelig av URI-er, og man bruker HTTP-verbene GET, PUT, POST og DELETE for&#160;&#229; lese, oppdatere, opprette og fjerne ressurser.<\/p><p>&#160;<\/p><p>N&#229;r man fetcher data med REST, vil man alltid f&#229; tilbake all data, og det er ikke mulig &#229; sette begrensninger for hvilke felter man &#248;nsker. Dette kalles &#39;over-fetching&#39; fordi man gjerne mottar mer data enn man har bruk for. Dersom man &#248;nsker &#229; fetche data fra to endepunkter, er man n&#248;dt til &#229; gj&#248;re to kall. Her viser GraphQL en stor fordel ved at man kan skreddersy queries og bare motta de feltene man &#248;nsker (kan sammenlignes med &#39;grunnleggende&#39; SQL). Med GraphQL kan man ogs&#229; motta flere objekter gjennom ett kall.<\/p><p>&#160;<\/p><p>GraphQL er veldig kraftig og viser en fordel n&#229;r det kommer til performance fordi man (potensielt) trenger f&#230;rre fetch-kall og fordi man kan begrense mengden data. N&#229;r det er sagt, s&#229; er det litt mer jobb &#229; sette opp GraphQL, og det er ikke n&#248;dvendig for alle typer applikasjoner. REST har en fordel n&#229;r det kommer til caching, og er i tillegg enklere &#229; sette seg inn i.<\/p><p>&#160;<\/p><p>REST har eksistert lenge og&#160;er fortsatt industri-standarden, og har dermed en fordel av at det finnes flere verkt&#248;y. Jeg har likevel inntrykk av at GraphQL begynner &#229; bli sv&#230;rt popul&#230;rt og anerkjent,&#160;og et supert utviklerverkt&#248;y er GrahpiQL, som er veldig kjekt &#229; bruke under utvikling og som i tillegg gj&#248;r det sv&#230;rt enkelt&#160;&#229; l&#230;re seg GraphQL ved &#229; leke med queries.<\/p><p>&#160;<\/p><p>Jeg vil&#160;ikke konkludere med at det ene biblioteket er bedre enn det andre. Det er som med alle biblioteker - hvilke teknologier som er best avhenger av&#160;type applikasjon.<\/p><p>&#160;<\/p><p><u>Kilder<\/u><\/p><p>https://www.restapitutorial.com/lessons/whatisrest.html<\/p><p>https://graphql.org/<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534423,"ext_inspera_userAssessmentSetupId":7140099,"ext_inspera_userAssessmentId":4842166,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Koteng Markus Thomassen (10034)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":14028570,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3086,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State og props<\/p><p>State brukes for &#229; lagre en komponents data. Props brukes til &#229; sende data nedover i komponenthierarkiet. Props er immutable (tilstand kan ikke endres etter opprettelse). Funksjoner som sendes nedover i hierarkiet, kan kalles for &#229; sette verdier h&#248;yere opp i hierarkiet. Props kan p&#229; denne m&#229;ten ogs&#229; sende data oppover i hierarkiet.&#160;<\/p><p>&#160;<\/p><p>Klassekomponent vs funksjonell komponent<\/p><p>Klassekomponenter og funksjonelle komponenter gj&#248;r det litt forskjellig n&#229;r de lagrer states. For klassekomponenter brukes this.state og this.setState for &#229; henholdsvis sette opprinnelig state, og for &#229; oppdatere states. Funksjonelle komponenter er n&#248;dt til &#229; ta i bruk hooks for &#229; gi funksjonalitet for &#229; sette og oppdatere states, dette gj&#248;res med useState().&#160;<\/p><p>&#160;<\/p><p>React Context API<\/p><p>React Context API gir mulighet til &#229; sende data gjennom komponenthierarkiet, uten &#229; m&#229;tte sende props i hvert niv&#229;. Context brukes til globale data, alts&#229; data som skal leses av mange komponenter. Eksempler p&#229; dette, kan v&#230;re tema, spr&#229;k, inlogget bruker osv. Context APIet skal egentlig bare brukes unntaksvis, dette fordi alt som bruker en context, re-rendres hver gang staten til contexten endres. Med mye bruk av APIet, vil derfor veldig mye m&#229;tte re-rendres, og ytelsen blir d&#229;rligere.&#160;<\/p><p>&#160;<\/p><p>State management<\/p><p>H&#229;ndtering av states er en utfordring i webapplikasjoner, blant annet i forhold til konsistens og redundans. Det er vanligvis mye data hos klienten i en Single Page Application (SPA), og den hierarkiske flyten av data kan fort bli uoversiktlig hvis state brukes i flere greiner. Dette gj&#248;r at states har en tendens til &#229; flyttes oppover i hierarkiet. For &#229; l&#248;se dette, brukes global state management. React sitt Context API kan brukes for global state, men er ikke effektiv n&#229;r states endres ofte, eller er kompleks. Her har Redux og MobX kommet inn som alternative l&#248;sninger.&#160;I Redux s&#229; lagres states ett sted, som kalles store. Store er read-only og kan bare endres via actions (meldinger). Endres kun via dispatch-metoden som tar inn &#171;actions&#187;. Ingen andre deler av koden kan endre p&#229; state. Endres med rene funksjoner (reducer).&#160;&#160;MobX gj&#248;r datastrukturer observerbare og komponenter kan gj&#248;res til observat&#248;rer. Det er enkelt og skalerbart, og er et bibliotek som i mindre grad p&#229;virker koden. Krever mindre boilerplate-kode enn Redux. Har stor fleksibilitet i design av state. MobX sin store(s) kan man b&#229;de lese og skrive til.&#160;<\/p><p>Hvis applikasjonen skal debugges effektivt og man vil ha god kontroll p&#229; dataflyten, s&#229; foretrekkes bruk av Redux. Hvis applikasjonen er liten, s&#229; foretrekkes MobX, siden det abstrakterer mekanismen for oppdatering av en komponent basert p&#229; tilstandsendringer.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2710,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React som ble lansert av Facebook i &#229;r. Blir derfor naturlig &#229; sammenligne Recoil opp mot Redux og MobX. Recoil gj&#248;r det mulig &#229; lage en dataflyt graf fra &#34;atoms&#34; gjennom &#34;selektorer&#34; og ned til React komponentene. &#34;Atoms&#34; er enheter av states, som kan &#34;abonneres&#34; p&#229; individuelt i motsetning til mange andre state-management systemer. N&#229;r et &#34;atom&#34; er oppdatert, re-rendres hver komponent som har &#34;abbonert&#34; p&#229; denne, med oppdatert verdi. &#34;Selektorer&#34; er en funksjon som tar inn et &#34;atom&#34; som parameter. N&#229;r et &#34;atom&#34; er oppdatert som abonnerer p&#229; &#34;selektor&#34;, vil &#34;selektor&#34;-funksjonen bli re-evaluert p&#229; nytt.&#160;<\/p><p>En fordel med Recoil over Redux og MobX er at det krever mindre konfigurasjoner for &#229; f&#229; satt opp og tatt i bruk. Recoil er derfor ansett som mye&#160;enklere &#229; komme igang med. Allikevel virker det som om Redux og MobX fortsatt er bedre n&#229;r det kommer til ytelse.<\/p><p>Det m&#229; ogs&#229; nevnes at siden Recoil er s&#229;pass nytt, s&#229; er det fortsatt i en utpr&#248;vingsfase. Det er derfor vanskelig &#229; ansl&#229; om det kommer til &#229; konkurere med Redux og MobX. Det at Recoil ogs&#229; er i en tidlig fase, gj&#248;r at det er vanskeligere &#229; finne dokumentasjon og hjelp p&#229; problemer/utfordringer som kan oppst&#229;.&#160;Det virker allikevel som starten er lovende, da det skal v&#230;re ganske enkelt &#229; komme i gang med. En forskjell fra Recoil til Redux og MobX, er at Redux og MobX er laget for state management for Javascript, mens Recoil er laget spesifikt for React. Dette kan gj&#248;re at Recoil i st&#248;rre grad kan opptimaliseres for React-applikasjoner. Det virker ihvertfall som utviklerne av Recoil mener det kan ta totalt over for Redux.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/li>\t<li>https://www.telerik.com/blogs/recoil-in-react<\/li>\t<li>https://recoiljs.org<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1760,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST<\/p><p>REST (Representational State Transfer)&#160;er det som vanligvis brukes i utvikling av web-api. Kommunikasjon av ressurser er identifisert med URIer. Her er det bestemt hvilke ressurser vi har og hvordan vi skal aksessere de.<\/p><p>&#160;<\/p><p>GraphQL<\/p><p>GraphQL er et sp&#248;rrespr&#229;k for api, og et alternativ til REST. Det er en server-side runtime for &#229; utf&#248;re sp&#248;rringer.<\/p><p>&#160;<\/p><p>Sammenligning<\/p><p>B&#229;de REST og GraphQL henter alts&#229; data fra en database. En fordel GraphQL har ovenfor REST, er at GraphQL unng&#229;r lasting av for mye data, ved &#229; kun hente dataen som ettersp&#248;rres. I REST f&#229;r man med all data fra endepunktet som ettersp&#248;rres, mens man med GraphQL kun f&#229;r dataen som faktisk ettersp&#248;rres. S&#229; med REST er det serveren som bestemmer formen og st&#248;rrelsen av resssursen, mens i GraphQL deklarerer de tilgjengelige ressursene, og klieten ettersp&#248;r akkurat hva den trenger. En annen fordel med GraphQL er at n&#248;dvendig data kan hentes med &#233;n foresp&#248;rsel. I REST m&#229; man for eksempel sende to foresp&#248;rsler, hvis man vil ha informasjon fra to objekter. GraphQL kan derfor v&#230;re veldig kraftfull, om man bruker det p&#229; riktig m&#229;te. REST har en fordel over GraphQL, med at den har implisitt caching i HTTP-laget. Dette gj&#248;r at man med REST kan gjenbruke datastrukturer i klienten. En annen forskjell der REST fungerer bedre enn GraphQL er ved feilh&#229;ndtering. GraphQL gir deg ofte en status kode p&#229; 200 OK, selv om ikke ting fungerer optimalt, REST kan gi bedre tilbakemeldinger p&#229; hva som gikk galt, ved bruk av forskjellige statuskoder. En annen ulempe med GraphQL er at det kun st&#248;tter JSON-data.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535018,"ext_inspera_userAssessmentSetupId":7140044,"ext_inspera_userAssessmentId":4841406,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Haagensen Per Dahl (10023)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":8714083,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1768,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Internett og applikasjoner p&#229; nett har gjennom tiden forandret seg mye. For bare noen &#229;r siden var den vanligste m&#229;ten &#229; lage nettsider p&#229; med HTML og CSS. Interaktivitet p&#229; nettsider ble gjort ved bruk av Javascript. Den dag i dag har det kommet mange nye m&#229;ter &#229; lage &#229; lage web applikasjoner p&#229;. React er et javascript bibliotek som har til hensikt &#229; forbedre mange av ulempene tradisjonell HTML og javascript applikasjoner m&#248;ter p&#229;.<\/p><p>&#160;<\/p><p>En av de st&#248;rste ulempene med tradisjonel HTML og javascript er hvordan DOM (document object model) fungerer. En av svakhetene med tradisjonel DOM er hvordan den h&#229;ndterer endringer i grensesnittet, f.eks brukerinputs, queries osv. Ved tradisjonel DOM h&#229;ndtering vil en endring av en state kreve at hele DOM treet oppdateres. Siden dagens DOM tr&#230;r er s&#229;ppas intrikate og store, er dette en ganske ressurskrevende prosess.<\/p><p>&#160;<\/p><p>React derimot bruker noe vi kan kalle for en Virtual DOM. En fordel med denne tiln&#230;rmelsen er hvordan React kan oppdaterer isolerte deler av DOM&#39;en (der det skjer endringer) og ikke hele trestrukturen. Dette fungerer p&#229; grunn av m&#229;ten React bruker isolerte komponenter p&#229;. react benytter seg av komponenter som tillater datafyt nedover i hiearkiet, som vil f&#248;re til at endringer i child-strukturer ikke vil p&#229;virke deres parent.&#160;<\/p><p>&#160;<\/p><p>Det er mange teknikker som brukes i React for &#229; manipulere tilstand. Den vanligste er ved bruk av s&#229;kalte props. Props er som navnet tilsier properties, og er egenskaper en utvikler bygger inn i komponentene sine. Hvis en &#248;nsker &#229; laste inn en komponent fungerer props som input-dataen du m&#229; gi for &#229; kunne rendre komponenter. En metode for &#229; dytte data ned i hiearkiet i en React applikasjon, kan v&#230;re med s&#229;kalt Prop-drilling. Her vil child-komponentene inneholde de samme propsa som parent, og p&#229; den m&#229;ten kan de dele data fra parent til child. Prop-drilling medf&#248;rer imidlertid en del ulemper. Problemet med denne tiln&#230;rmingen er hvis applikasjoner blir for store, kan det v&#230;re krevende &#229; f&#229; oversikt over applikasjonen. I&#160;tillegg kan prop-drilling f&#248;re til at strukturen p&#229; applikasjonen din blir for dyp. Hvis en &#248;nsker &#229; endre en del av en state som er en del av en parent komponent kan en benytte seg av Callback-functions.&#160;<\/p><p>&#160;<\/p><p>En l&#248;sning p&#229; dette problemet ble i react l&#248;st med nye rammeverk. Rammeverk som MobX og Redux er s&#229;kalte global state management. Hvis en vet at mye av dataen i en applikasjon skal benyttes av flere komponenter, kan det v&#230;re hensiktsmessig &#229; benytte disse. Ved &#229;&#160;bruke disse kan en enkelt passe global date rundt i applikasjonen. En ulempe med dette er at noen av rammeverkene kan v&#230;re krevende &#229; sette seg inn i, men gir mye tilbake til brukeren n&#229;r det f&#248;rst er implementert. React har ogs&#229; i senere tid innf&#248;rt en state manager som ligner p&#229; Redux og mobX kalt Context.&#160;<\/p><p>&#160;<\/p><p>De senere &#229;rene har ogs&#229; React inf&#248;rt ny funksjonalitet som har endret hvordan en utviklers perspektiv p&#229; state management. Ved innf&#248;ring av s&#229;kalte funksjonelle&#160;komponenter og Hooks. Funksjonelle komponenter er komponenter som ikke inneholder en state, men du kan innf&#248;re dise med bruk av s&#229;kalte hooks. Det finnes forskjellige hooks, og disse er ment for &#229; erstatte componentDidMount() for eksempel fra de eldre klassekomponentene. I funksjonelle komponenter kan du benytte for eksempel [number, setNumber] = useState(0). Her har du variabelen number, og en funksjon setNumber som manipulerer variabelen. Det som er genialt med statene, er at hele grensesnittet vil rerendres n&#229;r disse state-variablene endres. Dette gj&#248;r det enkelt &#229; manipulere endringer i brukergrensesnittet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2523,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. Recoil er en videref&#248;ring av Context API&#39;et&#160;som allerede finnes i React. Context API&#39;et er i hovedsak ment for &#229; h&#229;ndtere oppdateringer som ikke skjer s&#229; ofte, og det er dette Recoil &#248;nsker &#229; endre p&#229;. Recoil &#248;nsker alts&#229; &#229; ogs&#229; kunne h&#229;ndtere h&#248;y-frekvente oppdateringer. M&#229;ten Recoil pr&#248;ver &#229; endre dette p&#229; er ved innf&#248;rng av s&#229;kalte <strong>Atoms<\/strong> og <strong>Selectors<\/strong>&#160;<\/p><p>&#160;<\/p><p><strong>Atoms<\/strong>&#160;er sm&#229; deler av en state. Disse er mulig &#229; oppdatere, og mulig &#229; f&#248;lge for andre komponenter. Hvis en verdi i en Atom endrer seg, vil alle komponenter som &#34;f&#248;lger&#34; denne Atomen, ogs&#229; oppdatere seg (re-render). En konsekvens&#160;av egenskapene til et Atom, er at en kan benytte&#160;seg av disse istede for lokale komponent states. Atoms gir deg deg muligheten til &#229; dele states mellom flere komponenter.&#160;<\/p><p>&#160;<\/p><p><strong>Selectors&#160;<\/strong>er rene funksjoner som tillater Atoms eller andre selectors som input. Selectors representerer en del av en derived state. Komponenter kan ogs&#229; velge &#229; f&#248;lge selectors p&#229; lik linje som Atoms.&#160;<\/p><p>&#160;<\/p><p>I dette faget har mye av fokuset n&#229;r det kommer til &#229; l&#230;re seg om global state management, v&#230;rt p&#229; Redux og Mobx. Disse to er i utgangspunktet to helt uavhengige systemer som l&#248;ser det samme problemet. En tydelig fordel med Recoil slik jeg ser det er kanskje at l&#230;ringskurven ikke er like bratt, som n&#229;r man m&#229; sette seg inn i de to f&#248;rstnevnte. Recoil virker som &#229; v&#230;re ganske enkelt &#229; sette seg inn i, og bruker mange av elementene en allerede kan hvis en har satt seg inn i React states og Hooks. Hvis en &#248;nsker &#229; innf&#248;re Recoil i et prosjekt, vil en ikke trenge &#229; endre hele strukturen p&#229; prosjektet, som en kanskje m&#229; gj&#248;re ved bruk av for eksempe Redux.<\/p><p>&#160;<\/p><p>N&#229;r det kommer til global state management&#160;i React faller det meste ned p&#229; personlige preferanser. Selve hovedproblemet disse bibliotekene &#248;nsker &#229; l&#248;se er jo global state. Det som skiller dem er sm&#229; nyangser, og m&#229;ten de l&#248;ser problemet p&#229;. Slik jeg ser det virker det som om Recoil er en l&#248;sning som kan gangne mange nye utviklere i fremtiden. Hovedfordelen med Recoil er jo dens simelhet. Implementasjonen i Recoil minner veldig mye om React hooks, og derfor blir l&#230;ringskurven mye slakere enn Redux og Mobx. En av ulemene til Recoil, per dags dato er det faktum at det er et nytt bibliotek. Redux og Mobx har et mye st&#248;rre fotfeste, og selskaper verden rundt har basert applikasjonene sine rundt disse l&#248;sningene. Til syvende og sist handler det mest om hva du som utvikler foretrekker. Skal du lage en liten applikasjon med enkel state management, kan det v&#230;re hensiktsmessig &#229; se p&#229; Recoil. Skal du l&#230;re deg en state management som brukes i n&#230;ringslivet, og som er lurt &#229; kunne nesten uansett hva, se p&#229; Redux og Mobx.&#160;<\/p><p>&#160;<\/p><p>Informasjon hentet fra:<\/p><p>https://recoiljs.org/docs/introduction/getting-started&#160;<\/p><p>https://www.telerik.com/blogs/recoil-in-react<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1460,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det siste ti&#229;ret har den stadariserte metoden for &#229; designe web API&#39;er, v&#230;rt &#229; bruke REST. REST API&#39;er er enkle &#229; sette opp og fungerer veldig godt til enkelte bruksomr&#229;der. Det er omsider en del ulemper med REST, som GraphQL &#248;nsker &#229; l&#248;se.&#160;<\/p><p>&#160;<\/p><p>En av de st&#248;rste forskjellene p&#229; REST&#160;og graphql er hvordan de henter data fra Databaser. Et REST API henter vanligvis data fra mange forskjellige endepunkter. Disse endepunktene er satt opp som forskjellige routes i API&#39;et. Et eksempel kan v&#230;re hvis du &#248;nsker &#229; hente ut alle brukere som er registrert i et system, var routen du hentet disse fra f. eks /brukere/, eller en spesifikk bruker ved /brukere/:id. Ved &#229; benytte seg av et REST API, vil du kunne hente ut dataen som eksisterer i disse routsene ved &#229; fetche p&#229; url&#39;en til routen. Graphql gj&#248;r dette derimot annerledes. Her sender man queries direkte til serveren. En av de store fordelene med graphql er at man kan konkretisere hvilken data man &#248;nsker &#229; f&#229; returnert. N&#229;r man sender en query til databasen, vil en f&#229; returnert resultatene som JSON objekter hvor kravene er tilfredsstilt. Graphql bruker s&#229;kalte schamas for &#229; lagre data<\/p><p>&#160;<\/p><p>En av de store ulempene til et REST API, og hvordan denne henter data, er s&#229;kalt over- og underfetching. Disse problemene m&#248;ter du p&#229; fordi den eneste m&#229;ten &#229; hente data, er &#229; benytte endepunktene som er satt opp i API&#39;et. Over-fetching er som ordet sier, at klienten henter mer data en det som er strengt tatt n&#248;dvendig. La oss for eksempel si at du har en liste p&#229; en nettside som &#248;nsker &#229; bare vise frem filmnavn fra en database du har laget. I databasen har du lagt til filmer med &#229;rstall, beskrivelse, sjanger osv. Selvom jeg som utvikler bare &#248;nsker &#229; vise navnet p&#229; filmene, m&#229; jeg likevell hente alle dataene som er lagret om hver film i databasen. Hvis jeg bare skal vise filmnavn, er data som film&#229;r og sjanger un&#248;dvendig data. Dette l&#248;ser graphql ved at du i dine queries kan spesifisere hvilke data en &#248;nsker &#229; returnere.&#160;<\/p><p>&#160;<\/p><p>Et annet problem er underfetching. Dette hander om at hvis du har lagret forskjellige data i forskjellige endepunkter, er en n&#248;dt til &#229; utf&#248;re flere fetcher p&#229; forskjellge endepunkter for &#229; henta all dataen en trenger. Dette f&#248;rer til mye jobb for serveren. En konsekvens av den fleksible oppbydningen av graphql, kan endringer p&#229; klient-siden bli gjort uten &#229; p&#229;f&#248;re ekstra arbeid til serveren. Siden en i graphql ogs&#229; kan be om spesifikke data som skal returneres, trenger ikke de som setter opp backenden gj&#248;re endringer hvis frontenden endrer seg. Dette gj&#248;r at en kjapt kan utf&#248;re utvikling av appliakasjonen i grapghql.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535068,"ext_inspera_userAssessmentSetupId":7140028,"ext_inspera_userAssessmentId":4842170,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Jacobsen Haakon Reithaug (10141)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":31570817,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3018,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React bruker vi tilstand for komponentene v&#229;res. Tilstandene forteller oss rett og slett hvordan komponenter oppf&#248;rer seg (b&#229;de hvordan de ser ut rent grafisk, hva de gj&#248;r/kan gj&#248;re, og hvilke verdier de holder p&#229;), vi kaller disse for &#171;statefulle&#187; komponenter, og stateless hvis de ikke har noen logikk for dette.&#160;Ofte p&#229;virkers komponentenes tilstand av andre komponenter, om det er forgjengere tidligere i hierarkiet eller barn lenger ned. For dette er det viktig at data kan flyttes mellom de ulike komponentene. En metode som kan brukes her er &#229; la&#160;komponenter ta&#160;inn &#34;properties&#34; (props) og oppdaterer sin egen tilstand basert p&#229; dette. P&#229; den m&#229;ten kan man sende data nedover i hierarkiet slik at barn tar inn data fra forgjengeren, og p&#229; den m&#229;ten blir fortalt hvordan de&#160;skal oppf&#248;re seg. Et problem med dette er at barn ikke kan sende data oppover i hierarkiet p&#229; samme m&#229;te. Barn trenger derfor en form for callback logikk for &#229; kunne p&#229;virke foreldrene, og det er derfor man gjerne tar i bruk en&#160;global tilstandsh&#229;ndtering ved litt st&#248;rre applikasjoner. Ved global tilstandsh&#229;ndtering lagrer man tilstanden til applikasjonen som helhet og lar komponenter oppdatere seg basert p&#229; endringer i denne. Eksempelr p&#229; dette er Redux, Mobx og ogs&#229; React sitt Context API.&#160;<br /><br />Redux lagrer all data i en s&#229;kalt &#171;Store&#187; og jeg liker &#229; dra analogen til et innstillingspanel. Endrer man p&#229; innstillinger (alts&#229; verdier i &#171;storen&#187;) vil ogs&#229; komponenter endre seg. En brukerinteraksjon i Redux trigger en s&#229;kalt Action, som vi selv m&#229; definere. Actions oppdaterer data gjennom det som kalles for Reducers, som vi ogs&#229; m&#229; definere. Reducere oppdaterer verdiene i &#171;Store&#187;. N&#229;r verdiene endrer seg m&#229; vi ogs&#229; definere hvilke komponenter som skal lastes p&#229; nytt gjennom selectors, som er sm&#229; funksjon som henter tilstanden fra Store og oppdaterer de riktige komponentene. Redux krever mye tillegsdefinisjoner(boileplate) og legger til mye linjer i applikasjonen. Ved mindre applikasjoner kan dette derfor virke litt mye. Context API kan derfor v&#230;re mer hensiktsmessig.<br /><br />Context API h&#229;ndterer global data litt p&#229; samme m&#229;te som Redux ved at man har en &#171;context&#187; som ligger utenfor applikasjonen. Man definerer her en &#171;Provider&#187; som man pakker rundt selve applikasjonen, noe man fors&#229;vidt ogs&#229; gj&#248;r i Redux (glemte &#229; nevne). Denne s&#248;rger for &#229; tilgjengeliggj&#248;ring data for hele applikasjonen, og man kan sende data gjennom komponentene uten &#229; manuelt m&#229;tte sende data nedover gjennom &#229; spesifisere props. Et problem med context api er at det kan f&#248;re til at man oppdaterer flere komponenter enn strengt n&#248;dvendig, og at hver provider kun kan holde p&#229; en verdi.&#160;<br /><br />En mekanisme&#160;som er verdt &#229; nevne er React hooks. Hooks&#160;gir funksjonelle komponenter funksjonaliteter ved klassekomponenter der man kan bruke useState for &#229; h&#229;ndtere hvilken tilsatnd den funksjonelle komponenten er i, og useEffect for &#229; erstatte lifecycle metoder i klassekomponenter.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2632,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er i f&#248;lge dokumentasjonen et opensource bibliotek som benyttes for state managment. Dette derfor en annen teknologi for &#229; h&#229;ndtere tilstanden til en applikasjon og kan derfor ses p&#229; som en konkurrent til Redux og Context API.<br /><br />Utifra dokumentasjonen virker det som Recoil g&#229;r for &#229; v&#230;re mer minimalistisk, med lite &#34;boilerplate&#34;.&#160;Dette skal derfor medf&#248;re at det er enklere &#229; l&#230;re seg. Man wrapper applikasjonen sin i en &#60;RecoilRoot&#62;, og det er denne som skal h&#229;ndtere flyten av data gjennom aplikasjonen gjennom det som defineres som &#34;atoms&#34;, som i bunn og grunn bare betyr at noe deler samme state. Data blir fordelt til komponenter gjennom selectors, som definere som &#229; v&#230;re vanlige funksjoner. &#34;Atoms&#34; forklares som &#229; v&#230;re tilstander komponenter kan abonnere p&#229;, og disse kan oppdateres, noe som vil gi beskjed til komponenter som abonnerer. Atomene kan brukes i stede for at hver enkelt komponent har sin egen state.&#160;<\/p><p>&#160;<\/p><p>Etter selv &#229; ha brukt Redux for state h&#229;ndtering vet jeg at det er en del&#160;&#229; sette seg inn i, og alt er ikke like&#160;intuitivt som man kanskje skulle &#248;nsket. Dette kan v&#230;re en fordel ved Recoil da det virker &#229; v&#230;re minimalistisk og lett &#229; l&#230;re. Det at det kreves lite boilerplate er ogs&#229; en fordel i retningen av et minimalistisk oppsett, noe jeg ogs&#229; nevnte som en &#34;svakhet&#34; ved Redux i oppgave 1.&#160;<br /><br />En svakhet ved Contex APIet er at man kun kan lagre en verdi pr provider, noe som f&#248;rer til at man m&#229; ha et langt tre med providers som wrapper hverandre.&#160;Dette er ikke tilfellet ved Recoil. Her trenger man kun en provider som wrapper hele appen.&#160;<\/p><p>Recoil blir ikke lagret globalt som context API&#160;og Redux, og kodesplitting blir derfor mulig &#34;out of the box&#34;.<br /><br />En svakhet er at Recoil er ganske nytt og det gj&#248;r ogs&#229; det kan derfor v&#230;re hakket vanskelig for utviklere &#229; finne hjelp hvis de st&#248;ter p&#229; problemer ved bruken. Recoil kan ogs&#229; bare brukes i React.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3163,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er begge teknologier som benytter seg av&#160;HTTP&#160;request for &#229; hente/oppdatere informasjon fra/p&#229; en database.&#160;<\/p><p><br />REST API&#39;et har lenge v&#230;rt en standard for komminikasjon mellom server. Ved REST bruker vi gjerne flere HTTP kall som get, post, put og delete, og kallene spesifiserer hvor i databasen vi &#248;nsker &#229; hente informasjonen. Et praktisk eksempel p&#229; dette er &#229;&#160;legge&#160;til &#34;/spesifisert-lokasjon&#34; i HTTP kallene slik at vi forteller databasen n&#248;yaktig hvor i f.eks. JSON filen vi skal hente data. Dette betyr derfor at REST har det vi kaller for &#34;multiple endpoints&#34;, ettersom det er opp til kallene &#229; definer hvor man skal hente data. Ettersom vi har &#34;multiple endpoints&#34; kan det derfor f&#248;re til at vi m&#229; utf&#248;re en rekke kall for &#229; hente all dataen vi er interessert i. Dette skjer gjerne hvis den aktuelle dataen er spredt utover databasen p&#229; flere endepunkter, og vi f&#229;r da problemet ved &#34;under fetching&#34; som krever at vi m&#229; gj&#248;re flere kall for &#229; hente dataen vi tenger. Ved flere kall&#160;kan&#160;vi&#160;ende opp med &#229; hente mer data enn vi trenger &#34;overfetching&#34;. Dette er problmer som f&#248;lger av at REST APIet returnerer en &#34;fixed&#34; data struktur. Alts&#229; er ikke kallene&#160;dynamisk i utvalget og returnerer alt under det den f&#229;r beskjed om.&#160;Noe som er positivt ved REST APIet er browserkompabilitet for cahching av data, som gj&#248;r at du kan holde p&#229; data og slipper &#229; laste inn data du allerede har lastet inn.&#160;<br /><br />GraphQL er i motsetning til REST basert p&#229; at vi foretar ett kall til serveren for &#229; motta den n&#248;dvendige informasjonen, og skal derfor l&#248;se det nevnte problemet med &#34;over&#34; og &#34;under fetching&#34;.&#160;GraphQL kan derfor sies &#229; v&#230;re&#160;single endpoint, ettersom alle kall kaller til serveren ved &#34;/graphql&#34;. Alt som hentes gj&#248;res gjennom denne adressen og denne biten av http kallet&#160;er derfor &#34;fixed&#34;.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker sine queries for &#229; kunne hente all data ved kun ett kall. Disse&#160;lar deg definere et s&#248;k og hvilke data som skal returneres. F.eks. ville vi i en s&#248;keapplikasjon kunne spsifisere hvilke data vi &#248;nsker &#229; hente fra et objekt, f.eks. hvis vi skal laste inn en stor oversikt med mange elementer til en forhpndsvisning. Vi trenger ikke all infromasjon om hvert objekt, men heller bare den informasjonen som er sentral for brukeren, og som skal bli presentert. Hvis brukeren &#248;nsker &#229; f&#229; mer infromasjon om ett av elementene kan vi s&#229; laste inn den utvidete infromasjonen n&#229;r brukeren ber om det.&#160;<\/p><p><br />Noen av ulempene med GraphQL er at det ikke har like god chaching som REST API. Dette betyr rent praktisk at man kan ende opp med &#229;&#160;skape mer trafikk til serveren n&#229;r man h&#229;ndterer data som lastes inn ofte. Ved API vil denne dataen kunne lagres som nevnt over. GraphQL kan ogs&#229; v&#230;re noe tungvindt for mindre applikasjoner, ettersom oppsettet er mer kompleks enn REST API.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535074,"ext_inspera_userAssessmentSetupId":7140128,"ext_inspera_userAssessmentId":4842163,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Solibakke Per (10005)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37997989,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3911,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React applikasjoner er der generelle (inkluderte) mekanismener for tilstand. Props (Properties) og State.<\/p><p>Begge mekanismenere inneholder infomasjon som videre vil p&#229;virke UI til applikasjonen under render, men er forskjellige i henhold til kjerne funksjonaliteten.<\/p><p>&#160;<\/p><p>1. Props blir gitt til den respektive komponenten som en parameter:<\/p><p>const {<\/p><p>getTableProps,<\/p><p>getTableBodyProps,<\/p><p>&#160;<\/p><p>2. State&#39;s blir selv behandlet i selve komponenten:<\/p><p>handleOpenModal() {<\/p><p>this.setState({ showModal: true });<\/p><p>}<\/p><p>&#160;<\/p><p>Begge generelle komponentene ovenfor har diverse ulemper/fordeler med bruken av dem. Ved &#229; sette &#34;this.state&#34; og eller &#34;this.props&#34; vil tilstandene bli oppdatert og videre rendered i henhold til applikasjonen. I forhold til state er denne funksjonaliteten ansett som &#34;asynchronous&#34;. Hvor React velger &#229; &#34;batche&#34; alle state oppdateringene til slutten av et event. Dette medf&#248;rer at oppdateringer kan ta lag tid for brukerene.<\/p><p>Grunnen for at state funksjonaliteten er&#160;asynchronous er basert p&#229; &#34;preformance&#34;, ved &#229; ha en synchronous state funksjonalitet vil dette medf&#248;rer at gjennom et enkelt event blir applikasjonen &#34;re-rendered&#34; flere ganger.<\/p><p>&#160;<\/p><p>Desto st&#248;rre en &#34;Frontend&#34; applikasjon blir, desto mere &#34;trykk&#34; blir det p&#229; state managment under event&#39;s. Dette er et av dem st&#248;rre problemene ved React, spesielt med hensyn til &#229; bare bruke inkluderte bibloteker.<\/p><p>&#160;<\/p><p>I henhold til hver enkelts kompetanse med &#34;Frontend&#34; utvikling er det viktig &#229; ha en god forst&#229;else med innebygde mekanismer og funksjonaliteter f&#248;r en videre integrerer inn avanserte tredjeparts komponenter. Uten en viss generell forst&#229;else for React, f&#248;r vedkommende integrerer inn tredjeparts komponenter, vil en utvikling bli sterkt pregert av open source metoder, ettersom utvikleren vil ikke ha kompetansen til &#229; kunne utnytte tredjepartskomponentene p&#229; en personlig m&#229;te, men m&#229; heller forholde seg til l&#248;sninger gjennomf&#248;rt av andre.<\/p><p>&#160;<\/p><p>Eksterne Biblotekter.<\/p><p>For &#229; forbedre state managment i React, finnes det mange state management &#34;tredjeparts komponeter&#34; for &#229; kunne bidra til en bedre kontroll. Jeg selv har arbeidet med Redux, hvor MobX&#160;og&#160;&#160;Recoil(Neste oppgave) er andre typer av state managment eksterne bibloteker.&#160;<\/p><p>&#160;<\/p><p>Redux og MobX<\/p><p>B&#229;de Redux og MobX har lignende kjerne konsepter som baserer seg p&#229;:<\/p><p>1. Bruk av Lagrings butikker:<\/p><p>Dette er objektet/er som innholder all infomasjonen tilgjengelig i redux state mangement.<\/p><p>&#160;<\/p><p>2. Actions:<\/p><p>Dette betegner funksjonaliteten som endrer lagringsbutikken.<\/p><p>&#160;<\/p><p>3. Oppdateringer:<\/p><p>At selve lagringsbutikken/e blir oppdatert n&#229;r actions blir gjort p&#229; lagringsbutikken.<\/p><p>&#160;<\/p><p>Tiltross for at Redux og MobX har lignende kjerne funksjonaliteter er det tildels store forsjeller mellom dem.<\/p><p>Redux har bare en Lagringsbutikk som vil videre innholde all infomasjon sent/lagret i denne i en JSON fil. MobX derimot, kan har flere lagringsbutikker. Alle funksjoner som forandrer tilstanden innen MobX er ansett som &#34;Actions&#34;, mens Redux har selv definerete actions. Redux har ogs&#229; selv definerte oppdaterings metoder definert via &#34;Reducers&#34;, mens MobX oppdateres automatisk.<\/p><p>&#160;<\/p><p>Fordelere og ulemper med MobX og Redux.<\/p><p>&#160;<\/p><p>1. Ettersom Redux bare inneholder en enkelt lagringsbutikk, vil dette si at duplikats problemer samt videre &#34;local -fetching&#34; er lett &#229; forholde seg til under utviklingen. Derimot hos MobX kan muligheten for flere lagringsbutikker medf&#248;rer at &#34;local-fetching&#34; og duplikats problemer mye letter oppst&#229; under utviklingen, samt under lansering.<\/p><p>&#160;<\/p><p>2. Som nevnt er Oppdateres MobX automatisk og har ikke&#160;unik definert &#34;action&#39;s&#34;. Dette medf&#248;rer kan MobX&#39;s lagringsbutikk er ansett som &#34;urein&#34; (Oppdateringer gj&#248;res direkte i selve lagringsbutikken). Redux derimot har &#160;unik definert &#34;action&#39;s&#34; som kan beskrives som &#34;Pure functions&#34;. Dette medf&#248;rer lagringsbrutikken i Redux er &#34;read-only&#34; og direkter endringer kan ikke gj&#248;res.<\/p><p>&#160;<\/p><p>3. Overall:<\/p><p>Basert p&#229; popularitet, brukervennlighet, n&#248;dvendig forkunnskaper og skalerbarhet. Kan MobX bli annsett som det eksterne biblotekten som er lettes &#229; sette seg inn i, men redux er b&#229;de mer popul&#230;rt og lettere skalerbart.<\/p><p>&#160;<\/p><p>React Hooks<\/p><p>Dette verkt&#248;yet er et relativt nytt verkt&#248;y som har blitt implementert i React. Det generelle m&#229;let med Hooks er &#229; forbedre behandlingen av props og state integrert i React. Som nevnt, ble state behandlet i selve komponenten, men ved bruk av Hooks kan disse statene deles i forskjellige komponenter.<\/p><p>&#160;<\/p><p>Hooks er med andre ord et verkt&#248;y for &#229; hente ut logikk fra en komponent definert med en state og gi den videre til en eller flere andre komponenter.<\/p><p>&#160;<\/p><p>I forhold til MobX og Redux kan Hooks ogs&#229; sammenlignes i forhold til fordelere og ulemper:<\/p><p>&#160;<\/p><p>Generellt sett, vil det v&#230;re best &#229; bruke Hook i mindre applikasjoner hvor gjenntagende informasjone er n&#248;dvendig.<\/p><p>&#160;<\/p><p>Dette vil da for eksempel v&#230;re at du har en webapplikasjon som tar for seg en og en person i henhold til helse. Hvor en komponent definerer BMIen til personen og den andre komponenten sammeligner gjennomsnittlig vekt og h&#248;yde med denne enkelt personen. Dette er selvf&#248;lgelig et abstrakt eksempel, men poenget her vil v&#230;re at hooks kan da brukes til &#229; sende vekt og h&#248;yde som brukes i begge komponentene. Dette genererer da en lett og effektiv funksjonalitet ved bruk av hooks.<\/p><p>&#160;<\/p><p>Om tildels &#160;samme webapplikasjon skal gjennomf&#248;res, men i dette tilfellet blir alle registrerte brukeren hentet inn automatisk og gjennomsnittlig BMI i en komponent&#160; samt gjennomsnittlig vekt/h&#248;yde i forhold til registrerte brukeren i en annen komponent skal gjennomf&#248;res. Bruk av Hooks her vil ikke v&#230;re optimalt ettersom logikken vil v&#230;re veldig mye st&#248;rre. I dette tilfellet hadde det v&#230;rt bedre &#229; bruke redux, hvor lagringsbutikken inneholder informasjon om all registrerte brukere.&#160;<\/p><p>&#160;<\/p><p>Min konklusjon i henhold til tilstands verkt&#248;y i React er at alle overnevnte verkt&#248;y har sine nytter i ulike funksjoner, hvor som utvikler er det viktigere &#229; ha generell/viderg&#229;ende kunnskap om dem fleste verkt&#248;yene enn &#229; v&#230;re &#34;Expert&#34; i et verkt&#248;y. Dette vil gj&#248;re deg som utviklere mer feksibel og videre generere mere optimale l&#248;sninger for kommende utviklingsprosjekter.<\/p><p>&#160;<\/p><p>Dataflow:<\/p><p>Som nevnt ovenfor inng&#229;r React i mange komponeter. I henhold til Typscript som vi har arbeidet for det meste i dette faget. Er Typescript et supersett av Javascript hvor typescript kan ansess som et Objekt orientert programmerings spr&#229;k som genererer statisk &#34;typing&#34; og kan ha moduller. Dette gj&#248;r da at Typscript kan best&#229; av mange komponenter, definert med moduller og statisk &#34;typing&#34;. I forhold til javascript som i navnet er et &#34;scripting&#34;&#160; spr&#229;k.&#160;<\/p><p>Typisk sett fra begge programmene, er det definnert en hoved fill (App.tsx, App.js) denne hoved filen sender videre kall til andre komponenter definert i applikasjonen, Dette g&#229;r da videre inntill kallet har n&#229;d et endepunkt, hvor dem returnerte verdiene sendes tilbake. Dette vil da foreksempel v&#230;re en endring i state eller props.<\/p><p>&#160;<\/p><p>App.tsx --&#62; Komp1 --&#62; Komp2 (return) --&#62; Komp1 (return) --&#62; (App.tsx (Complete render)).<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2548,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil i henhold til dokumentasjonen er en &#34;state managment&#34; bibliotek og har henholdvis f&#248;lgende kjerne konseptene.<\/p><p>&#160;<\/p><p>Recoil kan bli sett p&#229; som et &#34;state managment&#34; tre, hvor bibliotek har:<\/p><p>&#160;<\/p><p>1. Atomer. (Definerer en shared state) --&#62;<\/p><p>&#160;<\/p><p>2. Selectors. (Fuksjoner) --&#62;<\/p><p>&#160;<\/p><p>3. Videre flyt til React componentene.&#160;<\/p><p>&#160;<\/p><p>I lihet med Redux (Brukt i selv i dette prosjektet) er det visse likheter og ulikheten mellom Recoil. Under bruk av Redux i prosjekt 3, merket jeg selv at integrering av Redux var lett, men &#229; bruke dette verkt&#248;yet p&#229; en effektiv og god m&#229;te var v&#230;rre.&#160; Et problem som oppstod med bruk av Redux var at (i henhold til v&#229;res utviklingsmetode) var at hovedfuksjonalitetene skulle p&#229; plass f&#248;r integreringen av Redux skulle gjennomf&#248;res. Dette valget var ikke det beste ettersom forst&#229;else og utvikling i henhold til Redux var b&#229;de krevende og ikke spesielt kompatibelt med integrering i et relativt stort prosjekt.&#160;<\/p><p>&#160;<\/p><p>Ettersom jeg selv ikke har arbeidet med Recoil, er det vanskelig &#229; argumentere for &#229; imot, om dette bibliotektet vill v&#230;re lettere &#229; integrere enn Redux. Men i forhold til gitt dokumentasjon skal Recoil v&#230;re lettere &#229; sette seg inn i.&#160;<\/p><p>&#160;<\/p><p>1. Kompatiblitet:<\/p><p>Recoil, basert p&#229; kjerne konseptene har i forhold til Redux har ikke behov for &#229; generere lagringsfunksjoner (Stores) og videre gjennomf&#248;re &#34;render&#34; av hele applikasjonen.&#160;<\/p><p>&#160;<\/p><p>2. Pure functions.<\/p><p>I likhet med Redux, hvor bare actions kan oppdatere&#160;lagringsbutikken. Kan bare Selectors brukes til &#229; oppdatere Atomene p&#229; root niv&#229;. Dette gj&#248;r at atomene er &#34;Read - only&#34; og direkter endring kan ikke gjennomf&#248;res p&#229; dem. Dette promoterer en videre stabilitet.<\/p><p>&#160;<\/p><p>3. Brukervennlighetet.<\/p><p>Som nevnt i forrige oppgave, er Redux ansett av flere utviklerere som en mer avansert tredjeparts - komponent enn for eksempel MobX og Hooks. Dette er en av dem st&#248;rre fordelerene nevnt for Recoil. Recoil generere samme n&#248;kkel&#160;funksjonaliteter, men i forhold til Redux er kreves det mye mindre r&#229; kode for &#229; oppn&#229; funksjonaliteten.<\/p><p>&#160;<\/p><p>4. React Hooks.<\/p><p>Recoil er videre bygd opp basert p&#229; funksjonaliteten til React Hooks.&#160; Som nevnt i forrige oppgave, gav Hooks muligheten til &#229; large state&#39;s over flere komponenter, noe som Recoil utnytter.&#160; Atomene kan anses som &#34;hooks&#34; i Recoil biblotektet og lagres og er videre definert med en unik n&#248;kkel.&#160; Dette gj&#248;r da at prinsippet: &#34;Dont Repeat Yourself&#34; som implementeres med hooks ogs&#229; brukes i Recoil.&#160;<\/p><p>&#160;<\/p><p>Med andre ord vil, om n&#248;dvendig gjentagende informasjon kunne hentes direkte ut fra et atom basert p&#229; den unike n&#248;kkelen.<\/p><p>&#160;<\/p><p>5. Utviklingsverkt&#248;y.<\/p><p>Ettersom Recoil er relativt nytt, er det fremdeles my room for nye utviklingsverkt&#248;y&#160;for &#229; kunne optimalisere bruken av Recoil. Til n&#229; er det blandt annet Reactime og Recoilize som brukes i henhold til Recoil APIet. Hvor uten &#229; g&#229; for dypt inn i dette kan Reactime sammelignes med Redux utviklingsverkt&#248;y og Recoilize er et mer visualiserende utviklingsverkt&#248;y som gj&#248;r det lettere &#229; debugge og sette opp flow - grafen for Atoms - Selektors - React components.&#160;<\/p><p>&#160;<\/p><p>I henhold til dokumentasjonen for Recoil, samt overnevnte beskrivelse er det min antagelse at Recoil vil bli mer popul&#230;rt og bedre optimalisert det neste &#229;ret. I henhold til reduksjonen av problemer ved bruk av Recoil i forhold til foreksempel Redux, virker det som at Recoil kan eventuellt overtak for Redux. Allikevel kan Recoil metode med bruk av mange atomer, medf&#248;rer i lik grad med MobX at skalerbarhet blir et problem.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2275,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest API er generellt ansett&#160; som &#34;Backend&#34; standarden for utvikling av databaser, men basert p&#229; en eksponinsiel utvikling og videref&#248;ring av &#34;frontend&#34; som har videre generert st&#248;rre krav for databaser i henhold til database kall og videre avanserte &#34;conditions&#34; har GraphQL blitt utviklet for &#229; b&#229;de forbedre effektiviteten og fleksibilliteten i henhold med interaksjon mot standard &#34;Rest API&#34;.<\/p><p>&#160;<\/p><p>Forskjeller:<\/p><p>1.<\/p><p>I henhold til Rest API (Noe som jeg selv har brukt under dette faget). Baserer &#34;Data fetching&#34; i Rest API p&#229; flere tilgjengelige endpunkter. Dette vil da si for eksempel om databasen inneholder en oversikt over SommerOL kan et kall v&#230;re: /SommerOL/&#197;rstall. Videre kan det da v&#230;re flere tilgjengelige endpunkter som sp&#248;r om mer konkret informasjon som /SommerOL/&#197;rstall/Idrettsut&#248;vere eller&#160;/SommerOL/&#197;rstall/idretter.&#160;<\/p><p>&#160;<\/p><p>I GrapQL derimot vil vil ha &#34;Data fetching&#34; i henhold til en enkelt &#34;query&#34;. Dette kan da for eksempel v&#230;re:<\/p><p>query {<\/p><p>SommerOL (&#197;rstall: TallNr) {<\/p><p>idrettsut&#248;vere<\/p><p>{<\/p><p>name<\/p><p>antall medaljer<\/p><p>osv<\/p><p>}}}<\/p><p>Dette gj&#248;r da et en GrapQL server ikke er begrenset i henhold til endepunktene i likhet med &#34;Rest API&#34;.&#160; Dette gj&#248;r at&#160;GrapQL kan drastisk redusere problemene som Rest API generelt har i henhold til &#34;Under og Over - Fetching&#34;.<\/p><p>&#160;<\/p><p>2.<\/p><p>Utvikling av applikasjonen:<\/p><p>Dette v&#230;re et problem jeg selv hadde med prosjekt 3. Ved bruk av Rest API og dem n&#248;dvendige endepunktene for innhenting av data vil videre utvikling av et prosjekt kreve en st&#248;rre arbeidsmengde. Dette vil da for eksempel v&#230;re at Applikasjonen orginalt bare &#248;nsket &#229; ha idrettsut&#248;vere i applikasjonen, men etter hvert inns&#229; prosjektet at det var n&#248;dvendig med kategorier og sporter. Ved bruk av Rest API medf&#248;rer dette at nye endepunkter p&#229; integreres for backenden for &#229; kunne opprettholde det datakravet stilt til den nye utviklingen.&#160;<\/p><p>&#160;<\/p><p>Under bruk av GrapQL, vil ikke dette problemet oppst&#229;. Forklart basert p&#229; query metoden for &#229; hente ut data.&#160;<\/p><p>&#160;<\/p><p>3.<\/p><p>Skjemaer.<\/p><p>I lihet med mongoose/mongoDB, bruker GrapQL skjermar for &#229; definere komunikasjonen mellom backend og frontend. Dette gj&#248;r at i forhold til Rest API, kan GrapQL definere dem n&#248;dvendige skjemaene (Modeller) som er n&#248;dvendig for web - applikasjonen og deretter kan &#34;frontend&#34; og &#34;Backend&#34; arbeide uavhenig. Dette kan anses som en enorm forskjell, spesielt hos store applikasjoner.<\/p><p>Et eksempel p&#229; en mongoose skjema er vist under (fra prosjektet):<\/p><p>&#160;<\/p><p>const schema = mongoose.Schema (<\/p><p>{<\/p><p>name: String,<\/p><p>winterOlympic: Boolean,<\/p><p>summerOlympic: Boolean,<\/p><p>category: String,<\/p><p>sport: Array,<\/p><p>medals: Number,<\/p><p>active: Boolean,<\/p><p>info: String<\/p><p>},<\/p><p>);<\/p><p>const Athlete = mongoose.model(&#39;Athlete&#39;, schema);<\/p><p>};<\/p><p>Et eksempel p&#229; en GrapQL skjema er vist under:<\/p><p>type Athlete<\/p><p>{<\/p><p>name: String!<\/p><p>category: Int!<\/p><p>sport: [sport!]!<\/p><p>}<\/p><p>&#160;<\/p><p>Som sett p&#229; sammenligning mellom dem to skjemanen er det veldig store likheter.<\/p><p>&#160;<\/p><p>4. Oversikt over &#34;Request&#34;<\/p><p>I forhold til Rest Api, kan ogs&#229; GrapQL anses som en et bedre program i forhold til &#229; kunne analysere hva som blir spurt om p&#229; klient siden til database siden. Denne typen analyse kan da gj&#248;re at un&#248;dvendig informasjon blir fjernt for en bedre preformance. For eksempel om hvilken kategori en idrettut&#248;vere deltar i er uinteressant blandt klienter av webapplikasjonen.&#160;<\/p><p>&#160;<\/p><p>I Rest API blir dette veldig vanskelig &#229; kunne analysere ettersom klientene m&#229; f&#248;lge endepunkter, som vil ende med at klientene henter ut all infomasjon om idrettsut&#248;veren alltid, mens med querys kan klienten velge &#229; bare hente ut en vis del av informasjonen.<\/p><p>&#160;<\/p><p>I forhold til dem overnevnte punktene, mener jeg at Rest API som til dags dato er &#34;standaren&#34; ikke vil v&#230;re standaren veldig mye lenger. Det virker som at b&#229;de&#160;GrapQL samt MongoDB, reduserer dem ellers store problemene med &#34;frontend&#34; - &#34;backend&#34; kommunikasjon, og ikke tar med seg store ulemper. Det &#229; kunne arbeid veldig uavhenig, mellom frontend og backend, uten &#229; m&#229;tte sette opp et enormt kommunikasjons nettverk anser jeg som framtiden i webutvikling.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11539213,"ext_inspera_userAssessmentSetupId":7139913,"ext_inspera_userAssessmentId":4841408,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hognes Sivert (10140)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37306143,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1789,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":1,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har flere m&#229;ter &#229; h&#229;ndtere tilstander p&#229;. En m&#229;te &#229; gj&#248;re det p&#229; er ved bruk av klasser som bruker constructor for &#229; definere tilstander, og setState brukes for &#229; oppdatere tilstanden. I React 16.8 (February 6, 2019) ble en ny m&#229;te &#229; h&#229;ndtere tilstander p&#229; introdusert, Hooks. Hooks ble laget for &#229; gj&#248;re koden enklere og mer lettlest, og man slipper &#229; lage klasser for h&#229;ndtere tilstandene. Hooks defineres som et par med en variable og funksjon for &#229; oppdatere tilstanden. Funksjonen brukes p&#229; lignende m&#229;te til setState. Det finnes i tillegg flere tredjeparts biblioteker for tilstand h&#229;ndtering, som Redux og MobX.<\/p><p>React har en en-veis dataflyt, data sendes nedover komponent hierkiet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3069,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state managment og data-flow. Tilstander i biblioteket defineres som atomer. Selectors er funksjoner som bruker atomer eller andre selectors for &#229; regne ut data basert p&#229; en tilstand. Hovedpoenget med Recoil er at atomer (tilstander) kan brukes i flere komponenter, og n&#229;r atomet endres vil alle komponenter som bruker atomet bli oppdatert. Det er flere m&#229;ter &#229; h&#229;ndtere tilstander i React p&#229;. Det er innebygde funksjoner som Context og, i nyere versjoner, Hooks, og andre tredjeparts biblioteker som Redux og MobX. N&#229;r et atom er definert, kan det brukes og endres p&#229; lignende m&#229;te som ved Hooks, bare ved bruk av useRecoilState istedenfor useState. I motsetning til Hooks kan Recoil atomer brukes i flere komponenter og alle komponenter oppdateres n&#229;r atomet endres. Redux og MobX er andre biblioteker som h&#229;ndterer tilstander p&#229; et globalt niv&#229;.<\/p><p>En fordel med Recoil er at man gjenbruke tilstander i flere kompontenter uten &#229; m&#229;tte sende tilstanden oppover til foreldre-komponenter og gjennom komponent hierarkiet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2311,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En forskjell mellom REST og GraphQL er at REST bruker flere endepunkter mens GraphQL bruker kun et endepunkt. Det betyr at REST bruker flere URI-er basert p&#229; hvilken data du skal hente. For eksempel, hvert skjema i en database bruker hvert sitt endepunkt for hente data fra skjemaet. Istedenfor &#229; bruke forskjellige endepunkter, s&#229; bruker GraphQL bare et endepunkt og hvor og hvilken data som skal hentes defineres ved &#39;query&#39;.<\/p><p>En annen forskjell er hva som blir sendt tilbake. REST vil returnere all data etter en foresp&#248;rsel. I GraphQL kan man spesifisere hvilken data man vil ha. Dette gj&#248;r at n&#229;r man lager en foresp&#248;rsel i REST vil den hente all dataen i resultatsettet, selv om du bare skal bruke noen felt i resultatene. GraphQL p&#229; en annen side henter bare den dataen og feltene du er p&#229; utkikk etter, og man slipper derfor &#229; bruke resurser p&#229; &#229; hente un&#248;dvendig informasjon.<\/p><p>Siden REST bruker flere endepunkter hender det ofte at man m&#229; gj&#248;re flere foresp&#248;rsler for &#229; hente data hvis det er forhold mellom dataen som hentes, en foresp&#248;rsel til hvert endepunkt. Siden GrasphQL kun bruker et endepunkt kan man unng&#229; un&#248;dvendige forsp&#248;rsler.<\/p>"}]}],"ext_inspera_totalScore":7,"score":7}},{"result":{"sourcedId":11539457,"ext_inspera_userAssessmentSetupId":7139985,"ext_inspera_userAssessmentId":4841327,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nguyen Kenny (10123)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":50987191,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3925,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For h&#229;ndtering av state og dataflyt i React-applikasjoner har React sin innebygde mekansime basert p&#229; props (properties), som er data du sender inn til en komponent n&#229;r den opprettes og states som er tilstandsdata som kan endres i kj&#248;restid. React er bygd opp som et komponenttre hvor det&#160;sendes&#160;data fra parent til child-komponent.&#160;Men det er ogs&#229; mulig &#229; sende props oppover i komponenttreet, alts&#229; komponenthierarkiet, ved &#229; sende call-back funksjoner som gj&#248;r at barn kan endre state i parent. Ved mer komplekse applikasjoner med mange komponenter hvor for eksempel samme data skal brukes av flere komponenter, eller data som skal sendes p&#229; tvers av komponenthierarkiet, vil dette f&#248;re til un&#248;dvendig mye callbacks, v&#230;re vanskelig &#229; vedlikeholde, rotete og un&#248;dvendig komplisert kode med potensielt mange feil. I tillegg vil komponentene v&#230;re sterkt tilknyttet hverandre. Dette er resultatet av prop drilling.<\/p><p>&#160;<\/p><p>Context API&#39;et er Reacts egenproduserte l&#248;sning p&#229; dette. Andre l&#248;sninger er ogs&#229; tredjeparts bibliotekene Redux og MobX. Her utnyttes global state mangagement, hvor all data lagres et&#160;sted og hvor en kan setter opp automatisk oppdatering av komponenter n&#229;r data endres. En kan se p&#229; det som et overordnet dokument som inneholder all dataen som skal distribueres. P&#229; den m&#229;ten trenger ikke props traversere hele komponenttreet for &#229; n&#229; frem til den &#248;nskede komponenten, og komponentene blir mindre tilknyttet hverandre. Sammenlignet med Redux som utnytter en singel store, kan Context og MobX&#160;ha flere stores som wrapper de ulike komponentene. Fordelen med en single store er at det resulterer i&#160;&#34;a single source of truth&#34;, mens fordelen med flere stores er at de kan gjenbrukes og er med fleksible. En annen forskjell mellom Redux og MobX er at bak Redux ligger det en veldefinert best-practise design med bruk av actions og reducers, mens Mobx har fokus p&#229; enkel syntaks og skjuler mye av det som skjer.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1295,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React, slik som Redux og Mobx. Derimot vil Recoil, sammenlignet med&#160;Redux og MobX, krever mye mindre konfigureringer og setup for &#229; sette i gang. En annen fordel med Recoil er at det bypasser n&#248;dvendigheten for en felles parent (common ancestor) som dataen m&#229; til, som kan f&#248;re til at store deler av komponenttreet m&#229; rerendres. Med recoil utnyttes et konsept kalt Atoms, som er en enhet med states som komponenter kan &#34;abonnere&#34; p&#229;. Dermed vil kun de komponentene som har abonnert til&#160;&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1962,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL og REST er to forskjellige l&#248;sninger for &#229; h&#229;ndtere kommunikasjonen mellom klient-server.&#160;<\/p><p>&#160;<\/p><p>REST API&#160;er en overordnet arkitektur med fokus p&#229; lesing og skriving av entiteter/ressurser.<\/p><p>I REST m&#229; det, for &#229; lese, skrive eller endre p&#229; entiteter/ressurser ved hjelp av URI eller HTTP requests, settes opp ett eller flere endepunkter. Her vil det v&#230;re definert hvilke data som skal returneres for en entitet/ressurs. En av fordelene med REST som ikke GraphQL&#160;har er cache-mekanismen. Denne mekanismen er default st&#248;ttet av alle nettlesere. Derimot kan en ulempe med REST v&#230;re at du m&#229; gj&#248;re mange kall for &#229; hente all dataen du trenger og dermed hente mer data enn du trenger, ved n&#248;dvendigheten for mer kompleks informasjon (mange endepunkter). Dette kalles for overfetching.<\/p><p>&#160;<\/p><p>GrapQL er et sp&#248;rrespr&#229;k.<\/p><p>Mens det for REST m&#229; settes opp endepunkter, er GraphQL basert p&#229; at du sender sp&#248;rringer til en server hvor du m&#229; definerer b&#229;de s&#248;k og hvilke data som skal returneres. Med GraphQL unng&#229;r du overfetching ved at all dataen kan spesifiseres og hentes i en request og dermed unng&#229;r&#160;&#229; laste ned for mye data. GrapQL er ogs&#229; et typesystem, og dermed muliggj&#248;r validering av sp&#248;rringer. En ulempe med GraphQL er at det kun st&#248;tter JSON og ikke har&#160;implisitt caching i HTTP-laget.&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535357,"ext_inspera_userAssessmentSetupId":7140098,"ext_inspera_userAssessmentId":4841448,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Heggstad Jon-Inge (10171)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":5702635,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2762,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r det snakkes om state i React er det hovedsakelig to forskjellige typer av komponenter vi trenger &#229; se p&#229;. Dette fordi prinsippet om state er vesentlig forskjellig i de to typene. P&#229; den ene sidden har vi klassebaserte komponenter som tillater &#229; initiallisere en state gjennom konstrukt&#248;ren. P&#229; den andre siden har vi funksjonelle komponenter som m&#229; ta i bruk en hook i form av useState for &#229; kunne innf&#248;re en logikk bak &#34;state&#34; konseptet. Begge typer komponenter er valide og kan i prinsippet brukes p&#229; enhver type komponent man vil lage, men syntaksen p&#229; de to er ulik. Det m&#229; ogs&#229; nevnes at klassebaserte komponenter gir oss tilgang til en del ekstra funksjonalitet, slik som lifecycle methods, men funksjonelle komponenter tilbyr hooks som tillater oss &#229; gj&#248;re det samme, slik som useEffect. I dag brukes det for det meste med funksjonelle komponenter innenfor utvikling.<\/p><p>&#160;<\/p><p>Det som kanskje er litt mer interessant &#229; snakke om er dataflyten i React-applikasjoner. I sm&#229; React applikasjoner er dataflyt utrolig lett &#229; h&#229;ndtere, gitt at flyten g&#229;r &#34;nedover&#34;. I tilfeller hvor man bare skal sende variabler og callback funksjoner fra &#34;parent&#34; komponenten til &#34;child&#34; komponenten, kan disse enkelt legges p&#229; som parametre i child komponenten og sendes via argument fra parent komponenten. Child komponenten har n&#229; tilgang til &#229; lese variablene fra parent komponenten og kalle funksjoner som er definert i parent komponenten. &#197; sende data i motsatt vei, alts&#229; &#34;oppover&#34;, krever litt mer arbeid. Dette skyldes at det ikke er en direkte m&#229;te &#229; returnere variabler fra child til parent. S&#229; alt som skal sendes oppover m&#229; gj&#248;res i form av callback funksjoner. I st&#248;rre prosjekt vil begge disse metodene for &#229; passere data via &#34;props&#34; fungere sv&#230;rt d&#229;rlig. Det er b&#229;de tungvint og error-prone om man ikke tar i bruk &#34;state management&#34; i form av enten Redux, Recoil, mobx eller tilsvarende rammeverk. Verkt&#248;y for &#229; behandle state har blitt n&#248;dvendig grunnet Reacts &#34;nedover&#34; design som ikke tillater oss &#229; enkelt sende data oppover til parent komponenten.<\/p><p>&#160;<\/p><p>&#197; sende variabler nedover kan ogs&#229; v&#230;re tungvint om man har en prop som skal brukes av en child komponent langt nede, eller alle tilknyttede children. React sitt eget Context system egner seg meget godt til &#229; erstatte dette. Her dropper man &#229; sende globale variabler som props og lar heller hele komponenttreet ta i bruk disse variablene. Merk at jeg skriver globale i den forstand at man fortsatt vil sende data som props, men om en variabel kan rettferdiggj&#248;res som &#34;global&#34; burde man behandle den gjennom Context systemet i stedet for &#229; sende som props langt nedover treet. Context innf&#248;rer to nye begreper som er verdt &#229; legge merke til, dette er &#34;provider&#34; og &#34;consumer&#34;. Provider vil si at en parent komponent som har en variabel den vil gj&#248;re tilgjengelig for children komponenter, kan gj&#248;re dette. Alle children komponenter kan da deklareres som consumer av det parent komponenten har deklarert at den &#34;provides&#34;. P&#229; denne m&#229;ten trenger man ikke sende variabler nedover flyten som props, men deklarerer den kun ett sted og den er tilgjengelig for alle komponenter nedover.<\/p><p>&#160;<\/p><p>I mange prosjekter er det derimot n&#248;dvendig &#229; oppdatere en global &#34;state&#34; som brukes av mange komponenter. Til dette er state-management vetk&#248;yet Redxu, fra pensum, ofte mye brukt. Redux er ikke spesifikt designet for React og fungerer dermed som et helt selvstendig state-management verkt&#248;y i form av at man teknisk sett ikke lenger trenger &#229; bruke React sine innebygde begreper om states. I redux har man en store som best&#229;r av actions som kan bli dispatched til reducers som igjen oppdaterer states. Redux har en flow i form av Action creators -&#62; Actions -&#62; dispatch -&#62; Reducers -&#62; State. N&#229;r Redux er integrert med React vil komponenter re-render n&#229;r state oppdateres, p&#229; lik linje som de re-render n&#229;r native state blir brukt. P&#229; denne m&#229;ten kan alle komponenter lese og skrive til state og s&#248;rge for at de n&#248;dvendige komponentene blir re-rendered.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2025,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En fordel med Recoil er at om man f&#248;rst setter opp et React prosjekt, kan man forvente at Recoil vil forbli st&#248;ttet med React. Man trenger ikke da &#229; bekymre seg om mangel p&#229; st&#248;tte etterhvert som versjonsoppdateringer til React komme ut, siden begge er laget av Facebook.<\/p><p>&#160;<\/p><p>Utover dette er noen av de tekniske fordelene med Recoil:<\/p><ul>\t<li>Atoms: r/w fra alle komponenter<\/li>\t<li>Subscribers: komponenter re-renders automatisk n&#229;r de r/w fra en atom<\/li>\t<li>Selectors: funksjoner som blir kalt ved endringer p&#229; atoms, disse kan ogs&#229; bli subscribed til<\/li>\t<li>Lettvint &#229; bruk<\/li><\/ul><p>&#160;<\/p><p>Kort fortalt fungerer Recoil ved at man definerer et Atom, dette representer et State objekt som har attributter knyttet til State. Komponenter kan &#34;subscribe&#34; til atoms, det vil si f&#229; lese og skrive tilgang til den definerte state. Ved en endring p&#229; noe i et atom vil alle komponenter som er subscribed til dette atom re-render med den nye verdien. Funksjoner i form av Selectors kan ogs&#229; knyttet til et atom og fyre av basert p&#229; endringer i atom. Komponenter kan videre subscribe til disse selector funksjonene for &#229; lese resultatet av funksjonen.<\/p><p>&#160;<\/p><p>Siden Recoil er laget for React, er det designet for &#229; l&#248;se en del av de state-management problemene som React har. Nemlig &#229; la komponenter lese og skrive av state uavhengig av hvor de er i komponenttreet og s&#248;rge for at resultatet blir likt p&#229; alle komponenter som er avhengig av en gitt variabel/state.<\/p><p>&#160;<\/p><p>&#197; sammenligne &#34;fordeler og ulemper&#34; p&#229; det det rent tekniske blir litt vanskelig. Recoil l&#248;ser mye av det samme som Redux og MobX fra dette aspektet. Det som derimot er en veldig stor fordel er hvor mye lavere l&#230;ringskurven er for Recoil enn de andre rammeverkene. Recoil er ekstremt &#34;plug and play&#34;, mens f.eks. Redux krever at man forst&#229;r ganske mye av flyten for &#229; effektivt kunne bruke det. Et av de store problemene med Redux er den h&#248;ye l&#230;ringskurven som gj&#248;r det vanskelig for nye &#229; sette seg inn i det. MobX er heller ikke det mest intuitive n&#229;r man sette det i React konteksten. Dette er en annen fordel med Recoil, nemlig at det er laget for React av det samme selskapet som lager React. Man kan dermed forvente at det blir vedlikehodt og utviklet i harmoni med React.<\/p><p>&#160;<\/p><p>Det er ogs&#229; klare ulemper med &#229; ta i bruk Recoil. Nemlig at det er nytt og fortsatt i en eksperimentell fase n&#229;r de andre verkt&#248;yene fra pensum er etablerte og godt dokumentert b&#229;de offisielt og uoffisielt. &#197; ta i bruk ny teknologi er en stor risiko p&#229; nye prosjekter, det er ogs&#229; en stor risiko i form av ressurser tilgjengelig for &#229; lese seg opp p&#229; teknologien. P&#229; det siste punktet er Redux definitivt vinneren. Redux er etablert og blir brukt av langt flere enn b&#229;de Recoil og MobX til sammen. Dette gj&#248;r at det er lett &#229; finne ressurser og man kan v&#230;re trygg p&#229; at Redux blir st&#248;ttet b&#229;de i og utenfor en React sammenheng i fremtiden.<\/p><p>&#160;<\/p><p>Recoil vil muligens vinne en stor andel, og bare tiden vil vise, men basert p&#229; de 40 minuttene jeg har satt av til denne oppgaven finner jeg ingen teknisk fordel annet enn at det kan bli godt integrert med React, samtidig som dette muligens vil f&#248;re til et sv&#230;rt optimalisert state management verkt&#248;y som vil v&#230;re langt mer effektivt enn de andre som er nevnt.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1775,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er den mer tradisjonelle metoden for &#229; sende data p&#229; tvers av en server og klient. Her bruker man CRUD HTTP Requests i form av GET, POST, osv. til spesifikke endepunkt for &#229; enten hente, oppdatere eller legge til ny data til en database. N&#229;r data skal behandles av en klient vil de gj&#248;re en sp&#248;rring til et av de definerte endepunktene. Her vil en database tilkobles, og man gj&#248;r et s&#248;k etter de objekter som tilfredstiller det klienten sp&#248;r etter. Deretter returnerer man resultatene. Et REST API tillater oss ikke &#229; flette sp&#248;rringer. Det betyr at man m&#229; fyre av flere sp&#248;rringer enn n&#248;dvendig til databasen. Typen sp&#248;rringer man kan gj&#248;re i denne typen API er begrenset av hvilke endepunkter som er implementert p&#229; serveren og sp&#248;rringene disse gj&#248;r til databasen. Det betyr at &#229; lage en ny type sp&#248;rring krever et nytt endepunkt og ny logikk rundt de. Dette gj&#248;r at det er serveren som begrensen typen sp&#248;rringer en klient kan gj&#248;re. Fordelen med dette er at prinsippene er standardisert og man har full kontrol over hvilke type sp&#248;rringer en klient har lov til &#229; gj&#248;re.<\/p><p>&#160;<\/p><p>GraphQL er en ny metode for &#229; behandle data p&#229; tvers av en klient, server og database, som er laget av Facebook. Her behandler man all data som skal hentes ut i form av grafer. GraphQL er laget spesifikt for &#229; v&#230;re ressurseffektiv og tillater flettede sp&#248;rringer som har som m&#229;l &#229; hente ut kun den spesifikke dataen klienten er ute etter. Dette designprinsippet er laget for en mobil verden hvor brukere ikke har ubegrenset data og hastighet som kan brukes p&#229; &#229; utf&#248;re sp&#248;rringer. GraphQL gj&#248;r dette ved &#229; ta i bruk kun 1 enkelt endepunkt. Sp&#248;rringene som blir gjort blir definert p&#229; klientsiden og deretter behandlet av endepunktet for &#229; returnere riktig data. Dette gj&#248;r at man ikke tar i bruk alle HTTP REQUEST metodene som er standardisert for &#229; gj&#248;re visse typer sp&#248;rringer. Som oftest sender man bare en POST request med det man har lyst til &#229; gj&#248;re. Dette har en nedside med at man ikke lenger har de godene som nettlesere tillater i form av caching, s&#229; vell som man m&#229; v&#230;re forsiktig med &#229; ikke la klienter gj&#248;re enorme sp&#248;rringer som effektivt vil fungere som et DoS angrep.<\/p><p>&#160;<\/p><p>Alt i alt egner begge to seg til bruk i dag, men GraphQL egner seg sv&#230;rt godt til applikasjoner og nettsider hvor man tenker seg at brukerbasen vil v&#230;re p&#229; mobile enheter hvor nettverskressurser m&#229; behandles p&#229; en effektiv m&#229;te. Dette fordi sp&#248;rringene blir individualisert og sl&#248;ser ikke med ressurser. Man m&#229; derimot v&#230;re forsiktig p&#229; at brukere ikke kan gj&#248;re store sp&#248;rringer som er kostbare for serveren og databasen. REST API er bedre egnet n&#229;r man vet at nettverksressurser ikke burde v&#230;re problematisk og man har et bilde av hvilke type sp&#248;rringer brukeren vil ha.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535489,"ext_inspera_userAssessmentSetupId":7140143,"ext_inspera_userAssessmentId":4841323,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Flytør Borgar Føll (10074)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34507872,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2729,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er flere ting som kan brukes for &#229; styre tilstand og dataflyt i React. React har flere typer hooks som kan endre p&#229; tilstandet i webapplikasjonen. En av de mest brukte er state-hooken som brukes til &#229; endre eller opptatere variabler eller komponenter i webapplikasjonen. sate kan ogs&#229; settes i konstruktoren i en klasse.&#160;useEffect-hooken er en hook som ogs&#229; er veldig ofte brukt til &#229; oppdatere tilstad i webapplikasjonen. Denner oppdateres hver gang det skjer en endring inni i selve hooken. I React kan man ogs&#229; lage sine egen hooks for &#229; oppdatere tilstad i webapplikasjonen. Det finnes ogs&#229; noe som bestemmer hvor lenge en komponent skal leve. Dette kan gj&#248;res med livssyklusmetoder i React. Disse bestemmer hvor lenge en effekt skal kj&#248;re f&#248;r den skal avsluttes eller byttes ut med noe annet. Disse&#160;Livssyklusmetodene er kaldt&#160;componentDidMount() som besttemer hvor lenge effekten skal kj&#248;re f&#248;r&#160;componentWillUnmount() kj&#248;res. React st&#248;tter ogs&#229; eventHandlers som i vanlig JS. I React kan man bruke onClick for &#229; oppdatere en state for eksempel.<\/p><p>&#160;<\/p><p>Et React prosjekt kan deles inn i flere komponenter som gj&#248;r og rendrer forskjellige elementer. Det er ganske vanlig &#229; ha en App.jsx (eller App.tsx hvis man bruker React med TypeScript) der man kan impotere forksjellige komponenter. Disse komponentene kan gj&#248;re litt forskjellige ting. En kan for eksempel h&#229;ndere klokke og tid, en annen kan for eksempel ha kontroll en liste med navn. Disse komponenten kan kalles flere ganger hvis samme opperasjon skal skje flere ganger. Disse komponentene kan man sende med noe som henter props. Props st&#229;r for properties og er navngitte variabler som man sender med komponenter. Hvis man har mange props kan man definere disse i et interface. Hvis det er&#160;noe data som skal brukes av mange komponenter kan man bruke Context. Context kan defineres globalt og kan settes inni alle koponentene.&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;https://reactjs.org/docs<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2394,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state mangaement bibliotek som er utviklet av Facebook. I motsettning til de andre state management biblotekene som vi har p&#229; l&#230;replanen er Recoil laget for React. B&#229;de Redux og MobX trenger ikke &#229; v&#230;re knyttet til React, men kan brukes med andre verkt&#248;y. Atoms brukes for &#229; sette opp en state store. Det er i atoms states settes og lagres. Recoil har veldig god integrasjon med React sine hooks og er ikke s&#229; veldig ulik en vanlig React useState-hook. I Reacoil kan man ogs&#229; sortere states med en Selector. Et array med oppgaver kan for eksempel sorteres med en selector etter oppgaver som er fullf&#248;rt og oppgaver som ikke er ferdige. Recoil kan ogs&#229; lagre asynkrone kall til en database for eksmepel. Dette kan v&#230;re veldig nyttig hvis et asynkront kall skal oppdatere en state. Recoil har ogs&#229; noe som heter atom effects som skal hjelpe til med &#229; logge states, men dette er i en testfase enda.<\/p><p>&#160;<\/p><p>Noe som Recoil gj&#248;r likt b&#229;de MobX og Redux er at denne bruker ogs&#229; en form for store der alle states lagres. Recoil bruker egene React hooks for &#229; oppdatere states som er litt anderledes enn b&#229;de Redux og MobX. Redux oppdaterer props, mens MobX oppdaterer states med&#160;observers og med React context.&#160;<\/p><p>&#160;<\/p><p>Fordeler med Recoil er at det har veldig god integrasjon med React. Har masse nyttige funksjoner som Selectors og&#160;Asynkrone datasp&#248;rringer.<\/p><p>Ulempene mer Recoil er at det er ikke like utbret som Redux og MobX. Du kan heller ikke bruke det utenfor React.<\/p><p>&#160;<\/p><p>Kilder:&#160;https://recoiljs.org,&#160;https://react-redux.js.org/,&#160;https://mobx.js.org/react-integration.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1951,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST bruker HTTP-requests for &#229; hente og oppdatere data fra forskjellige nedrepunkter. I REST defineres dataene som du skal hente fra den ressursen du sp&#248;r etter. Ofte s&#229; brukes GET, PUT, POST og DELETE for &#229; h&#229;ndtere foresp&#248;rsler til en ressurs, enten for &#229; oppdatere data eller bare for &#229; sp&#248;rre etter data.&#160;<\/p><p>GraphQL fungere litt anderledes enn REST. I stedet for &#229; bruke HTTP-request, s&#229; sender GraphQL sp&#248;rringer i queryform. I sp&#248;rringene defineres b&#229;de s&#248;k og hvilke data som skal returneres. GrapQL sender ogs&#229; foresp&#248;rsler til endpoints akkuratt som REST. Alle data som hentes i GraphQL defineres i skjemaer hvor du kan definere hvilke type informasjon du henter. Du lager foresp&#248;rsler etter hvordan dataene er beskrevet i skjemaet.<\/p><p>&#160;<\/p><p>Fordeler&#160;med GraphQL er sp&#248;rring og s&#248;k skjer i en foresp&#248;rsel. Dette gj&#248;r at du kan hente eller oppdatere data med en request til server. GraphQL har ogs&#229; en fordel over REST n&#229;r det kommer til store sp&#248;rringer hvor REST kan ende opp med overfetching av data. Data&#39;ene er definert i skjemaer i GraphQL som b&#229;de kan v&#230;re en fordel eller en ulempe. REST st&#248;ttes &#229; hente data i flere formater, mens GrapQL har bare st&#248;tte for &#229; hente data i JSON format. I REST kan man ha caching i HTTP-laget. GraphQL har s&#248;tte for&#160;caching p&#229; klientsiden, men ikke i HTTP-laget.<\/p><p>&#160;<\/p><p>Kilder:&#160;https://graphql.org/ ,&#160;https://restfulapi.net/<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11535561,"ext_inspera_userAssessmentSetupId":7139986,"ext_inspera_userAssessmentId":4841398,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gabrielsen Oskar (10029)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":47170124,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1447,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React brukes det states og props for &#229; h&#229;ndtere tilstand og dataflyt. Props er variabler, de brukes av et forelder komponent for &#229; &#34;passe&#34; data til et child komponent (i henhold til React komponentenes tre-struktur). Disse props variablene b&#248;r ikke forandres i child komponentet. I React g&#229;r dataflyten kun denne veien. Fra toppen og ned i tre strukturen. Det kan alts&#229; kun sendes data fra forelder komponenter til barn og ikke motsatt.<\/p><p>&#160;<\/p><p>I tillegg kan komponenter ha states. States er ogs&#229; variabler, disse variablene er det dog komponentet selv som initialiseres og styrer. Alts&#229; ingen innblanding fra andre komponenter. N&#229;r et komponent sin state forandres s&#229; vil komponentet re-rendres.<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; bruke tredjeparts bilioteker for &#229; h&#229;ndtere tilstand og dataflyt i React.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3227,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management i React. Det er alts&#229; et alternativ til Redux og MobX som vi har brukt i dette emnet.<\/p><p>&#160;<\/p><p>Recoil fungerer slik at data flyter fra &#34;atoms&#34; gjennom &#34;selectors&#34; og s&#229; inn i React komponentene. Komponentene kan velge hvilket atom de bruker for state. Det er alts&#229; her mulig for flere komponenter &#229; ha samme state(atom), noe som ikke er mulig i vanlig React. Komponentene velger ogs&#229; hvilke selectorer de bruker. Selector er en funksjon som tar et atom eller en annen selector som input og returnerer noe basert p&#229; dette. Eksempelvis kan et atom inneholde en array med 10 bilmerker og en selector kan returnere lengden p&#229; denne arrayen.<\/p><p>&#160;<\/p><p>Recoil skiller seg fra Redux p&#229; flere ting. i Redux har man en global state kalt store hvor alle data lagres. I Recoil slipper man alts&#229; dette. En fordel med recoil over Redux er at atomer alltid vet hvilke komponenter som er avhengig av den, og dette gj&#248;r at det blir minimalt med re-rendering. I Redux er det ikke mulig &#229; gj&#248;re dette like effektivt.<\/p><p>Det virker som om Recoil er lettere &#229; sette opp og krever mindre arbeid for &#229; komme i gang med. Recoil virker rett og slett som et bedre alternativ p&#229; alle omr&#229;der. Eneste ulempen jeg kan se for meg med Recoil er at det er veldig nytt og ikke har samme milj&#248; bygd opp rundt seg. Med dette mener jeg at det er ikke like mye informasjon om det og det er ikke like mye verkt&#248;y for det(eks. for debugging).<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2189,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er en arkitekturell stil for APIer som bruker HTTPS requests til &#229; sende og motta informasjon. Kan tenkes p&#229; som regler server og klient m&#229; f&#248;lge. Poenget med REST API er &#229; ha en standard for hvordan man kan sende og motta data mellom server og klient.<\/p><p>&#160;<\/p><p>GraphQL er et data query spr&#229;k for APIer.<\/p><p>&#160;<\/p><p>En vesentlig forskjell mellom de to er hvordan man henter informasjon. I et REST API har serveren flere forh&#229;ndslagde metoder(endpoints) for &#229; hente/sende data. Klienten kan da bruke disse metodene. For en GraphQL server vil klienten sende en query til server hvor queryen bestemmer hva slags informasjon klienten ber om. GraphQL har alts&#229; ikke forh&#229;ndsdefinerte metoder p&#229; samme m&#229;te som et REST API. Dette gj&#248;r at GraphQL er mer fleksibelt, fordi klienten kan sp&#248;rre om akkurat den informasjonen den vil ha. GraphQL l&#248;ser alts&#229; problemet om over/underfetching av data.<\/p><p>&#160;<\/p><p>En annen ulempe med REST API er at den kan v&#230;re n&#248;dvendig &#229; sende flere REST kall for &#229; f&#229; tak i all informasjonen klienten trenger, avhenging av hvilke metoder REST serveren har.<\/p><p>&#160;<\/p><p>En ulempe som er verdt &#229; nevne med GraphQL er at response data m&#229; sendes som JSON. Dette er ikke et krav for REST API.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11535671,"ext_inspera_userAssessmentSetupId":7140080,"ext_inspera_userAssessmentId":4841394,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bartnes Cathrine (10147)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":30152352,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2637,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Forskjellige state management:<\/p><p>Dersom det kun er klienten som her behov for &#229; vite tilstanden kan man benytte seg av local state, og hvis flere elementer har behov for &#229; bruke den kan man plassere den h&#248;yere opp i tre-strukturen og passere staten ned med props.&#160;<\/p><p>&#160;<\/p><p>Det er flere forskjellige m&#229;ter &#229; h&#229;ndtere props. M&#229;tene som er tilgjengelig uten &#229; laste ned noen pakker er ved bruk av props eller React Context. Context er en m&#229;te &#229; sende data via komponenter uten &#229; passere props i hvert enkelt niv&#229;, slik man ellers m&#229; hvis man kun benytter seg av props. Her lager man en context.provider som wrappes rundt de komponentene som skal ha tilgang til tilstanden, disse er context consumers.&#160;<\/p><p>&#160;<\/p><p>Redux er en annen m&#229;te og h&#229;ndtere state p&#229;. Her har man en global-store som holder p&#229; hele appens tilstand. Denne kan endres ved bruk av &#34;actions&#34; og &#34;reducers&#34;. Her er det action som interagerer med storen og reduceren spesifiserer hvordan tilstanden endres basert p&#229; &#34;dispatched&#34; actions (handlinger).&#160;<\/p><p>&#160;<\/p><p>Enda en m&#229;te &#229; hente ut state p&#229; er &#229; bruke MobX. Her har man flere stores, og det er stor fleksibilitet i design av state. MobX gj&#248;r datastrukturer observable og komponeter kan gj&#248;res til observat&#248;r.<\/p><p>&#160;<\/p><p>Dataflyt:<\/p><p>React har en &#34;unidirectional flow&#34; noe som betyr at data kun har en m&#229;te &#229; overf&#248;res til andre deler av applikasjonen. I React betyr det at komponenter nestes og det er kun foreldrekomponenten som har en tilstand. Denne kan passeres ned til&#160;barn-komponenter via props. &#197; endre en state vil aldri p&#229;virke noen andre enn barna, noe som f&#248;rer til at staten ofte plasseres h&#248;yt i komponent-treet slik at alle komponenter som trenger &#229; vite tilstanden f&#229;r det.&#160;P&#229; denne m&#229;ten blir tilstanden sendt til barn-komponenter og viewet. Viewet kan bli triggret av handlinger som f&#248;rer til oppdtering av staten som igjen som igjen oppdaterer tilstanden til barn-komponentene og viewet. P&#229; grunn av enveis-bindinger kan ikke dataflyten g&#229; i motsatt retning. Dette f&#248;rer til en rekke fordeler slik som:<\/p><p>- Du har mer kontroll over dataen<\/p><p>- Det er lettere &#229; debugge, i og med at man vet hvor dataen kommer fra.<\/p><p>- Systemet blir mer effektivt, siden biblioteket allerede kjenner til begrensingnene for hver komponent.&#160;<\/p><p>Kilde:&#160;https://flaviocopes.com/react-unidirectional-data-flow/<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2772,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil kan sammenliknes som en kombinasjon av useState og Context, der man wrapper komponetnene som skal ha tilstanden tilgjengelig med en RecoilRoot. I stedet for useState har man en egen hook som heter useRecoilState som setter staten til et &#34;atom&#34; som representerer staten. Et atom kan skrives til og leses fra enhver komponent.&#160;<\/p><p>En &#34;selector&#34; representerer en endret tilstand, som vil si at man kan gj&#248;re noen endringer f&#248;r man f&#229;r tilstanden tilbake. Denne kan man sette&#160;ved useRecoilValue som henter ut den samme verdien som SetRecoilState, men den gir ikke noe set-metode siden det er en selektor.<\/p><p>Kilde:&#160;https://recoiljs.org/docs/introduction/getting-started<\/p><p>&#160;<\/p><p>Recoil er nyttig dersom man vil dele en tilstand i flere komponenter og man trenger h&#248;y ytelse. Problemet som Recoil l&#248;ser er un&#248;dvendige re-renders som skjer b&#229;de ved bruk av Context og Redux. N&#229;r staten er tilgjengelig for flere barn-komponenter vil alle disse komponentene re-rendres. Med Redux kan det hende at hele siden eller appliksajonen re-rendres dersom man har mange tilstander&#160;under en stor komponent. Ved &#229; bruke Recoil og atom gj&#248;r man det mulig at en komponent kan subscribe til et atom, og n&#229;r verdien til atomet endres, vil kun tilh&#248;rende komponenter re-rendre. Det er ikke n&#248;dvenidg &#229; skrive masse boilerplate-kode slik som Redux krever. Det er ogs&#229; mulig &#229; bruke Recoil delvis, applikasjonen trenger ikke &#229; avhenge av denne l&#248;sningen alene.&#160;<\/p><p>Kilde:&#160;https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1751,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API vs GraphQL<\/p><p>Den st&#248;rste forksjellen mellom REST API og GraphQL er hvordan de henter data p&#229;.<\/p><p>&#160;<\/p><p>Et REST API har flere endepunkt for &#229; hente ut data. Det vil si at den her flere url/paths som reagerer p&#229; forskjellige foresp&#248;rsler. Et endepunkt for REST settes opp p&#229; m&#229;ten: http-verb/path/body, der http-verbene kan v&#230;re: GET, POST, PUT, PATCH, DELETE, OPTIONS. Det er de som lager APIet som bestemmer hvilke paths som er tilgjengelige. N&#229;r man gj&#248;r en sp&#248;rring til et REST API vil man hente ut all data som er tilgjengelig for denne sp&#248;rringen. For en bruker som har feltene: id, navn, adresse, telefonnummer og man kun &#248;nsker &#229; hente ut id og navn for personen er dette ikke&#160;mulig i REST API. Her vil man hente ut all data som er spesifisert i urlen.&#160;<\/p><p>&#160;<\/p><p>GraphQL har kun ett endepunkt som kan reagere p&#229; foresp&#248;rsler. Det er kun http-verbet POST som kan brukes og pathen er gjerne satt til /graphql. Det er alltid en POST-foresp&#248;rsel fordi man alltid sp&#248;r etter hvilke data man vil ha. GraphQL har sitt eget graphql-query spr&#229;k som ligner mye p&#229; m&#229;ten man gj&#248;r sp&#248;rringer mot en database. Det finnes forskjellige operasjons typer, der man enten kan sp&#248;rre etter data med &#34;query&#34; eller endre p&#229;/legge til ny data med &#34;mutation&#34;. Det er ogs&#229; noe som heter operasjons-endepunktet, som er objektet man sp&#248;rr etter. Her kan man hente ut den dataen som er n&#248;dvendig for din sp&#248;rring. Dersom man &#248;nsker &#229; hente ut informasjonen til en bruker som her feltene: id, navn, adresse, telefonnummer og man kun &#248;nsker &#229; hente ut id og navn for personen er dette mulig i GraphQL.<\/p><p>&#160;<\/p><p>Ulempen med REST API er at man ofte henter ut mer data enn hva som er n&#248;dvendig. Fordelen er at det er lett &#229; sett seg inn i, og det er ikke n&#248;dvendig &#229; l&#230;re seg et nytt spr&#229;k for bruke det.<\/p><p>Ulempen med GraphQL er at dersom man skriver sp&#248;rringene selv er det veldig lett &#229; f&#229; feilmeldinger. Det er derfor utviklet flere pakker som er tilgjenglig &#229; bruke som hjelper deg med &#229; skrive sp&#248;rringer feks Apollo Client. Fordelen er at man kan spesifisere hvilke data man vil ha, og det &#229; sende sp&#248;rringer er enklere.&#160;<\/p><p>&#160;<\/p><p>Dersom man har en web-app som trenger forskjellige sp&#248;rringer med forskjellig data p&#229; forskjellige sider, og man m&#229; v&#229;re p&#229;passelig med bandwidth vil GraphQL absolutt v&#230;re den beste l&#248;sningen.&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;https://www.youtube.com/watch?v=PeAOEAmR0D0<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11536163,"ext_inspera_userAssessmentSetupId":7139927,"ext_inspera_userAssessmentId":4841494,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Westby Dina Myhrum (10045)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34686699,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3759,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For komponenter har vi den interne variabelen state som er tilstanden til komponenten.&#160;N&#229;r tilstanden endres vil gjerne komponenten rerendres. Ved hjelp av setState() kan man endre komponentens tilstand.<\/p><p>&#160;<\/p><p>Man skal alts&#229; ikke bruke:<\/p><p>this.state.eksamen =&#160; &#39;Hei&#39;;<\/p><p>&#160;<\/p><p>men heller bruke:<\/p><p>this.setState({eksamen: &#39;Hei&#39;});&#160;<\/p><p>&#160;<\/p><p>State er originalt bare i Class, men kan brukes i funksjonelle komponenter som hooks (useState).&#160;<\/p><p>&#160;<\/p><p>Dataflyt g&#229;r i utgangspunktet&#160;nedover i&#160;komponenthierarkiet&#160;fordi&#160;tilstanden til en komponent bare kan p&#229;virkes av komponentene under i treet. Man burde f&#248;rst finne alle komponentene som som skal rendre noe basert p&#229; den bestemte tilstanden, s&#229; finne en felles eierkomponent eller en komponent h&#248;yere opp i hierarkiet som skal eie tilstanden. Eventuelt kan man&#160;lage en helt ny komponent h&#248;yere opp i hierarkiet som bare skal holde p&#229; den tilstanden.&#160;<\/p><p>&#160;<\/p><p>For &#229; implementere dataflyt oppover i et React komponent hierarki kan en foreldre komponent&#160;sende &#34;callback&#34; funksjoner som props&#160;til barna sine. Ved hjelp av disse kan barnekomponentene sette state p&#229; forelderen.&#160;<\/p><p>&#160;<\/p><p>Props kan ogs&#229; brukes for &#229; implementere dataflyt. Det er informasjon som sendes&#160;fra foreldrekomponenter til barn.&#160;<\/p><p>&#160;<\/p><p>I React-applikasjoner kan man lagre state lokalt ved hjelp av state eller&#160;globalt. N&#229;r applikasjoner er mer omfattende og krever mer for &#229; vedlikeholdes, bruker vi gjerne globale states for &#229; unng&#229; un&#248;dvendig&#160;callbacks og mye informasjon&#160;som flyttes oppover i komponenthierarkiet.&#160;Slik jeg har tolket oppgaven skal jeg svare p&#229; global state management i oppgave 2. Der vil jeg forklare redux, context og mobx.&#160;<\/p><p>Kilde:&#160;https://reactjs.org/docs/state-and-lifecycle.html&#160;<\/p><p>og&#160;https://reactjs.org/docs/thinking-in-react.html&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2290,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. P&#229; listen over l&#230;ringsm&#229;l har vi de liknende l&#248;sningene context, redux og mobx i tillegg til Reacts egen state (component state).&#160;<\/p><p>&#160;<\/p><p>Kilde: https://recoiljs.org/docs/introduction/getting-started<\/p><p>og&#160;https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10&#160;<\/p><p>&#160;<\/p><p>Med Recoil kan man lage dataflyt grafer som flyter fra atoms (delt tilstand) gjennom selectors (funksjoner) og ned til React komponentene. Et atom&#160;er en del av tilstanden som komponenten kan abonnere p&#229;. Selectorene kan endre tilstanden enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Den store fordelen med Recoil slik jeg har forst&#229;tt det kommer inn n&#229;r man har problemer med &#229;&#160;dele en del av en tilstand i flere komponenter.&#160;<\/p><p>&#160;<\/p><p>1. Component state: Med Recoil har vi den samme enkle get/set interfacen som i lokal state, men Recoil &#248;nsker &#229;&#160;l&#248;se&#160;problemet med at man med component state bare kan dele tilstand opp til felles foreldre, noe som kan f&#248;re til et veldig stort tre.&#160;<\/p><p>&#160;<\/p><p>2. Context: Bruker Context.Provider for &#229; deklarere hva som skal v&#230;re tilgjengelig for barn. Context.Consumer er den som skal bruke dataen fra provideren. En ulempe med Context er er at alle komponentene som abonnerer p&#229; den rerendres hver gang context oppdateres. Til forskjell kan man med Recoil&#160;erstatte tilstanden med en &#34;avledende data&#34; uten at det p&#229;virker komponenten som bruker den, slik jeg har forst&#229;tt det.<\/p><p>&#160;<\/p><p>3. Redux: er&#160;skalerbart, men krever mer &#229; sette opp. Der er det Store som inneholder alle globale states. Actions er funksjoner som forteller hva som skal gj&#248;res og reducers tar inn actions, utf&#248;rer endringer p&#229; state og returnerer ny state. Med Redux slipper man &#229; bruke context fordi det allerede har innebygd provider. Fordelen med Recoil over Redux er at med en stor container komponent ved bruk av Redux vil hele siden rerendres. Noe som fungerer greit for mange applikasjoner, men ikke alle.&#160;<\/p><p>&#160;<\/p><p>4. MobX: MobX er mindre skalerbart enn Redux, men er til gjengjeld lettere &#229; sette opp. @obseravle brukes for de observerbare globale tilstandsvariablene og&#160;@action er hva som skal skje med de. I motsetning til Redux&#160;har ikke MobX egen provider, det kan man lage med Context (for at komponenter skal f&#229; tilgang p&#229; tilstandene)<\/p><p>&#160;<\/p><p>mulige fordeler og ulemper:&#160;<\/p><p>&#160;- oppf&#248;rselen er ganske lik React<\/p><p>&#160;- man kan code-splitte ved der tilstanden lever og der den brukes fordi definisjonen av tilstanden er inkrementell&#160;<\/p><p>&#160;- det finnes mange gode l&#248;sninger fra f&#248;r (som mobx og redux), mange mener en l&#248;sning til ikke er n&#248;dvendig. Mange applikasjoner vil ikke f&#229; s&#229; mye nytte av det, se an om du virkelig trenger det f&#248;r du bruker det.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1081,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er begge l&#248;sninger for kommunikasjon mellom klient og server i web applikasjoner.&#160;<\/p><p>&#160;<\/p><p>REST:<\/p><p>&#160;- REST baserer seg p&#229; endepunkter ved hjelp av URI og HTTP requests.<\/p><p>&#160;- for &#229; definere endepunkter bruker vi: POST; PUT; GET; DELETE ...<\/p><p>&#160;- det er definert hvilke data som skal hentes (i motsetning til med GraphQL)<\/p><p>&#160;- ulempe:&#160;&#160;dersom man har mange endepunkter m&#229; man kanskje gj&#248;re flere kall enn n&#248;dvendig og man henter derfor mer data enn n&#248;dvendig. Det kan f&#248;re til overfethcing eller underfetching.&#160;<\/p><p>&#160;- fordel: med REST kan man bruke caching som er viktig for effektivitet og&#160; skalerbarhet&#160;<\/p><p>&#160;<\/p><p>GraphQL:&#160;<\/p><p>&#160;- opprettes ved &#229; definere typer og felt, og lager funksjoner for hvert felt p&#229; hver type&#160;<\/p><p>&#160;- vi har et typesystem der vi beskriver dataene som er tilgjengelige i API-et og ber klienten kun om relevante data. Dataen kommer tilbake i samme form som sp&#248;rringen.&#160;<\/p><p>&#160;- fordel: unng&#229;r derfor overfetching og underfetching som med REST fordi vi kun f&#229;r det vi sp&#248;r om&#160;(effektiv datainnsamling)<\/p><p>&#160;- ulempe:&#160;GraphQL st&#248;tter kun JSON-data og mangel p&#229; caching&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11536246,"ext_inspera_userAssessmentSetupId":7139964,"ext_inspera_userAssessmentId":4841403,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Vågene Lars-Olav (10002)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":21911195,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1940,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I en React-applikasjon skiller man mellom lokal og global tilstand, og mellom props/state.<\/p><p>&#160;<\/p><p>React best&#229;r av komponenter (objekter) arrangert i et hierarki. Den lokale tilstanden til en komponent er delt i <em>props (properties)&#160;<\/em>og <em>state<\/em>. Begge disse er mengder av variabler som komponenten har tilgang p&#229;, men den har kun lesetilgang til &#34;props&#34;.<\/p><p>N&#229;r man lager en komponent sender man &#34;props&#34; inn som parametere&#160;og komponenten m&#229; eventuelt rerenderes hvis disse endres utenfra. Dette utgj&#248;r den prim&#230;re dataflyten i React, der &#34;props&#34; sendes ned i hierarkiet fra komponent til komponent.<\/p><p>&#34;State&#34; er de feltene i komponenten som den kan endre selv, men kun med hjelp av Reacts innebygde metoder (useState-hooken&#160;for funksjonelle komponenter og setState for klassebaserte komponenter).<\/p><p>&#160;<\/p><p>N&#229;r man trenger tilgang til tilstandsvariabler mange steder i applikasjonen kan man &#34;l&#248;fte&#34; denne tilstanden h&#248;yere i komponenthierarkiet og s&#229; sende den ned igjen dit den trengs som props. N&#229;r dette ikke er tilstrekkelig kan man bruke det som kalles global tilstand. Da kan man for eksempel bruke Context-APIet som er innebygd i React, eller eksterne bibliotek som MobX eller Redux. Prinsippet er uansett det samme:<\/p><p>Man pakker inn toppniv&#229;et av applikasjonen i denne globale tilstanden, og alle komponenter i hierarkiet f&#229;r da automatisk og &#34;usynlig&#34; tilgang til den samme tilstanden.<\/p><p>Hvordan man kommuniserer mellom komponent og global tilstand varierer utifra hvilket bibliotek man bruker, men sluttresultatet er uansett at alle komponenter f&#229;r tilgang til de samme globale variablene og enkelt kan dele data med hverandre. Om dette er god praksis kan vel diskuteres, men jeg vil si man b&#248;r unng&#229; det s&#229; langt man kan. Om ikke annet s&#229; gj&#248;r det koden mindre gjenbrukbar n&#229;r man knytter komponentene sammen slik.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1315,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilsvarende l&#248;sninger i l&#230;ringsm&#229;lene vil da prim&#230;rt v&#230;re Context-APIet, Redux og MobX.<\/p><p>Recoil ser ut til &#229; v&#230;re en utvidelse eller alternativ implementasjon av Context-APIet. Prinsippet ser ut til &#229; v&#230;re at man definerer en tilstandsvariabel (&#34;atom&#34;) der man vil, med en unik ID, og s&#229; kan man f&#229; tilgang til dem samme variabelen hvor som helst i programmet med en &#34;selector&#34; med samme ID.<\/p><p>&#160;<\/p><p>P&#229; overflaten ser dette ut til &#229; v&#230;re en god l&#248;sning som er enda enklere i bruk enn Context. Den st&#248;rste ulempen med b&#229;de Redux og MobX er at man m&#229; skrive mye &#34;boilerplate&#34;-kode for &#229; bruke det, og de er relativt kompliserte &#229; sette seg inn i. Recoil er bygd p&#229; enkle setters/getters som kan defineres hvor som helst og gir et minimum av boilerplate, kanskje mindre enn Context.<\/p><p>&#160;<\/p><p>Den st&#248;rste ulempen jeg ser med Recoil er at det er et relativt nytt bibliotek. Eksemplene de gir i dokumentasjonen ser enkle nok ut, men min erfaring er at man i praksis ofte m&#248;ter p&#229; problemer som ikke dekkes av dokumentasjonen. Fordi Recoil er relativt nytt s&#229; vil man finne f&#230;rre tr&#229;der p&#229; Stackoverflow der kjente problemer forklares og man vil finne f&#230;rre tutorials/eksempler p&#229; hvordan ting skal gj&#248;res.<\/p><p>Recoil er ogs&#229; s&#229;pass nytt at det ikke har TypeScript-st&#248;tte enda, noe jeg antar er grunnen til at vi ikke har brukt det i prosjektene v&#229;re. Det finnes utallige JS-biblioteker og rammeverk, og n&#229;r man velger hvilke man skal bruke i et prosjekt er det ekstremt viktig &#229; velge noe som har bred st&#248;tte, god dokumentasjon og som har eksistert lenge nok til at de fleste problemene har blitt oppdaget.<\/p><p>Jeg ville derfor v&#230;rt veldig skeptisk til &#229; bruke Recoil n&#229;, spesielt n&#229;r fordelene ikke er spesielt tungtveiende. En fordel med Recoil er fors&#229;vidt at det er laget av Facebook og ikke en &#34;ukjent&#34; tredjepart, og man kan dermed forvente at de vedlikeholder det og forbedrer det i lang tid fremover.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1864,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><em>Svaret er basert p&#229; f&#248;lgende kilder:<\/em><br />https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p><p>https://goodapi.co/blog/rest-vs-graphql<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://www.apollographql.com/blog/graphql-caching-the-elephant-in-the-room-11a3df0c23ad/<\/p><p>&#160;<\/p><p>En viktig forskjell mellom REST og GraphQL er hva de faktisk henter. N&#229;r man sender en foresp&#248;rsel til et REST API s&#229; f&#229;r man tilbake alt som ligger p&#229; det endepunktet, intet mer eller mindre. Med GraphQL sender man en sp&#248;rring som spesifiserer akkurat hva man vil ha tilbake og da f&#229;r man kun det. Man slipper alts&#229; det som kalles &#34;overfetching&#34;, der man med et REST API kan f&#229; ut mye mer informasjon enn man egentlig trengte. Forskjellen er alts&#229; at med REST er det serveren som bestemmer hva som skal sendes, mens med GraphQL er det serveren som sier hva den har og klienten som ber om det den vil ha.<\/p><p>&#160;<\/p><p>Med GraphQL man kan ogs&#229; bygge mer kompliserte sp&#248;rringer og hente ut alt man vil ha i &#233;n jafs. Man trenger ogs&#229; bare &#229; forholde seg til ett endpoint. Med REST vil man ofte m&#229;tte sende flere requests til forskjellige endpoints for &#229; f&#229; ut det man trenger.<\/p><p>&#160;<\/p><p>En ulempe med GraphQL er at det gj&#248;r caching vanskeligere og mindre nyttig. Mer kompliserte sp&#248;rringer gir flere unike ting &#229; cache (det hjelper ikke &#229; ha en &#34;nesten lik&#34; sp&#248;rring i cache). GraphQL har ogs&#229; et litt mer kj&#248;lig forhold til HTTP, og man m&#229; derfor i st&#248;rre grad h&#229;ndtere eventuell caching selv i stedet for &#229; f&#229; det &#34;gratis&#34; fra HTTP-protokollen.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11536407,"ext_inspera_userAssessmentSetupId":7139951,"ext_inspera_userAssessmentId":4841407,"dateLastModified":"2020-12-01T10:01:40Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:40Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bendiktsen Eivind (10106)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443634,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1245,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State kan h&#229;ndteres p&#229; flere m&#229;ter. En av de mest vanlige er &#229; bruke et state management library som f.eks. Redux eller Mobx, som h&#229;ndterer state for deg.<\/p><p>Hvis state skal v&#230;re tilgjengelig globalt, alts&#229; tilgjengelig over alt i applikasjonen, kan det v&#230;re en id&#233; &#229; bruke Context for &#229; lagre globale variabler.<\/p><p>Hvis state kun skal v&#230;re tilgjenglig i &#233;n komponent kan man bruke useState hooken for &#229; lagre state. Dette forutsetter at komponenten er en funksjonell komponent.<\/p><p>Har man istedenfor en klassekomponent kan man bruke <em>this.state =&#160;<\/em>for &#229; initialisere state i constructor, og deretter referere til&#160;<em>this.state<\/em><em>&#160;<\/em>for &#229; hente state igjen. Hvis man skal sette state i komponenten kan man bruke&#160;<em>this.state.setState()&#160;<\/em><\/p><p>&#160;<\/p><p>&#197; h&#229;ndtere state lokalt i en komponent er ikke s&#230;rlig komplisert, men hvis en komponent skal endre state i en annen komponent m&#229; man tenke seg litt mer om.<\/p><p>En &#34;foreldre&#34; komponent&#160;kan sende data&#160;til et barn&#160;(&#34;child-component&#34;) via props, slik at denne komponenten kan bruke data fra komponenten h&#248;yere i hierarkiet.<\/p><p>Hvis man skal gj&#248;re det motsatt vei, alts&#229; sende data fra et barn til en foreldre komponent kan man bruke &#34;callback functions&#34;. Da sender man en funksjon som kan endre state som&#160;prop til et barn slik at barnet kan bruke denne funksjonen til &#229; endre staten i foreldre komponenten.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://reactjs.org/docs/hooks-state.html<\/p><p>-&#160;https://reactjs.org/docs/state-and-lifecycle.html<\/p><p>-&#160;https://reactjs.org/docs/faq-functions.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3690,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management library slik som Redux og Mobx.<\/p><p>Det kan ogs&#229; sammenlignes med Context API&#39;et.<\/p><p>Redux bruker en enkelt store hvor all state er lagret, mens Mobx kan ha flere stores.&#160;<\/p><p>Dette betyr at komponenter kan gis tilgang til en store slik at de dermed f&#229;r tilgang til state som er lagret der.<\/p><p>Context brukes ved at man lager en context provider som definerer &#34;variabler&#34; med state, samt funksjoner tilh&#248;rende disse variablene. Deretter legger man denne &#34;provider&#34; rundt alle komponentene, f.eks. i App filen, noe som gj&#248;r at alle komponenter lengre ned i hierarkiet f&#229;r tilgang til denne dataen.<\/p><p>Recoil trenger ikke lage noen store og bruker atomer som enheter for state.&#160;Komponenter kan &#34;abonnere&#34; p&#229; disse atomene individuelt. Hvis en komponent leser verdien til et atom er det implisitt abonnert til dette atomet.&#160;<\/p><p>Dermed trenger ikke en komponent ha tilgang til hele &#34;storen&#34; n&#229;r den egentlig bare trenger tilgang til en enkelt state &#34;variabel&#34;.<\/p><p>Dette betyr ogs&#229; at hvis man bruker Recoil vil bare de komponentene som abonnerer p&#229; atomer bli oppdatert (&#34;re-rendered&#34;) n&#229;r state endres, mens hvis man bruker Redux eller Context vil alle komponentene bli oppdatert.<\/p><p>Mobx er lik Recoil her ved at komponentene kun oppdateres hvis en komponent bruker state som blir oppdatert.<\/p><p>&#160;<\/p><p>Recoil gir deg ogs&#229; tilgang til noe de kaller selectors. Det gj&#248;r at man kan bruke state til &#229; beregne ting istedenfor &#229; lage en ny state &#34;variabel&#34; for &#229; lagre denne informasjonen.<\/p><p>&#160;<\/p><p>Fordelen ved &#229; bruke Recoil istedenfor&#160;andre biblioteker er at det er veldig simpelt. Du har to prinsipper som ligger til grunn for biblioteket, og det er atomer og selectors. I tillegg f&#248;les dette biblioteket veldig ut som React, og med dette mener jeg at m&#229;ten man skriver koden p&#229; har store likhetstrekk med m&#229;ten man skriver kode i React. Dette biblioteket ser nesten ut&#160;som en global versjon av Reacts useState.<\/p><p>En fordel vil ogs&#229; v&#230;re at b&#229;de React og Recoil er laget av Facebook.<\/p><p>&#160;<\/p><p>Litt mer spesifikt vil fordelen ved &#229; bruke Recoil (sett bort i fra preferanse av syntaks osv) v&#230;re at man slipper &#229; oppdatere alle komponenter hvis state endres, men istedenfor oppdateres kun de komponentene som abonnerer p&#229; atomet som endres.<\/p><p>&#160;<\/p><p>Ulemper ved &#229; bruke Recoil istedenfor andre biblioteker er f&#248;rst og fremst at det er et nyere bibliotek.<\/p><p>Mens for eksempel Redux har mye dokumentasjon og et stort samfunn som bruker det, er Recoil et relativt nytt bibliotek og med de &#34;problemene&#34; det f&#248;rer med seg.<\/p><p>Det er derfor vanskeligere &#229; f&#229; hjelp hvis man m&#248;ter p&#229; problemer ved bruk av Recoil siden det er f&#230;rre som bruker dette biblioteket.<\/p><p>Et nyere bibliotek vil nok ogs&#229; ha flere &#34;barnesykdommer/bugs&#34; enn gamlere biblioteker som har blitt oppdatert over tidene.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://blog.logrocket.com/redux-vs-mobx/<\/p><p>-&#160;https://recoiljs.org<\/p><p>-&#160;https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851<\/p><p>- https://medium.com/@dbottiau/a-state-management-comparison-with-react-hooks-mobx-and-recoiljs-3b7e2f4cc6c3<\/p><p>-&#160;https://blog.logrocket.com/simple-state-management-react-recoil/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2170,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ved &#229; bruke et REST API lager man endepunkter for &#229; hente data.<\/p><p>Det betyr at vi har flere endepunkter med ulik logikk alt etter hva slags data man vil hente.<\/p><p>For eksempel i vil man kanskje hente ut brukerdata, og da kan ett endepunkt v&#230;re /users/id.<\/p><p>Vil man hente ut alle brukere kan et endepunkt enkelt og greit v&#230;re /users .<\/p><p>&#160;<\/p><p>Ved &#229; bruke GraphQL er det ganske annerledes. Tanken er at alle entiteter i GraphQL er&#160;knyttet sammen og man kan derfor kombinere data fra ulike entiteter. &#160;Man sender rett og slett en sp&#248;rring til serveren med de &#34;kravene&#34; eller spesifikke attributtene man trenger, og f&#229;r tilbake et JSON objekt.<\/p><p>For eksempel kan man si at man vil ha navn p&#229; brukeren med id lik 3;<\/p><p>&#160;<\/p><p>query {<\/p><p>&#160; User(id: 3) {<\/p><p>&#160; &#160; name<\/p><p>&#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>Ved &#229; se p&#229; dette ser man ogs&#229; at GraphQL er mye bedre til &#229; hente n&#248;yaktig den dataen man trenger.<\/p><p>Et REST API m&#229; definere endepunktene for &#229; hente dataen man trenger, og det er ikke enkelt &#229; lage disse endepunktene slik at de henter kun n&#248;yaktig det man vil ha. Derfor ender man ofte opp med &#229; enten hente for mye eller for lite data.<\/p><p>Skal man for eksempel hente navn og f&#248;dselsdato p&#229; alle brukere vil man kanskje f&#248;rst m&#229;tte gj&#248;re et API kall for &#229; hente alle brukere, og deretter ett nytt kall for &#229; f&#229; navn og f&#248;dselsdato p&#229; hver bruker.<\/p><p>Hadde man lagt denne infoen i kallet hvor man henter alle brukere vil man f&#229; infoen hver gang man vil hente alle brukere, selv om man kanskje ikke trenger det.<\/p><p>All logikk&#160;m&#229; alts&#229; implementeres&#160;i endepunktene.<\/p><p>&#160;<\/p><p>Et annet eksempel er hvis man skal hente ut brukere og innlegg. Ved &#229; bruke REST API m&#229; man da gj&#248;re to kall, f&#248;rst til brukere og deretter innlegg, mens i GraphQL kan man kombinere disse og trenger dermed bare sende en sp&#248;rring.<\/p><p>&#160;<\/p><p>Hovedpunktene her er alts&#229; at GraphQL er mye mer fleksibel og henter den spesifikke dataen man trenger.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>-&#160;https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11536462,"ext_inspera_userAssessmentSetupId":7140138,"ext_inspera_userAssessmentId":4841270,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bergan Oscar Marenius Bråten (10115)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330929,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1427,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Mekanisker og teknikker for &#229; h&#229;ndtere tilstand og dataflyt er veldig viktig i React-applikasjoner. Spesielt ved store prosjekter er det &#248;nskelig med systemer som h&#229;ndteres endringer i state, og p&#229;f&#248;lgende dataflyt.&#160;<\/p><p>Dersom prosjektet ikke benytter seg at state-systemer m&#229; alle endringer i props drilles ned i komponenthierarkiet hver kan en endring oppst&#229;r, noe som fort kan bli komplisert og uoversiktlig.<\/p><p>Derfor er det flere forskjellige verkt&#248;y som kan brukes for &#229; oppdatere&#160;props, uten &#229; m&#229;tte drille.&#160;<\/p><p>&#160;<\/p><p>State brukes til &#229; holde styr p&#229; hvilken tilstand en komponent er i, og en hver endring av state vil rendre komponenten p&#229; nytt. Endring av staten kan ogs&#229; endre props, slik at dataflyten skjer uten drilling.<\/p><p>&#160;<\/p><p>Context API brukes til &#229; sette variabler som skal kunne benyttes av mange forskjellige komponenter. Dette kan f.eks. v&#230;re om nettsiden skal v&#230;re i light/dark mode. De forskjellige komponentene kan abonnere til contexten, om dersom en endring i contexten oppst&#229;r vil de tilknyttede komponentene kunne lese den nye verdien og rendres p&#229; nytt, uten &#229; m&#229;tte drille endringen ned gjennom komponenttreet.<\/p><p>&#160;<\/p><p>Redux er en state-handler som brukes til &#229; definere, endre og lagre state i et prosjekt. De forskjellige tilstandene blir lagret i en store, og kan kun endret av en reducer. En reducer har overikt over hvilken state forskjellige komponenter befinner seg i, og f&#229;r inn en action som kan p&#229;virke denne statet. Dersom kombinasjonen av n&#229;v&#230;rende state og innkommende action vil endre staten, blir denne endringen lagret i store. Komponentene kan bruke useState() for &#229; lese verdier of oppdatere props, slik at endringen av state f&#248;rer til re-rendering av komponenten. Dette gj&#248;r ogs&#229; at dataen flyter direkte til komponenten og drilling unng&#229;s.&#160;<\/p><p>&#160;<\/p><p>Hvorvidt bruk av mekanisker for &#229; h&#229;ndtere state og dataflyet er n&#248;dvendig i det hele tatt varierer fra prosjekt til prosjekt. Dersom det er f&#229; komponenter og lite data som m&#229; endret vil det ofte v&#230;re &#34;overkill&#34; &#229; implementere en state-handler. Det er ikke en fasit p&#229; hva som er riktig og galt, og denne beslutningen m&#229; tas av de som jobber med prosjektet.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2417,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som bruk for &#229; handtere tilstand&#160;og dataflyet i et prosjektet. Det benytter seg av atoms og selectors. Et atom er en enhet av en tilstand, og en selector en en funksjon som tar inn et atom og gj&#248;re passende endringer p&#229; tilstandet. Komponenter kan abonnere p&#229; forskjellige selectors, slik at de oppdateres automatisk n&#229;r en tilstand(atom) endres av selectoren gjennom bruk av hooks. Selectoren kan gj&#248;re endringer b&#229;de synkront og asynkront.<\/p><p>&#160;<\/p><p>Recoil kan sammenlignes med Redux, der atoms er staten og en selector har samme oppgave som en reducer. Det er dog mer vesentlig &#229; se p&#229; forskjellene mellom disse. I recoil blir state lagret flere separerte steder i prosjekter, i steden for en global&#160;store som i Redux. Dette kan gj&#248;re det mer uoversiktlig &#229; bruke, dersom veldig mye skal lagres i state. Recoil er ogs&#229; utvikling spesielt for React, der Redux er utvikliklet for alle JavaScript applikasjoner. Dette gj&#248;r Recoil mer str&#248;mlinjet i en React-app. Recoil st&#248;tter ogs&#229; asynkrone endringer, noe som gj&#248;r at synkrone komponenter kan benytte seg av asynkrone endringer av state.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1561,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST-API benytter seg av&#160;forskjellige endepunkter for &#229; lese/skrive til databasen. Gjennom bruk av forskjellige HTTP-requester sammen med en URI kan APIet hente ut/endre p&#229;/legge til data slik programmereren &#248;nsker. REST-API kan skrive/lese/endre bestemte deler av datasettet gjennom &#229; lage et objekt med forskjellige krav som m&#229; oppfylles, som f.eks tittel som starter p&#229; en bestemt bokstav. I et REST-API blir hele objekter returnert, som kan f&#248;re til overfetching, dersom du kun trenger f.eks. to av atributtene til objektene returnert.<\/p><p>&#160;<\/p><p>N&#229;r kan bruker REST-API kan nettleseren lagre hva som ble skrevet/lest/endret ved et spesifikt kall. Dette blir lagret i cache, noe som gj&#248;r av fremtidige kall med samme URI vil f&#229; raskere da dataen er lagret lokalt. Bruk av REST i st&#248;rre prosjekter f&#248;rer ofte til veldig mange endepunkter, der hvert endepunkt ofte gjennomf&#248;rer flere HTTP-requester. Dersom objektene i databasen er relatert, m&#229; endringen av disse objektene ogs&#229; oppdaterer i samme endepunkt. F.eks. dersom et review for en film skal slettes, m&#229; ogs&#229; dette reviewet slettes i film-objektet.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker forskjellige sp&#248;rringer der filtrering, eventuell sortering og eventulle oppdateringer defineres. Dette gj&#248;r at en sp&#248;rring kan oppn&#229; det samme som en REST-endepunkt som innholder flere HTTP-requester. Dette gj&#248;r at en GraphQL-backend har f&#230;rre funksjoner for &#229; oppn&#229; samme funksjonalitet, og funksjonene er mer fleksible. I GraphQL kan det ogs&#229; defineres hvilke atributter ved de forskjellige objektene som skal returnes, slik at man slipper overfetching.&#160;GraphQL st&#248;tter dog ikke automatisk lagring i cache.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11537886,"ext_inspera_userAssessmentSetupId":7139977,"ext_inspera_userAssessmentId":4841420,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Skår Erik Mjaaland (10145)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34693470,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1978,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Her vil det v&#230;re naturlig &#229; skille mellom to hovedkategorier: state og props.<\/p><p>&#160;<\/p><p>State:<\/p><p>Innenfor React er state veldig viktig ettersom at komponenter kun re-renderes dersom staten er oppdatert. Det vil si at dersom man definerer en state og refererer til den verdien i JSX vil komponentet bli re-renderet med den nye verdien n&#229;r man oppdaterer staten. Dette er til motsetning til&#160;dersom det bare er en &#34;ikke state&#34;&#160;variabel som oppdateres. Da vil ikke komponentet i DOM-en re-renderes.<\/p><p>State er ogs&#229; m&#229;ten man bruker for &#229; f&#229; data fra child components opp til parent components. En annen m&#229;te &#229; gj&#248;re dette p&#229; er ved &#229; bruke callbacks, men state er ofte lettere &#229; bruke.<\/p><p>Noe som er veldig viktig med state er at state skal behandles som om den er immutable, alts&#229; skal man ikke endre den direkte. Dette er for &#229; s&#248;rge for at komponentet blir re-renderet som det skal. Eksempel:<\/p><p>&#160;<\/p><p>const [count, setCount] = useState(0);<\/p><p>&#160;<\/p><p>count = 5; // Dette er ikke lov fordi det endrer state direkte.<\/p><p>&#160;<\/p><p>setCount(5); // Dette er lov fordi det ikke endrer state direkte, men heller lar React ta seg av oppdateringen, som s&#248;rger for at komponentet blir oppdatert.<\/p><p>&#160;<\/p><p>Innenfor state finnes det to kategorier: local state og global state. Local state er lokal for hvert komponent og vil kun v&#230;re tilgjengelig for det komponentet. Global state er tilgjengelig for alle komponenter i et prosjekt. For global state brukes ofte biblioteker som Redux og MobX.<\/p><p>&#160;<\/p><p>Tidligere f&#248;r hooks ble implementert i React var det vanlig &#229; bruke s&#229;kalte &#34;lifecycle methods&#34; for &#229; oppdatere state. Dette gjorde at man kunne oppdatere state basert p&#229; om et komponent har blitt lagt til i DOM-en, om det skal fjernes fra DOM-en osv. Med hooks bruker man forskjellige hooks for &#229; oppn&#229; samme effekt, men uten boilerplaten som fulgte med den gamle metoden.<\/p><p>&#160;<\/p><p>Props:<\/p><p>Props er navnet p&#229; &#34;arbitrary inputs&#34; som kan bli sendt inn i komponenter (passed in). Props er en av faktorene som gj&#248;r at komponenter er gjenbrukbare ettersom at ved bruk av props vil man kunne sende data ned til komponenter fra komponentet over. Props kan bli sendt ned s&#229; langt man vil i DOM-treet. Dersom du har 100 komponenter inne i hverandre vil man kunne sende dataen fra det &#248;verste komponentet til det nederste komponentet ved bruk av props.&#160;Siden props er &#34;arbitrary input&#34; s&#229; vil man kunne sende inn data som strings, numbers, booleans, objekter og funksjoner. Den vanligste m&#229;ten &#229; lage callbacks p&#229; er ved &#229; sende inn en funksjon som prop.<\/p><p>&#160;<\/p><p>Alle React komponenter skal v&#230;re pure eller &#34;rene&#34; funksjoner. Dette vil si at de aldri skal endre props som blir sendt inn. S&#229; dersom man sender inn de samme verdiene to ganger p&#229; rad skal man f&#229; samme resultat ut. Dersom man vil at de skal kunne endre p&#229; det som blir sendt inn s&#229; skal man heller bruke state.&#160;<\/p><p>&#160;<\/p><p>https://reactjs.org/docs/components-and-props.html<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1994,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ut i fra dokumentasjonen kan vi se at Recoil er et state management bibliotek. Basert p&#229; det de skriver under &#34;motivation&#34; virker det som Recoil skal kombinere det beste fra f.eks. Redux og Context og v&#230;re noe som er litt midt i mellom disse. Recoil skal v&#230;re boilerplate-fritt, som Context, men ogs&#229; kunne re-rendere komponenter basert p&#229; global state uten at hele DOM-en m&#229; re-renderes fra toppen og ned som Redux. Det vil beholde simplisiteten ved Context, men ha muligheten til &#229; holde uendelig mengder state, noe Context ikke kan.<\/p><p>&#160;<\/p><p>Basert p&#229; dokumentasjonen ser det ut som en mer moderne og &#34;integrert&#34; m&#229;te &#229; h&#229;ndtere global state i React. Noen fordeler med dette biblioteket er at grunnet at det er boilerplate-fritt vil man kunne utvikle mye raskere enn dersom man skulle brukt noe som Redux, men fortsatt ha global state som er lagd for st&#248;rre applikasjoner i motsetning til Context. Ettersom det er Facebook som har laget biblioteket, de samme som originalt lagde React,&#160;s&#229; vet man at det vil f&#248;lge stilen til React i hvordan det brukes. Dette vil f&#248;re til at biblioteket vil virke mer integrert i utviklingen s&#229; state management ikke vil f&#248;les som en separat del av prosjektet.<\/p><p>&#160;<\/p><p>En ulempe ved Recoil er hvor nytt det er. P&#229; Github har de over 100 &#229;pne issues som sier litt om hvor mye jobb som gjenst&#229;r f&#248;r man kan anse det som ferdig. Dermed vil man kunne m&#248;te p&#229; problemer under utviklingen som ikke vil v&#230;re l&#248;sbare og da m&#229; man pause utviklingen til Facebook har pushet en l&#248;sning. Siden webteknologier endres i et s&#229;pass h&#248;yt tempo er det ingen garanti for at biblioteket er vedlikeholdt i fremtiden. Dermed kan det hende at den ene buggen man har som pauser utviklingen aldri blir fikset, og dermed m&#229; man bytte state management bibliotek. Disse problemene er naturligvis ikke eksklusive til dette biblioteket, men det er problemer som mange biblioteker som ikke har hatt tid til &#229; modne har hatt.<\/p><p>&#160;<\/p><p>Alt i alt virker det som et bibliotek som har funnet en gylden middelveg mellom andre biblioteker som Redux og Context kan v&#230;re spennende &#229; pr&#248;ve ut.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://github.com/facebookexperimental/Recoil<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1765,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er to forskjellige m&#229;ter &#229; kommunisere mellom servere og klienter. Hovedforskjellen mellom REST og GraphQL ligger i hvordan dataen hentes ut. Med REST vil hvert endepunkt ha definert hva det skal returnere fra f&#248;r. For eksempel kan et endepunkt v&#230;re /people/getPerson/{id} hvor da det vil returnere alle feltene til en person med den ID-en. Hvis man da kun har bruk for navnet til personen vil man m&#229;tte hente ut alle feltene un&#248;dvendig (overfetching) eller m&#229;tte definere et eget endepunkt for &#229; hente ut bare navnet. Med GraphQL vil man kunne definere akkurat hvilken data man har lyst til &#229; hente ut fra klientsiden slik at man slipper &#229; f&#229; med all dataen man ikke har bruk for.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av REST vil man f&#229; ut mange forskjellige statuskoder som 200 OK eller 430 Forbidden, men i GraphQL vil du bare f&#229; ut enten 200 OK eller 500 Internal Server Error. Dette f&#248;rer til dersom man pr&#248;ver &#229; hente ut data som ikke finnes vil man f&#229; ut null med 200 OK istedet for 404 Not Found. Man kan skrive egne error handling funksjoner som sender tilbake forskjellige statuskoder, men dette er ikke vanlig.<\/p><p>&#160;<\/p><p>Tidligere har det ogs&#229; v&#230;rt stor forskjell i caching mellom REST og GraphQL med at REST st&#248;tter caching i alle moderne nettlesere. Ved bruk av biblioteker som Apollo Client vil man ogs&#229; f&#229; denne st&#248;tten ved bruk av GraphQL.<\/p><p>&#160;<\/p><p>GraphQL st&#248;tter kun JSON-data, men ettersom det er basert p&#229; skjemaer for &#229; definere strukterer og typer vil man kunne samsvare disse p&#229; frontend og backend for &#229; for eksempel bruke verkt&#248;y for &#229; autogenere objekttyper p&#229; frontenden utifra disse skjemaene.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://www.apollographql.com/docs/react/caching/cache-configuration/<\/p><p>https://graphql.org/faq/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11534501,"ext_inspera_userAssessmentSetupId":7139969,"ext_inspera_userAssessmentId":4841483,"dateLastModified":"2020-12-01T10:01:45Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:45Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Gomo Ingrid Frøyland (10138)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35444053,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2795,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React-applikajsoner har komponenter&#160;en state (tilstand) som blir satt ved &#229; sende komponenten props. Dette gj&#248;r at vi kan lage genrelle komponenter, f.eks. en knapp, og gjenbruke denne flere steder p&#229; siden og sende inn ulike props, f.eks. til&#160;knapp-teksten, slik at en knapp sier &#34;Submit&#34; og en annen sier &#34;Ok&#34;. P&#229; denne m&#229;ten kan vi gjenbruke&#160;kode og vi f&#229;r et gjenomg&#229;ende&#160;design. Staten til en komponent settes ved oppretteselse og kan oppdateres ved &#229; sende nye props.<\/p><p>&#160;<\/p><p>Vi kan alts&#229; sette tilstanden til &#233;n komponent fra en annen komponent. Dette g&#229;r greit n&#229;r vi endrer staten&#160;til en child-komponent fra forelder-komponenten, men blir mer vrient n&#229;r vi m&#229; bevege oss oppover i hierarkiet. F.eks. hvis vi vil sende en props fra ett barn til et annet barn et annet&#160;sted i hierarkiet. Dette l&#248;ser vi&#160;med global state management. Det vil si at vi har en overordnet del av koden som fungerer som et taler&#248;r mellom de ulike komponentene som har kontroll p&#229; enhver state til enhver tid. P&#229; denne m&#229;ten kan vi flytte p&#229; data rundt i komponentreet uten &#229; trenge &#229; sende props p&#229; alle de ulike niv&#229;ene.<\/p><p>&#160;<\/p><p>Det finnes flere m&#229;ter &#229; implementere global state management p&#229;. Noen velkjente metoder er bruk av context, Redux og Mobx. Context (som i grunn ble forklart ovenfor) er ikke n&#248;dvendigvis det mest effektive. Redux baserer seg p&#229; context-api&#39;et, men implementeres p&#229; en annen m&#229;te.&#160;Redux kan sees p&#229; som en oppskrift man f&#248;lger&#160;og s&#229; implementerer selv. N&#229;r man&#160;skal endre noe i staten lagrer man&#160;en ny versjon av hele state. I redux bruker man en store som er en read-only-data som endres via actions, der actions er en oppskrift for&#160;hva som skal gj&#248;res med tilh&#248;rende data. Dersom vi bare skal bruke deler av staten kan vi bruke &#34;useSelector()&#34;. Redux kan kreve litt &#229; sette opp, men etter at det er p&#229; plass kan det utvides til &#229; fungere p&#229; store progammer. Redux brukes derfor ofte til tilstand og dataflyt hos&#160;grupper som utvikler store React-applikasjoner.<\/p><p>&#160;<\/p><p>Mobx har en litt annen status da det&#160;fungerer mer som et bibliotek, og&#160;det krever&#160;mindre kode man m&#229;&#160;skrive selv. Mobx har med observer og observable &#229; gj&#248;re, og komponentene det skal f&#248;lges med p&#229; staten til gj&#248;res til observat&#248;rer. Her har man ogs&#229; en store som man gj&#248;r observerbar ved &#229; benytte funksjonen&#160;useLocalObservable(createStore).<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2253,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management-bibliotek for React. Som forklart i forrige oppgave har Reacts innebygde state management-metoder noen begrensninger. F.eks.&#160;kan context bare lagre &#233;n verdi og ikke et stort sett med verdier som kan v&#230;re &#248;nskelig for &#229; ha bedre oversikt og dataflyt i applikasjonen. Recoil bruker da det de kaller&#160;Atoms som er state-enheter som komponenter kan lytte til og oppdatere. Hvis samme atom brukes av flere komponenter vil disse komponentene dele state.<\/p><p>&#160;<\/p><p>Recoil, Redux, Mobx og Context har alle&#160;samme hensikt&#160;at de lager en plass hvor man lagrer global&#160;data og kun re-redrer de n&#248;dvendige komponentene. Ser man f.eks. p&#229; context kan komponent-staten bare deles ved &#229; sende den til felles forfedre som f&#248;rer til at man m&#229; re-rendre et potensielt stort tre. Sammenligner man Recoil med Redux ser man at selv om&#160;Redux p&#229; mange m&#229;ter er veldig bra kan v&#230;re mye &#229; sette seg inn i for en som ikke er kjent med det da Redux har strenge regler for hvordan ting skal implementeres. Fordelen med&#160;Recoil er at man kan man i motsetning til ved Redix kan kj&#248;re kompleks logikk med lite boilerplate. Recoil ser ut til &#229; v&#230;re en god mellomting mellom enkelhet og kvalitet. Recoil fungerer fint med React hooks og er verken den beste eller den v&#230;rste n&#229;r det kommer til performance.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2080,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST st&#229;r for REpresentational State Transfer, hvor prinsippet er at man overf&#248;rer tilstand ved hjelp av HTTP-requests som GET, POST, PUT osv. Man definerer ett eller flere endepunkter for &#229; skrive til,&#160;lese fra eller endre p&#229;&#160;ressursene ved &#229; bruke HTTP-requestene og URI, der hver ressurs har en unik URI. REST er tilstandsl&#248;st som vil at et serveren egentlig ikke tar vare p&#229; kommunikasjon mellom klient og server. REST baserer seg ogs&#229; p&#229; standard web-protokoll som gir&#160;fordelen av at man kan benytte seg av caching-mekanismen, og man slepper da &#229; tenke p&#229; det n&#229;r man utvikler.&#160;En ulempe er derimot at dersom&#160;man har mer kompleks informasjon (mange endepunkter) m&#229; man gj&#248;re mange kall for &#229; hente data, og man kan endre opp med &#229; hente mer data enn man egentlig trenger.<\/p><p>&#160;<\/p><p>P&#229; den andre siden har vi&#160;GraphQL som fungerer som at sp&#248;rrespr&#229;k&#160;hvor man har server-side runtime for &#229; utf&#248;re sp&#248;rringer. I motsetning til REST hvor man bruker GET, sender man i GraphQL sp&#248;rringer til server&#160;hvor man definerer b&#229;de s&#248;k og hvilke data som skal returneres. Man unng&#229;r p&#229; den m&#229;ten lasting av for mye data (overfetching, som kan v&#230;re et problem med REST) da man kan sp&#248;rre etter akkurat den informasjonen man er interessert i. For eksempel: Man &#248;nsker &#229; finne en film og informajson om skuespillerne. Her vil REST f&#248;rst hente filmen, og s&#229; hente informasjon om alle skuespillerne som er knyttet til filmen. Det blir mange kall. Med GraphQL kan man gj&#248;re dette i &#233;n sp&#248;rring.&#160;Noen ulemper med GraphQL som REST ikke har er at GraphQL kun st&#248;tter JSON-data, og man har ikke implisitt caching. I motsetning til ved&#160;REST ligger imidlertid koblingen mellom server og client ligger tett(ere) i GraphQL, og dette f&#248;rer til at man har muligheten til &#229; validere.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534755,"ext_inspera_userAssessmentSetupId":7140018,"ext_inspera_userAssessmentId":4841339,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Lien Lars Eivind Røstum (10031)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":22089045,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1983,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I react g&#229;r data kun en vei. Applikasjonene er organisert som en serie av nestete komponenter. De mottar informasjon via argumenter (props) og sender informasjon via return verdiene deres.&#160;<\/p><p>Unidirectional data flow, betyr at man ofte nester barnekomponenter under h&#248;yere ordens forelderkomponenter. Foreldrekomponenten har ofte en state, som deretter blir sendt ned til sine barnekomponenter via read-only props. Barnekomponentene kan kommunisere tilbake til forelderen via en callback funksjon, og p&#229; denne m&#229;ten endre staten til forelderkomponenten.&#160;<\/p><p>&#160;<\/p><p>Mulighetene for &#229; definere state i en komponent baserer seg p&#229; bruken av hooks (funksjonelle komponenter), definere en lokal state i komponenten (klassekomponenter), eller bruke et state management rammeverk for &#229; sette en global state.&#160;<\/p><p>&#160;<\/p><p>For &#229; best h&#229;ndtere states, er det viktig &#229; bestemme seg for om hvilke state som b&#248;r v&#230;re lokalt og hvilke som b&#248;r v&#230;re globalt. Dersom en state er delt mellom mer enn to komponenter, er det ofte lurt &#229; benytte seg av global state management, slik som redux, MobX, Recoil osv. Men dersom den ikke er delt mellom mer enn to komponenter, og den mest sannsynlig ikke kommer til &#229; bli det heller, kan det l&#248;nne seg &#229; benytte seg av lokal state.&#160;<\/p><p>&#160;<\/p><p>Globale state rammeverk l&#248;ser problemer relatert til prop-drilling og un&#248;dvendige re-renders av en applikasjons komponenttre.&#160;<\/p><p>&#160;<\/p><p>https://medium.com/@lizdenhup/understanding-unidirectional-data-flow-in-react-3e3524c09d8e#:~:text=A%20unidirectional%20data%20flow%20means,within%20higher%2Dorder%20parent%20components.&#38;text=The%20parent%20component%20passes%20this,and%20Candidate%2C%20via%20explicit%20props.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2115,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for &#229; h&#229;ndtere tilstand i React. Recoil best&#229;r i all hovedsak av to ting - atomer og selektorer. Atomer er enheter av tilstand. De kan oppdateres og abonneres p&#229;, og n&#229;r atomet oppdateres, vil hver komponent som abonnerer p&#229; atomet re-rendres med den mye verdien. Selektor er en funksjon som aksepterer atomer eller andre selektorer som input. N&#229;r atomene eller selektorene oppdateres, vil selektorfunksjonen kj&#248;re p&#229; nytt. Komponenter kan ogs&#229; abonnere p&#229; selektorer, slik at n&#229;r selektorene endres, vil komponentene re-rendres.&#160;<\/p><p>&#160;<\/p><p>B&#229;de Context, Redux og Recoil er ment til &#229; l&#248;se problemer relatert til prop-drilling og un&#248;dvendige re-renders av en applikasjons komponenttre.&#160;<\/p><p>&#160;<\/p><p>Context API er kun ment for &#34;low-frequency&#34; oppdateringer, slik som temaendringer. En annen negativ ting ved Context er at hver gang Provideren f&#229;r en ny verdi, vil alle komponenter med en tilsvarende Consumer re-rendres, selv om komponenten bare benytter seg av en del av denne tilstanden.&#160;<\/p><p>&#160;<\/p><p>Med recoil er det ikke n&#248;dvendig &#229; implementere en egen store, slik som i Redux. Dette gj&#248;r at man ikke trenger &#229; sette seg inn i kompliserte oppsett, og det er mye mindre kode som er n&#248;dvendig for &#229; komme i gang.&#160;<\/p><p>&#160;<\/p><p>I redux, blir handlinger kj&#248;rt via dispatch-metoden, mens i Recoil kj&#248;res handlingen vha. en selektor. Recoil er basert p&#229; react hooks, og det fremst&#229;r relativt enkelt &#229; oppdatere state med recoil, ettersom man kan utf&#248;re en setState, men med useRecoilState, i stedet for useState. Ettersom man mest sannsynlig er kjent med vanlige hooks metoder fra React, fremst&#229;r recoil som enkel &#229; sette seg inn i og intuitiv &#229; bruke.&#160;<\/p><p>&#160;<\/p><p>https://blog.usejournal.com/react-state-management-in-2020-eeb01739a691<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3045,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST (REpresentational State Transfer) API er en &#34;best-practice&#34; design av web-api, som benytter HTTP requests til &#229; aksessere og modifisere data. Operasjoner inkluderer GET, POST, PUT og DELETE.&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k, med server-side runtime,&#160;for API-er. Her prioriteres det &#229; gi klienten n&#248;yaktig den dataen den trenger, og ikke mer.&#160;<\/p><p>&#160;<\/p><p>Med et REST API, har du ett endepunkt til hver oppgave / data du &#248;nsker &#229; hente ut. Her er det fastsatt hvilke data som returneres, og det er ikke mulig &#229; begrense feltene som et REST API returnerer, dette kalles over fetching. GraphQL bruker derimot sp&#248;rrespr&#229;ket sitt til &#229; skreddersy requesten din til n&#248;yaktig hva du trenger. Dette gj&#248;r at n&#248;dvendig data kan hentes med kun &#232;n sp&#248;rring. Det betyr at man unng&#229;r b&#229;de over fetching og under fetching.&#160;<\/p><p>&#160;<\/p><p>I GraphQL, har utviklerene mulighet til &#229; f&#229; innsikt i hvilke data som hentes i back-end, og hvordan denne dataen blir brukt, ettersom hver klient spesifiserer n&#248;yaktig hva slags informasjon som trengs. Dette kan utviklerene bruke til &#229; forbedre API ytelsen.<\/p><p>&#160;<\/p><p>I GraphQL er det et typesystem som validerer og dokumenterer, og som forteller klienten hvordan aksesseringen av data skal foreg&#229;. Fordelen med dette er at b&#229;de front-end og back-end utviklere er kjent med strukturen av dataen, og kan derfor jobbe uavhengig av hverandre.<\/p><p>&#160;<\/p><p>I motsetning til REST, har ikke GraphQL implisitt caching i HTTP - laget. Caching i nettverkslaget er viktig, ettersom dette kan redusere mengden trafikk til serveren betraktelig.<\/p><p>&#160;<\/p><p>I GraphQL er det en kobling mellom klient og tjener, noe som gj&#248;r at det ikke er like skalerbart som REST API. REST arkitekturen frakobler klient og server, noe som gj&#248;r at skalering av produkter og applikasjoner kan skje uten store vanskeligheter.&#160;<\/p><p>&#160;<\/p><p>REST API er mer fleksibel enn GraphQL. Data er ikke knyttet til ressurser eller metoder, noe som gj&#248;r at REST kan h&#229;ndtere ulike typer kall og returnere ulike dataformater.&#160;GraphQL har kun JSON for utveksling av data.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11542296,"ext_inspera_userAssessmentSetupId":7140131,"ext_inspera_userAssessmentId":4841209,"dateLastModified":"2020-12-01T10:01:27Z","ext_inspera_startTime":"2020-12-01T08:00:51Z","ext_inspera_endTime":"2020-12-01T10:01:27Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tufte-Johnsen Kristoffer (10008)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35325548,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2040,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React gj&#248;r det mulig &#229; registrer hva som blir endret og bare endre p&#229; komponenten hvor endringene har effekt.<\/p><p>Den klassiske m&#229;ten react holder styr p&#229; og oppdaterer tilstanden reactkomponentene skal v&#230;re i er at de f&#229;r tilsendt informasjon ovenfra gjennom props (foreldrekomponenter aktiverer&#160;alts&#229; barnekomponentene&#160;hvor de samtidig sender med propsegenskaper.) Props sendes fra toppen og ned, alts&#229; vil mye av logikken p&#229; n&#229;r endringer skal forekomme ligge h&#248;yt i komponenthierarkiet slik at de aktuelle barnekomponentente kan oppdage n&#229;r endringer skjer. Props er imutable, als&#229; kan ikke proppen endres p&#229; veine av en komponent&#160; n&#229;r informasjoen flyter nedover i minnehierarkiet.<\/p><p>En hver komponent kan ogs&#229; holde p&#229; en intern state. Denne staten kan ikke endres direkte p&#229; av andre komponenter men er privat for denne komponenten og endres etter intern logikk.<\/p><p>&#160;<\/p><p>Hvordan komponentene holder styr p&#229; state og props, kommer i noen grad p&#229; hvorvidt det er snakk om en klasse- eller en funkjsonell komponent. Klassekomponent har noe som kalles livssykluser. De viktigste syklusene er n&#229;r komponenten initieres, opdateres og avsluttes. React har en del innebygde funksjoner som h&#229;ndterer disse rosessene i riktig rekkef&#248;lge. componentDidMount() er et eksempel p&#229; dette, en funkjsnon som kalles etter komponenten har rendret ut p&#229; siden, ettersom effekten av componentDidMount kan v&#230;re avhengig av at nettsiden er satt opp riktig.<\/p><p>Funkjsonelle komponenter har introdusert &#34;hooks&#34; som hopper inn i tilstanden og kan manipulere staten til en funkjsonell komponent i veldig lik grad som i en klassekomponent. useState() f.eks. en hook som kan holde p&#229; en tilstand for en variable eller et objekt av noe sort, samrt oppdater staten etter kall. Jeg kommer ikke til &#229; g&#229; noe videre inn p&#229; dette men ville are poengtere at det er noe forskjell p&#229; statemanagment av klasse og funkjsonelle komponenter.&#160;<\/p><p>&#160;<\/p><p>Det kan ved store applikajoner bli komplisert eller unaturlig&#160;&#229; h&#229;ndtere state og props fra ovenfra og ned slik den klassiske fremgangsm&#229;ten tilsier. I enkelte tilfeller vil det ikke v&#230;re n&#248;dvendig for komponentene mellom foreldrekomponenten og barnekomponenten som skla motta proppet &#229; kjenne til propverdiene. Enkelte tilstander i en komponent kan ogs&#229; v&#230;re interssant for andre komponenter eller kankjs hele applikasjoen. Context er et fint verkt&#248;y som kan definerer enkelt egneskaper som globale. Det vil si at noe informasjon om enkelte komponenter kan n&#229;es fra hele applikasjonen.<\/p><p>&#160;<\/p><p>Redux er et annet eksempel som definerer en globals state. Forskjelen er at hele staten til applikasjoenn h&#229;ndteres av redux og kan n&#229;es fra overalt i applikasjonen. Ved store applikasjoner kan dette v&#230;re gunstig og oversiktlig.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2633,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en form for statemanager som deler flere egenskaper med Context APIet og redux.&#160;<\/p><p>Recoil bygger p&#229; et atoms og selectors. Atoms er tilstandsenheger som komponenter kan lytte etter. Hvis en endring forekommer i stateten til et atom, vil alle som lytter p&#229; dette atomet rerendres og oppdatere komponenten der det er aktuelt. Selctors tar inn atomer eller andre selctors som input. Selectors endrer staten til et atom enten synkront eller asynkront og likt med atoms kan denne selectors benyttes av alle komponenter som lytter p&#229; den. Til forskjell fra redux trenger mang ikke definere reducers og stores hver for seg, men kan sette staten direkte, nesten som setState i en vanlig react komponent men bare med useRecoilState i stedet for.<\/p><p>&#160;<\/p><p>En av de strore fordelen med Recoil over redux er alts&#229; at Recoil krever mindre kode(trenger ikke separer stroes fra reducers) og staten kan aksesseres direkte fra komponenten. Likevel er det bare komponenten som lytter p&#229; oppdateringene som endres og ikke helle komponenthierarkiet&#160;slik som ville v&#230;rt n&#248;dvendig med Redux.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2426,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ved REST defineres enkelte endepunkter for &#229; lese, skrive eller endre p&#229; ressurser gjennom HTTP og URI requests. Benytter du REST kan du dra fordel av caching-mekanismen som default st&#248;ttes av alle weblesere. Det finnes &#229;pnebart en del fleksibilitet &#229; kunne skape egne endepunkt for &#229; hente ut, sende&#160;eller p&#229; andre m&#229;ter manipulere data.<\/p><p>En mulig ulempe med REST er at ved mer kompleks informasjon kreves det av og til kall til flere endepunkter for &#229; hente ut riktig data (eller skrive, oppdater, etc.). Rest har som utfordring at det kan v&#230;re vanskelig &#229; spesifisere hvilke data som egentlig &#248;nskes. Av og til trenger du bare deler av kallet(kalles for overfetching) mens andre ganger trenger du&#160;mer enn et kall(kalles for underfetching).<\/p><p>&#160;<\/p><p>GraphQL er et basert p&#229; at du sender en sp&#248;rring til en server hvor du definerer b&#229;de s&#248;k og hvilke data som skal returneres (eller oppdateringer). Fordelene er at alle data kan hentes i en request og at du unng&#229;r lasting av for mye data. I tillegg er det det typesystem som gj&#248;r det mulig &#229; validere data.<\/p><p>&#160;<\/p><p>Ulemper er mangel p&#229; implisitt caching i HTTP-lage og at det kun st&#248;tter JSON-data. Kobling mellom tjener og klient kan ogs&#229; v&#230;re noe tettere i ved bruk av GraphQL siden det brukes skjema som definerer struktur og typer, men dette kan ogs&#229; vurderes som en fordel siden det muliggj&#248;r validering.<\/p><p>&#160;<\/p><p>Ved GraphQL kan alts&#229; sp&#248;rringene defineres slik at all&#160;&#248;nsket informasjon og ingenting mer, blir spurt om og hentet ut i et og samme kall. Rest API er mer statisk og endepunktene er forh&#229;ndsdefinert og er, uten importering av moduler eller tredjepartskomponter,&#160;ikke i stand til &#229; spesifisere akkurat hvilke informasjon som &#248;nskes. Det finnes likvel en del importeringsmuligheter som gj&#248;r det mulig for REST &#229; oppf&#248;re seg som GraphQL sp&#248;rringer, ekempelvis mongoose. GraphQL krever likevel at all data mottes som JSON-objekter, noe REST ikke gj&#248;r. GraphQL vil validere hva som blir sendt tilbake ettersom formen p&#229; skjemaet er definert. Denne valideringen har i utgangspunktet ikke REST. REST har alts&#229; en del muligheter men uten importering av moduler eller tredjepartskomponenter vil REST APIet til tider v&#230;re v&#230;re lite tilpasselig i forhold til GrapQL.<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11543075,"ext_inspera_userAssessmentSetupId":7140020,"ext_inspera_userAssessmentId":4841307,"dateLastModified":"2020-12-01T10:01:33Z","ext_inspera_startTime":"2020-12-01T08:02:22Z","ext_inspera_endTime":"2020-12-01T10:01:33Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Vangen Andreas Frenning (10092)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":24824869,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1237,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er en variabel som deklareres med setState, enten importert fra useState eller som en del av react klassen. State brukes for &#229; lagre data som vi kan skrive til eller hente. React f&#248;lger med p&#229; verdiene og oppdaterer automatisk komponenter hvor State verdier endrer seg.&#160;<\/p><p>&#160;<\/p><p>For &#229; kontrollere og h&#229;ndtere States i React bruker vi i st&#248;rre applikasjoner biblioteker som Redux, MobX, (Recoil),&#160;eller s&#229; bruker vi egendefinerte &#34;stateful components&#34;&#160;for h&#229;ndtering av states. Slik f&#229;r vi kontroll over verdiene som befinner seg i statene v&#229;re. Slik jeg har skj&#248;nt det benyttes verkt&#248;y&#160;til &#229; legge til en providerkomponent som inkapsulerer komponenter vi vil skal benytte samme data. Komponentene under arver en storage variabel vi kan bruke en select funksjon for &#229; hente data og en dispatch/setState&#160;funksjon for &#229; skrive data til State objektet og lagre&#160;data i storage. ( her mener jeg dispatch som generelt, ikke spesifikk referanse til Redux). Slik har vi bedre kontroll over verdiene v&#229;re og kan lage kontrollerte set/dispatch funksjoner for &#229; garantere korrekt data i applikasjonen v&#229;r.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2649,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Facebook Recoil er et state management bibliotek som lar oss h&#229;ndtere states lettere? Det ser mer lettvekt ut og forholder seg til verdiene i &#34;storage&#34; med en key.&#160;<\/p><p>&#160;<\/p><p>Punkter:<\/p><p>Recoil addresserer at n&#229;r verdier pushes til typ: Providers i andre biblioteker eller l&#248;sninger ser vi ofte at hele treet under blir re-rendered. I Recoil refereres alle komponenter som benytter seg av en en state som subscribers til den staten og alle subscribers re-rendres n&#229;r verdien oppdateres istedet for alle under provideren.&#160;<\/p><p>&#160;<\/p><p>Selectors: Komponenter kan subscribe til funksjoner som foredler state verdier istedet for &#229; gj&#248;re det selv med state dataen n&#229;r den oppdateres.<\/p><p>--<\/p><p>Forskjell fra Redux og MobX er at jeg ser ingen type kontroll eller definering ved&#160;&#34;dispatching&#34; av data. I redux definerer vi funksjoner som manipulerer state verdien med newState verdier som kommer inn. Og i MobX definerer vi Actions som funksjoner, hvor slik sjekking er enkelt &#229; gj&#248;re. I disse funksjonene er det enkelt &#229; kontrollere input mens i Recoil ser det ut som at det er en mer i komponent-h&#229;ndtering av hva som skal v&#230;re i enkelt state. Dvs. typesjekking/feilkontroll etc. skjer f&#248;r dispatch.&#160;I min mening gir det mulighet for &#229; forveksle hva slags data som skal lageres i en state mellom komponenter som benytter staten. TypeScript vil vel gj&#248;re det lettere med interfaces i setter/state etc, men i forhold til Redux foreksempel er det manglende kontroll av input til staten. &#60;- noelunde feil, men ikke helt hvis man benytter seg av useRecoilState/useSetRecoilState istedet for en selector for &#229; sette data.<br />I&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee vises det derimot en god m&#229;te &#229; typesjekke p&#229;? verdiene som blir satt av setRecoilState hentes fra en selector som er subscribed til staten og returnerer en inkrementert verdi av staten. Slik har han full kontroll over verdien i staten og det er ingen ambisi&#248;s kontroll av&#160; typen.<\/p><p>&#160;<\/p><p>Derimot har Recoil mye, mye! mindre &#34;boilerplate&#34; kode en Redux og en kortere l&#230;ringskurve. Personlig forstod jeg Recoil veldig fort, men det kan v&#230;re etter &#229; ha satt meg inn i Redux/MobX, men Recoil ser veldig simpelt ut.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1577,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er definerte endepunkter, typ ____.no/basketballTeam:id/players, mens GraphQL er ett endepunkt som tar imot HTTP requests med query stil for &#229; returnere spesifisert &#248;nsket data. API endepunkter har bare predefinert data. Derfor hvis man vil ha flere objekter som er relevante for hverandre m&#229; en hente fra to endpunkter i API mensi GraphQL kan en lage sp&#248;rringer som returnerer akkurat den dataen vi vil ha. Et annet punkt som er overfetching, veldig relevant ved REST API mens GraphQL har ikke dette problemet. GraphQL lar oss spesifisere dataen vi vil ha i queries slik at vi aldri henter mer en det vi trenger. Dette er ikke designet til REST API by default.<\/p><p>&#160;<\/p><p>REST API er tilstandsl&#248;s(skal ikke huske klienters foresp&#248;rsler) og v&#230;re uavhengig av tidligere informasjon for &#229; svare klienten.og har utfordringer med h&#229;ndtering av sortering, filtrering og paging.(REST-Graphql-state.pdf Forelesningsnotater). GraphQL derimot h&#229;ndterer paging, filtrering og sortering enkelt, men for b&#229;de REST og GraphQL kommer dette an p&#229; databasen i bruk.<\/p><p><br />Rest API er et endtepunkt med data, foreks /basketballTeams?id=&#34;x&#34;&#38;active=&#34;x&#34;, som krever URL parametere for sortering og krever derfor at en koder metoder for &#229; forst&#229; urlene og benytte teknikker for &#229; h&#229;ndtere filter,paging og s&#248;ke variabler. Dette kan v&#230;re vrient mtp. spesielle karakterer eller vriene filtreringer. I GraphQL er ikke dette et problem, filtering, sortering og paging-verdier kan legges til i query.<\/p><p>&#160;<\/p><p>I Rest API m&#229; vi definere endepunkter for data vi vil hente mens i GraphQL m&#229; vi definere queries og reducers for dataen vi vil f&#229; tak i. Derfor krever fort Rest API mer planlegging en GraphQL, i Rest m&#229; vi vite hva som skal v&#230;re defintert og kunne hentes i hvert endepunkt mens i GraphQL er det veldig lett &#229; endre en reducer eller query for &#229; f&#229; med eller fjerne data.<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11536596,"ext_inspera_userAssessmentSetupId":7140048,"ext_inspera_userAssessmentId":4841360,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Stabell Vilde Voss (10196)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331058,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2654,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><em>I denne oppgaven antar jeg at det er snakk om tilstand og flyt av data i form av props og state osv. og ikke bruk av f.eks. importerte konstanter.&#160;<\/em><\/p><p>&#160;<\/p><p>I React applikasjoner flyter data fra foreldre- til barn-komponenter ved hjelp av props, videre kan barne-komponenter sende data til foreldrene gjennom callback funksjoner.&#160;<\/p><p>&#160;<\/p><p>Props st&#229;r for &#34;properties&#34; og er immuteable. Det vil si at de ikke kan endres etter komponenten er opprettet. Hvis det er behov for &#229; holde styr p&#229; data som kan endres av selve komponenten kan state brukes. Endring av state i en react komponent gj&#248;res ved hjelp av den asynkrone funksjonen setState(), og vil f&#229; komponenten til &#229; rendere p&#229; nytt. For &#229; oppdatere state n&#229;r en komponent opprettes kan den innebygde funksjonen componentDidMount() brukes. Liknende kan componentDidUpdate() brukes for &#229; holde state oppdatert n&#229;r det har skjedd endringer.&#160;<\/p><p>&#160;<\/p><p>I funksjonelle komponenter kan hooks brukes istedenfor state. Disse deklareres ved hjelp av useState(&#60;startVerdi&#62;) og lagres som&#160;to variabler: en for &#229; lese verdien og en for &#229; endre verdien.&#160;<\/p><p>&#160;<\/p><p>Props og State er avhengige av sending av data mellom komponenter, og kan gi mye overhead n&#229;r applikasjonen blir st&#248;rre og mange komponenter skal ha tilgang til samme data. Da kan man bruke state management teknologier som Redux eller MobX. Disse baserer seg p&#229; konseptet om &#229; ha en kjerne av state data, som kan leses og endres fra alle komponenter. (Dataen endres ikke direkte, men gjennom f.eks. actions og reducers i Redux)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2337,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React, tilsvarende Redux og MobX fra pensum. State management biblioteker gj&#248;r det lettere &#229; holde styr p&#229; tilstanden til applikasjonen n&#229;r det er data som brukes i mange komponenter i ulike deler av komponenthierarkiet.&#160; N&#229;r man bruker Recoil kan komponenter subscribe og endre atoms, som representerer state-verdien. Selectors kan ogs&#229; subscribes til, og disse gir verdier avledet av atom-verdier. Bruken av atoms likner bruken av vanlige react hooks. Til forskjell fra Redux trenger ikke Recoil en Store.&#160;<\/p><p>&#160;<\/p><p>Fordeler med Recoil overfor f.eks. Redux er at recoil har mindre boilerplate, samt at likheten til hooks kan&#160;gj&#248;re l&#230;ringskurven mindre. I tillegg vil bare komponenter som har subscribet til et atom eller en selector oppdateres ved endringer, i motsetning til Redux hvor hele komponenttreet m&#229; oppdateres. (MobX har derimot bedre ytelse p&#229; dette punktet, men med ulempen at implementasjonen er mer abstrakt og &#39;usynlig&#39;)&#160;<\/p><p>&#160;<\/p><p>En ulempe med Recoil er mangel p&#229; st&#248;tte for ES5, som vil si at utviklere m&#229; vurdere om dette er n&#248;dvendig for prosjektet f&#248;r man bestemmer seg for &#229; bruke biblioteket.&#160;<\/p><p>&#160;<\/p><p>Recoil er basert p&#229; react hooks, og kan derfor skape problemer hvis utviklerne trenger &#229; bruke det i komponenter som ikke kan v&#230;re funksjonelle.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>For &#229; svare p&#229; dette sp&#248;rsm&#229;let har jeg brukt dokumentasjonssiden som ble oppgitt, samt&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2062,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API sender informasjon til klienten, eller lar klienten endre informasjon, basert p&#229; hvilket endepunkt som er brukt i foresp&#248;rselen (Og om det er gitt gyldig autorisering). Rest er mye brukt, og st&#248;ttet i nesten alle browsere. Det har st&#248;tte for caching, som reduserer ressurskostnader ved gjentatte sp&#248;rringer. Hvor mye, og hvilken&#160;informasjon som sendes i respons til en foresp&#248;rsel kommer an p&#229; hvordan databasen er satt opp. Dette f&#248;rer til problemer som overfetching og underfetching. Overfetching g&#229;r ut p&#229; at un&#248;dvendig data blir sendt i tillegg til dataen som klienten faktisk trenger. Underfetching g&#229;r ut p&#229; at dataen klienten trenger&#160;ikke er lagret i samme tabell, s&#229; klienten m&#229; sende flere f&#248;resp&#248;rseler for &#229; f&#229; n&#248;dvendig data. Hvis man for eksempel skal ha navn til alle bilene i en liste m&#229; man f&#248;rst sp&#248;rre om listen av biler, og s&#229; gj&#248;re en sp&#248;rring per bil for mer informasjon (som sannsynligvis inneholder ekstra data i tillegg til navnet).&#160;<\/p><p>&#160;<\/p><p>Graphql ble laget som et svar p&#229; dette. Graphql er et sp&#248;rrespr&#229;k som kan svare p&#229; queries p&#229; formen definert av serveren, og bare returnerer den dataen som er &#248;nskelig. Disse sp&#248;rringene (queries) kan v&#230;re n&#248;stede, og dermed returnere relatert informasjon fra ulike tabeller i databasen om n&#248;dvendig. Eksempelet fra over krever bare &#233;n sp&#248;rring i Graphql (hvis serveren har st&#248;tte for slike queries).&#160;Ettersom sp&#248;rringene bruker typer, blir ogs&#229; validering lettere.<\/p><p>En ulempe med Graphql er begrensninger p&#229; hvilken type data som kan sendes, da det som regel bare er st&#248;tte for json. Dette gj&#248;r bl.a. filh&#229;ndtering vanskelig, og f&#248;rer ofte til at Graphql-l&#248;sninger brukes sammen med f.eks. et REST API.&#160;<\/p><p>I tillegg er det ikke like mye st&#248;tte for Graphql som Rest.&#160;&#160;<\/p><p>Graphql har heller ikke implisitt st&#248;tte for caching, som Rest har.&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11537890,"ext_inspera_userAssessmentSetupId":7140106,"ext_inspera_userAssessmentId":4841285,"dateLastModified":"2020-12-01T10:01:32Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:32Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bø Edvard Mattias (10110)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":31744618,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2117,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React er den en rekke teknikker som brukes for state og dataflyt i React.&#160;<\/p><p>&#160;<\/p><p>Klassekomponenter i React kan opperere med sin egen interne state. N&#229;r et state-objekt oppdaterer seg, vil komponenten den tilh&#248;rer re-rendre seg. I funksjonelle komponenter kan man bruke useState for &#229; holde styr p&#229; interne states. useState er en&#160;<em>hook.&#160;<\/em>Man kaller det inni en funksjonell komponent, for &#229; legge til en state. Da definerer man en variabel, og en funksjon for &#229; endre p&#229; den gitte variabelen:<\/p><p>const [count, setCount] = useState (0)<\/p><p>Her er count variabele, mens setCount er funksjonen. I det vi definerer denne sette vi count = 0 i useState. For &#229; endre denne m&#229; vi kalle setCount(X), hvor X er tallet vi vil sette.&#160;<\/p><p>&#160;<\/p><p>For &#229; sende data nedover i hierarkiet (fra parent til child), kan man sende data via props. Props er immutable, som vil si at den overskrives aldri, men det lages en ny versjon. Ofte vil man sende props ned, og denne propen vil oppdatere en state til den&#160;mottagende komponenten.&#160;<\/p><p>&#160;<\/p><p>Dersom man har data man trenger &#229; benytte p&#229; en rekke ulike steder i en applikasjon, kan det v&#230;re tungvindt &#229; m&#229;tte sende props over alt. Da vil man m&#229;tte sende props ned forbi diverse komponenter, s&#229;kalt prop-drilling. Da er det lettere &#229; bruke en teknologi som holder styr p&#229; states i et globalt repository. Det finnes en rekke ulike metoder &#229; gj&#248;re dette p&#229;.&#160;<\/p><p>&#160;<\/p><p>Context API er en slik teknologi. Den lar deg opprette globale variabler som kan sendes rundt i applikasjonen. P&#229; denne m&#229;ten trenger man ikke sende data gjennom ledd, man kan bare hente ut dataen akkurat der man trenger den. Verdiene kan ogs&#229; oppdateres vja hooks Dette gj&#248;res ved at man oppretter en Context Provider &#248;verst i hierarkiet i applicasjonen. Denne provideren f&#229;r med seg dataen man &#248;nsker &#229; dele som props. Deretter oppretter man Context Consumers i det komponentene som trenger &#229; benytte seg av den valgte dataen. Hensikten med Context er &#229; h&#229;ndtere s&#229;kalte &#34;low frequency updates&#34;, som er endringer som ikke forekommer s&#229; ofte, som endring av fargetema eller authentication av bruker.&#160;<\/p><p>&#160;<\/p><p>Man kan ogs&#229; bruke andre state management libraries, som Redux eller MobX. Dette er andre bibliotek som har som m&#229;l &#229; holde styr p&#229; komponenter, og passe p&#229; at alle er synkronisert.<\/p><p>&#160;<\/p><p>Redux er mest utbredt. Da lagres alle states globalt, og komponentene har ikke egen state, men henter det fra <em>store<\/em>, hvor alle states er lagret. Store er ogs&#229; immutabelt, som betyr at verdiene blir aldri endret, men det opprettes nye versjoner. Man definerer s&#229; en reducer, som tar inn en action som oppdaterer store. Store oppdateres alts&#229; via en reducers, som har en action, som har en verdi.<\/p><p>&#160;<\/p><p>MobX har en action, som oppdaterer en observable, og denne observablen skaper en reaksjon p&#229; de stedene observablen blir brukt. Dette vil si at applikasjonen kanskje bare trenger &#229; oppdatere noen f&#229; komponenter, som MobX vet n&#248;yaktig hvor er.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; benytte seg av state management systemer i teknologien man bruker f&#229; &#229; hente data. GraphQL kan man bruke Apollo eller Relay, mens REST har react-query eller SWR.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3555,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt state management bibliotek, som er utviklet av Facebook.<\/p><p>&#160;<\/p><p>Det opprerer med Atoms og Selectors, hvor Atoms er enheter med state. De kan oppdateres og subscribes til. Dette betyr at n&#229;r et atom oppdateres, vil alle komponenter som subscribet til dette atomet re-rendres med den nye verdien. Seltors er rene funksjoner som aksepterer atomer eller andre selectors som input. N&#229;r disse blir oppdatert, vil selector funksjonene re-evalueres. Komponenter kan subscribe til selectorer, akkurat som med atomer, og vil da re-rendres n&#229;r selctoren endres. Selectorer kan endre atomet state enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Slik jeg ser det er hensikten med recoil &#229; l&#248;se en del problemer knyttet til redux (som ogs&#229; ble utviklet av Facebook). Dette er problemer knyttet til at Redux krever en del &#229; sette seg inn i og sette opp. Recoil tar bort en del av disse problemene, og lar utvikleren hoppe inn i det mye fortere. Recoil lar data g&#229; fra atomer (shared state) gjennom selectorer (rene funksjoner) og ned til React komponentene, uten &#229; m&#229;tte lage store og re-rendre hele App komponent treet mens state oppdateres.&#160;<\/p><p>&#160;<\/p><p>Slik jeg ser det ligner dette mer p&#229; MobX, hvor atoms og selectors blir actions og observables, som kun oppdateres der hvor observablene blir brukt. Begge disse l&#248;ser det samme problemet, med effektiv render og bredt delte states.&#160;<\/p><p>&#160;<\/p><p>Recoil virker som et lovende og spennende nytt verkt&#248;y, som l&#248;ser problemene Facebook har hatt med Redux. Det er likevel&#160;ikke et verkt&#248;y som l&#248;ser alle problemer. Context vil for eksempel&#160;fortsatt egne seg best for lav-frekvens oppdateringer. En annen ulempe kan v&#230;re at dette verkt&#248;yet vil gi mindre innsikt. Med Redux har man bedre oversikt over sitt eget state management system, siden man har brukt mer tid p&#229; &#229; sette det opp, og har definert egen store. Recoil virker dog lettere &#229; komme i gang med, og fjerner en del hassle i oppstartsfasen.<\/p><p>&#160;<\/p><p>Jeg f&#248;ler det er viktig &#229; p&#229;peke at Recoil er et veldig nytt verkt&#248;y, som betyr at det ikke har blitt testet skikkelig av utviklermilj&#248;et enda. Derfor er det nok flere svakheter ved det enn hva som kommer frem i dag. De som har omfavnet det s&#229;langt er &#34;early adopters&#34; som har en tendens til &#229; skape stor hype rundt alt som er nytt. Derfor kan det v&#230;re lurt &#229; ha en viss skepsis, og kanskje ikke implentere dette i et nytt stort, viktig prosjekt, f&#248;r man har blitt skikkelig kjent med det.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1323,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API benytter seg av HTTP protokollene slik de er tiltenkt &#229; brukes, ved at man bruker GET-kall for &#229; hente data, POST for &#229; laste opp data, PUT/POST for &#229; endre p&#229; data, og DELETE for &#229; slette data. REST foretar s&#229;kalt &#34;overfetching&#34;, som vil si at man alltid f&#229;r et komplett dataset for hvert kall. Hvis jeg vil ha info om et bestemt objekt i et dataset, men kun &#233;n attributt, vil jeg fortsatt f&#229; hele objektet med alle dets attributter.&#160;<\/p><p>&#160;<\/p><p>GraphQL bruker bare POST kall for &#229; gj&#248;re alle sine oppgaver, og fokuserer p&#229; &#229; optimalisere ytelse og fleksibilitet. Fordelen med GraphQL er at man kan spesifisere hvilken data man trenger n&#229;r man gj&#248;r kall. P&#229; denne m&#229;ten kan man gj&#248;re et kall, men spesifisere hvilke felt man trenger. Kanskje trenger man kun fornavn og etternavn, men ikke alder og bio. P&#229; denne m&#229;ten blir mindre data sendt, og man f&#229;r kun det man trenger. Objektene her er definert som noder, og forholdet mellom nodene er represented med kanter. Alle objekter er hentet av en resolver, som aksesserer serverens data.&#160;<\/p><p>&#160;<\/p><p>REST arkitekturen er p&#229; denne m&#229;ten nettverksbasert, ved at den benytter seg av protokollene. GraphQL er mer query basert, ved at den har et sett med verkt&#248;y som lar skaperen hente den dataen som trengs, over et&#160;enkelt HTTP endpoint. Dersom man vil ha data om to objekter fra vhja REST, m&#229; man foreta to kall.<\/p><p>&#160;<\/p><p>Fra et personlig perspektiv vil jeg si at REST var enkelt &#229; sette opp og komme i gang med, med intuitive kall som GET, POST og DELETE. Det var enkelt &#229; forholde seg til at et endpoint gjorde &#233;n oppgave. GraphQL krevde mer jobb &#229; sette seg inn i og sette opp, men n&#229;r det f&#248;rst var oppe var det veldig enkelt og behagelig &#229; jobbe med.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537953,"ext_inspera_userAssessmentSetupId":7140054,"ext_inspera_userAssessmentId":4841322,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nyvoll Kristoffer (10062)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331160,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1844,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er mange uliker m&#229;ter &#229; h&#229;ndtere tilstand og dataflyt i react-applikasjoner. For mindre applikasjoner kan det v&#230;re tilstrekkelig &#229; bruke react&#39;s innebygde funksjoner, men for st&#248;rre og mer komplekse applikasjoner vil det v&#230;re fordelsaktig &#229; bruke et eksternt bibliotek.<\/p><p>&#160;<\/p><p><strong>Lokal tilstandsh&#229;ndtering<\/strong> er vedlig rett frem: verdiene og tilstanden til variabler opprettes og sendes gjennom komponenttreet til react-applikasjonen vha state og props (properties). Props er det som man passer inn som parameter (input), mens state er det som h&#229;ndteres i selve komponenten.&#160;I ren react g&#229;r dataflyten utelukkende nedover - alts&#229; kan man bare passe tilstanden nedover i komponenttreet.<\/p><p>&#160;<\/p><p>Det sier seg selv at denne sendingen av tilstand gjennom hvert lag av komponenttreet blir s&#229;rbart for feil og ekstremt tungvint dersom applikasjonen blir kompleks nok. Dette er der <strong>Context API<\/strong>-et som er innebygd i react, eller eksterne bibliotek som <strong>Redux og MobX<\/strong> kommer inn. De introduserer en form for &#34;<strong>global tilstand<\/strong>&#34; som komponenter kan importere og aksessere (samt endre), med fastsatte rammer for hvordan dette skal skje p&#229; en best mulig m&#229;te. Dette har som m&#229;l &#229; gj&#248;re tilstanden tilgjengelig der man har spesifisert (gjerne overalt), slik at <strong>dataflyten<\/strong> kan effektivt g&#229; b&#229;de oppver og nedover i komponenttreet. Med andre ord s&#229; lagres tilstand utenfor komponentene.<\/p><p>&#160;<\/p><p>Ulike l&#248;sninger som er mye brukt for tilstandsh&#229;ndtering<\/p><p><strong>Redux<\/strong>: Den mest kompliserte l&#248;sningen av de tre, men ogs&#229; mest funksjonsrik<\/p><ul>\t<li>Lagrer global state i store. Denne er tilgjengelig, men immutable, for komponenter. Kan dermed ikke endres direkte.<\/li>\t<li>Endring av state m&#229; gj&#248;res ved at et event trigger en action, som forteller reduceren hva som skal endres i tilstanden.<\/li>\t<li>Actions sender men en action-type, og oppdateringen (i reduceren) avhenger av denne.<\/li>\t<li>Er ganske h&#248;y kompleksistet med redux, men du har igjen vedlig god kontroll over hva som skjer.<\/li><\/ul><p><strong>MobX<\/strong>: En litt vennligere l&#248;sning enn redux<\/p><ul>\t<li>Har i likhet med redux en (eller flere) store(s) med global state - som &#229;penbart er tilgjengelig for komponentene i applikasjonen.<\/li>\t<li>Tilstanden er b&#229;de lesbar og muterbar, som betyr at komponenter kan b&#229;de bruke og endre p&#229; verdien til en gitt variable i global state.<\/li>\t<li>Dette trigger da en re-rending av de komponentene som inneholder den endrede variablen.<\/li>\t<li>Dataflyten er litt &#34;abstrahert&#34; i forhold til redux, men dette er en del lettere &#229; sette opp som konsekvens.<\/li><\/ul><p><strong>Context<\/strong>-API: react sin innebygde l&#248;sning - utmerket for mindre applikasjoner<\/p><ul>\t<li>Context wrapper i likehet selve appen (eller de komponentene som trenger tilgang til tilstanden) i en provider, men til forskjell fra de to andre s&#229; lagres tilstanden i en context-provider som en egen fil i prosjektmappen.<\/li>\t<li>Tilstanden er da utenfor selve komponentene, og contexten kan importeres og endres i komponentene.<\/li>\t<li>Er en l&#248;sning som er mye lettere enn de andre to, men vil bli lite egnet ved st&#248;rre applikasjoner. Da er det behov for en mer fastsatt og sterkt definert l&#248;sning.<\/li><\/ul><p>&#160;<\/p><p>Alle l&#248;sningene har hver sine styrker og svakheter, og alle passer godt til hvert sitt bruksomr&#229;de.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2803,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil<\/strong> er et bibliotek for tilstandsh&#229;ndtering i react. Det er et veldig ferskt opensource-prosjekt utviklet av Facebook som er ment &#229; forenkle tilstandsh&#229;ndtering.<\/p><p>&#160;<\/p><p>Til forskjell fra de andre l&#248;sningene for tilstand som vi har v&#230;rt innom i emnet til n&#229; (Context, Redux og MobX), s&#229; er recoil enn&#229; i den eksperimentelle fasen (de er per n&#229; p&#229; versjon 0.1.2 - https://github.com/facebookexperimental/Recoil), og har enn&#229; ganske f&#229; brukere (2 800 p&#229; github-siden)<\/p><p>&#160;<\/p><p>Slik fungerer det: Recoil lar deg lage en dataflyt som g&#229;r fra atoms (shared state), gjennom selectors (pure components) og ned i react-komponenttreet til dine komponenter - uten at du m&#229; styre med store eller re-rendre applikasjonen ved endring av tilstand.<\/p><p>&#160;<\/p><p>En &#229;penbar ulempe er jo at det er eksperimentelt og tilsynelatende lite testet i produksjon. I den tidlige fasen av alle l&#248;sninger pleier det &#229; fremkomme bugs/feil eller v&#230;re noe mangel p&#229; implementasjon, som en burde ha i bakhodet f&#248;r man bestemmer seg for &#229; bruke det.<\/p><p>Det er ogs&#229; avdart om f&#248;lgende i dokumentasjonen deres: &#34;<span><span>Note: Recoil is based on react hooks and will only work for functional components<\/span><\/span>&#34;, s&#229; dette m&#229; ogs&#229; tas i betraktning ved et eventuelt valg av denne l&#248;sningen.<\/p><p>&#160;<\/p><p>Basert p&#229; dokumentasjonen virker recoil mye lettere &#229; sette opp og konfigurere enn redux, samt at det tilbyr mer funksjonalitet enn man f&#229;r ved bruk av Context-API&#39;et. Det st&#229;r at man unng&#229;r boilerplate, som er mitt st&#248;rste irritasjonsmoment ved Redux.<\/p><p>&#160;<\/p><p>Recoil vs Redux<\/p><ul>\t<li>Redux trenger store, og bruker reducers for &#229; endre tilstand, recoil trenger ingen av disse. I stedet s&#229; deles tilstand vha atoms - som kan ansees som en del av &#34;shared state&#34;<\/li>\t<li>Recoil kan modifsere og bruke den delte tilstanden til atoms med useRecoilValue/useRecoilState direkte, i stedet for &#229; bruke useDispatch og useSelector med actions som props sammen med den tilstanden man vil sende.<\/li>\t<li>Begge wrapper appen i en provider, men redux passer komponentene som children.<\/li>\t<li>Siden dataen er immutable og man har full kontroll (og synlighet) til tilstand og data i redux, s&#229; kan det gi deg som utvikler st&#248;rre kontroll over hva som skjer i applikasjonen.<\/li><\/ul><p>Recoil vs Context<\/p><ul>\t<li>For mindre applikasjoner er context APi en helt kurant l&#248;sning. Med 16.3 releasen av react ble Context veldig popul&#230;rt, men det har et par feil som gj&#248;r det lite egnet til st&#248;rre applikasjoner. Lite egnet for mange updates (h&#248;y frekvens), men bedre for ting som theme, brukerautentisering, osv.&#160;<\/li>\t<li>Recoil tilbyr en l&#248;sning p&#229; problemene som Context har, men samtidig med en tilsynelatende lettere l&#248;sning enn redux.<\/li>\t<li>Hovedforskjellen mellom context og recoil er kanskje at man har en shared state i atoms i recoil, der man har ulike contexts for hver variabel man trenger tilstandsh&#229;ndtering til ved bruk av context.<\/li><\/ul><p>Recoil vs MobX<\/p><ul>\t<li>Disse fremst&#229;r som ganske like i st&#248;rrelsesorden og virkem&#229;te<\/li>\t<li>State er muterbar og observerbar<\/li>\t<li>Bruk av selctors gir utvikleren bedre kontroll over endringer ved recoil enn i MobX<\/li><\/ul><p>Fordeler ved recoil:<\/p><ul>\t<li>Lett &#229; sette opp<\/li>\t<li>Re-rendrer ikke hele komponenttreet n&#229;r state oppdateres<\/li>\t<li>Ingen boilerplate<\/li>\t<li>Fortsatt veldig rikt p&#229; funksjonalitet<\/li>\t<li>H&#248;y troverdighet (Samme skaper som er bak react)<\/li>\t<li>Fremst&#229;r som mer brukervennlig enn redux<\/li><\/ul><p>Ulemper ved recoil:<\/p><ul>\t<li>Ganske nytt og tilsynelatende upr&#248;vd<\/li>\t<li>F&#229; brukere (enn&#229;)<\/li>\t<li>Bare st&#248;tte for funksjonalle komponenter<\/li>\t<li>Andre l&#248;sninger, som redux, mobX og context, fremst&#229;r som tryggere alternativer enn s&#229; lenge. Der ogs&#229; mer dokumentasjon og informasjon (Stack overflow-tr&#229;der) p&#229; dem enn recoil.<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2516,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er to ulike l&#248;sninger p&#229; det samme problemet - nemlig klient-server kommunikasjon (Backend API)<\/p><p>Her er kjennetegnene ved hver av dem:<\/p><p>&#160;<\/p><p>REST<\/p><ul>\t<li>Ett eller flere endepunkter som defineres for &#229; lese/skrive eller endre enheter vha HTTP requests<\/li>\t<li>Du definerer hvilken data du skal returnere<\/li>\t<li>Kan utnytte caching-mekanismen som st&#248;ttes av de fleste nettlesere<\/li>\t<li>Bruker URI-lenker til &#229; hente ut data, som f.eks /users/profiles/id<\/li>\t<li>M&#229; gj&#248;re mange kall til disse endepunktene, slik at en mulig ulempe med REST er <strong>overfetching<\/strong> dersom kompleksiteten er h&#248;y nok (Alts&#229; at det hentes mer data enn n&#248;dvendig)<\/li><\/ul><p>GraphQL<\/p><ul>\t<li>Sp&#248;rrespr&#229;k for en mer effektiv og fleksibel uthenting av data<\/li>\t<li>Sp&#248;rringen inneholder b&#229;de s&#248;ket og dataen (eller mutasjonen) du &#248;nsker &#229; returnere<\/li>\t<li>Har et typesystem - som kan luke bort un&#248;dvendige feil<\/li>\t<li>Kan hente ut all dataen du trenger med &#232;n sp&#248;rring - overfetching er ikke et problem<\/li>\t<li>Mangler implisitt caching i HTTP-laget<\/li>\t<li>Opererer bare med JSON-data (REST kan f.eks bruke XML)<\/li><\/ul><p>&#160;<\/p><p>Det som fremkommer av punktene over er noen umiddelbare forskjeller. Det som fremst&#229;r som ett av de st&#248;rste problemene med REST, er at man ikke kan spesifisere n&#248;yaktig hvilke datafelter man &#248;nsker &#229; returnere. Et resultat av dette er, som nevnt, overfetching. Dette i seg selv kan insinuere oss til &#229; foretrekke GraphQL til applikasjoner der b&#229;ndbredde er kritisk - f.eks mobilapplikasjoner, smartklokker eller andre IoT-enheter.<\/p><p>&#160;<\/p><p>For en som er ny til webutvikling kan nok REST fremst&#229; som lettere &#229; sette seg inn i. Man gj&#248;r et kall til en URI og f&#229;r gj&#248;r operasjoner p&#229; dataen avhengig av hvilken request det er - GET, POST, DELETE, PUT, PATCH gj&#248;r hver sin unike operasjon (GraphQL bruker utelukkende POST). Mulig det er en litt brattere l&#230;ringskurve p&#229; GraphQL. Noen oppgaver blir ogs&#229; un&#248;dvendig komplekse &#229; l&#248;se med GraphQL, mye p&#229; grunn av at man m&#229; definere typer, sp&#248;rringer, mutasjoner og resolvers - som kan v&#230;re overkill for enkle applikasjoner. &#160;<\/p><p>&#160;<\/p><p>En annen faktor som ogs&#229; spiller inn her, er at man kan definere ulike skjemaer med GraphQL. Disse fastsetter hvilke typer objekter vi f&#229;r returnert, hvilke felter som er tilgjengelige p&#229; de objektene, osv. (Kilde: https://graphql.org/learn/schema/). Denne valideringen kan v&#230;re grei for &#229; luke bort enkle feil. Overordnet sett er GraphQL litt st&#248;rre og mer komplekst, med st&#248;rre muligheter for effektivisering av sp&#248;rringer for &#229; unng&#229; overfetching/underfetching.&#160;<\/p>"}]}],"ext_inspera_totalScore":14,"score":14}},{"result":{"sourcedId":11539875,"ext_inspera_userAssessmentSetupId":7140120,"ext_inspera_userAssessmentId":4841254,"dateLastModified":"2020-12-01T10:01:30Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:01:30Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Johannessen Jonathan Sileshe (10009)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34554517,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2414,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Dataflyt i React<\/strong><br />React&#160;er unidirectional som inneb&#230;rer at dataflyten g&#229;r i et hierarki fra forelderkomponent til barnekomponent. Tilstandsh&#229;ndtering gjennomf&#248;res da gjennom &#229; sende data nedover hierarki-treet ved bruk av properties. I klassekomponenter henter du ut props fra forelderkomponenten ved &#229; kalle p&#229; super-metoden i constructoren og i funksjonelle komponenter vil props g&#229; med som et parameter til funksjonen. Ved &#229; bruke callbacks i barne-komponenter kan man endre tilstanden i foreldrekomponenter. Callbacksene kan v&#230;re funksjoner som forelderen sender ned til barna sine som direkte endrer forelderen sin tilstand. Mer om useState hooks i nedre avsnitt.&#160;<br /><br /><strong>Tilstandsh&#229;ndtering<\/strong><br />Ut av boksen s&#229; har React tilstandsh&#229;ndtering for klasse- og funksjonelle komponenter. Ved &#229; bruke constructoren i klassekomponenter med et state attribute til klassen, s&#229; sikrer man at komponenten rendres p&#229; nytt hver gang den interne staten oppdaterer seg. Ved &#229; bruke useState hooken -&#160;som returnerer et array med to elementer; staten og en callback for &#229; endre den - kan man implementere tilstandsh&#229;ndtering i funksjonelle komponenter ogs&#229;. Her b&#248;r ogs&#229; useEffect hooken nevnes, da denne kan trigges p&#229; endringer i tilstanden og h&#229;ndtere mekanismer som er utenfor rendringen av web-applikasjonen.<br /><br /><strong>Context<\/strong><br />En barnekomponent kan arve foreldres props&#160;ved &#229; kalle p&#229; super() metoden i constructoren til et klassekomponent-barn eller ved at en foreldre-komponent sender sine props med {...props} til sitt funksjonelle barn. Om du har et node-tre med komponenter som spenner langt ut og g&#229;r dypt ned, vil det v&#230;re &#248;nskelig &#229; slippe &#229; m&#229;tte sende nedover props for en mellom-forelder hvis den ikke selv er eksplisitt interessert i propen.&#160;<br />Her kan man bruke Context API-et rett ut av boksen for &#229; drive med enkel tilstandsh&#229;ndtering. Ved &#229; gj&#248;re en komponent til barn av en &#60;Context.Provider/&#62; s&#229; vil alle barne-barne-....-barna kunne hente ut dataen uten at de m&#229; sendes nedover hele treet. Teknikker som brukes her kan v&#230;re useContext hooken for &#229; hente ut contexten i de relevantene komponentene, samt en egen context-modul som lages med React.CreateContext.&#160;&#160;Context APIet gj&#248;r koden enda tryggere da du enklere vet hvilke komponenter som har tilgang til tilstanden, spesielt n&#229;r web-applikasjonen f&#229;r veldig mange komponenter.&#160;<br /><br /><strong>Redux og MobX<\/strong><br />Det stemte ikke helt at det er s&#229; lett &#229; vite hvilke komponenter som har tilgang til tilstanden med Context-API-et. Et komponent-tre med mange l&#248;v-noder eller mellom-noder som har tilgang til Contexten gj&#248;r det fort uoversiktlig &#229; vite hvor tilstanden endrer seg, og da kan det v&#230;re en ide &#229; trekke hele tilstanden ut av komponenttreet. For &#229; l&#248;se dette har vi Redux og MobX. Dette er to biblioteker for tilstandsh&#229;ndtering.<\/p><p>&#160;<\/p><p>Redux er inspirert av funksjonell programmering og tilstreber at utvikleren m&#229; skrive kode som ikke direkte endrer tilstanden, men kun oppdaterer den ved &#229; lage en ny tilstand med samme data. Her bruker vi en ekstern &#34;store&#34; der tilstanden v&#229;r er lagret. Vi har ogs&#229; reducers, som forteller Redux hvordan den skal endre tilstanden avhengig av hvilke actions som ble dispatchet. Actions er rene javascript objekter som m&#229; ha en type og en &#34;payload&#34;. For &#229; forklare med andre ord: La oss si du har en state best&#229;ende av navnet til den innloggede brukeren samt antall ganger vedkommende har klikket p&#229; en knapp. Hver gang knappen klikkes p&#229; kan en action dispatches med en type &#34;knapp/klikket&#34;. Da vil dette sendes til reducerne, som har oversikt over alle actionene og den vil finne ut at state-en skal oppdatere antall knappeklikk med en. Om brukeren endrer innloggingsnavnet sitt vil en annen action dispatches med en payload som er navnet til brukeren og reduceren vil endre staten der. N&#229;r jeg sier &#34;endre&#34; mener jeg egentlig at den lager en ny state med den oppdaterte dataen basert p&#229; forrige state. Man kan abonnere p&#229; tilstandsendringer ved at komponentene bruker selectors.&#160;<br />For &#229; forenkle reducers og actions kan vi enkelt lagre tilstanden v&#229;r i &#34;slices&#34;. Her setter vi opp en initiell tilstand og definerer reducere som oppdaterer tilstanden alt ettersom. S&#229; eksporterer vi &#34;actions&#34; som er direkte hentet ut av reducerne. Alt dette&#160;ved hjelp av biblioteket reduxjs/toolkit.&#160;<br /><br />MobX har mindre boilerplate-kode enn Redux. Denne tilstandsh&#229;ndteringsl&#248;sningen utnytter &#34;observers&#34; som observerer de relevante komponentenes tilstandsendringer og oppdaterer den/de lokale store-ene deretter. Dette skiller seg fra Redux som kun har en store. MobX f&#248;lger ikke tankegangen fra funksjonell programmering og har ikke store kvaler med &#229; la deg direkte endre staten. Samtidig er MobX mye lettere &#229; sette opp og skaper mye mindre kode.&#160;<br /><br />Redux kommer ogs&#229; med et nettleser-tillegg som heter Redux Dev Tools. Dette verkt&#248;yet lar deg g&#229; gjennom state-endringene som en historielogg og se hvilke action-dispatches som trigget visse state-endringer. S&#229;dan blir debugging mye lettere.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2443,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil bruker Atoms og Selectors for tilstandsh&#229;ndtering. Atoms er simpelthen en tilstand som flere komponenter kan abonnere p&#229;. Ved &#229; bruke syntax tilsvarende useState hooken kan komponentene hente ut tilstanden samt en funksjon for &#229; endre tilstanden. Selectors er en ren funksjon som &#34;observerer&#34; atoms og gj&#248;r tilsvarende endringer i tilstand. Eksempel p&#229; dette er et atom som best&#229;r av default-verdien &#34;John&#34; og som beskriver navnet p&#229; en doktor. En selector observerer dette navnet og legger til ordet &#34;Dr. &#34; foran strengen. En komponent for &#229; vise frem navnet f&#248;lger med p&#229; verdien gitt av selectoren og en knapp for &#229; endre navnet bruker const [doctor, setDoctor] = useRecoilState(nameState) som vanlig useState hooks for &#229; endre navnet. Atoms kan alts&#229; oppdateres og abonneres p&#229;, mens selectors kan bli abonnert p&#229; og selv abonnere p&#229; andre selectorer og atoms. Gode utvikler-verkt&#248;y som TotailRecoilJS har ogs&#229; dukket opp for &#229; gj&#248;re tilsvarende arbeid som Redux Dev tools.&#160;<\/p><p>&#160;<\/p><p><strong>Recoil vs Context/Redux/MobX<\/strong><br />Sammenlignet med Redux er atoms &#34;state-store&#34; delt opp i sm&#229; biter, selectors er som reducers; rene funksjoner og du m&#229; wrappe hele komponent-treet i en RecoilRoot ala det samme du gj&#248;r i Redux hvor du bruker Provider. Istedenfor &#229; &#34;dispatche&#34; &#34;actions&#34; bruker du recoilState hooks for &#229; endre tilstanden.&#160;Sammenlignet med MobX kan vi se at komponentene &#34;abonnerer&#34; p&#229; tilstandsendringer.&#160;<br />Recoil virker ganske likt som context i den grad at det f&#248;les som en &#34;react&#34; m&#229;te &#229; gj&#248;re ting p&#229;, men at du s&#229; klart trekker tilstanden ut av komponent-treet p&#229; lik linje som MobX og Redux.&#160;<br />&#160;<\/p><p><strong>Fordeler og ulemper<\/strong><\/p><p>F&#248;lgende avsnitt lister opp fordeler. Recoil har mye mindre boilerplate enn Redux og litt mindre&#160;enn MobX. Recoil er skrevet av de samme som lagde react og tilstreber &#229; l&#248;se tilstandsh&#229;ndtering p&#229; en &#34;react&#34; m&#229;te ved bruk av kode som minner om useState hooken. Recoil er mye raskere enn Redux med re-rendering av siden. Recoil har en mye mindre l&#230;ringskurve enn Redux, spesielt for utviklere godt kjent med React.&#160;Recoil har ikke all tilstand lagret i en og samme store, noe som kan v&#230;re b&#229;de en fordel og en ulempe. En &#34;source of truth&#34; kan gj&#248;re koden mye ryddigere, men samtidig m&#229; hele store-funksjonen kj&#248;res ved oppdatering.&#160;<br /><br />F&#248;lgende avsnitt lister ulemper. Recoil er et ungt bibliotek og har derfor f&#230;rre&#160;utviklere enn Redux/MobX. Dette medf&#248;rer f&#230;rre ressurser for &#229; l&#248;se problemer samt en mer usikker kodebase. Recoil har ikke en &#34;source of truth&#34;,&#160;som nevnt i forrige avsnitt, kan risikere at koden blir uoversiktlig, spesielt siden du kan spre atoms rundt i hvilke filer du vil. Recoil utnytter funksjonelle komponenters &#34;hooks&#34;, og kan derfor ikke brukes med klassekomponenter. Dette regner jeg som en stor drawback for utviklere med prosjekter der en refactoring av komponentene fra klasse- til funksjonelle komponenter er for mye jobb.&#160;<br /><br />Alt i alt virker Recoil lovende, med mye mindre boilerplate og med verkt&#248;y som &#34;TotalRecoilJS&#34; er det ikke mye man kommer til &#229; savne fra Redux, om man endrer web-applikasjonen sin til &#229; bruke Recoil.<br /><br /><strong>Kilder:&#160;<\/strong><\/p><p>https://recoiljs.org<\/p><p>https://medium.com/@silvia.kemp/introducing-totalrecoiljs-a-new-developer-tool-for-visualizing-your-recoil-state-cafc58e792d4&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2161,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Hva er Rest og GraphQL?<\/strong><\/p><p>REST API er en web arkiktektur som bruker et ressurs paradigme. Utviklerne m&#229; se p&#229; dataen som sendes frem og tilbake som predefinerte ressurser. I GraphQL derimot er all dataen tenkt p&#229; som sammensatte noder, der du bruker Schema&#39;s for &#229; definere et sett med mulige queries og mutations, alts&#229; sp&#248;rringer og oppdateringer/endringer og der klienten selv kan kombinere disse for &#229; hente ut/endre akkurat den dataen klienten trenger.&#160;<\/p><p>&#160;<\/p><p><strong>Frontend-utviklers perspektiv<\/strong><br />REST API utnytter endepunkter for &#229; gj&#248;re requestene sine, mens GraphQL bruker bodyen i requesten for &#229; tilpasse hvilke ressurser den &#248;nsker &#229; hente eller data den &#248;nsker &#229; oppdatere/sette inn.&#160;<br />Dette inneb&#230;rer at hvis du vil hente ut en liste over brukere m&#229; du gj&#248;re dette p&#229; nettside.no/bruker og for &#229; f&#229; en enkelt bruker m&#229; du bruke nettside.no/bruker/&#60;id&#62;, mens i graphQL sender du en query i bodyen som samsvarer med det forh&#229;ndsdefinerte Schemaet for &#229; query etter enten listen over alle brukere, eller ved &#229; querye etter en bruker.&#160;<br /><br />Dette medf&#248;rer at REST API kan enten sende oss un&#248;dvendig mye data, eller for lite data, alt ettersom hvilket endepunkt vi er i. Vi er mye mer avhengig av at backenden har implementert akkurat de endepunktene vi trenger, og hvis vi m&#229; gj&#248;re noe som bruker mer data enn vi f&#229;r fra et gitt endepunkt&#160;m&#229; vi enten endre backenden, eller lagre data fra et endepunkt, g&#229; over til et annet endepunkt ogs&#229; gj&#248;re logikken p&#229; klientsiden for &#229; lage den n&#248;dvendige kombinasjonen. Dette gj&#248;r at frontend utviklerne er mye mer l&#229;st enn de ville v&#230;rt med graphQL.<\/p><p>&#160;<\/p><p><strong>Backend-utviklers perspektiv<\/strong><\/p><p>Som Backend utvikler er GraphQL ogs&#229; lettere &#229; sammensmelte med databaser som neo4j og mongodb, da node-strukturen til neo4j og objekt-strukturen til mongodb har mye til felles med schema-definisjonen. Med REST&#160;har du dog mye mer kontroll over hvordan klienten har tilgang til backenden, da du selv implementerer akkurat hvordan data hentes ut av databasen i hvert av dine predefinerte endepunkter. Det kan&#160;ogs&#229; v&#230;re&#160;mindre boilerplate med REST/Express kombinasjonen enn det er med GraphQL/Express eller GraphQL/Apollo kombinasjonen. Men hvis endepunktene blir mange vil det v&#230;re mer kode med Rest/Express kombinasjonen.&#160;<\/p><p>&#160;<\/p><p><strong>Sikkerhet<\/strong><br />GraphQL et rammeverk som er noe mer usikkert enn REST. Ettersom klienten kan sende akkurat en hvilken som helst kombinasjon av queries er backenden mer utsatt for &#229; bli overarbeidet om noen ondsinnede skulle finne p&#229; &#229; sende queries til backenden v&#229;r.&#160;<\/p><p>&#160;<\/p><p><strong>Samarbeid mellom frontend og backend utviklere<\/strong><br />P&#229; forh&#229;nd m&#229; frontend og backend v&#230;re enig om utformingen av Schemaet og&#160;typeDefs. Dette gj&#248;r at front-end utviklerne og back-end utviklerne blir tvunget til &#229; samarbeide mer, noe som b&#229;de kan v&#230;re positivt og negativt. I v&#229;re prosjekt var dette veldig greit, da vi kun var 3 stykker og allerede hadde tett samarbeid.&#160;I st&#248;rre prosjekter er det naturlig &#229; &#248;nske &#229; separere disse to bolkene med mennesker, og da er det viktig at ikke front-end eller backend teamet gj&#248;r en endring i schemaet eller typedefsen uten at den andre parten er med p&#229; endringen.<br /><br />Det samme gjelder ogs&#229; om flere klienter utnytter samme backend. I et REST API tilfelle vil klientene ikke bry seg s&#229; mye om hvordan requestene h&#229;ndteres, s&#229; lenge et gitt endepunkt gir akkurat den dataen man vil ha. Om backend-utviklerne&#160;har endret navnet p&#229; et query parameter fra &#34;Adresse&#34; til &#34;Bosted&#34; samt i databasen&#160;vil dette skape forvirring om ikke dette kommuniseres for front-enden.&#160;<\/p><p>Jeg vil ogs&#229; legge til at integrasjonstesting med GraphQL er out-of-the box.<br /><br /><strong>Kilder:&#160;<\/strong><\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p>"}]}],"ext_inspera_totalScore":14,"score":14}},{"result":{"sourcedId":11540121,"ext_inspera_userAssessmentSetupId":7139975,"ext_inspera_userAssessmentId":4842167,"dateLastModified":"2020-12-01T10:31:22Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:31:22Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Onsøyen Emil (10035)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":26238364,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3065,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har vi muligheten til &#229; h&#229;ndtere state av komponenter p&#229; ulike m&#229;ter og med ulike verkt&#248;y.<\/p><p>&#160;<\/p><p>React har selv en overordnet komponent-state som kan deffineres for enhver komponent, enten den er funksjonell eller en klasse. Denne staten defineres med setState()-metoden, og n&#229;r tilstanden endres s&#229; vil komponenten svare med &#229; rendere p&#229; nytt. State kan enten deklareres inne i en komponent eller s&#229; kan komponenten &#34;arve&#34;&#160;en tilstand fra foreldre-komponenten gjennom props(properties).&#160;<\/p><p>&#160;<\/p><p>React Context APIet gj&#248;r det mulig &#229; sende state nedover i komponent-treet uten &#229; m&#229;tte manuelt sende props nedover p&#229; alle niv&#229;er i treet. Dette er nyttig for eksempel ved tilstander som benyttes av veldig mange komponenter, ofte langt ned i komponenttreet, som for eksempel UI-ets fargetema.&#160;Context er derfor nyttig for &#229; h&#229;ndtere det man &#248;nsker &#229; behandle som &#34;globale&#34; verdier for applikasjonen. Et eksempel er n&#229;r en bruker &#248;nsker darkmode p&#229; en nettside. Dette er en &#34;global&#34; UI-endring som m&#229; endre fargen p&#229; s&#229; og si alle synlige elementer p&#229; nettsiden. Context gj&#248;r det mulig &#229; dele tilstanden p&#229; tvers av niv&#229;er uten &#229; eksplisitt sende denne tilstanden nedover til hver komponent som trenger den.<\/p><p>&#160;<\/p><p>Redux er et tredjepartsbibliotek som benytter en Redux store for &#229; holde kontroll over React applikasjonen sin state. Med Redux defineres de endringer man &#248;nsker at skal&#160;skje som actions, for s&#229; &#229; definere funksjoner som tar inn state og actions som bestemmer hvordan enhver action skal forandre p&#229; hele applikasjonen sin state. Disse funksjonene kalles for reducers. Det er vanlig &#229; starte med en egen reducer p&#229; applikasjonens rotniv&#229;, som s&#229; gradvis splittes inn i individuelle reducers utover i state-treet etterhvert som applikasjonen vokser. Dette f&#248;lger logikken til hvordan React opererer med komponentene sine som ligger p&#229; ulike niv&#229;er.&#160;Dette er veldig nyttig for utvikling ettersom man enkelt kan spore alle endringer av states til de actions som utl&#248;ste endringen. I tillegg, n&#229;r man implementerer state management p&#229; denne m&#229;ten s&#229; skalerer det veldig bra uavhengig av applikasjonens st&#248;rrelse.<\/p><p>&#160;<\/p><p>MobX er enda et tredjepartsbiliotek for state management i React. MobX benytter observat&#248;r/observert-teknikken for &#229; h&#229;ndtere states. Med MobX s&#229; wrapper man&#160;React-komponentene i en observer som automatisk oppdager endring i states, gir beskjed til alle komponenter og beregninger som er avhengig av denne staten&#160;for s&#229; &#229; f. eks rendere disse komponentene p&#229; nytt med oppdatert state.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://redux.js.org/introduction/core-concepts<\/p><p>https://mobx.js.org/README.html<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2242,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt state-management bibliotek for React som pr&#248;ver &#229; l&#248;se problemer st&#248;rre aplikasjoner f&#229;r ved bruk av f.eks Context APIet. Dette gj&#248;r Recoil ved &#229; definere en rettet graf som er ortogonal med React-treet (Recoil-grafen). Denne fungerer uavhengig av React-treet, noe som betyr at &#34;globale&#34; state verdier kan aksesseres av komponenter langt ned i React-treet uten &#229; g&#229; via roten slik som i Context.<\/p><p>&#160;<\/p><p>Komponenter p&#229; hver sin gren som er avhengig av samme state kan enkelt&#160;kommunisere endringer som p&#229;virker dem begge ved &#229; g&#229; via Recoil-grafen istedenfor &#229; g&#229; oppover i React-treet. Dette gj&#248;res ved at komponentene &#34;abonnerer&#34; (subscriber) p&#229; &#34;atoms&#34; som er state enhetene i Recoil. Disse ligger p&#229; rotniv&#229;et i Recoil-grafen. State endringer g&#229;r fra r&#248;ttene p&#229; Recoil-grafen (atoms)&#160;via egne funksjoner som benytter atoms kalt&#160;&#34;selectors&#34; og deretter til komponentene.&#160;<\/p><p>&#160;<\/p><p>Fordeler med Recoil er at man slipper &#229; m&#229;tte re-rendere hele React-treet ved state endringer i komponenter ettersom de slipper &#229; sende state opp gjennom hele React-treet. Samtidig kan man&#160;lagre en mengde verdier i staten, der Context bare har mulighet til &#229; lagre en enkelt verdi. Recoil er designet for &#229; v&#230;re et enkelt &#229; bruke bibliotek som&#160;er enkelt &#229; l&#230;re seg (fordi det&#160;f&#248;lger og &#34;tenker&#34; som React)&#160;og har veldig lite &#34;boilerplate-kode&#34;, i motsetning til f. eks Redux som kan v&#230;re vanskeligere &#229; l&#230;re seg og har sv&#230;rt mye boilerplate.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/docs/introduction/getting-started<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er begge APIs som bruker HTTP til &#229; kommunisere og sende data.<\/p><p>Kjernen i REST er &#229; benytte et sett av definerte operasjoner som GET, PUT, DELETE osv. til &#229; aksessere resursser p&#229; bestemte URLer. GraphQL derimot er et query-basert API som ikke benytter seg av dedikerte resursser, men heller behandler hele systemet som en sammenkoblet graf. I GraphQL s&#229; behandles requests ved at man sp&#248;r om akkurat den informasjonen som trengs i en &#229; samme sp&#248;rring.<\/p><p>&#160;<\/p><p>Forskjeller mellom REST og GraphQL<\/p><p>- REST data fetching kan f&#248;re til over- og under-fetching: nemlig at klienten f&#229;r mer informasjon enn den egentlig trenger i en request, eller at endpointet i HTTP-requesten&#160;ikke kan gi all informasjonen som trengs slik at man m&#229; gjennomf&#248;re flere sp&#248;rringer. Dette er ikke et problem i&#160;GraphQL, ettersom systemet behandles som en sammenkoblet graf kan man i en og samme sp&#248;rring fint requeste ulike typer data som er lagret p&#229; forskjellige steder i systemet, og man f&#229;r akkurat det man har behov for og intet mer.<\/p><p>&#160;<\/p><p>- Ettersom REST er endpoint-basert, med en global og unik URL-identifikator, s&#229;&#160;implementeres det automatisk et caching-system for requests som sendes ofte. Dette gj&#248;res ikke automatisk p&#229; samme m&#229;ten i&#160; GraphQL. I GraphQL m&#229; man selv implementere caching gjennom f.eks egne globale id-felter for hver sp&#248;rring. Tilsvarende, med slike unike endpoints vil man da ved REST kunne definere objekter allerede i backend&#160;mens dette ikke er mulig for objekter man henter ved GraphQL.<\/p><p>&#160;<\/p><p>- Ved bruk av REST s&#229; er det serveren som bestemmer st&#248;rrelse og begrensning p&#229; dataresurssen, s&#229; dersom en klient sp&#248;r om en resurss som kun er lagret p&#229; en URL, s&#229; er klienten n&#248;dt til &#229; laste inn ogs&#229; all annen informasjon lagret p&#229; den URL-en.&#160;Med GraphQL s&#229; vil serveren heller presisere hvilke dataresursser som er tilgjengelig, ogs&#229; kan&#160;klienten sp&#248;rre&#160;om akkurat det den trenger.<\/p><p>&#160;<\/p><p>- REST har et mer utbredt system av ulike feilkoder for error handling, der GraphQL ofte benytter seg av en enkelt 200 OK error status. I GraphQL behandles alle feilmeldinger p&#229; samme m&#229;te, de havner i en error-array, uavhengig av hva slags feil som har oppst&#229;tt. Dette kan gj&#248;re det vanskelig &#229; h&#229;ndtere feilkoder da man ikke alltid vet hva som har g&#229;tt galt eller hva som var &#229;rsaken. Samtidig kan det gj&#248;re det vanskelig &#229; vite hvilke errors som er viktigst &#229; addressere.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://graphql.org/learn/<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p><p>https://sachee.medium.com/200-ok-error-handling-in-graphql-7ec869aec9bc<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11540147,"ext_inspera_userAssessmentSetupId":7140097,"ext_inspera_userAssessmentId":4841346,"dateLastModified":"2020-12-01T10:01:36Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:36Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Balasingham Anchana Visvalingam (10208)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34503448,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1963,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere ulike mekanismer og teknikker for &#229; h&#229;ndtere state og dataflyt i React-applikasjoner. Uten tilstandsh&#229;ndtering kunne man ha sjekke DOM elementene til applikasjonen, men ved &#229; h&#229;ndtere tilstandene manuelt kan vi sjekke dataen selv. Denne dataen kan vi lese, endre og slette slik det passer oss, og denne kontrollen er viktig for &#229; kunne lage et optimalt sluttprodukt. Fra prosjektene har vi f&#229;tt kjennskap til tre m&#229;ter fortilstandsh&#229;ndtering, nemlig MobX, Redux og Context API.<\/p><p>&#160;<\/p><p><strong>MobX<\/strong><\/p><p>MobX er et relativt nytt bibliotek og har flere stores for &#229; kunne lagre tilstander. Dette gj&#248;r det enklere p gjenbruke kode, da man i st&#248;rre grad kan f&#229; de fragmentene av koden man &#248;nsker. Denne oppdeling gj&#248;r det ogs&#229; mulig &#229; gjenbruke kode utenom prosjekter, noe som er sv&#230;rt fordelaktig n&#229;r man arbeider med webutvikling. MobX bruker actions til &#229; endre p&#229; state, og s&#248;rger for at alle derivations (alt man kan hente fra en state uten &#229; gj&#248;re endringer) oppdateres automatisk n&#229;r man gj&#248;r en endring p&#229; state.&#160;<\/p><p>&#160;<\/p><p><strong>Redux<\/strong><\/p><p>Redux er p&#229; mange m&#229;ter forgjengeren til MobX, og er et velutpr&#248;vd og mye brukt bibliotek for tilstandsh&#229;ndtering.&#160;Her har man en enkelt store, som alene brukes for &#229; holde kontroll p&#229; de ulike tilstandene til applikasjonen. For &#229; kunne bruke storen i st&#248;rre grad, kan den splittes opp til flere reducers. Disse reducerene brukes for &#229; oppdatere tilstandene (state). I tillegg brukes actions for &#229; oppdatere storen.<\/p><p>&#160;<\/p><p><strong>Context API<\/strong><\/p><p>Context API&#8217;et skiller seg p&#229; mange m&#229;ter fra de to foreg&#229;ende tilstandsbibliotekene ved at man ved denne tilstandsh&#229;ndteringen ikke trenger &#229; passe props manuelt gjennom hierarkiet, noe som sparer oss for mye innviklet tilstandsh&#229;ndtering. I Context brukes Contect Object, Provider og Consumer for &#229; h&#229;ndtere dataflyten. Denne tilstandsh&#229;ndteringen er i hovedsak tenkt for data som er ansees &#229; v&#230;re globalt. Dette fikk vi en praktisk tiln&#230;rming til gjennom prosjekt 2, da gruppene blant annet kunne bruke API&#8217;et for &#229; endre p&#229; teamene for hver side.<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper<\/strong><\/p><p>Det finnes flere ulike fordeler og ulemper ved de ulike tilstandsh&#229;ndteringsbibliotekene og som det er viktig &#229; ha fokus p&#229; f&#248;r man velger biblioteket til sitt neste prosjekt. Redux er det vanligste biblioteket &#229; velge, siden det er godt dokumentert og typisk &#229; bruke som utvikler. Likevel er det en ganske bratt l&#230;ringskurve for &#229; forst&#229; seg p&#229; Redux, og for mange kan det ta lang tid f&#248;r man forst&#229;r seg p&#229; hva som skal gj&#248;res n&#229;r. Et alternativ til Redux er MobX, som er et nyere bibliotek. Siden MobX er relativt oppdelt, brukes en objektorientert tiln&#230;rming som kan v&#230;re enklere &#229; l&#230;re seg enn Redux som bruker funksjonell programmering. Likevel er MobX mye mindre dokumentert enn det Redux er, noe som kan v&#230;re verdt &#229; tenke p&#229; dersom man skal sette seg inn i et nytt bibliotek.<\/p><p>&#160;<\/p><p>Context API bruker som nevnt tidligere en helt annen tiln&#230;rming til stateh&#229;ndtering. Siden fokuset ligger p&#229; at man skal kunne dele globale states mellom hverandre uten &#229; m&#229;tte h&#229;ndtere den innviklede dataflyten gjennom komponenttreet, l&#248;ser denne mange av utfordringene som MobX og Redux st&#229;r ovenfor. L&#230;ringskurven er ikke i n&#230;rheten av like komplisert for Context som for MobX og Redux, men denne h&#229;ndteringsmetoden har enkelte mangler. Den st&#248;rste utfordingen er at det ikke finnes en m&#229;te for reducer states til &#229; bli delt mellom st&#248;rre komponenter, noe som begrenser bruken av Context en del.<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><ul>\t<li>https://medium.com/@mwanahamuntu/redux-vs-mobx-vs-react-context-api-4febfe1bad0&#160;<\/li>\t<li>https://reactjs.org/docs/context.html<\/li><\/ul><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3182,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil<\/strong><\/p><p>Recoil er et Facebook open source bibliotek for React. I dokumentasjonen nevnes det at man trenger Recoil for &#229; h&#229;ndtere enkelte av utfordringene man st&#229;r ovenfor i dag n&#229;r det kommer til tilstandsh&#229;ndtering i React-applikasjoner. Med Recoil f&#229;r man en &#171;boilerplate-free&#187; kode, der delte tilstander bruker samme enkle get/set metoder som andre lokale React-tilstander. Tilstanden er inkrementell og distribuert, noe som gj&#248;r kode-splitting mulig. Tilstander kan erstattes av data man avleder fra andre tilstander, uten at det har en innvirkning p&#229; komponenten. I selve koden brukes &#60;RecoilRoot&#62; rundt komponentene som skal bruke dette biblioteket.<\/p><p>&#160;<\/p><p>Recoil best&#229;r i hovedsak av atoms og selectors. Atomer er tilstander, og disse kan oppdateres eller komponenter kan oppdateres som f&#248;lge av atomets oppdatering (subscribe). Det samme atomet kan brukes i flere komponenter, og da vil alle komponentene ha den samme staten. Alle atomer m&#229; ha en globalt unik key. For &#229; kunne lese fra eller skrive til et atom brukes hooken useRecoilstate. Selectors aksepterer kun andre selektorer eller atomer som input, og brueks for &#229; gj&#248;re endringer p&#229; atomene. P&#229; samme m&#229;te som med atomene, kan komponenter subscribe til selektorene. Selektorene har en oversikt over hvilke tilstander atomer krever, noe som gj&#248;r dem sv&#230;rt effektive. For &#229; bruke selektorene brukes en &#171;selector&#187; funkjson.<\/p><p>&#160;<\/p><p><strong>Fordeler og ulemper sammenlignet med andre tilstandsh&#229;ndteringer<\/strong><\/p><p>Recoil minner om videref&#248;ring og effektivisering av Context API&#8217;et. Context ble introdusert for &#229; gj&#248;re tilstandsh&#229;ndtering mellom komponentene mindre innviklet, ved at man n&#230;rmest kunne teleportere dataen mellom komponentene som beh&#248;vde den. Context brukes i hovedak for &#229; dele data som er globalt mellom komponenter, for eksempel temafarger, noe som gj&#248;r bruken noe begrenset. Recoil virker til &#229; pr&#248;ve &#229; pr&#248;ve &#229; l&#248;se de samme utfordringene som Context, men p&#229; et mer komplekst niv&#229;, slik som Redux og MobX, ved innf&#248;ringen av atomer og selektorer, samt &#60;RecoilRoot&#62; som minner om Redux sin &#60;Provider&#62;. Ved &#229; blande elementer fra Redux og Context, mestrer Recoil &#229; v&#230;re et bibliotek som bruker enkle l&#248;sninger p&#229; utfordrende problemer.<\/p><p>&#160;<\/p><p>En annen fordel ved bruken av Recoil er at den i stor grad &#248;nsker &#229; minne om syntaksen til React. Dette gj&#248;r terskelen for at nye brukere tar i bruk dette biblioteket mye mindre, som i lengden er sv&#230;rt nyttig med tanke p&#229; &#229; videreutvikle biblioteket og dokumentasjonen. I tillegg m&#229; man skrive mye mindre kode enn ved bruken av Redux og Context, noe som gj&#248;r det enklere &#229; l&#230;re seg og unng&#229; feil. &#160;<\/p><p>&#160;<\/p><p>Per n&#229; er dokumentasjonen noe kort og mangelfull, noe som kan gj&#248;re bruken av dette biblioteket hakket mer utfordrende for enkelte. I tillegg er st&#248;tten for bruken relativt liten. Det kan bli en ond sirkel ved at man trenger mer dokumentasjon for &#229; l&#230;re seg det nye biblioteket, samtidig som at man ikke kan skrive mer dokumentasjon uten &#229; kunne det nye biblioteket. Utfordringen l&#248;ses nok over tid, men er i stor grad tilstede ved bruken av biblioteket akkurat n&#229;.<\/p><p>&#160;<\/p><p>Recoil bruker unike n&#248;kler for hvert atom. Til sammenligning bruker MobX og Redux stores til &#229; holde en oversikt over de ulike tilstandene, mens det i Recoil er mye mer distribuert. For mindre applikasjoner kan dette fungere utmerket, mens for st&#248;rre applikasjoner kan det bli uoversiktlig og utfordrende &#229; holde oversikt over s&#229; mange atomer.<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><ul>\t<li>https://recoiljs.org/docs/introduction/core-concepts&#160;<\/li>\t<li>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee&#160;<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2037,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><em>Siden oppgaven sp&#248;r etter vesentlige forskjeller, vil jeg ikke g&#229; i dybden p&#229; hva REST API og GraphQL er.<\/em><\/p><p>&#160;<\/p><p>REST API er et arkitektonisk konsept for nettverksapplikasjoner, eller en standardisert m&#229;te &#229; strukturere data p&#229;. GraphQL bruker p&#229; sin side en graf til &#229; organisere dataen sin p&#229;, og objekter representeres gjennom noder. Relasjonen mellom nodene er representert gjennom kanter p&#229; grafen. B&#229;de REST og GraphQL bruker i hovedsak http-protokollen.<\/p><p>&#160;<\/p><p>En stor forskjell mellom REST og GraphQL er m&#229;ten de henter ut informasjon p&#229;. N&#229;r en bruker &#248;nsker &#229; f&#229; tak i informasjon, returneres fullstendige datasett n&#229;r man bruker REST. Ved bruken av GraphQL, brukes skjema til &#229; returnere kun den dataen som beh&#248;ves. Dette gj&#248;res ved at man bruker key-value par til &#229; lete seg frem til akkurat den informasjonen som brukeren ettersp&#248;r. Fenomenet med &#229; hente ut for mye data, slik det ofte gj&#248;res med REST, kalles over fetching. Utfordringen med over fetching f&#248;rer til un&#248;dvendig bruk av ressurser, samt en mindre optimal l&#248;sning p&#229; problemet man &#248;nsker &#229; l&#248;se. &#160;<\/p><p>&#160;<\/p><p>En annen forskjell mellom REST og GraphQL er mengden endepunkter. I GraphQL har man ett endepunkt, mens man ved bruken av REST har ett endepunkt til hver oppgave som m&#229; utf&#248;res. REST har dermed en enklere struktur, noe som gj&#248;r det lettere &#229; manipulere dataen, samt forst&#229; den. Likevel, om vi forteller GraphQL hvilken data vi trenger, slipper vi over fetching fra endepunktene til REST.<\/p><p>&#160;<\/p><p>GraphQL baserer seg p&#229; sp&#248;rringer til databasen, og kan derfor v&#230;re noe mer komplekt &#229; sette seg inn i enn REST. Dersom man har en bakgrun som tilsier at man kan en del om databaser, vil ike utfordringen v&#230;re den samme. Likevel &#248;ker dette terskelen for at flere velger &#229; bruke GraohQL, og REST vil derfor foretrekkes av mange.&#160;<\/p><p>&#160;<\/p><p>REST API har blitt standarden for mange i IT-bransjen, noe som gj&#248;r at den er mer kjent og velutpr&#248;vd. I tillegg er det mer dokumentasjon og analyser knyttet til REST, noe som gj&#248;r bruken av GraphQL noe mer utfordrende til sammenligning. I tillegg brukes REST for &#229; lage nye API&#8217;er, mens GraphQL arbeider med &#229; forbedre seg selv.<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><ul>\t<li>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&#160;<\/li><\/ul>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540338,"ext_inspera_userAssessmentSetupId":7139930,"ext_inspera_userAssessmentId":4841366,"dateLastModified":"2020-12-01T10:01:38Z","ext_inspera_startTime":"2020-12-01T08:00:14Z","ext_inspera_endTime":"2020-12-01T10:01:38Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Eggemoen Vemund (10047)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331194,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1769,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Med React kan kan man enten bruke deres egen funksjonalitet for state management eller man kan bruke tredjeparts-biblioteker.<\/p><p>&#160;<\/p><p>Deres egen funksjonalitet g&#229;r ut p&#229; props. Det er data som sendes inn til en kompoenent n&#229;r den oppretters. State er tilstanden til kompoentens data.&#160;Man kan ogs&#229; sende data oppover i app kompoenent treet, med funksjoner som call-back. De har i oppgave &#229; endre staten til&#160;foreldrene.&#160;N&#229;r man har komplekse applikasjoner hvor data brukes flere steder og ofte langt unna hverandre er det lurt &#229; ta i bruk &#34;global state&#34;. Da lagres all data p&#229; samme sted og kan oppdatere komponenter automatisk ettesom data endres. Redux, mobX er ofte brukt.<\/p><p>&#160;<\/p><p><strong>mobX.<\/strong><\/p><p>State data i mobX er observerbar, dette vil si at n&#229;r data endres&#160;vil en re-render view (compoenent) automatisk trigres. For &#229; f&#229; samme funksjonalitet som redux m&#229; vi da legge til lyttere. MobX deler lagringen i to, En for UI state og en for domain sate. Hensikten er da &#229; kunne teste domain state universalt som er gunsig for &#229; bruke data p&#229; nytt. mobX er read and write, dvs. at de er mutable. En annen fordel er at state kan bli oppdatert uten &#229; triggre en action. For &#229; oppsumere er mobX gunstig for sm&#229; applikasjoner.&#160;<\/p><p>&#160;<\/p><p><strong>Redux<\/strong><\/p><p>Redux er en m&#229;te for &#229; h&#229;ndetere application state. Hvis programmet blir fort komplekst og det er mange ulike state &#229; holde styr p&#229;, er redux genialt. Dette blir h&#229;ndtert ved &#229; lagre alle state i en global store. Disse statene er tilgjengelige for alle komponenter, men kan bare leses. redux er derfor immutable. For &#229; kunne oppdatere states tar redux i bruk reducers og action. Ulempe er at dette er en tungvidt m&#229;te &#229; sette opp et prosjekt, spesielt hvis du skal konvertere til redux etter &#229; ha begynt og det blir mye boiler-plate data. En fordel er at redux har en enkelt lagring og debugging blir mye enklere, spesielt n&#229;r kan har konsistent oppf&#248;rsel av dataen, med read only som nevnt tidligere. For &#229; oppsumere er redux bra for store programmer.<\/p><p>&#160;<\/p><p><strong>Context<\/strong><\/p><p>Context er en del av react sin l&#248;sning p&#229; global state. De lar oss unng&#229; &#229; sende props gjennom ulike komponenter som ikke tar dem i bruk, Videre kommer context med en provider som endringer i andre kompoenter lovlig.&#160; Context mangler derimot noen features som redux og mobX har, men er god l&#248;sning p&#229; sm&#229; applikasjoner.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2401,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et at de moderne sate management open source biblotek utviklet av Facebook. Recoil lar oss opprette en data-flow graf som str&#248;mmer gjennom &#34;atoms&#34;. Atoms beskrives som &#34;shared state&#34; der hver atom har en del av en state. Fra atoms g&#229;r de gjennom &#34;selectors&#34; og nedover i React komponenter. Selectors er &#34;pure functions&#34; som transformerer staten synkront eller asynkront. Atoms we updatable og subcribable, det er viktig &#229; f&#229; med seg at n&#229;r et atom oppdateres, s&#229; vil hvert subcribed komponent bli re-rendered med en ny verdi. Det vil si at recoil er mutable! Recoil bruker hooks som useRecoilState for &#229; lese og skrive atomer fra en komponent.<\/p><p>&#160;<\/p><p><strong>Redux vs. Recoil<\/strong><\/p><p>Der hvor redux trenger en &#34;store&#34; for global state, trenger ikke Recoil dette.<\/p><p>Redux lager reducers, Recoil opretter en shared state ved bruk at atoms hvor v&#230;rt atom beregnes som en del av staten.&#160;<\/p><p>For &#229; &#34;fire a state&#34; i redux brukes Actions. I Recoil gj&#248;r vi endring og modifiserer den allerede eksisterende atom staten med selectors.<\/p><p>For &#229; koble alle komponentene sammen bruker Redux hooks som useSelector og useDispatch, her er det ogs&#229; mulig &#229; lage class-components og wrappe komponentene &#229; sende state actions som props. Atoms kan derimot direkte bruke shared atom state value med useRecoilValue og oppdatere staten. Dette er som &#229; bruke setState. Derimot er Recoil basert p&#229; React hooks og kan derfor ikke bruke class-components.<\/p><p>B&#229;de redux og Recoil wrapper med en &#34;provider&#34; for &#229; sende komponentene ned som barn.&#160;<\/p><p>&#160;<\/p><p><strong>Fordeler:<\/strong><\/p><ul>\t<li>Boiler-free API<\/li>\t<li>Ser bort i bra store creations<\/li>\t<li>Lett &#229; sette opp.<\/li>\t<li>re-render ikke hele App komponent treet n&#229;r en state oppdateres.<\/li><\/ul><p><strong>Ulemper:<\/strong><\/p><ul>\t<li>Kun functional compoenents.<\/li>\t<li>eksperimentelt og lite testet.<\/li><\/ul><p>&#160;<\/p><p>For &#229; oppsumere gj&#248;r Recoil mye av det samme som redux, men trenger ikke bruke store creations og re-render hele App komponent trees n&#229;r en state oppdateres.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3009,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Rest&#160;<\/strong><\/p><p>I rest defineres det et eller flere endepunkter for &#229; kunne lese, skrive eller endre data. Dette gj&#248;res ved HTTP requests. Rest har en caching-feature som st&#248;ttes av alle nettlesere. En ulempe med Rest er at du ofte m&#229; m&#229; gj&#248;re flere kall for &#229; hente data og irrelevant data kan bli hentet ut (overfetching). En annen ulempe er at kan ikke dynamisk kan filterere i requesten, men at det m&#229; gj&#248;res i backend eller frontend. Man har flere ulike kall som: post, get og&#160;put for &#229; nevne noen.<\/p><p>&#160;<\/p><p><strong>GrapgQL<\/strong><\/p><p>GraphQL er basseres p&#229; &#229; sende sp&#248;rringer til en server. Disse sp&#248;rringene defineres det et s&#248;k og et resultat med data som skal returneres. Her er en fordel at man henter ut akuratt den dataen man trenger, fordi filtreringen skjer i requesten. Det er i tilegg mulighet for &#229; validere dataen pga. typesystemet. Dette er et system der man defierer en type objekt med parametere. GraphQL bruker bare post request som kan deles inn i query eller mutations avhengig av om man skal lese eller skrive / oppdatere. I tilegg brukes det schemes og sammen med type er dette kraftfullt og godtar kun komplette request. En ulempe er at graphQL kun oppererer med JSON-data og mangler implisitt caching i HTTP-laget. GraphQL har b&#229;de client og server som kj&#248;r koblingen mot databasen noe n&#230;rmere.&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11540344,"ext_inspera_userAssessmentSetupId":7139956,"ext_inspera_userAssessmentId":4841365,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:00:15Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Juskenas Sarunas (10170)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35198717,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1557,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Tilstandene (states) i react komponenter er lokale/innkapslet&#160;for bare det komponentet tilstanden befinner seg i. Ingen andre komponenter kan f&#229; tilgang til eller endre p&#229; tilstanden i et komponent.<\/p><p>&#160;<\/p><p>Et komponent kan velge &#229; sende ned tilstanden sin til child komponenter i form av props. Props et child komponent f&#229;r er read-only og komponentet kan ikke endre p&#229; dem direkte.&#160;<\/p><p>Slik oppsett av tilstander gj&#248;r at dataflyten i React applikasjoner g&#229;r bare en vei, fra parent til child komponenter, alts&#229; ned i komponenthierarkiet. Dataflyten kan sammenlignes med en foss der vannet (dataen) renner ned og hver ny state kan sees p&#229; som en ny vannkilde som ogs&#229; renner ned.&#160;<\/p><p>&#160;<\/p><p>Child komponenter kan barer endre p&#229; parent tilstanden hvis de f&#229;r en funksjon tilsendt i props. Denne funksjonen kan da kobles opp til noe i child komponentet og kan samarbeide med&#160;og oppdatere&#160;tilstanden av parent komponentet. Slike funksjoner er kalt for callback funksjoner.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1755,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek som benytter atoms og selectors. Atoms er deler av selve staten. React komponenter kan &#34;subscribe&#34; til atoms og vil da bli re-rendered n&#229;r atom oppdateres. Selectors er funksjoner som tar imot atoms eller andre selectors som input. Komponenter kan ogs&#229; subscribe til selectors, akkurat som med atoms.<\/p><p>&#160;<\/p><p>Recoil kan sammenlignes med f.eks. React Redux som er et annet state management bibliotek. St&#248;rste fordelen Recoil har over Redux er hvor lett det er &#229; implementere det i et eksisterende prosjekt. F&#248;rst og fremst kommer redux med mye av den s&#229;kalte &#34;boilerplate&#34; koden, koden som m&#229; inkluderes for at biblioteket skal kunne fungere. I tillegg krever redux ogs&#229;, i de fleste tilfeller, en re-strukturering av hele prosjektet. Dette, i tillegg til en lavere l&#230;ringskurve, gj&#248;r Recoil et mer attraktivt valg enn Redux n&#229;r det gjelder state management.&#160;<\/p><p>&#160;<\/p><p>Context APIet kan ogs&#229; nevnes her siden vi snakker om state management, men med tanke p&#229; hvor begrenset APIet er i forhold til Recoil/Redux vil det, mest sannsynligvis, ikke brukes&#160;for samme oppgaver/m&#229;l som de bibliotekene. Her er det da snakk om hvor begrenset selve staten i context APIet er, siden den kan bare lagre en verdi i tilstanden sin, i motsetning til de to andre biblioteker diskutert tidligere.&#160;&#160;<\/p><p>&#160;<\/p><p>En viktig grunn &#229; ikke bruke recoil i prosjektene forel&#248;pig er hvor eksperimentelt&#160;og nytt&#160;biblioteket framdeles er. Siden den er fortsatt i en tidlig fase er det &#229;pent for mange store endringer. &#197; bruke et slikt bibliotek i et st&#248;rre prosjekt er risikabelt og kan potensielt&#160;f&#248;re til mye vedlikehold/oppdateringer av koden ettersom biblioteket oppdateres<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1062,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er et konsept for arkitekturen i et prosjekt. Backenden i prosjektet settes opp med &#34;endpoints&#34; som returnerer bestemt data, dvs. x endpoint returnerer x data. Et slik oppsett gj&#248;r det lett &#229; forst&#229; og sette seg inn i koden. Det er ogs&#229; lett &#229; vedlikeholde og manipulere disse endpoints. Et stort problem med REST API og endpoints er at de alltid returnerer hele resultatsettet. Man kan ikke begrense/filtrere resultatene fra en endpoint og m&#229; alltid hente alt. Dette kalles for &#34;over-fetching&#34;. Mens det er ikke et stort problem for mindre prosjekter, blir problemet st&#248;rre og st&#248;rre jo st&#248;rre mengde data man jobber med.&#160;<\/p><p>&#160;<\/p><p>For &#229; lettere behandle store resultatsett, kan man bruke GraphQL. GraphQL er et queryspr&#229;k. Spr&#229;ket brukes over et endpoint for &#229; spesifisere requestene som blir sendt til den. Spesifikasjoner kan v&#230;re alt fra bestemte objekter til bestemte felt innenfor bestemte objekter.&#160;Siden man begrenser resultatsettet, begrenser man ogs&#229; hvor mye processing som m&#229; gj&#248;res for hver request, noe som kan hjelpe med kj&#248;retiden av et program ekstremt mye.&#160;<\/p><p>&#160;<\/p><p>REST har likevel sine bruksfelt med tanke p&#229; mindre og enklere prosjekter som opererer ikke med mye data. Siden REST har v&#230;rt rundt lengre enn GraphQL, har den ogs&#229; flere support verkt&#248;y, f.eks. n&#229;r det gjelder API analytics.&#160;<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11540350,"ext_inspera_userAssessmentSetupId":7139921,"ext_inspera_userAssessmentId":4841416,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:15Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Langli Karoline Lillevestre (10021)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330989,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1899,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React er det to hovedformer for state. Dette er global og lokal state. En lokal state eksisterer i en komponent, og om andre komponenter skal bruke denne staten, m&#229; den sendes opp/ned gjennom komponentene som props. Hvis en annen komponent skal endre staten m&#229; den f&#229; tilsendt en callback funksjon fra komponenten som hadde staten, som kan brukes til &#229; endre staten.&#160;<\/p><p>&#160;<\/p><p>Dette virker bra dersom staten ikke skal flyttes langt (f.eks. hvis et barn/forelder skal ha den), og hvis det ikke er mange komponenter som trenger den. Men hvis det motsatte er tilfellet, at enten mange komponenter m&#229; ha tilgang til staten, eller at man flytter staten langt, er ikke lokal state optimalt. Det vil gjerne f&#248;re til at mange komponenter som egentlig ikke trenger tilgang til staten f&#229;r det allikevel. Da burde man heller bruke global state.&#160;<\/p><p>&#160;<\/p><p>En global state er en tilstand som lagres &#34;utenfor&#34; komponentene, og som hver komponent kan f&#229; tilgang til, uten &#229; m&#229;tte f&#229; den&#160;tilsendt som props. Det finnes flere m&#229;ter &#229; implementere dette p&#229;, og eksempler p&#229; dette er Redux, Mobx og Reacts egne Contex API.&#160;<\/p><p>&#160;<\/p><p>Med Redux&#160;lagres all state i &#233;n store, og endringer skjer via funksjoner kalt reducers. Redux er godt&#160;skalerbart, og brukes ofte i st&#248;rre applikasjoner av denne grunn. Det finnes flere gode utviklerverkt&#248;y for Redux, noe som bl.a. gj&#248;r debugging&#160;enklere. Redux&#160;er ogs&#229; mye brukt, noe som vil si at det er lett &#229; finne gode svar p&#229; problemer p&#229; nett.&#160;<\/p><p>&#160;<\/p><p>Mobx&#160;har derimot flere steder &#229; lagre staten p&#229;. Det er ikke like skalerbart&#160;som Redux, noe som er grunnen til at Mobx&#160;ofte brukes i litt mindre applikasjoner. Men hvis man &#248;nsker &#229; komme rakst i gang, og ikke vil lage en veldig stor applikasjon, er Mobx bra. Dette skyldes at det er lettere &#229; l&#230;re (spesielt om man kan objektorientert programmering, da Mobx bygger p&#229; dette), og oppstarten er mindre tidkrevende. Koden p&#229;virkes ikke like mye av Mobx som den gj&#248;r av Redux.&#160;<\/p><p>&#160;<\/p><p>Context har den fordelen at det er bygget inn i React, s&#229; man slipper &#229; laste ned tredjeparts avhengigheter for &#229; komme i gang. Context lar&#160;andre komponenter subscribe til staten, og de kan da bruke/endre dataen. Om endringer skjer ofte&#160;l&#248;nner det seg ikke &#229; bruke Context, da hver oppdatering trigger en re-rendring som er vanskelig &#229; optimalisere. Det vil v&#230;re bedre &#229; bruke Redux&#160;i slike tilfeller. Men for ting man ikke endrer s&#229; ofte, som f.eks. tema, kan det v&#230;re en god l&#248;sning.&#160;<\/p><p>&#160;<\/p><p>Ellers, n&#229;r det gjelder dataflyt, trenger man ikke n&#248;dvendigvis &#229; sende state som props. Props kan ogs&#229; brukes til &#229; sende annen data. F.eks. om &#233;n komponent har en liste med alle verdens land (AllCountries), og en annen komponent viser frem ett land (Country), kan navn p&#229; landene sendes som props fra AllCountries til Country. Man kan da bruke f.eks. .map for &#229; vise alle landene.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3508,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en global state manager. I motsetning til Redux og Mobx, er Recoil lagd for &#229; likne p&#229; React, noe som vil si at kan v&#230;re lettere &#229; sette seg inn i for en person som allerede kan React.&#160;<\/p><p>&#160;<\/p><p>N&#229;r det gjelder hvordan staten lagres likner det kanskje mer p&#229; Mobx enn Redux, da Redux har &#233;n store, mens Mobx lagrer statene flere steder. Dette gj&#248;r ogs&#229; Recoil, som lagrer state i flere atoms. Et atom lages ved bruk av en atom-funkson&#160;som importeres fra Recoil. N&#229;r et atom er lagd kan alle andre komponenter bruke det ved hjelp av useRecoilState, som lar komponentene subscribe til atomene. Denne hooken likner veldig p&#229; useState mtp syntaks og bruk. Dvs den henter b&#229;de verdien og en funksjon for &#229; endre verdien.<\/p><p>&#160;<\/p><p>I tillegg til atoms har Recoil selectors. Dette er en/flere funksjoner som tar atomer/selectorer som input, og bruker det til &#229; returnere derived data, alts&#229; data som er basert p&#229; staten. F.eks. hvis man &#248;nsker &#229; holde orden p&#229; et tall, og samtidig vil kunne hente dette tallet som en streng, ville man i Redux/Mobx/Contex&#160;m&#229;tte lagd en egen global state for strengen, eller gjort denne overgangen alle steder i koden hvor det er &#248;nsket (kunne evt lagd en funksjon som gj&#248;r dette og kalle den over alt). Recoil lar deg bruke selectorene som atoms (som ikke kan endres), og de oppdateres hver gang et atom oppdateres. Da re-rendres ogs&#229; komponentene som subscriber til selectorene.&#160;<\/p><p>&#160;<\/p><p>En ulempe med Recoil vil derimot v&#230;re at det enda er relativt nytt, og nettsamfunnet for dette er ikke s&#229; stort. Dvs. at det kan v&#230;re vanskeligere &#229; finne gode kilder p&#229; nett, og &#229; f&#229; hjelp. Redux har et veldig stort nettsamfunn, s&#229; det er greit &#229; finne svar p&#229; sp&#248;rsm&#229;lene man har. Forskjellen mellom Mobx/Context og Recoil er litt mindre p&#229; dette punktet, da de er nyere enn Redux, og ikke har et like stort nettsamfunn.&#160;<\/p><p>&#160;<\/p><p>Context API-et er jo ogs&#229; lagd for React, men har et par problemer. Staten kan bare deles ved &#229; sende den opp til en felles forfader, og Context lagrer bare en enkelt verdi, alts&#229; ikke et ubestemt antall verdier med egne consumere. Recoil skal fikse disse problemene, og som nevnt over kan man enkelt lage atomer som alle komponenter kan benytte seg av.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>- https://recoiljs.org<\/p><p>- https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1587,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST (Representational state transfer) er et konsept/en standard&#160;for nettverksbasert software som beskriver hvordan webl&#248;sninger sender data&#160;over http. F.eks. hvordan man skal f&#229; data fra en database eller endre innholdet i den, over http. REST er skalerbart. Det virker slik at hvis man &#248;nsker &#229; hente data, tar man kontakt med et endepunkt som da sender all dataen sin tilbake til deg. Med REST kan man sende flere typer data mellom klient og server, ikke f.eks. bare json.&#160;<\/p><p>&#160;<\/p><p>Problemet med REST&#160;er at en endepunkt alltid sender all dataen, man kan ikke velge hva som hentes. Dvs. at dersom man &#248;nsker navn og f&#248;dsels&#229;r fra et endepunkt som ogs&#229; har bosted, f&#229;r man med bostedet ogs&#229;, noe som kalles overfetching. Man kan evt. dele opp dataen i flere endepunkter, men da opplever man gjerne underfetching, alts&#229; at hvis man da &#248;nsker b&#229;de navn, f&#248;dsels&#229;r og bosted er det ikke nok &#229; kontakte ett endepunkt, man m&#229; kontakte to.&#160;<\/p><p>&#160;<\/p><p>GraphQL organiserer dataen som en graf, hvor objekter lagres som noder, og forholdene mellom objektene er kanter. Som ved REST kommuniserer systemer over http. GraphQL er ikke bare en standard, men er b&#229;de&#160;et querry language, en spesifikasjon og et sett verkt&#248;y. Her brukes bare ett endepunkt for all dataen, og man henter spesifikke deler av dataen ved &#229; lage sp&#248;rringer. Dvs. at man kan hente ut akkurat den dataen man &#248;nsker. Vil man bare ha navn og f&#248;dsels&#229;r kan dette lett gj&#248;res, man kan ogs&#229; hente data basert p&#229; f.eks. en ID.Dvs. at man i motsetning til REST unng&#229;r over/under fetching. Dette gj&#248;r ogs&#229; at det er lettere &#229; endre p&#229; UI senere, da man bare kan endre sp&#248;rringene p&#229; klient-siden av applikasjonen for &#229; endre p&#229; hva som hentes fra databasen, i stedet for &#229; gj&#248;re endringer i selve serveren.&#160;<\/p><p>&#160;<\/p><p>Et problem med GraphQL er derimot at det bare returnerer json objekter. Dvs. at man f.eks. ikke kan lagre bilder med GraphQL. Dette skiller seg ut fra REST, s&#229; en mulig l&#248;sning vil f.eks. v&#230;re &#229; bruke et REST API om man skulle &#248;nske &#229; lagre bilder ogs&#229;. GraphQL bruker heller ikke http spesifikasjonene for caching, noe REST gj&#248;r automatisk. Ellers er error handling vanskeligere i GraphQL enn i REST.&#160;<\/p><p>&#160;<\/p><p>For mindre applikasjoner vil REST gjerne l&#248;nne seg, da det er letter &#229; komme i gang med dette, enn det er &#229; komme i gang med GraphQL.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540775,"ext_inspera_userAssessmentSetupId":7140059,"ext_inspera_userAssessmentId":4841468,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:00:12Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bjærum Nina (10051)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":28288165,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2052,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Som kjent er React en komponentbasert arkitektur. Dette kan gj&#248;re prosjekt eller&#160;applikasjon modul&#230;r og gjenbrukbar, men det stiller ogs&#229; krav til hvordan de&#160;ulike komponentene snakker sammen og deler data.&#160;<\/p><p>&#160;<\/p><p>I arkitekturen er som regel komponentene ordnet i en form for hierarki og&#160;vi betegner komponentene som forelder og barn, p&#229; samme m&#229;te som vi kaller en wrapper-div forelder til elementene inni den. Dataflyten i React g&#229;r kun en vei: nedover. Alts&#229; fra forelder til barn. For &#229; sende/dele data mellom React komponenter bruker vi props (kort for properties). Vi kan sende data&#160;props, som vi sender input/parameter til en funksjon. (Men, dataprops er kun for &#34;lesing&#34; de kan brukes og vises, men de kan ikke endres av komponenten som mottar dem.&#160;<\/p><p>En annen mekanisme som brukes i React er State. State er et &#34;built-in&#34; objekt, som h&#229;ndteres innenfor selve komponenten. Vi bruker alts&#229; ikke state til &#229; sende data mellom komponenter (som props) men for at komponentene kan lagre og behandle data innad. Vi kan si at state er privat for komponenten.&#160;Vi bruker hooks som useState() og setState(), for &#229; bruke og oppdatere en komponents state. N&#229;r staten endres, s&#229; re-rendres komponenten. Vi bruker state for &#229; gj&#248;re en komponent dynamisk, eller med andre ord at den kan bli interaktiv. Det er ogs&#229; verdt &#229; nevne at React State ikke endres, den er &#34;immutable&#34;. Men, endringer gj&#248;res til en kopi av original tilstand til staten.&#160;<\/p><p>&#160;<\/p><p>For &#229; behandle/bruke tilstand eller state&#160;har vi ogs&#229; s&#229;kalte State Management Tools, som Redux og MobX er eksempler p&#229;. For &#229; illustrere hvorfor state management kan v&#230;re nyttig, kan vi se p&#229; det som ble nevt over: dataflyten i React g&#229;r kun nedover, ikke for eksempel sidelengs. Redux er veldig popul&#230;rt &#229; bruke med React, fordi det kan l&#248;se problemet med dataflyten ved &#229; lagre data &#34;utenfor&#34;, slik at den kan sendes/passes til alle. Vi kan for eksemple legge all data i den &#34;&#248;verste&#34; komponenten og sende med props&#160;videre og videre, men det er lett &#229; se for seg at jo st&#248;rre applikasjonen blir og des flere komponenter, jo mer komplekst og kaotisk kan dette bli. Ved &#229; bruke Redux lagrer vi alts&#229; state i&#160;et globalt Redux Store. Redux har s&#229;kalt single-store for hele applikasjonen. Deretter bruker vi Actions (med en type) og Reducers for &#229; oppdatere en state.&#160;<\/p><p>&#160;<\/p><p>Kort fortalt bruker vi state management tools for &#229; gj&#248;re data tilgjengelig globalt, dersom flere komponenter skal bruke den. Vi kan ogs&#229; f&#229; til dette med props, state og for eksempel Context APIet, men for et hvert prosjekt b&#248;r man gj&#248;re en vurdering p&#229; hva som er n&#248;dvendig. Hvor stort skal prosjektet bli? Er det mange states/data som flere komponenter trenger tilgang til? Ved et lite prosjekt kan det v&#230;re un&#248;dvendig &#229; bruke Redux eksempelvis, ettersom det krever en del kode. For eksempel for &#229; oppdatere en state.&#160;&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2578,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nyere open-source&#160;State managemen bibliotek for React, fra Facebook. Det vil si, det vil v&#230;re naturlig &#229; sammelikne det med andre verkt&#248;y for state management fra pensum, som Redux og MobX.&#160;<\/p><p>&#160;<\/p><p>Jeg leste meg opp til at Recoil tilbyer &#34;App-wide observation&#34;. Dette handler om &#229; observere endringer i states. Dette minner om MobX, som ogs&#229; har bruker Observable datastruktur. MobX &#34;wrapper&#34; datastrukturen eller objektet i en observable, som gj&#248;r at endringer og oppdateringer kan detekteres. Dette resulter i mindre kode, enn for eksempel Redux, hvor dette m&#229; kodes manuelt. F&#248;r du har implementert s&#229;kalte &#34;listeners&#34; som f&#248;lger med p&#229; staten, vil det v&#230;re passivt ved bruk av Redux. I Recoil kan derimot komponenter lytte eller abonnere p&#229; atomer.&#160;<\/p><p>&#160;<\/p><p>Recoil definerer en rettet graf, som gjenspeiler eller h&#248;rer til tre-strukturen i React. Forandring i state, g&#229;r med denne rettede grafen, fra &#34;r&#248;ttene&#34; som Recoil definerer som atomer. Endringen g&#229;r s&#229; gjennom funksjoner, kalt selectors, og deretter til komponentene.&#160;Det presiseres p&#229; recoiljs.org at dette bidrar til &#34;boileplate-free API&#34;, som i praksis betyr mindre &#34;fyllkode&#34;. Dette vil jeg anse som en fordel sammenliknet med for eksempel Redux, som fort kan ende med ganske mye boilderplate for ikke s&#229; mye funksjonalitet.&#160;<\/p><p>&#160;<\/p><p>Recoil definerer som sagt atomer, eller &#34;Atoms&#34;. Disse er enheter av states, som de innbygde objektene i React. I forrige oppgave nevnte jeg hook&#39;en useState(). En potensiell fordel med Recoil, er at man kan bruke den liknende hooken useRecoilState(). Den fungerer p&#229; samme m&#229;te, men man kan dele staten mellom komponenter, som ikke er mulig ellers (de er private). En fordel med dette er at de som har kjenskap til React er vant til &#229; bruke useState() og siden konseptet er likt, kan l&#230;ringen og overgangen g&#229; lettere. P&#229; samme m&#229;te som at en komponents state har en default verdi, har ogs&#229; et atom dette.&#160;Atomene har i tillegg en unik n&#248;kkel, (det er viktig at denne er unik), slik at de kan brukes globalt.&#160;<\/p><p>&#160;<\/p><p>Recoil-biblioteket omtales ogs&#229; som den mest &#34;reactish&#34; m&#229;ten &#229; h&#229;ndtere state p&#229;. Vi ser at Recoil stort sett likner p&#229; react hooks.&#160;Som nevnt over kan likheter v&#230;re en fordel, ettersom det gir reactutviklere mulighet til &#229; adaptere og bruke biblioteket relativt fort, uten &#229; m&#229;tte l&#230;re seg noe helt nytt. S&#230;rlig kanskje sammenliknet med Redux vil dette v&#230;re en fordel, ettersom Redux er komplekst og l&#230;ringskurven kan v&#230;re bratt.&#160;<\/p><p>&#160;<\/p><p>Kilde oppgitt i oppgavetekst.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2513,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er to ulike l&#248;sninger for klient-server kommunikasjon i web applikasjoner. Man kan si at GraphQL har blitt et alternativ til REST. De har begge to fordeler og ulemper, og i ulike situasjoner vil kanskje GraphQL v&#230;re en god l&#248;sing, mens REST er bedre&#160;i et annen.&#160;<\/p><p>&#160;<\/p><p>Den f&#248;rste forskjellen jeg vil trekke frem, er denne: REST er et overordnet design, konsept&#160;eller arkitektur&#160;for web basert klient/server kommunikasjon. Dette inneb&#230;rer en rekke &#34;constrainst&#34; eller regler, som m&#229; tilfredsstilles. GraphQL derimot, er et &#34;query language&#34; eller et sp&#248;rrespr&#229;k, hvor du spesifiserer sp&#248;rringer i JSON, hva og hvilke data du vil ha. Responsen er&#160;<\/p><p>&#160;<\/p><p>Et annet aspekt&#160;er hvordan data er organisert. GraphQL har samme funksjonalitet, eller f&#248;lger de samme reglene som REST APIer, men dataen er organisert som en graf, med noder og kanter. Objekter representeres som noder, og kantene i grafen blir relasjoner mellom dem. Dette skaper videre noen andre forskjeller.&#160;<\/p><p>En vesentlig forskjell &#229; diskutere her, er dette med respons og datafetch. N&#229;r du bruker et REST API for &#229; fetche informasjon, s&#229; f&#229;r du alltid et komplett datasett. Dette kan v&#230;re mer data, enn akkurat det du trenger i tilfellet. Dette kaller vi for over-fetching og det skjer ofte fordi du har definerte endepunkt. Noen ganger er ogs&#229; ressurser avhengige av hverandre, som kan bety at kan f&#229; en domino-liknende effet med foresp&#248;rsler. GraphQL p&#229; den andre siden er som nevnt et sp&#248;rrespr&#229;k. Dette brukes til &#229; lage mere spesifikke foresp&#248;rsler, du kan tilpasse din request/foresp&#248;rsel til akkurat den dataen du trenger. Dette kan i tur for eksempel minske prosesseringen, ettersom du ikke lenger over-fetcher.&#160;<\/p><p>&#160;<\/p><p>De har som nevnt ulike fordeler, dette er noen av dem som er verdt &#229; nevnte. I tillegg vil jeg legge til at REST er industristandard, og det er gjerne fordi det er enkelt &#229; forst&#229;. Ulempen er for eksempel dette med over-fetching, og er kommer GraphQL inn som et alternativ som kvitter seg med problemet. GraphQL er&#160;ikke like etablert som REST, men er trolig &#34;up &#38; coming&#34;.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Jeg leste denne artikkelen i forkant av eksamen, legger den ved som kilde:<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11541184,"ext_inspera_userAssessmentSetupId":7140011,"ext_inspera_userAssessmentId":4841393,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:17Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tellefsen Hedda Sofie (10156)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35271299,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3419,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har en tre-struktur som gj&#248;r at states og props som skal brukes i flere komponenter m&#229;&#160;sendes opp og ned i treet for &#229; n&#229; de komponentene som skal benytte seg av de. For store applikasjoner med stor dybde i treet kan dette v&#230;re sv&#230;rt tungvint, og man &#248;nsker ikke at komponenter som ikke har noe med en state &#229; gj&#248;re skal re-rendres ved endring i staten.&#160;Eksempler p&#229; l&#248;sninger for dette er&#160;Context-APIet&#160;og&#160;React State Management-biblioteker som Redux og MobX.&#160;<\/p><p>&#160;<\/p><p>Context API-et fungerer p&#229; den m&#229;ten at man lagrer ting som skal brukes av to eller flere komponenter (gjerne flere)&#160;i context.&#160;Man har en Provider i appen som &#34;holder styr p&#229;&#34; hvilke komponenter som lytter til context.&#160;De aktuelle komponentene som benytter seg av innholdet i context, f&#229;r beskjed om forandringer i&#160;context ved hjelp av funksjonen useContext(), og n&#229;r det skjer forandringer i context vil disse komponentene re-rendre.<\/p><p>&#160;<\/p><p>Et eksempel p&#229; noe som egner seg &#229; bruke context til er tema p&#229; en nettside, som vi brukte i prosjekt 2. Da hadde vi en knapp som var ment for &#229; endre temaet, og n&#229;r den knappen ble trykket&#160;inn endret&#160;staten i context seg. Stylingen som de ulike komponentene skulle&#160;bruke l&#229; ogs&#229; i context. Alle komponentene som lyttet&#160;til context ble da re-rendret&#160;og fikk&#160;den nye stylingen gitt ved staten i context.<\/p><p>&#160;<\/p><p>Context er laget spesielt&#160;for React, mens Redux og MobX er state management-biblioteker som fungerer veldig bra med React (selv om de ogs&#229; kan brukes med&#160;andre biblioteker).<\/p><p>&#160;<\/p><p>Redux er et state management-bibliotek, som lar komponenter lytte til det&#160;som er aktuelt for dem, i stedet for alt som ligger i Redux (i motsetning til Context som re-rendrer alle komponenter som lytter til context ved forandring). I Redux har man en Reducer som har actions som oppdaterer &#34;Store&#34;-en. N&#229;r reduceren endrer en verdi i Store (ved hjelp av en action), oppdateres alle komponentene som benytter seg av denne verdien. Man bruker &#34;Dispatch&#34; for &#229; kj&#248;re en action, og bruker en &#34;Selector&#34; for &#229; hente verdier fra Store i Redux. Den valgte Actionen har en Value som sendes gjennom Reduceren for &#229; oppdatere Store.<\/p><p>&#160;<\/p><p>MobX er ogs&#229; et state management-bibliotek.&#160;I MobX bruker man observers&#160;som f&#248;lger med p&#229; observables i applikasjonen. En event har en action som oppdaterer staten til en observable. N&#229;r staten til en observable oppdateres, iverksettes en reaction p&#229; de komponentene som observeres. Dette vil igjen f&#248;re til en oppdatering av brukergrensesnittet.&#160;<\/p><p>&#160;<\/p><p>I MobX kan man ha forskjellige stores som brukes p&#229; forskjellige m&#229;ter, s&#229; det er mer fleksibelt enn Redux som har en enkelt store for hele applikasjonen. I MobX kan du endre Store n&#229;r du vil, de kan endres&#160;gjennom komponenter, handlinger, funksjoner og debugging, og vil umiddelbart iverksette re-render av applikasjonen. Redux er litt mer tungvint, men samtidig veldig stabilt. Du kan ikke endre noe i Store uten &#229; g&#229; via Dispatch og actions.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://mobx.js.org/README.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2276,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er ogs&#229; et state management bibliotek for React, slik som MobX og Redux.&#160;Biblioteket er ment for &#229; l&#248;se de samme utfordringene som MobX og Redux, men bare p&#229; en litt annerledes m&#229;te. Ideen med Recoil er &#229; flytte states som brukes av flere komponenter ut av treet og opp i s&#229;kalte &#34;Atoms&#34;, som kan ses p&#229; som noder som er tilknyttet treet ortogonalt. Dataen flyter fra Atoms gjennom Selectors ned til React-kompoentene. N&#229;r for eksempel en komponent som er langt nede i react-treet p&#229; den ene siden skal bruke samme state som en komponent som&#160;er langt nede p&#229; den andre siden av treet, er det en mye kortere vei mellom de hvis man knytter de sammen med et slikt&#160;Atom. P&#229; samme m&#229;te som Redux og MobX lytter komponentene til Atomene&#160;og re-rendres ved forandring.<\/p><p>&#160;<\/p><p>I stedet for &#229; bruke en &#34;global state&#34;, benytter Recoil seg av Reacts innebygde state-management-funksjoner. Fordelen med &#229; bruke mest mulig av det som allerede er innebygd i react er at det gj&#248;r Recoil mer kompatibelt med nye react-funksjoner, uten at man m&#229; forandre p&#229; Recoil for &#229; matche forandringene som skjer i react. Det er i tillegg ikke noe ekstra boiler-plate, som det for eksempel er mye av i Redux.&#160;<\/p><p>&#160;<\/p><p>En annen fordel&#160;med biblioteket er at Atomene er p&#229; en annen akse enn resten av treet, s&#229; ved forandringer i trestrukturen trenger man ikke forandre state-managementet. Sammenliknet med for eksempel context, er dette en stor fordel, da context trenger providere til komponentene sine, og krever en del ekstra arbeid for &#229; endre p&#229; strukturen.&#160;<\/p><p>&#160;<\/p><p>En ulempe med Recoil kan v&#230;re at det er ganske nytt og ikke s&#229; utbredt&#160;sammenliknet med de andre bibliotekene. Dette gj&#248;r at det finnes mindre dokumentasjon p&#229; nett, og at det er f&#230;rre selskaper som bruker det per dags dato.&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;https://recoiljs.org<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1361,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En stor forskjell mellom REST API og GraphQL er at REST har flere endpoints, mens Graphql bare har ett. I POST Requesten til et REST-API bruker man en kombinasjon av URL og HTTP verbs, for &#229; kalle p&#229; den riktige&#160;handlingen p&#229; serveren. POST Requesten til et GraphQL-API inneholder&#160;en Query som definerer den dataen man trenger fra serveren. En slik query beskriver n&#248;yaktig den dataen man vil ha, slik at man mottar kun den og ikke noe ekstra. Dette er litt annerledes enn REST, som ofte fetcher mer data enn man egentlig trenger, noe som kan v&#230;re en ulempe hvis man har en applikasjon som stadig henter ny data fra serveren. URL-en til REST blir dog veldig tydelig, fordi man kan se de forskjellige betingelsene for dataen som hentes ut.&#160;<\/p><p>&#160;<\/p><p>REST-API er mer brukt enn GraphQL-APIer, men valget mellom&#160;de to&#160;avhenger selvf&#248;lgelig av behovene til applikasjonen man bygger. REST er noe enklere &#229; bruke, og krever ikke ekstra pakker for &#229; skrive kode som fungerer p&#229; klientsiden. GraphQL kan v&#230;re noe mer tungvint da man trenger ekstra pakker p&#229; klient-siden for at queriene skal fungere. Men ved bruk av tredjepartskomponenter som for eksempel Apollo, kan man f&#229;&#160;hjelp til &#229; bruke GraphQL og da trenger det ikke n&#248;dvendigvis &#229; v&#230;re s&#229; vanskelig allikevel.&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;https://www.youtube.com/watch?v=PeAOEAmR0D0&#38;t=946s<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11541884,"ext_inspera_userAssessmentSetupId":7139905,"ext_inspera_userAssessmentId":4841461,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:00:34Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Iversen Espen (10168)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34605363,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2888,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rimelig &#229;pen oppgave, s&#229; f&#229;r pr&#248;ve &#229; dele opp og begrense litt. (I ettertid er jeg litt usikker p&#229; om delene om context api-et og Redux er passende her ettersom at det kun er mekanismer og teknikker som nevnes i oppgaven, noe api-er og biblioteker faller litt utenfor,&#160;men jeg velger &#229; la det st&#229; p&#229; tross av dette, veldig relevant for oppgave 2).<\/p><p>&#160;<\/p><p>I utgangspunktet har alle react-komponenter mulighet for &#229; lagre hver sin state, som er en samling av data&#160;tilknyttet en instants av komponentet. N&#229;r et komponent har et foreldrekomponent&#160;vil det ogs&#229; v&#230;re mulig for foreldrekomponentet &#229; sende inn andre attributter/data(tenk egenskaper), og dette kalles props, og&#160;kan igjen&#160;p&#229;virke staten til barnekomponentet. I utgangspunktet er det ikke mulig for et barnekomponent &#229; direkte p&#229;virke/endre state til foreldrekomponentet, s&#229; man sier derfor at&#160;react og react-komponenter har en&#160;enveis dataflyt. At dataflyten er enveis f&#248;rer blant annet til &#248;kt ytelse og modularitet (komponenter har i utgangspunktet mindre strenge avhengigheter om hva som m&#229; v&#230;re forelder), og er ogs&#229; en viktig drivkraft for &#229; strukture en react-applikasjon med en hensiktsmessig komponentstruktur. En viktig bemerkning er at barnekomponenter implisitt kan p&#229;virke state for komponenter lenger opp i treet ved bruk av&#160;funksjoner de har f&#229;tt tilsendt. Dette er funksjoner som er deklarert i foreldrekomponentet, og som sendes nedover komponenttreet via props. Dette gj&#248;r det alts&#229; mulig for barnekomponenter &#229; p&#229;virke state lenger opp i treet, men de vil fortsatt ikke ha tilgang til state de ikke selv har f&#229;tt sendt inn som props.<\/p><p>&#160;<\/p><p>En viktig del av state h&#229;ndtering i react er bruken av livssyklusmetoder eller hooks(spesifikt useEffect)&#160;(alt ettersom om komponentet er henholdsvis et klassekomponent eller funksjonelt komponent). Disse baserer seg p&#229; visse triggere som om komponentet rendres, eller om noen endringer skjer for visse data i komponentets state. Dette gj&#248;r det mulig &#229; kontrollere hva som skal skje dersom komponentet f.eks. rerendres eller f&#229;r state endret, og dermed m&#229; oppdatere seg selv/annen state. (Litt usikker p&#229; hvor relevant dette er i forholdt til hva oppgaven sp&#248;r om, men strengt tatt er jo dette mekanismer som muliggj&#248;r state management).<\/p><p>&#160;<\/p><p>React har nylig f&#229;tt et innebygd api for &#229; dele data med hele komponenttreet uten &#229; manuelt sende dataen som props gjennom hvert niv&#229; (prop drilling). Dette kalles context, og brukes hovedsakelig n&#229;r dataen skal v&#230;re tilgjengelig for mange komponenter p&#229; forskjellige niv&#229;er i treet. Dette gj&#248;res (enkelt presentert)&#160;ved &#229; opprette et context object, wrappe komponentene som trenger den nye globale staten/contexten med&#160;context provider, og aksessere den globale staten/contexten med context consumer.&#160;<\/p><p>&#160;<\/p><p>En annen mer involvert l&#248;sning for global state h&#229;ndtering er bibliotek som Redux og MobX. Redux fungerer ved &#229; skape en&#160;sentralisert store, som holder styr p&#229; en global state som alle komponenter kan hente/lese fra og endre/p&#229;virke. Dette gj&#248;res ved &#229; sette opp: den globale staten (kalt store),&#160;reducer funksjoner som inneholder logikk for &#229; endre store, actions som kan utf&#248;res for &#229; kalle reducer-funksjonene og subscriptions som gj&#248;r det mulig for komponenter &#229; lese den globale storen. Ulempen jeg selv har oppdaget ved bruk av Redux spesifikt er at det krever sv&#230;rt mye boilerplate, alts&#229; mye kode som m&#229; p&#229; plass for &#229; f&#229; kommet i gang i det hele tatt med l&#248;sninger.<\/p><p>&#160;<\/p><p>En annen mulig ulempe ved bruk av global-state management via context/redux er at det kan trivialisere dette med en hensiktsmessig komponentstruktur, noe som kan f&#248;rer til mindre intuitiv og oversiktlig kode/struktur og som kan gj&#248;re debugging av applikasjonen vanskeligere.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2330,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Global state management (l&#248;sninger for dette som er l&#230;ringsm&#229;l)&#160;er nevnt en del i forrige oppgave, s&#229; jeg vil ikke g&#229; gjennom det helt p&#229; nytt her, men heller se p&#229; sammenligning, fordeler/ulemper.<\/p><p>&#160;<\/p><p>Recoil er&#160;et state management bibliotek for react. Biblioteket tar i bruk s&#229;kalte Atoms (state som skal deles) og selectors (pure functions - ingen annen p&#229;virkning enn &#229; gi bestemt output for bestemt input, alts&#229; p&#229;virkning av global data til komponentene som trenger det) for &#229; implementere state som kan deles og p&#229;virkes av alle komponentene som har bruk for det. Dette er jo mye likt hva context-apiet og redux pr&#248;ver &#229; l&#248;se, men recoiljs skal visstnok ha enkelt fordeler fremfor disse. Recoil har i motsetning til Redux lite boilerplate (som jeg p&#229;pekte i oppgave 1), og selve syntaksen for API-kallene skal v&#230;re mye renere og passe bedre inn (mer lignende vanilla react state h&#229;ndtering). I forhold til context-apiet virker det som at recoil har den fordelen at et komponent kan lese fra flere forskjellige &#34;kilder&#34;/providers samtidig og at atoms har mulighet til &#229; holde styr p&#229; flere verdier. Et annet poeng er at selectorene i Recoil skal ha mulighet til &#229; fungere asynkront, uten at komponentet som bruker selectoren trenger &#229; ta h&#248;yde for det - i motsetning til Redux, der det finnes flere tilleggsbiblioteker som redux thunk og redux sagas for &#229; implementere og forenkle dette. Det er vanskelig &#229; p&#229;peke umiddelbare ulemper ved bruk av biblioteket uten &#229; ha pr&#248;vd det selv i et ekte prosjekt, men en ting&#160;som kan p&#229;pekes er at Recoil fortsatt er p&#229; et tidlig stadie, og derfor er mindre &#34;tried and tested&#34; enn andre metoder, og at man derfor ogs&#229; er litt mer p&#229; egenh&#229;nd i forhold til hvis man hadde valgt mer kjente state-management l&#248;sninger som context eller redux (noe som er en viktig faktor i et emne som dette).<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1797,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST API er basert p&#229; &#229; lage endepunkter (URI-er) som tilsvarer spesifikke ressurser som kan hentes. Dette gj&#248;res over HTTP, og st&#248;tter operasjoner som GET for henting, POST for tillegging/oppdatering, PUT for oppdatering, og DELETE for sletting. Et n&#248;kkelkonsept er at alt, gitt URIen, er en ressurs som kan p&#229;virkes eller hentes. REST-API-er har lenge v&#230;rt standarden for klient-server kommunikasjon. En fordel med REST er at det gj&#248;r det mulig &#229; ta i bruk caching i webleseren, alts&#229; &#229; lagre data som ofte/allerede er hentet for &#229; sjekke opp om sp&#248;rringen er n&#248;dvendig &#229; gjennomf&#248;re igjen. En ulempe med REST er at det man ofte m&#229; overhente ressurser, ettersom at det umulig &#229; ha et eget endepunkt for hver eneste ressurs(kombinasjon) som m&#229;tte bli forespurt. Man kan dermed ogs&#229; ende opp med &#229; m&#229;tte gj&#248;re mange sp&#248;rringer for &#229; hente ut spesifikk og sammenhengende informasjon, noe som er p&#229;virker ytelsen.<\/p><p>&#160;<\/p><p>GraphQL er derimot (grovt sagt)&#160;en spesifikasjon for et sp&#248;rrespr&#229;k som implisitt spesifiserer en API design arkitektur, der hovedpoenget er at man fleksibelt skal kunne hente ut akkurat den dataen som er relevant/som trengs (dette definerer ogs&#229; i sp&#248;rringen), med kun ett endepunkt. Det ligger litt i navnet at alt av ressurser sees p&#229; som graf som er tilknyttet hverandre, og det er p&#229; grunn av dette at man effektivt kan hente ut akkuratt det som trengs. GraphQL er avhengig av en platform/klient som Apollo (Client) for &#229; representere og kommunisere&#160;med&#160;denne API-arkitekturen. En annen fordel med bruk av GraphQL er at sp&#248;rringer kan baseres p&#229; et typesystem, noe som &#229;pner opp for validering.<\/p><p>&#160;<\/p><p>Generelle fordeler/ulemper beskrevet over, som f&#229;r frem forskjeller. Videre kan det nevnes at&#160;GraphQL st&#248;tte kan oppleves som mer kronglete &#229; sette opp enn et REST-API, men at GraphQL ofte oppleves som enklere &#229; jobbe med n&#229;r man f&#248;rst har et fungerende oppsett. Igjen kan det ogs&#229; nevnes at REST har v&#230;rt standarden i lang tid, og det kan derfor v&#230;re enklere &#229; finne ressurser/st&#248;tte for implementasjoner av dette. GraphQL har derimot f&#229;tt god medfart de siste par &#229;rene, og det finnes flere utviklere som tror GraphQL vil v&#230;re ledende i n&#230;r fremtid. Dette gjenst&#229;r selvf&#248;lgelig &#229; se:)<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11542108,"ext_inspera_userAssessmentSetupId":7139903,"ext_inspera_userAssessmentId":4841419,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:42Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rognerud Robin (10231)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34391226,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2329,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har innebygde funksjoner, Hooks, som bruker useState og setState til &#229; lagre tilstanden i komponentene. Dette er for &#229; kunne dele opp logikk som ellers er vanskelig &#229; gj&#248;re i livsyklus-funksjonene som componentDidMount. Man kaller setState der man f&#229;r inn &#248;nsket verdi, f. eks. ved onClick p&#229; en knapp,&#160;og s&#229; lagrer det seg i variabelen tidligere satt i komponenten<\/p><p>&#160;<\/p><p>Vi kan ogs&#229; bruke redux/mobx til &#229; lagre state globalt. Spesielt i redux lagrer man staten i en &#34;store&#34; hvor man har egne funksjoner for &#229; hente &#229; lagre staten, eller evt. har en defaultState ved start. Positivt med dette er at det som nevnt ligger globalt, og er mulig for alle komponenter og hente. Redux/mobx er derfor mer passende n&#229;r prosjektet vokser seg st&#248;rre og f&#229;r flere komponenter. Siden redux samler staten sin p&#229; ett sted er det ogs&#229; veldig forutsigbar, og man er trygg p&#229; &#229; f&#229; riktige verdier ut. Dette gj&#248;r ogs&#229; koden oversiktlig&#160;og er lett &#229; endre p&#229;, noe som er positivt om man gir fra seg prosjektet. Men man m&#229; passe seg for &#229; ikke dytte for mye logikk inn i redux. Enkle inputs b&#248;r bli behandlet i komponent-hierarkiet fordi redux kan f&#248;re med seg en del overhead. Og enklere prosjekter trenger heller ikke sette opp redux, da det er enklere med state-hooks.<\/p><p>En annen ulempe med redux kan v&#230;re at prosjektet blir langt mer komplekst enn hva man trodde i begynnelsen, og at man &#248;nsker &#229; ta i bruk redux midt i prosjektet. Dette kan f&#248;re til store endringer i koden da det tar en del tid &#229; sette opp redux. (https://www.smashingmagazine.com/2016/06/an-introduction-to-redux/)<\/p><p>&#160;<\/p><p>N&#229;r det kommer til dataflyt i react er det vanlig &#229; bruke props. Dette er en m&#229;te &#229; sende data nedover i hierarkiet til neste komponent. Hvis man for eksempel &#248;nsker &#229; lage flere tabeller p&#229; en nettside, kan man i en komponent ha logikk til &#229; lage en tabell med en overskrift. Mens man i denne overskriftene kun kaller p&#229; props, kan man i overliggende komponent kalle p&#229; x antall tabellkomponeneter med egen overskrift som parameter. Slik kan man gj&#248;re det enklere med gjenbruk i react, noe som gj&#248;r prosjektet langt mer agilt og raskere. Men om prosjektet blir stort og det er mange komponenter b&#248;r man holde tunga rett i munnen om man sender props i en lang kjede nedover i hierarkiet, her er det lett &#229; st&#248;te p&#229; feil og bugs.<\/p><p>&#160;<\/p><p>For &#229; hindre slike feil med props kan man bruke Context. Dette er en innebygd funksjon i react som kan lagre props globalt, alle komponenter kan f&#229; tak i det. I v&#229;rt prosjekt brukte vi Context til &#229; sende en &#34;theme&#34; som alle nettsider m&#229;tte ha tak i om man endret det p&#229; nettsiden. P&#229; denne m&#229;ten kan Context forenkle prosjektet drastisk. Men man b&#248;r begrense seg med bruken ogs&#229;. Om det kun er &#233;n eller to komponenter som faktisk beh&#248;ver propsene er det overfl&#248;dig &#229; bruke context. Funksjonen kan ogs&#229; hindre mulighetene for gjenbruk av kode, s&#229; man b&#248;r avveie om det er n&#248;dvendig/hjelpsomt &#229; implementere det.<\/p><p>(https://reactjs.org/docs/context.html)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2276,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil blir brukt som et state-management verkt&#248;y der hver endring i staten utl&#248;ser en update av siden. Hovedkonseptet med biblioteket er at state ligger i&#160;<em>atomer<\/em>&#160;som kan oppdateres eller f&#248;lges. Ved endring av staten re-rendrer komponentene som f&#248;lger atomet.&#160;<em>Selectorer&#160;<\/em>er funksjoner som tar inn atomet og behandler dataen til enten &#229; bli akseptert i en annen selector, eller til &#229; bli visuelt representert i en komponent. Kan p&#229; mange m&#229;ter sammenlignes med funksjoner lagt inn i en funksjonell komponent f&#248;r return. Selectorene kan ogs&#229; oppdatere state/f&#248;lges av komponentene. Tilslutt tar komponentene i bruk dataen fra selectorene som har gjort h&#229;ndteringen enklere.<\/p><p>&#160;<\/p><p>Fordelen med dette er at forenkler sv&#230;rt interaktive sider. Det er lett &#229; begrense hva som skal oppdateres/re-rendres slik at siden blir s&#229; effektiv og rask&#160;som mulig. Det kreves heller ikke noe eget oppsett av en &#34;store&#34; slik det gj&#248;r i redux, noe som er tidsbesparende og enklere.<\/p><p>&#160;<\/p><p>Recoil er ogs&#229; enkelt &#229; implementere i komponentene, og fungerer ganske likt som state-hooks. Dette er positivt, men ikke utelukkende bedre enn redux da dette ogs&#229; er greit &#229; implementere ved hjelp av useSelector&#160;og dispatch.<\/p><p>&#160;<\/p><p>Recoil fungere ogs&#229; bedre enn Context p&#229; flere m&#229;ter, bl. a. ved at context bare kan lagre &#233;n verdi. Og at context bare kan bli brukt om den ligger p&#229; p&#229; h&#248;yeste forelder av de som deler den, der hvor recoil er global og kan brukes hvor som helst.<\/p><p>&#160;<\/p><p>Ulempene med recoil er at prosjektet ofte m&#229; v&#230;re ganske komplisert for at det skal l&#248;nne seg ytelsesmessig, da det er enda enklere igjen &#229; bare bruke state-hooks. Biblioteket er ogs&#229; ganske nytt, og er fremdeles under utvikling s&#229; noe bugs m&#229; man regne med.<\/p><p>&#160;<\/p><p>Oppsummert er recoil omtrent like enkelt &#229; bruke som de innebygde state-hooks, men at det ogs&#229; ligger globalt og er enkelt &#229; hente. Biblioteket l&#248;ser de ovennevnte problemene til context, og er langt enklere &#229; implementere enn redux. Ulempen med &#229; bruke det n&#229; er at det enda er ganske nytt og under utvikling.<\/p><p>&#160;<\/p><p>(https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1986,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den st&#248;rste forskjellen mellom REST og GraphQL er responsen n&#229;r man requester fra endepunktet. REST vil alltid returnere all dataen som er requestet og man ikke begrense s&#248;ket til n&#248;yaktig det man &#248;nsker. Det kan man gj&#248;re i GraphQL. Der kan man bestemme hvilke deler av den mulige responsen man &#248;nsker &#229; ta med seg slik at man kun f&#229;r tak i det man &#248;nsker. Dette hindrer over/underfetching, som er det store problemet til REST.<\/p><p>&#160;<\/p><p>En annen ting er at REST helst vil bruke data som kommer fra &#233;n kilde, og ikke flere. Grunnen er at det m&#229; tas flere runder med serveren for &#229; hente &#248;nsket data. GraphQL derimot kan forme en query som kun kontakter ett endepunkt, noe som s&#248;rger for kun en runde med serveren for &#229; hente &#248;nsket data. (https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083)<\/p><p>&#160;<\/p><p>Det positive for REST er at n&#229;r dataen f&#248;rst er hentet, er det mulig &#229; cache det. Noe som ikke er mulig for GraphQL.<\/p><p>&#160;<\/p><p>Bruken av REST og GraphQL kommer derfor helt an p&#229; hva ett prosjekt trenger. For komplekse s&#248;k og datasett er GraphQL bra, da man kan snevre inn s&#248;ket veldig. Mens REST kan v&#230;re bedre hvis du beh&#248;ver &#229; fleksibel, f. eks. ved flere forskjellige kall til server, samt forskjellige representasjoner av data.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11542633,"ext_inspera_userAssessmentSetupId":7140092,"ext_inspera_userAssessmentId":4841523,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:01:16Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Halvorsen Magne (10030)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":50644450,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":871,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Komponentene er ordnet i en trestruktur.<br />Der alle komponenter har en forelder, og kan ha flere barn.<br />En komponent kan ha tilstand.<br />Denne tilstanden er tilgjengelig i komponenten selv,<br />og innholdet i tilstanden kan sendes nedover i hierarkiet.<\/p><p>For &#229; la data flyte oppover i hierarkiet,<br />kan man la et komponent sende en funksjon, som endrer tilstanden sin, nedover i hierarkiet.<\/p><p>React tilbyr ogs&#229; en m&#229;te &#229; dele data p&#229; over et subtre av komponentstrukturen kalt &#34;context&#34;.<br />Context&#160;gj&#248;r det mulig &#229; ha sende data nedover i hierarkiet uten at den m&#229; innom alle komponentene p&#229; veien. Context er ikke designet for hyppige oppdateringer av tilstand, men heller noen f&#229; n&#248;kkelattributter som innloggingstatus, tema etc. som ikke oppdateres s&#229; ofte.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2849,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil lar oss lage tilstand som en rettet graf.<br />Tilstandene lever i &#34;atoms&#34;, en enhet med tilstand.<br />Disse enhetene former r&#248;ttene til grafen.<\/p><p>&#34;Selectors&#34; er grennodene og l&#248;vnodene v&#229;re.<br />De kan lese verdien av &#34;atoms&#34; og andre &#34;selectors&#34;.<\/p><p>Tilstandene kan deles mellom komponenter ved at de abonnerer p&#229; et &#34;atom&#34; eller en &#34;selector&#34;.<br />N&#229;r en tilstand i et atom oppdateres, oppdateres komponentene som abonnerer p&#229; dette atomet.<\/p><p>Til forskjell fra Context, kan Recoil ha mange sett med verdier.<br />Context og Redux krever at man lager en &#34;store&#34; og at man pakker inn et subtre av komponentstrukturen i en &#34;Provider&#34;.<br />Med Recoil m&#229; man fortsatt pakke en del av subtreet inn i en RecoilRoot, men man trenger ikke en store for tilstanden.<br />Man oppretter den delte tilstanden og bruker den p&#229; samme m&#229;te som en lokal tilstand.<br />En annen konsekvens av dette er at man kun trenger &#229; oppdatere de komponentene som er ber&#248;rt av endringen i tilstanden,<br />i stedet for hele subtreet som er pakket inn i Provideren.<br />Dette medf&#248;rer mindre tid brukt p&#229; &#229; tegne opp igjen komponenter som ikke trenger noen endring.<\/p><p>Recoil fungerer bare for funksjonelle komponenter og ikke klassebaserte komponenter.<br />Dette gj&#248;r at det ikke er mulig &#229; bruke i eldre prosjekter som har klassebaserte komponenter,<br />uten &#229; skrive om alle komponentene til &#229; v&#230;re funksjonelle.<br />&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2406,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST APIer opererer med ressurser,<br />der man alltid henter en hel ressurs n&#229;r man gj&#248;r et kall.<\/p><p>Eksempelvis:<br />Hente en ressurs:<br />&#180;GET /movies/1&#180;<br />Svarer med:<br />&#180;&#180;&#180;<br />{<br />&#160; &#160; &#34;id&#34;: 1729<br />&#160; &#160; &#34;title&#34;: &#34;foo&#34;,<br />&#160; &#160; &#34;releaseYear&#34;: 1999,<br />&#160; &#160; &#34;runtime&#34;: 90,<br />&#160; &#160; &#34;directors&#34;: [42],<br />&#160; &#160; ...<br />}<br />&#180;&#180;&#180;<\/p><p>Her f&#229;r man all informasjonen om en ressurs, enten man trenger den eller ikke.<br />Her vil man ogs&#229; m&#229;tte gj&#248;re et nytt kall p&#229; &#34;directors&#34; hvis man vil ha detaljer om dem.<br />Formen p&#229; svaret og m&#229;ten man henter det p&#229;, er satt sammen.<br />Dette omtales som et &#34;endepunkt&#34;.<\/p><p>GraphQL opererer ogs&#229; med ressurser,<br />men her er ikke svaret p&#229; en sp&#248;rring fastsatt av hvilken ressurs man henter.<\/p><p>Tilgjengelige ressurser beskrives:<br />&#180;&#180;&#180;<br />type Movie {<br />&#160; &#160; id: ID<br />&#160; &#160; title: String<br />&#160; &#160; releaseYear: Int<br />&#160; &#160; runtime: Int<br />&#160; &#160; directors: [Director]<br />&#160; &#160; ...<br />}<\/p><p>type Director {<br />&#160; &#160; id: ID<br />&#160; &#160; firstName: String<br />&#160; &#160; lastName: String<br />&#160; &#160; dateOfBirth: Date<br />&#160; &#160; nationality: String<br />&#160; &#160; ...<br />}<br />&#180;&#180;&#180;<\/p><p>Man beskriver ogs&#229; tillatte sp&#248;rringer:<br />&#180;&#180;&#180;<br />type Query {<br />&#160; &#160; movie(id: ID!): Movie<br />&#160; &#160; director(id: ID!): Director<br />}<br />&#180;&#180;&#180;<\/p><p>S&#229; kan man gj&#248;re sp&#248;rringer mot API&#39;et ved &#229; sende formen p&#229; svaret man vil ha:<br />GET /graphql?query=&#34;{movie(id: 1729) {title, directors {firstName}}}&#34;<br />Svarar med:<br />&#180;&#180;&#180;<br />{<br />&#160; &#160; &#34;title&#34;: &#34;foo&#34;,<br />&#160; &#160; &#34;directors&#34;: [<br />&#160; &#160; &#160; &#160; { &#34;firstName&#34;: &#34;Srinivasa&#34; }<br />&#160; &#160; ]<br />}<br />&#180;&#180;&#180;<\/p><p>Med GraphQL kan man skreddersy en sp&#248;rring og f&#229; tilbake akkurat den informasjonen man trenger, og ikke mer.<br />Man har koblet formen p&#229; ressursene og m&#229;ten man sp&#248;r om dem fra hverandre.<br />Dette bidrar til &#229; redusere antall sp&#248;rringer man trenger &#229; gj&#248;re for &#229; f&#229; tak i informasjonen,<br />i forhold til et REST API.<br />Med f&#230;rre sp&#248;rringer med mindre redundant data, reduseres ogs&#229; datatrafikken.<br />&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11543119,"ext_inspera_userAssessmentSetupId":7139968,"ext_inspera_userAssessmentId":4841525,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:02:29Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Stensrud Christoffer (10022)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443673,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1303,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React tilstander (states) er m&#229;ten React kan endre hvordan UI-et ser ut over tid. React apper er bygget i et hierarki, der komponenter har flere komponenter under seg, eller ligger inne i andre komponenter (eller begge), dette kalles foreldre- og barn-komponenter henholdsvis.<\/p><p>Vi har en app som skal la brukeren telle hvor mange ganger hen klikker p&#229; en knapp: Vi trenger&#160;en komponent som viser en count for hvor mange ganger en knapp er klikket (&#34;ShowCount&#34;), samt en komponent med en knapp som skal &#248;ke denne counten med 1 hver gang knappen klikkes (&#34;IncreaseCount&#34;). Begge disse komponentene kan enkapsuleres i en foreldre-komponent som h&#229;ndterer tilstanden til appen (&#34;CountContainer&#34;).<\/p><p>Tilstanden som skal lagres er &#34;count&#34;, CountContainer vil dermed ha v&#230;re komponenter der selve tilstanden eksisterer. Hva counten er&#160;sendes ned til ShowCount slik at UI kan oppdatere antallet. Counten sendes til IncreaseCount som et prop, slik at n&#229;r en bruker oppdaterer counten i IncreaseCount vil den kunne sende den nye dataen &#34;opp&#34; til foreldre-komponenten.<\/p><p>&#160;<\/p><p>React har det som kalles for unidirectional data flow. Dette betyr at man ofte n&#248;ster barn-komponenter inne i foreldre-komponentene i appen. Foreldre-komponentene har en container som innehar staten til appen. Den kan s&#229; sende ned hva staten er akkurat n&#229; til barn-komponentene som kan oppdatere n&#248;dvendige omr&#229;der, eller komunisere tilbake til foreldrekomponenten med hva som m&#229; oppdatere seg i tilstanden. (En bruker har klikket p&#229; en knapp, eller sendt inn et form)<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3043,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for React. Biblioteket har videreutviklet data-flowen man kan se i vanlig native React. &#34;Atoms&#34; er en slags shared state, der atomene er alts&#229; en liten del av staten. Disse atomene kan oppdateres og abonneres p&#229; av andre komponenter. Dersom komponent A abonnerer p&#229; et atom og komponent B oppdaterer atomet, vil den nye tilstanden til atomet vises i komponent A.<\/p><p>P&#229; samme m&#229;te som en barn-komponent oppdaterer props til foreldre-komponentet og sender det videre til et annet barn-komponent.<\/p><p>Recoil minner meg veldig om MobX, da MobX ogs&#229; tar i bruk shared states.&#160;<\/p><p><br />En ulempe jeg kan se med bilbioteket er at det ikke har all funksjonaliteten som andre state management&#160;bibliotek kan tilby.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1606,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av de store problemene med REST API er at det ofte enten fetcher for lite eller for mye data.<\/p><p>&#160; &#160;For eksempel om vi har en applikasjon som skal vise fram navnene til forskjellige Pokemon&#160;s&#229; vil REST API mest sannsynlig treffe `/pokemon` endpointet som inneholder all data og attributter lagret ved Pokemon, som h&#248;yde og vekt. Dette er mer enn vi trenger &#229; hente ut, for vi &#248;nsker bare `/pokemon/name`.<\/p><p>&#160; &#160;P&#229; andre siden om vi &#248;nsker &#229; hente ut en array med de nyeste 2 pokemon i alle brukere sine pokedex s&#229; m&#229; vi ser p&#229; `/users/&#60;user-id&#62;/pokedex` for hver &#60;user-id&#62;. Med REST API m&#229; appen hente ut `/users` endpointet i tillegg til en `/users/&#60;user-id&#62;/pokedex` endpoint hvor hver bruker. Dette er ogs&#229; kalt n+1 problemet, siden appen henter ut n+1 antall endpoints i forhold til n brukere.<\/p><p>&#160;<\/p><p>GraphQL eliminerer mye av dette med at de tar i bruk queries, der appen spesifiserer eksakt hvordan data den skal hente ut, istedenfor &#229; h&#229;ndtere statiske endpoints slik som REST. Serveren leverer n&#248;yaktig det query-et ber om, p&#229; det formatet det blir bedt om. Eksempel:<\/p><p>&#160;<\/p><p>{&#160;<\/p><p>&#160; data: {&#160;<\/p><p>&#160; &#160; &#34;User&#34;: {&#160;<\/p><p>&#160; &#160; &#160; &#34;user-id&#34;: asdfgadfg23ewrgefg<\/p><p>&#160; &#160; &#160; &#34;name&#34;: &#34;Test Testingson&#34;,<\/p><p>&#160; &#160; &#160; &#34;pokedex&#34;: [<\/p><p>&#160; &#160; &#160; &#160; { &#34;name&#34;: &#34;Blastoise&#34; },<\/p><p>&#160; &#160; &#160; &#160; { &#34;name&#34;: &#34;Charmander&#34; },<\/p><p>&#160; &#160; &#160; ]<\/p><p>&#160;&#160; &#160;}<\/p><p>&#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>Videre s&#229; vil apper utviklet med henhold til REST API bli utviklet slik at endpointsa reflekterer hvordan appen er bygget opp. Dette er veldig lite dynamisk siden dersom frontenden endrer seg drastisk, m&#229; backenden mest sannsynlig endre seg ogs&#229;.Det tar dermed mye lenger tid &#229; videreutvikle applikasjoner med tanke p&#229; feedback fra brukere. GraphQL eliminerer denne drawbacken med en gang, fleksibiliteten til graphQL s&#248;rger for at endringer p&#229; frontenden kan gj&#248;res uten &#229; tenke altfor mye p&#229; backenden, siden man trenger bare &#229; spesifisere akkurat det man trenger.<\/p>"}]}],"ext_inspera_totalScore":7,"score":7}},{"result":{"sourcedId":11533608,"ext_inspera_userAssessmentSetupId":7139944,"ext_inspera_userAssessmentId":4841361,"dateLastModified":"2020-12-01T10:01:37Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:37Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Myhre Henrik Øberg (10188)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331021,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2961,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Redux:<\/strong><\/p><p>Redux er utviklet av Facebook og h&#229;ndterer states for javascript-applikasjoner. Redux er bygget opp rundt sin &#34;store&#34; som inneholder alle states og kan gj&#248;res tilgjengelig for et helt prosjekt ved &#229; bruke den i en Provider i &#248;verste niv&#229;. Redux bruker ogs&#229; actions og reducers. Actions dispatches n&#229;r en state&#160;i store skal endres. Actions sier til reducere at de skal oppdatere en state. Dette er et relativt omfattende, og det kan v&#230;re litt mye for et lite prosjekt. Alle komponenter som er subscribet til storen vil re-rendres ved en store-oppdatering, noe som f&#248;rer til un&#248;dvendig mange re-renders sammenlignet med andre alternativer. Redux er tett knyttet til React og vil trolig v&#230;re kompitabel med fremtidige endringer.&#160;<\/p><p>&#160;<\/p><p><strong>MobX:<\/strong><\/p><p>MobX&#160;er litt enklere &#229; h&#229;ndtere uten mye boilerplate. Dette er fordi MobX abststraherer mye av boilerplaten ved &#229; for eksempel automatisk lage listeners for &#229; reagere p&#229; endringer p&#229;&#160;observerbar data. Dette gj&#248;res ved innpakning i &#34;observable&#34;. I MobX kan det ogs&#229; v&#230;re flere stores, mens det kun er &#233;n i Redux. Dette kan separere UI-staten og domene-staten, noe som e.g. er nyttig for separat&#160;testing og gjenbruk av domene-staten.<\/p><p>&#160;<\/p><p><strong>Context:<\/strong><\/p><p>React tilbyr context for &#229; h&#229;ndtere states i en React-applikasjon. Context inneholder globale verdier og brukes ofte som en erstatning til props som sendes langt nedover et komponenttre. En ulempe er at context medf&#248;rer re-renders av alle komponenter, mens for eksempel redux kun re-rendrer oppdaterte komponenter. Context er i likhet med Redux tett knyttet sammen React, og vil ha de samme fordelene ved &#229; v&#230;re kompitable&#160;med fremtidige endringer av React.&#160;<\/p><p>&#160;<\/p><p><strong>Props:<\/strong><\/p><p>Props sender init state og sendes fra en parent-component til en child-component. Disse verdiene er statiske og brukes ofte til &#229; utforme children. For eksempel hvis man har en komponent for button, kan man sende label og funksjon som props for en spesifikk button. Dette gj&#248;r at alt som er felles for alle buttons kan gjenbrukes, men at buttonen samtidig kan v&#230;re spesifikk for sitt use-case.&#160;All annet state kan h&#229;ndteres i button-komponenten. For eksempel om den har blitt trykket p&#229; eller ikke Det kan ogs&#229; sendes en funksjon som lar barnet endre p&#229; state i en forelder.<\/p><p>&#160;<\/p><p><strong>State:<\/strong><\/p><p>(Her menes lokal state for en enkelt komponent.)&#160;Denne staten er avgrenset en komponent hvis ikke man sender den videre i props eller p&#229; en annen m&#229;te gj&#248;r den tilgjengelig for andre komponenter ved &#229; e.g. lagre den i storen til redux. I klassekomponenter kan man n&#229; staten ved this.state, mens i funksjonelle komponenter er man n&#248;dt til &#229; bruke hooken useState. Funksjonelle komponenter er egentlig stateless, men man kan alts&#229; implementere state ved hooks.Verdiene i state er oppdaterbare, i motsetning til props-verdier. I eksempelet mitt under &#34;Props&#34;, kan state v&#230;re naturlig &#229; bruke for &#229; holde styr p&#229; om en knapp har blitt trykket p&#229; eller ikke (S&#229;klart avhengig av hva man &#248;nsker &#229; bruke denne informasjonen til).&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2381,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Recoil:<\/strong><\/p><p>Recoil er et annet state-management bibliotek for React-applikasjoner som legger til funksjonalitet som er vanskelig &#229; oppn&#229; med React alene. Denne funksjonaliteten er noe lik funksjonalitet som kommer av andre state-management bibliotek, men er samtidig mer splittet opp, noe som har sine fordeler.&#160;<\/p><p>&#160;<\/p><p><strong>Fordeler:<\/strong><\/p><p>En fordel med Recoil er bruken av atoms og selectors. Atoms er som sm&#229; state-handlers, og selectors tar inn state som kan manipuleres. Selectors kan for eksempel brukes for &#229; filtrere en liste med data. Komponenter kan subscribe til b&#229;de atoms og selectors, og re-rendres kun hvis det de sbscriber til oppdateres. Dette medf&#248;rer mye f&#230;rre re-renders enn hva e.g. Redux og Context f&#248;rer til fordi alle komponenter som er subscribet til storen eller contexten re-rendres. Dette gj&#248;r at applikasjonen som helhet har mye mer spesifikke re-renders.<\/p><p>&#160;<\/p><p>En annen fordel er at Recoil er sv&#230;rt tett knyttet til React og vil antagelig v&#230;re relativt godt og raskt kompotabelt med nye React-features. Dette er for eksempel ikke tilfellet for MobX. Redux og Context er ogs&#229; tett knyttet til React.&#160;<\/p><p>&#160;<\/p><p>I tillegg kan det anses som en fordel at state-funksjonaliteten kan bringes inn i spesifikke komponenter, noe e.g. redux ikke medf&#248;rer, som har logikken separat.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; veldig mye mindre boilerplate enn for eksempel Redux har. Dette gj&#248;r det litt enklere &#229; bruke siden det ikke krever en like bratt l&#230;ringskurve. MobX har ogs&#229; mindre boilerplate enn Redux, og blir ogs&#229; sett p&#229; som fordelaktig basert p&#229; dette aspektet.&#160;<\/p><p>&#160;<\/p><p><strong>Ulemper:<\/strong><\/p><p>En ulempe ved Recoil som forekommer av oppsplittingen (ved atoms og selectors) ligner litt p&#229; ulempen&#160;til REST sammenlignet med GraphQL. Man blir n&#248;dt til &#229; subscribe til mange atoms eller selectors dersom en komponent skal ha tilgang til mye data i forskjellige atoms. Applikasjoner der dette er n&#248;dvendig&#160;kan&#160;l&#248;ses&#160;bedre ved bruk av e.g. Redux. Man kan vel kun ha ett atom for all dataen, men da forsvinner poenget med &#229; bruke Recoil.&#160;<\/p><p>&#160;<\/p><p>Recoil er spesifikt en React-utvidelse. MobX har mer universale bruksomr&#229;der.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1776,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>REST:<\/strong><\/p><p>Man definerer flere endupunkt i REST, men man kan ogs&#229; definere kun ett endepunkt. Her bruker URl og HTTP requests for &#229; endre p&#229; eller lese data. En fordel med REST som ikke er mulig i GraphQL, er caching-mekanismen som gj&#248;res i alle nettlesere. En annen fordel er at det er veldig enkelt &#229; bruke p&#229; grunn av simpelheten ved at ett endpoint utf&#248;rer &#233;n oppgave. Dersom man skulle&#248;nske &#229; hente my informasjon som blir n&#248;dt til &#229; stamme fra mange endpoints, er man n&#248;dt til &#229; gj&#248;re mange kall. Man kan heller ikke bestemme hvilke data som skal returneres. Det &#229; motta for mye data kalles overfetching. Tilgjengelige operasjoner for REST&#160;er GET, POST, PUT og DELETE. Her er det ikke n&#248;dvendig med body.<\/p><p>&#160;<\/p><p><strong>GraphQL:<\/strong><\/p><p>GraphQL l&#248;ser overfetching ved &#229; definere hvilke data som skal returneres eller oppdateres sammen med s&#248;ket ved &#229; bruke queries. Dette gj&#248;r at man unng&#229;r overfl&#248;dig data og un&#248;dvendig prosessering, samt &#229; s&#248;ke i forskjellige endpoints. Dette gj&#248;r ogs&#229; utviklingen raskere fordi man slipper &#229; lage mange endpoints, som man m&#229; ved &#229; bruke REST. Ulemper ved GraphQL er at det ikke st&#248;tter andre dataformater enn JSON-data, og at det i motsetning til REST ikke tillatter cachig-mekanismen til browsere. Det er ogs&#229; noe mer komplisert enn REST siden man m&#229; spesifisere b&#229;de s&#248;k og data, noe som kan medf&#248;re en litt brattere l&#230;ringskurve.&#160;En annen forskjell er at GraphQL benytter seg av&#160;et skjema som bestemmer struktur og typer. Dette &#229;pner for validering og binder tjener og klient tettere. GraphQL er nyere enn REST, og de kan ogs&#229; bli brukt sammen dersom det er fordelaktig. GraphQL bruker kun operasjonen POST fordi det er query-basert, noe som betyr at det ikke spiller noen rolle hvordan request du gj&#248;r siden querien ligger i bodyen. Det m&#229; derfor alltid inkluderes body.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533617,"ext_inspera_userAssessmentSetupId":7139922,"ext_inspera_userAssessmentId":4841500,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Husnes Sandra Helen (10105)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34495985,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3503,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har et eget system for &#229; holde orden p&#229; tilstand&#160;og dataflyt med State og Props. State i React lagrer dataene til komponenetene, og har asynkron oppf&#248;rsel. Den blir definert i konstrukt&#248;ren og har funksjonen setState() for &#229; oppdatere tilstand. Hooks i React tillatter at man har states selv om komponentene er funksjonelle komponenter ved bruk av f.eks.: [state, setState] =&#160;useState(0) og man oppdaterer state ved &#229; kalle p&#229; setState().<\/p><p>&#160;<\/p><p>Dataflyten i React er one-way-data binding, som betyr at dataene blir sendt fra foreldre komponenten til barnekomponenten. Props er immutable og blir brukt for &#229; sende dataflyten nedover i hierarkiet. For &#229; sende props oppover i hierarkiet bruker man callback-funksjoner, som tillater barn &#229; endre state hos forelderen.<\/p><p>&#160;<\/p><p>Hvis det derimot er en kompleks applikasjon, vil den innebygde h&#229;ndteringen av dataflyt og states fort bli uoversiktlig siden states har en tendens til &#229; flytte seg oppover i hierarkiet til foreldrekomponenten, og det blir ogs&#229; un&#248;dvendig komplisert. Da kan man benytte seg av en global state som gj&#248;r at alle dataene vil lagres p&#229; ett sted, og man setter opp automatiske oppdateringer for komponenter n&#229;r dataene har behov for endring.<\/p><p>&#160;<\/p><p>For enkel global h&#229;ndtering av states og dataflyt har React Context. Context tillater at dataene g&#229;r nedover gjennom hierarkiet uten at det er et behov f&#229;r &#229; gi props p&#229; hvert niv&#229; den bes&#248;ker manuelt. Context gj&#248;r da at mange komponenter kan dele de samme verdiene/statene uten at det f&#248;rer til un&#248;dvendige komplikasjoner. Likevel er ikke Context egnet for &#229; h&#229;ndtere states som endres ofte eller states av en viss&#160;kompleksitet.<\/p><p>&#160;<\/p><p>Til React applikasjoner blir bl.a.&#160;Redux, MobX, og Apollo Client&#160;brukt for global state management for mer komplekse applikasjoner. Redux er bygget p&#229; best-practise design, og bruker actions og&#160;reducers som mekanismer for &#229; h&#229;ndtere states (som lagres i store(s)) og&#160;dataflyten til komonentene. MobX har mekanismene actions og observables, der MobX selv holder styr p&#229; alle stedene hvor observables har blitt brukt. Dermed er mye av det som skjer for &#229; h&#229;ndtere states/dataflyt&#160;skjult, men syntaksen er enklere. Apollo Client har ogs&#229; en enklere syntaks enn Redux, da den automatisk utf&#248;rer normalizing og denormalizing av dataene, og den har kontroll over alle dataene gjennom en enkelt kilde i steden for &#229; synkronisere de mellom flere stores (som er tilfellet i Redux med eksempelvis lokale og eksterne data).<\/p><p>&#160;<\/p><p>https://reactjs.org/docs/context.html<\/p><p>https://dev.to/adriantwarog/mobx-vs-redux-comparison-41bo<\/p><p>https://www.apollographql.com/blog/demystifying-cache-normalization/<\/p><p>https://leapgraph.com/graphql-redux-apollo<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2098,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managemenet bibliotek for React og kan sammenlignes med Context, Redux, MobX og Apollo Client, som alle hjelper React med h&#229;ndtering av states og data.<\/p><p>&#160;<\/p><p>Recoil best&#229;r av atoms og selectors, der atoms er delte states, som kan som ogs&#229;&#160;kan brukes i steden for Reacts lokale state-komonent; mens selectors are rene funksjoner som tar inn atoms eller selectors som input, og omformer atom state synkront eller asynkront.<\/p><p>&#160;<\/p><p>Mulige fordeler med Recoil er at man kan lage en dataflyt graf som g&#229;r fra delte states gjennom selectors og direkte ned til React komonentene uten at man f.eks. m&#229; legge de i store(s), i tillegg til at man ikke trenger &#229; re-rendere hele applikasjonenstreet hver gang states oppdateres.<\/p><p>&#160;<\/p><p>En vesentlig ulempe med Recoil er at den er bygget med React primitiver, og dermed ikke kan bli brukt utenfor React prosjekter. Recoil er ogs&#229; fortsatt under utvikling og har ikke det store spekteret av dokumentasjon, verkt&#248;y osv. slik som det<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1546,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er en programvarearkitektur stil og definerer ulike endepunkter for lesing, skriving eller redingering av entiteter ved hjelp av URI og HTTP requester, og det er definert hva slags data som blir returnert for en entitet.<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k (query language), og fungerer ved at man sender en sp&#248;rring til server hvor man definerer s&#248;k og hvilke data som skal returneres/oppdateres, og er dermed definert kun over ett endepunkt.<\/p><p>&#160;<\/p><p>Fordelen med REST er at caching-mekanismen som st&#248;ttes av alle nettlesere. REST&#160;har blitt en kjent standard noe som ogs&#229; gir den en fordel, siden den da er sv&#230;rt mye brukt,&#160;har god dokumentasjon og gode verkt&#248;y for utvikling. Likevel har den sine ulemper med at jo mer kompleks informasjonen er, desto flere endepunkter blir det, og man m&#229; utf&#248;re mange kall for &#229; hente ut de dataene man trenger. Dette kan ogs&#229; resultere i overfetching, der man henter mer data enn man trenger.<\/p><p>&#160;<\/p><p>GraphQL derimot har ikke mulighet for cashing i HTTP-laget, og den st&#248;tter kun JSON-data, noe som er ulemper. I tillegg er GraphQL relativt nytt noe som gj&#248;r at det kan v&#230;re mer komplisert/utfordrende &#229; implementere noe fra bunnen av siden det finnes betydlig mindre dokumentasjon/eksmpler p&#229; bruk enn det som er tilfellet for REST.&#160;En annen forskjell er at den bruker skjema for &#229; definere strukturer og typer, som skaper en tettere kobling mellom server og klient enn det REST har, og gir dermed mulighet for validering. Fordelene med GraphQL er at alle data hentes i kun &#233;n request, der REST til sammenligning m&#229; bruke flere, og man unng&#229;r derfor hele problemet med overfetching, i tillegg til typesystemet som ogs&#229; hjelper med muligheten for &#229; validere dataene.<\/p><p>&#160;<\/p><p>Kilde: https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533706,"ext_inspera_userAssessmentSetupId":7139999,"ext_inspera_userAssessmentId":4841385,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Wold Mathias (10221)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330901,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2881,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React-applikasjoner finnes det flere teknikker og mekanismer for tilstand og dataflyt. Hvis man f&#248;rst fokuserer p&#229; &#34;plain&#34; React uten tredjepartsbibliotek, kan man skille mellom det som kalles&#160;<strong>state,<\/strong>&#160;<strong>props<\/strong>&#160;og&#160;<strong>context<\/strong>.<\/p><p>&#160;<\/p><p>React-komponenter kan alle ha sin egendefinerte <strong>state <\/strong>(tilstand). Staten kan inneholde en eller flere variabler og datatyper. State kan initialiseres med en verdi, eller den kan bli definert som for eksempel &#34;undefined&#34; og senere bli oppdatert gjennom en lifecycle-metode (f. eks. hente data fra et API i componentDidMount/useEffect), eller via interaktivitet fra brukeren p&#229; siden (f. eks. trykk p&#229; en knapp).&#160;Dersom statens verdier brukes i render-funksjonen til komponenten, vil komponenten re-rendere innholdet p&#229; siden dersom staten endres.&#160;<\/p><p>&#160;<\/p><p>I og med at komponenter ofte opptrer sammen&#160;i et hierarki i React, er det vanlig &#229; sende en komponent sin state (parent) videre ned til sine under-komponenter (children). Dette gj&#248;res gjennom&#160;<strong>props <\/strong>(properties, egenskaper), og props er dermed ansvarlig for <strong>dataflyt nedover<\/strong> i hierarkiet. Alle komponenter kan ta i mot props, og ekstra praktisk er det ogs&#229; hvis typene til propsene er forh&#229;ndsdefinert (via. f. eks. TypeScript). For eksempel kan man fra en Account-komponent sende props i form av navn, e-post og telefonnummer ned til en &#34;dum&#34;&#160;komponent som viser denne dataen dynamisk i et profil-kort p&#229; nettsiden. &#34;Dum&#34; her betyr stateless, alts&#229; at profil-kort-komponenten ikke har egen state, men kun er avhengig av props i render-funksjonen. Dersom Account-komponenten endrer state (hvis man bytter bruker / logger ut), vil propsene som sendes ned til profil-kort-komponenten endres, og dermed vil den re-rendere.<\/p><p>&#160;<\/p><p>Props kan ogs&#229; brukes til <strong>dataflyt oppover<\/strong>&#160;i komponent-hierarkiet, gjennom callbacks.&#160;Dette er nyttig for eksempel hvis man har en komponent som renderer en &#34;dum&#34;&#160;form-komponent, med tilh&#248;rende logikk for &#229; sende formets data til en server n&#229;r man trykker &#34;Lagre&#34;. Da kan denne &#248;vre komponenten implementere funksjonen &#34;handleSubmit&#34;, og sende denne callbacken ned til formet gjennom&#160;propen &#34;onSubmit&#34;. Dermed sendes form-dataen fra formet opp til den &#34;smarte&#34; komponenten over, som jobber videre med dataen og kanskje sender det til api-et.<\/p><p>&#160;<\/p><p>&#197; sende props for langt opp eller ned i komponent-hierarkiet&#160;(prop-drilling) kan skape uoversiktlighet og bugs. Det er spesielt uheldig hvis man har data fra komponent A som skal brukes i komponent D, ogs&#229; m&#229; da dataen sendes (ubrukt) via props fra A til B til C til D. En l&#248;sning p&#229; dette er &#229; bruke React sin <strong>C<\/strong><strong>ontext<\/strong>. Ved bruk av Context kan man sende data mellom komponenter i hierakriet uten &#229; m&#229;tte g&#229; gjennom alle komponentene, alts&#229; kunne man sendt data direkte fra A til D. Man kan dermed tenke p&#229; Context som &#34;global&#34; data som alle komponenter kan aksessere. Dette er ogs&#229; veldig nyttig hvis man har data som skal brukes av mange komponenter, som et fargetema eller et brukerobjekt. Ved bruk av Context slipper man da &#229; gjenta props overalt i applikasjonen.<\/p><p>&#160;<\/p><p>Ut fra dette f&#229;r man en fin overgang til det som kalles <strong>state management<\/strong>, noe tredjepartsbibliotek som Redux og MobX tilbyr. Disse gir komponentene i&#160;applikasjonen tilgang til en &#34;global&#34; state, som kan opptre som den ene og den riktige&#160;datakilden i applikasjonen&#160;(globalt, man kan fortsatt ha lokal state i komponentene). Hvis man som eksempel ser p&#229; Redux, s&#229; er den globale staten, kalt store, read-only for komponentene og kan kun endres gjennon forh&#229;ndsdefinerte actions og reducers. Komponentene kan sende (dispatche) actions til storen, som blit tatt i mot av en reducer. Reduceren ser p&#229; hvilken action som ble sendt og p&#229; eventuell data som ble sendt med (payload), og &#34;reduserer&#34; dette til en ny store. Alle komponenter som lytter p&#229; storen (gjennom connect eller useSelector) vil da f&#229; med seg endringen i store og oppdatere seg deretter. &#197; dispatche actions er alts&#229; den eneste m&#229;ten &#229; endre den globale storen p&#229;, og man f&#229;r dermed god kontroll p&#229; staten i applikasjonen.<\/p><p>&#160;<\/p><p>(Kilder: Jeg har ikke brukt noen spesifikke kilder i denne oppgaven. Dette er kunnskap jeg har tilegnet meg gjennom semesteret gjennom arbeid med prosjektene og forelesninger.)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2422,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er, som Redux og MobX, et bibliotek som h&#229;ndterer state management i React. Det er en l&#248;sning som implementerer state management p&#229; en enkel m&#229;te ved &#229; unng&#229; boilerplate og ved &#229; v&#230;re s&#229; lik som React sin syntaks som mulig.<\/p><p>&#160;<\/p><p>State i Recoil implementeres gjennom&#160;<strong>Atoms<\/strong>. Et atom inneholder en n&#248;kkel (et unikt navn / ID) og en default-verdi. I komponenter kan man lytte til endringer i atoms og endre deres verdier direkte. Dette gj&#248;res gjennom hooken useRecoilState, som fungerer veldig likt som React sin useState. Forskjellen er at state-endring av et atom gjennom useRecoilState oppdatere alle komponenter som lytter p&#229; dette atomet, alts&#229; er det delt state.<\/p><p>&#160;<\/p><p>I Recoil finner man ogs&#229;&#160;<strong>Selectors<\/strong>. Selectors er rene funksjoner som tar imot atomer (eller andre selectors) som input og som returnerer data basert p&#229; dette. At de er rene funksjoner betyr at de alltid returnerer samme type data for samme input, og at de ikke har noen side-effects. For eksempel kan en selector basert p&#229; et atom som inneholder fullt navn p&#229; en person, returnere initialene p&#229; personen (Ola Nordmann --&#62; ON). De kan ogs&#229; utf&#248;rer asynkrone handlinger p&#229; atomene, slik som &#229; kalle p&#229; API-er med atomets innhold. Selectorene kan lyttes til p&#229; samme m&#229;te som Atoms gjennom useRecoilValue, og disse endrer verdi dersom atomet som den er bastert p&#229; endres.&#160;Felles for Atoms og Selectors er da at komponententer re-renderer n&#229;r deres verdier endres, men Selectorer sine verdier er read-only (de endres kun n&#229;r atomet endres).<\/p><p>&#160;<\/p><p>Sammenlignet med Redux og MobX kan man fort se at Recoil er enklere &#229; sette seg inn i grunnet lik syntaks som plain React hooks&#160;og f&#229; funksjoner/hooks. Det er ogs&#229; raskere &#229; sette opp Recoil&#160;i prosjektet enn Redux/MobX, da det ikke kreves noen form for boilerplate. Videre vil jeg sammenlikne med Redux, men mye gjelder ogs&#229; for MobX.&#160;Mens Redux krever oppsett av store, reducers og actions p&#229; forh&#229;nd, trenger man i Recoil&#160;kun &#229; definere en bit av state (atom) direkte (og eventuelle selectors) og bruke den med en gang. Videre vil man under utvikling generelt bruke mindre tid og kode p&#229; &#229; legge til ny funksjonlaitet i Recoil enn i Redux.<\/p><p>&#160;<\/p><p>I Redux er den globale staten read-only, og staten endres kun gjennom forh&#229;ndsdefinerte actions og reducers. I&#160;Recoil kan alle komponenter endre staten direkte, og m&#229;ten staten endres p&#229; kan v&#230;re forskjellig fra komponent til komponent. Dette kan v&#230;re en ulempe siden man fort kan miste kontrollen over staten, og man f&#229;r ingen &#34;single source of truth&#34; p&#229; samme m&#229;te som i Redux. Man kan selvf&#248;lgelig ogs&#229; se p&#229; dette som en&#160;fordel siden dette gj&#248;r staten og utviklingen mer fleksibel. Si man i Redux har en state som inneholder en liste av filmer, med en action og reducer for &#229; legge til nye filmer. Dersom man under utvikling plutselig trenger muligheten til &#229; slette hele denne listen (fjerne alt innhold), er man n&#248;dt til &#229; definere nye actions og reducers til denne hensikten, og man skaper mye mer kode i kodebasen. I Recoil derimot er det bare &#229; bruke useRecoilState direkte i komponenten for &#229; t&#248;mme listens innhold.<\/p><p>&#160;<\/p><p>Alt i alt kan man si&#160;at Recoil er &#229; foretrekke for mindre applikasjoner/kodebaser der man ikke har altfor mye global/delt state. Dette fordi det er raskt &#229; sette opp og krever mindre kode. Ved st&#248;rre prosjekter er nok Redux/MobX &#229; foretrekke, da man f&#229;r bedre oversikt over staten, man unng&#229;r mye feils&#248;king og man f&#229;r standardiserte m&#229;ter &#229; endre state p&#229; gjennom bruk av actions og reducers. Man kan sammenlikne dette valget som valget mellom &#229; bruke JavaScript alene eller &#229; ogs&#229; bruke TypeScript. F&#248;rstnevnte er raskest og egner seg for sm&#229; prosjekter, mens sistnevnte er nesten et must i st&#248;rre applikasjoner.<\/p><p>&#160;<\/p><p>(Kilde:&#160;https://recoiljs.org)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1819,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GrahpQL&#160;er begge arkitekturer for &#229; sende data mellom en klient og en server, alts&#229; web API-er. Selv om de i seg selv tilbyr samme overordnede funksjonlalitet, er de ganske ulike i b&#229;de egenskaper og bruk.<\/p><p>&#160;<\/p><p>En viktig forskjell er hvordan man f&#229;r tilgang til ressurser. I REST har alle ressurser unike URI-er, der de ulike URL-ene kan ta i mot ulike typer foresp&#248;rsler (GET, POST, PUT). Dette vil si at man er n&#248;dt til &#229; sende flere foresp&#248;sler til ulike URI-er for &#229; f&#229; tilgang til data som henger sammen, men som ikke er lagret samme sted. N&#229;r det gjelder GraphQL finnes det kun et enkelt endepunkt &#229; sende foresp&#248;rsler til, der man i foresp&#248;rslene kan definere hvilken data man &#248;nsker &#229; f&#229; i retur. Si man har en database for Twitter. Her lagres brukere, tweets og kommentarer i ulike tabeller i databasen. Si man &#248;nsker navnet p&#229; en bruker, brukerens tweets og tilh&#248;rende kommentarer til alle tweets.&#160;I REST er man da n&#248;dt til &#229; sende foresp&#248;rsle til bruker-endepunktet (f eks. med en ID) for &#229; f&#229; ut navnet p&#229; brukeren. Videre sender man en foresp&#248;rsel til tweets-endepunktet med brukerens ID for &#229; f&#229; ut alle tweets. Til slutt er man n&#248;dt til &#229; sende en foresp&#248;rsel med tweet-id-ene til kommentar-endepunktet for &#229; f&#229; ut kommentarene til tweetsene. I hvert steg her f&#229;r man ofte med mer data enn man trenger.&#160;I kontrast til dette kan man gjennom Grahpql sende en foresp&#248;rsel der man ber om en bruker med tilh&#248;rende tweets og kommentarer, i en og samme melding. Man kan ogs&#229; definere de feltene av data man &#248;nsker, slik at man unng&#229;r &#229; hente un&#248;dvendig mye data.<\/p><p>&#160;<\/p><p>En annen forskjell er at REST har implisitt caching av data hos klienten. Data fra for eksempel GET-requests kan dermed lagres lokalt til og aksesseres ved senere requests.&#160;Dette har ikke GraphQL (by default), man er n&#248;dt til &#229; utvikle slik caching p&#229; egenh&#229;nd (ved &#229; for eksempel bruke bibliotek som Apollo Client). REST tilbyr ogs&#229; overf&#248;ring av flere ulike datatyper, mens GraphQL kun st&#248;tter JSON.<\/p><p>&#160;<\/p><p>Mens REST er tilstandsl&#248;s, kan man si at man under GrahpQL har &#34;koblet sammen&#34; klient og server gjennom bruk av GraphQL sitt skjema for sp&#248;rringer. Dette skjemaet definerer typing for sp&#248;rringer og retur-verdier, som blant annet integreres veldig godt med TypeScript. Dette gj&#248;r det ogs&#229; mulig &#229; validere sp&#248;rringer p&#229; forh&#229;nd, og man m&#248;ter generelt p&#229; mindre feil og bugs enn ved bruk av REST.&#160;<\/p><p>&#160;<\/p><p>(Kilder: Jeg har ikke brukt noen spesifikke kilder i denne oppgaven. Dette er kunnskap jeg har tilegnet meg gjennom semesteret gjennom arbeid med prosjektene og forelesninger.)<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11537864,"ext_inspera_userAssessmentSetupId":7140040,"ext_inspera_userAssessmentId":4841386,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Øiseth Thomas (10206)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":17259506,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2272,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har hver enkelt komponent sin egen state. Denne staten kan v&#230;re definert i hver enkelt komponent, eller sendes ned fra parent-komponenten gjennom props. Ved &#229; sende states ned som props kan man bruke samme komponent til forskjellige ting. Dette er veldig praktisk, ettersom det gj&#248;r at man enkelt kan gjenbruke kode. Props kan enten settes som obligatoriske eller frivillige i en komponent.&#160;<\/p><p>Dataflyten i et react prosjekt starter &#248;verst i App. Parent-komponenten sender s&#229; informasjon nedover til mindre komponenter gjennom props. Slik sendes informasjonen nedover i prosjektet. Selv om data sendes nedover i applikasjonen, sendes state oftest oppover i hierarkiet. Dette kan fort bli utfordrende n&#229;r state skal &#34;g&#229; i mot str&#248;mmen&#34;.&#160; Derfor&#160;brukes ofte andre verkt&#248;y som Context eller Redux for &#229; p&#229;virke state lengre opp i applikasjonen, ettersom man som utvikler ofte kommer over situasjoner der en komponent lengre nede skal p&#229;virke hele nettsiden.&#160;<\/p><p>Et eksempel p&#229; dette er om man skal designe lightmode og darkmode p&#229; en nettside. Hvis man da lager en egen button komponent som skal bytte mellom disse, m&#229; den p&#229; en eller annen m&#229;te sende informasjon opp om hvilken state nettsiden skal ha. Context er da et mulig verkt&#248;y man kan utnytte for &#229; sette variabler som er tilgjengelig i hele react-applikasjonen. Staten til de &#248;vre komponentene kan s&#229; endres n&#229;r en bestemt variabel endrer seg.&#160;<\/p><p>Det er flere m&#229;ter &#229; p&#229;virke state p&#229;, og beste m&#229;ten &#229; gj&#248;re dette p&#229; avhenger av komponenten. I klassekomponenter kan man bruke &#34;this.state&#34;, ettersom komponenten oppf&#248;rer seg som et eget objekt. Funksjonelle komponenter har ikke &#34;this&#34;, s&#229; der m&#229; man bruke hooks som &#34;setState&#34; og &#34;useState&#34; for &#229; p&#229;virke state.<\/p><p>&#160;<\/p><p>Kilder:<\/p><ul>\t<li>React dokumentasjonen: https://reactjs.org/docs/<\/li><\/ul><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2130,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for &#229; h&#229;ndtere state i React. Det bruker en struktur av <em>atoms<\/em> og <em>selectors<\/em>, der <em>atoms<\/em> representerer state og <em>selectors<\/em> som er rene funksjoner. Selectors tar inn atoms som input og subscriber p&#229; endringer i atomene. Det betyr at hvis det skjer en endring i et atom, vil selectorene som subscriber p&#229; dette atomet reevaluere seg selv. P&#229; samme m&#229;te som selectors subscriber p&#229; atoms, subscriber react komponentene p&#229; selectoren, s&#229; hvis selectoren endrer seg, vil komponenten rendres p&#229; nytt ogs&#229;. Hvert atom og selector m&#229; ha en unik id, som brukes for identifikasjon og feils&#248;king.<\/p><p>&#160;<\/p><p>React recoil er veldig effektivt og forhindrer mange un&#248;dvendige rerendringer av komponentene, ettersom alle komponentene ikke m&#229; rendres p&#229; nytt med en gang staten endrer seg. Dette skiller seg fra for eksempel React Context, hvor&#160;alle komponentene rendres p&#229; nytt, selv om dataen deres er den samme. Recoil utnytter ogs&#229; hooks bedre enn Redux, MobX og Context, ettersom disse tre ble alle utviklet f&#248;r hooks ble en greie.&#160;<\/p><p>&#160;<\/p><p>Recoil er et veldig nytt bibliotek, s&#229; fra et utviklerperspektiv kan det v&#230;re en utfordring &#229; finne kilder til hjelp utenfor dokumentasjonen. For eksempel er det trolig f&#230;rre tr&#229;der med sp&#248;rsm&#229;l p&#229; Stack Overflow om Recoil enn Context, MobX og Redux. For mer erfarne utviklere som har erfaring med de andre state-management verkt&#248;yene, er det ogs&#229; en ekstra overhead &#229; sette seg inn i et nytt bibliotek for et prosjekt. Man vet heller ikke helt om React Recoil n&#248;dvendigvis kommer til &#229; bli like utbredt som Context, Redux og MobX. Worst case can dette bety at Facebook kan stoppe support av Recoil i fremtiden dersom de ikke anseer biblioteket som en suksess, men dette er en relativt liten risiko. P&#229; den andre siden oppdateres Recoil ganske hyppig for &#248;yeblikket (Se Recoil blog:&#160;https://recoiljs.org/blog), som betyr at det stadig vekk forbedres og har et aktivt community som bruker og forbedrer det.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2344,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den grunnleggende forskjellen mellom REST API og GraphQL er at REST er et strukturert oppsett for applikasjoner som henter og sender data over et netverk, mens GraphQL er et query-spr&#229;k og andre redskaper som brukes for &#229; effektivt hente data fra et endpoint med HTTP.<\/p><p>&#160;<\/p><p>En av de store forskjellene mellom REST og GraphQL er mengden kall de trenger til databasen. GraphQL har ikke de samme problemene med over og under-fetching som REST har. REST returnerer alltid et fullt datasett, mens GraphQL henter alltid bare n&#248;yaktig den dataen du trenger. Dette betyr at REST har en st&#248;rre grad av over-fetching. GraphQL er derfor mye mer effektivt &#229; bruke en REST, ettersom det f&#248;rer til en lavere p&#229;kjenning p&#229; backenden. Siden GraphQL henter akkurat den informasjonen du trenger fra et endpoint, er den heller ikke utsatt for under-fetching. I REST f&#229;r du ikke n&#248;dvendigvis all informasjonen du trenger fra et endpoint. Dette betyr at du kanskje m&#229; gj&#248;re flere fetch-kall til databasen, som er mindre effektivt.<\/p><p>&#160;<\/p><p>En annen forskjell mellom GraphQL og REST er at GraphQL har st&#248;tte for &#229; hente relasjonell data. Dette betyr at hvis du for eksempel er p&#229; IMdB og s&#248;ker opp en film, s&#229; kan GraphQL hente informasjon om filmen fra en tabell, og s&#229; knytte detaljert informasjon om hver enkelt skuespiller i filmen opp til dataen om selve filmen. I REST ville dette krevd to kall til forskjellige endpoints i databasen.<\/p><p>&#160;<\/p><p>Ettersom REST er mye mer generelt og ethvert endpoint er designet for &#229; hente ut en type informasjon, er det mye lettere &#229; ta i bruk. GraphQL p&#229; den andre siden er en del mer komplekst &#229; sette seg inn i, ettersom alle sp&#248;rringene til databasen g&#229;r igjennom et endpoint. Det er derfor mye viktigere &#229; skrive gode queries i GraphQL for &#229; f&#229; ut den informasjonen du &#248;nsker. S&#229; selv om GraphQL er mer effektivt enn REST, s&#229; har det en brattere l&#230;ringskurve.&#160;<\/p><p>&#160;<\/p><p>En annen forskjell mellom REST og GraphQL er at GraphQL ikke har implisitt caching i HTTP-laget, mens REST kan basere seg p&#229; caching i nettleseren. GraphQL er ogs&#229; typet, noe REST ikke er. Dette kan gi GraphQL noen fordeler, ettersom du alltid vet hvilken type data du f&#229;r tilbake, mens i REST er ikke dette n&#248;dvendigvis sikkert.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11540270,"ext_inspera_userAssessmentSetupId":7140078,"ext_inspera_userAssessmentId":4841417,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:10Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Schirmer-Mikalsen Sondre (10157)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":38237947,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1898,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State i React er et javascript-objekt som lagrer tilstanden til en React-komponent. Dersom denne tilstanden endrer seg (f.eks. gjennom museklikk, inntasting osv. p&#229; nettsiden), vil komponenten oppdateres og lastes p&#229; nytt slik at den nye tilstanden blir tatt i bruk og rendret der komponenten kalles. For &#229; endre state, kan man benytte seg av setState-metoden. Denne metoden kan ta inn en funksjon som argument, som kan spesifisere hvilke(t)&#160;state-attributt som skal oppdateres, og hvordan verdien til denne attributten skal endre seg. Dette er nyttig &#229; bruke dersom den nye tilstanden avhenger av den n&#229;v&#230;rende tilstanden. setState-metoden kan ogs&#229; ta inn et state-objekt som argument, som vil overskride den n&#229;v&#230;rende tilstanden.&#160;<\/p><p>Dersom man &#248;nsker &#229; bruke state uten &#229; lage en selvstendig klasse, kan man bruke useState, som er en React-Hook som kan brukes til &#229; bruke state i funksjonelle komponenter.<\/p><p>&#160;<\/p><p>For &#229; h&#229;ndtere dataflyt i React-applikasjoner, brukes props (properties) til &#229; sende inn argumenter med&#160;verdier&#160;i komponentene slik at flere kall av samme komponent&#160;kan rendre forskjellige &#34;utgaver&#34; av komponenten. Man sender props i en komponent p&#229; samme m&#229;te som man setter HTML-attributter, og man kan h&#229;ndtere hvordan disse brukes i komponenten ved bruk av props.[attributt] eller this.props.[attributt] avhengig av om komponenten er en funksjonell komponent eller en klasse.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2486,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil-biblioteket har som form&#229;l &#229; forenkle og forbedre h&#229;ndtering av state i React, ved &#229; blant annet unng&#229; &#229; m&#229;tte &#34;pushe&#34; opp state til parent-komponenter. Med Recoil kan man opprette &#34;atomer&#34; som kan lagre state. De minner veldig om den innebygde staten i React, men kan tas direkte i bruk av flere komponenter. Komponentene kan aksessere atomene ved &#229; &#34;subscribe&#34;. Dersom et atom oppdateres, vil da komponentene som abonnerer p&#229; atomet rendres p&#229; nytt med oppdaterte verdier. For &#229; skrive til eller lese et atom fra en komponent, bruker man useRecoilState-hooken, som minner veldig om useState-hooken i React. Dersom en komponent endrer p&#229; tilstanden til atomet, vil ogs&#229; de andre komponentene som abonnerer p&#229; atomet rendres p&#229; nytt. Recoil har ogs&#229; selectors, som er funksjoner som aksepterer atomer som input og som oppdateres n&#229;r atomene endrer tilstand.&#160;<\/p><p>&#160;<\/p><p>Recoil fors&#248;ker &#229; l&#248;se det samme problemet som Redux; global tilstandsh&#229;ndtering. En fordel med Recoil kontra Redux er at det ser ut til &#229; v&#230;re enklere &#229; sette opp - det er ikke et separat store, og har et mindre kompleks oppsett.<\/p><p>&#160;<\/p><p>Med&#160;Context-API-et kan state deles mellom komponenter ved &#229; &#34;pushe&#34; den opp til foreldrer-komponenten, men det kan f&#248;re til un&#248;dvendig re-rendering av enkelt&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2763,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Med REST hentes&#160;informasjon ved &#229; opprette ett eller flere endepunkter gjennom &#229; sende HTTP-requests til spesifikke URL-er. Serveren definerer hvilke data som returneres, i motsetning til GraphQL, hvor serveren uttrykker hvilken informasjon som er tilgjengelig, og hvor det er klienten som bestemmer hvilken informasjon som skal hentes. Dette er en fordel med GraphQL kontra REST n&#229;r man h&#229;ndterer st&#248;rre datasett, ettersom man unng&#229;r &#229; hente redundant informasjon (overfetching) som ikke brukes av klienten.&#160;Med Graphql kan man sende sp&#248;rringer for &#229; hente all n&#248;dvendig data i &#233;n request. GraphQL kan ogs&#229; bruke et typesystem for &#229; forh&#229;ndsbestemme om en sp&#248;rring er gyldig.<\/p><p>&#160;<\/p><p>En fordel med REST er at GET-requestene er &#34;cacheable&#34;, som gj&#248;r at data som brukes ofte kan lagres i request-response-stien, og optimaliserer nettverket ved &#229; redusere b&#229;ndbredden og ventetiden p&#229; foresp&#248;rslene. GraphQL er ikke cahceable. Mens Graphql kan kun hente JSON-formatert data, st&#248;tter REST ogs&#229; XML og andre formater.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11541030,"ext_inspera_userAssessmentSetupId":7140111,"ext_inspera_userAssessmentId":4841390,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:13Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sverdrup-Thygeson Simen (10103)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":20866852,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2431,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er basert p&#229; komponentbasert utvikling hvor de ulike komponentene hver er ansvarlig for en &#34;bit&#34; av applikasjonen. Disse komponentene tar properties (props) n&#229;r de opprettes og data kan dermed flyte nedover i komponenthierarkiet. Props er immutable (de kan ikke endres) og dette er fordi props kan tenkes p&#229; som states bestemt av &#34;eierkomponenten&#34; til kompontenen som mottar props ved initialisering. Komponenten selv skal ikke kunne endre p&#229; disse dataene. I eierkomponenten derimot, vil propsene som sendes nedover i hierarkiet kunne endres hver gang komponenten re-rendrer. Alts&#229;, props er immutable men kan endres hver gang komponenten re-initialiseres.<\/p><p>&#160;<\/p><p>Props kan dog bare sendes nedover i hierarkiet, til child-komponentene til en gitt komponent, med mindre callback-funksjoner benyttes. En callback-funksjon vil si at en komponent sender en funksjon som props nedover til en child-komponent. Komponenten som f&#229;r callback-funksjonen som props kan da kj&#248;res i child-komponenten og dermed gj&#248;re state-endringer i parent-komponenten. P&#229; denne m&#229;ten kan data sendes oppover i komponenthierarkiet.<\/p><p>&#160;<\/p><p>Omfattende bruk av callbackfunksjoner kan dog fort bli rotete og trigge un&#248;dvendige re-renders. Derfor brukes ofte global state management n&#229;r flere komponenter er avhengig av samme data (og ogs&#229; child-komponentene trenger &#229; endre p&#229; dataene). Med states menes komponentenes tilstandsdata, som kan endres innad i komponeten i kj&#248;retid (i motsetning til props). State kan n&#229;s ved this.state dersom komponenten er klassebasert eller useState()-hooken dersom den er funksjonell. En endring av state vil trigge en re-render av komponenten. Dermed er det viktig &#229; ikke endre state n&#229;r man ikke trenger, for &#229; hindre un&#248;dvendige re-renders. Eksempelvis kan det v&#230;re lurt &#229; dele opp eventuelle useEffect()-funksjoner i flere mindre deler, ikke en monolitt-funksjon som endrer en rekke ulike states og dermed trigger un&#248;dvendige re-renders.<\/p><p>&#160;<\/p><p>Normalt vil dog states kunne v&#230;re mulig &#229; interagere med innad i komponenten, men ikke dersom&#160;global state benyttes. Dette betyr at applikasjonen som helhelt har et &#34;bibliotek&#34; med states som er tilgjengelige for alle komponentene. Data som skal deles p&#229; tvers av applikasjonen kan dermed lagres her, hvorp&#229; oppdatering (re-rendering) av kompontener som er avhengig av en gitt state vil skje automatisk ettersom denne staten endres i det globale &#34;biblioteket&#34;. Eksempler p&#229; global state management l&#248;sninger inkluderer MobX og Redux. Context og Apollo kan ogs&#229; brukes til global state data. Omfattende bruk av Context er dog ikke sett p&#229; som best-practice dersom applikasjonen har en betydelig mengde states som skal deles. Dette fordi&#160;alle komponentene som benytter seg av context-en vil re-rendres ved endring av Context-dataen, selv om ikke disse komponentene benyttet seg av den aktuelle staten som ble endret. Dermed brukes gjerne Mobx eller Redux i stedet. Disse er eksterne l&#248;sninger som m&#229; importeres inn i React. Redux krever gjerne en del mer overhead (m&#229; sette opp reducers osv.) enn MobX, men har mer mulighet for tilpasning. Redux benytter ogs&#229; kun en store (bibliotek for de globale state-ene), mens MobX kan ha flere. Redux blir dermed ofte brukt p&#229; st&#248;rre applikasjoner hvor den ekstra setup-en er &#34;verdt&#34; innsatsen. MobX har mindre overhead og brukes gjerne p&#229; noe mindre applikasjoner.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://reactjs.org/docs/context.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2749,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React, utviklet av Facebook. Biblioteket fungerer ved at man plasserer RecoilRoot h&#248;yt oppe i komponenthierarkiet. Dernest brukes s&#229;kalte atoms. Disse er deler av en state og kan bli lest fra og skrevet til fra alle komponeter (lenger nede enn&#160;RecoilRoot i hierarkiet). Alle komponenter som leser atom-verdier blir automatisk &#34;subscribed&#34; til atomet og vil dermed oppdateres automatisk&#160;n&#229;r atomet endres. For komponenter som ogs&#229; trenger &#229; endre atom-verdien brukes useRecoilState()-funksjonen. Denne fungerer veldig lignende som useState()-hooken vi er kjent med fra funksjonelle React komponenter. Til sist har man selectors, som representerer &#34;derived state&#34;, alts&#229; en transformasjon av en state, feks hvis en state blir sendt til en funksjon hvor den blir modifisert. Selectoren (den nye, modifiserte staten) kan deretter n&#229;s ved useRecoilValue()-hooken. Dette gj&#248;r det mulig med automatisk re-rendering av komponenter som ber&#248;res av en transformasjon av en state (og ikke staten selv).<\/p><p>&#160;<\/p><p>N&#229;r det kommer til fordeler, er Recoil APIet ganske simpelt og enkelt &#229; forst&#229;. Recoil-syntaksen mye om React sin egen useState()-syntaks og er dermed intuitiv for React-utviklere &#229; ta i bruk. Dette st&#229;r i relativt skarp kontrast til spesielt Redux, som kan f&#248;les un&#248;dvendig komplisert, spesielt i setup-fasen.<\/p><p><br />Recoil har sv&#230;rt lite boilerplate (mengde med setup n&#248;dvendig), i motsetning til spesielt Redux som er kjent for en betydelig mengde overhead, selv for sm&#229; applikasjoner. MobX har mindre overhead, men fortsatt mer enn Recoil.<\/p><p>&#160;<\/p><p>Recoil inneholder ogs&#229; async st&#248;tte uten &#229; beh&#248;ve tredjepartskomponenter. Derived state (selector) kan b&#229;de v&#230;re asynkron eller synkron uten &#229; modifisere komponentene som bruker den. I Redux benyttes som regel Redux Thunk middlewaren til asynkrone operasjoner, alts&#229; beh&#248;ves det et tredjepartsbibliotek. I MobX trenger ikke, i prinsippet, asynkrone prosesser noen spesialbehandling - s&#229; lenge de er markert/wrappet med &#34;action&#34;-kodeordet og &#34;flow&#34;-wrapperen brukes istedenfor async/await.<\/p><p>&#160;<\/p><p>En annen betydelig ulikhet er at Recoil ikke lagrer alle de globale statene i en/et f&#229;talls state-biblioteker slik som Redux, MobX og Context APIet. State (atom) definering kan gj&#248;res distribuert i de ulike komponetene, noe som gj&#248;r kode-splitting mye enklere. Dette kan dog ogs&#229; ses p&#229; som mer uoversiktlig og forvirrende da states som trigger re-rendering er spredt rundt i hele komponenttreet.<\/p><p>&#160;<\/p><p>Sammenlignet med Context APIet til React, er den viktigste fordelen med Recoil at oppdatering av states (atoms) kan gj&#248;res veldig granul&#230;rt, slik at kun ber&#248;rte komponenter m&#229; oppdateres. Som nevnt i oppgave 1 er Context veldig grov i m&#229;ten re-rendering trigges p&#229; og alle komponenter som benytter seg av contexten m&#229; oppdatere selv om kun en liten del av contextet oppdateres. MobX og Redux st&#248;tter for &#248;vrig ogs&#229; slik granul&#230;r state h&#229;ndtering. Context st&#248;tter heller ikke dynamisk introdusering av nye context providers, men denne funksjonaliteten kan forholdsvis enkelt gj&#248;res i Recoil med atomFamily og selectorFamily.<\/p><p>&#160;<\/p><p>Sist men ikke minst er Recoil et veldig nytt bibliotek og det er dermed fortsatt en del uvisshet rundt hvor godt det fungerer i praksis - selv om det virker veldig lovende. Biblioteker som Redux og MobX er mye mer etablerte og det er dermed knyttet mindre uvisshet til disse.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/<\/p><p>https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/p><p>https://mobx.js.org/actions.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1890,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST st&#229;r for REpresentational State Transfer og er en arkitektur for web-basert kommunikasjonen over HTTP protokollen. Arkitekturen bruker URI til &#229; identifisere ressurser og HTTP requests (GET, PUT, POST, DELETE osv.)&#160;for &#229; lese, endre, poste (opprette) eller slette ressurser. REST er ogs&#229; stateless, dvs&#160;at hver request inneholder alt som kreves for &#229; h&#229;ndtere foresp&#248;rselen, all session state er hos klienten.<\/p><p>&#160;<\/p><p>N&#229;r man setter opp et REST API, vil man sette opp endepunkter for &#229; kunne endre p&#229; ressurser. Dette gj&#248;res som sagt via HTTP og URI, dvs at man setter opp request handlers som utf&#248;rer forh&#229;ndsdefinerte handlinger med dataen som mottas. Dataen sendes som URL parametre.&#160;Request handlerne kan deretter brukes til &#229; enkelt lese, endre, opprette eller slette data, av eksterne applikasjoner. Et stor fordel med REST er ogs&#229; at man kan&#160;benytte seg av den innebygde caching-funksjonaliteten i som st&#248;ttes av alle nettlesere.<\/p><p>&#160;<\/p><p>N&#229;r det kommer til ulemper ved REST, kan man nevne at man ofte henter mer data enn man trenger (overfetching) og m&#229; gj&#248;re mange kall, dersom man &#248;nsker &#229; gj&#248;re mer&#160;kompleks data-uthenting/manipulasjon.<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k for lesing og manipulering av JSON data. Tjenesten baserer seg p&#229; at man sender en GraphQL sp&#248;rring til en server og presiserer hva slags data man vil f&#229; returnert (hvis noe). Et typesystem er implementert for &#229; st&#248;tte denne valideringen av datatype.&#160;Dermed kan man, i mye st&#248;rre grad enn ved REST,&#160;tilpasse sp&#248;rringen slik at man kan hente all dataen man trenger i &#233;n request, uten &#229; ogs&#229; hente ut en mengde un&#248;dvendig data.<\/p><p>&#160;<\/p><p>GraphQL har dog noen ulemper. For det f&#248;rste st&#248;ttes kun JSON-data. Selv om dette har blitt et&#160;veldig popul&#230;rt dataformat, hender det at man har behov for andre formater. For det andre kan man ikke benytte seg av caching i HTTP-laget slik som i REST. Caching kan likevel settes opp manuelt ved &#229; benytte andre biblioteker, men er ikke innebygget. Til sist kan det nevnes at man ogs&#229; m&#229; l&#230;re seg GraphQL sp&#248;rrespr&#229;ket. Dette er ikke uhyre komplekst, men spr&#229;ket endrer seg raskt og de fleste er ikke kjent med dette slik som de er kjent med HTTP protokollen og tilh&#248;rende syntaks.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://restfulapi.net/caching/<\/p><p>https://stablekernel.com/article/advantages-and-disadvantages-of-graphql/<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11541352,"ext_inspera_userAssessmentSetupId":7140049,"ext_inspera_userAssessmentId":4841491,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:20Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Græsdal Kaspar Paus (10175)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":32291588,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1158,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En tilstand (state) er en variabel som h&#229;ndteres internt i en komponent, som vil re-rendre komponenten dersom den forandres. States kan sendes som data&#160;til andre komponenter ved bruk av props. Props er data som er &#34;read only&#34;, og en parent-komponent har mulighet til &#229; sende b&#229;de funksjoner og states som props ned til child-komponenter. Ved at en child-komponent s&#229; kaller funksjonen den mottar av sin parent (dette kalles callback), kan den indirekte forandre tilstander&#160;til parent-en. Dette er en mekanisme for dataflyt i React-applikasjoner, og ved store hierariske komponent-strukturerer er det mye data som sendes/forandres&#160;oppover og nedover.&#160;<\/p><p>&#160;<\/p><p>Dersom komponent hierarkiet blir stort, kan det v&#230;re kronglete &#229; sende mye data rundt&#160;til ulike komponenter, da data kanskje m&#229; sendes gjennom komponenter som ikke har bruk for det. Det er her man f&#229;r bruk for API&#160;som lar deg definere globale variabler, slik at man slipper &#229; sende data opp/ned komponent-hierarkiet. MobX og Redux er eksempler p&#229; API som h&#229;ndterer tilstander globalt, og lar komponenter lese/skrive til tilstander uavhengig av plassen i komponent-hierarkiet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3424,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tilstand-h&#229;ndterings bibliotek for React. Det kan sammenlignes med l&#230;ringsm&#229;l om bruk av en state manager, slik som MobX og&#160;Redux (globalt) i prosjekt 3, eller Context i prosjekt 2. Ved bruk av MobX og Redux lager man en klasse/komponent med globale&#160;tilstander, som alle komponenter uavhengig av plass i komponent-hierarkiet kan lese fra og skrive til (I MobX sitt eksempel man m&#229; wrappe komponente i en Provider, f.eks Store.Provider).&#160;Det samme gj&#248;r Recoil. En ulempe med Mobx og Redux er at dersom en global tilstand forandres, vil alle komponenter som bruker globale tilstander re-rendre. Dette slipper man med Recoil; hvis en komponent oppdaterer en global tilstand, s&#229; vil kun de komponentene som bruker denne tilstanden re-rendre. Alt&#160;re-rendres alts&#229; ikke. Dette gj&#248;res ved bruk av &#34;Atoms&#34;. Atoms definerer tilstander, som komponenter s&#229; kan &#34;abonnere&#34; p&#229; via Selectors. Ved &#229; deklarere ulike Atoms for ulike komponenter, kan man re-rendre enkelte komponenter som bruker tilstander i ulike Atoms.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":910,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL bruker kun en sp&#248;rring for &#229; s&#248;ke og hente data, mens REST API m&#229; definere ett eller flere endepunkter for &#229; hente/endre data. Dette gj&#248;res via URI og HTTP requests. Dersom det er mye informasjon med flere endepunkter, kan det v&#230;re at man m&#229; gj&#248;re flere kall og&#160;blir n&#248;dt til &#229; hente mer data enn man trenger (overfetching). Dette problemet slipper man med GraphQL da man som sagt kun trenger en sp&#248;rring som s&#248;ker etter og henter data samtidig. I GraphQL er det mulighet for validering, i motsetning til REST. REST har mulighet for caching, det har ikke GraphQL. GraphQL st&#248;tter kun JSON-data, det gj&#248;r ikke n&#248;dvendigvis REST.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11532875,"ext_inspera_userAssessmentSetupId":7140108,"ext_inspera_userAssessmentId":4841458,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Johannessen Jakob Lund (10239)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34667945,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3450,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det er flere m&#229;ter &#229; gj&#248;re state og dataflyt i React p&#229;. Disse er sv&#230;rt mye diskutert, og det er ingen rett eller galt. Alle har sin preferanse og trives godt med det.&#160;<\/p><p>&#160;<\/p><p>Her lister jeg noen m&#229;ter og diskuterer forskjellige mekanismer og teknikker:<\/p><p><strong>1. Innebygd react state (Local state).<\/strong><\/p><p>Dette har v&#230;rt en kjenning for React utviklere over lengre tid. I klassekomponenter har det v&#230;rt mulig &#229; hente et state objekt, og sette et state-object ved &#229; bruke this.state, og this.setState.&#160;<\/p><p>Staten lever i komponenten, og vil settes til initialveriden hver gang komponenten rerendres. Dette gj&#248;r det vanskeligere &#229; lage web-apper hvor samme state kan brukes flere steder, og gj&#248;r at du m&#229; sende med callbacks til childs dersom en child component skal kunne gj&#248;re endringer p&#229; en parent.<\/p><p>I 2018 introduserte React hooks, og bringte med dette useState-hooken, som har gjort utvikling med functional components industristandard. For utviklere betyr dette at man ikke lenger trenger &#229; bruke Class Components for &#229; bruke den innebygde staten, noe som gj&#248;r koden mer lettlest, og enklere &#229; vedlikeholde.<\/p><p>&#160;<\/p><p>N&#229;r man jobber med mindre prosjekter er innebygde states veldig lett &#229; ha med &#229; gj&#248;re, da lesbarheten er mye bedre enn med andre tredjeparts-biblotek.&#160;<\/p><p>Dette skyldes at hele staten lever i samme komponent, og du slipper &#229; ta hensyn til stores, reducers, og hva n&#229; enn de andre biblotekene bringer. Derimot er dataflyten frav&#230;rende.<\/p><p>&#160;<\/p><p><strong>2. Context<\/strong><\/p><p>En teknikk, som ogs&#229; er litt diskutabel om det er en mekanisme for state, er &#229; bruke Context API-et.<\/p><p>Flere jeg har pratet med det siste &#229;ret (p&#229; diverse intervjuer) er p&#229; vei vekk fra Redux, og velger &#229; lage&#160;global states ved hjelp&#160;Context API-et. Dette gj&#248;r at man m&#229; skrive mye wrapper funksjoner for de globale statesene, men til gjengjeld f&#229;r man noe mer gloable states, som ogs&#229; kan hentes i &#34;child&#34; components (her brukt som komponenter som ikke har useState-hooken, og dermed ikke &#34;eier&#34; staten) uten &#229; sende det som props.<\/p><p>En klar ulmepe er at hele siden vil rerenderes dersom det gj&#248;res en oppdatering i staten, noe Redux blant annet tar h&#229;nd om ved &#229; kun oppdatere de komponentene som blir p&#229;virket.&#160;<br />Riktignok kan man klare seg godt med at det gj&#248;res oppdateringer i &#34;wrapper-laget&#34;, alts&#229; med &#60;Provider&#62;&#60;App /&#62;&#60;/&#62;-kode (her eksempel p&#229; et wrapper-lag) ved &#229; gj&#248;re gode useEffect-valg.<\/p><p>&#160;<\/p><p>Dataflyten i Context er relativt lik Redux, ettersom man vil m&#229;tte bruke en set&#60;name&#62;State()-funksjon hentet fra Context for &#229; oppdatere en imutable state, hvilket ligner mye p&#229; action creators. Derimot lever disse funksjonene i samme komponent som komponenten som bruker dataen, i stedet for i en action-creators-fil, hvilket kan v&#230;re noe mer lesbart.<\/p><p>&#160;<\/p><p><strong>3. Redux<\/strong><\/p><p>Redux har lange v&#230;rt goto-bibloteket for utviklere som &#248;nsker global state. Det har bringt mye funksjonalitet til React som gj&#248;r utviklingen av webapps mange hakk enklere enn &#229; sende props overalt.<\/p><p>Med Redux skiller man state-funksjonalitet ut av komponentene, som i en del tilfeller kan v&#230;re en fordel, men ogs&#229; en ulempe, hvilket jeg har diskutert i avsnittene over.<\/p><p>I Redux oppretter man en store, som inneholder all den globale staten. For &#229; gj&#248;re endringer p&#229; denne m&#229; man dispateche applikasjonene med en action creator. Deretter vil Redux s&#248;rge for at alle Mounted Components blir oppdatert med den nye staten. Trenger man &#229; bruke en state i en komponent henter man enkelt dette fra storen.<\/p><p>Staten er imutable, hvilket betyr at dataflyten alltid vil v&#230;re lik, med en dispatch av en action creator.<\/p><p>&#160;<\/p><p>Det at Redux kun har en store, alts&#229; en global state, har blitt kritisert, og andre bibloteker har fors&#248;kt &#229; utfordre dette med flere stores. Derimot l&#248;ser redux dette fint ved at createStore kan ta v&#230;re et store objekt best&#229;ende av flere reducers, for eks {userReducer, movieReducer}.&#160;<\/p><p>I produksjon er det ogs&#229; blitt en konvensjon &#229; lage &#34;ducks&#34;, alts&#229; mapper for hver reducer, med tilh&#248;rende aciton creators og action types, hvilket gj&#248;re redux mer lesbart enn &#229; ha dette i tre store filer. Her er redux ganske &#229;pent for forskjellige l&#248;sninger, hvilket bringer mange muligheter til forskjellige applikasjoner!<\/p><p>&#160;<\/p><p>Faktumet at Redux er soppas oppdelt, gj&#248;r det ogs&#229; enkelt &#229; teste de forskjellige funksjonene, og kan gi deg trygghet i at en reducer som er helt avgj&#248;rende, ikke feiler dersom du gj&#248;re en oppdatert. Dette vil v&#230;re mye vanskeligere med Context-l&#248;sningen for eks.<\/p><p>&#160;<\/p><p><strong>4. Mobx<\/strong><\/p><p>Redux har v&#230;rt mye kritisert for &#229; v&#230;re s&#229; mye boiler plate, og lite lesbart. Dette &#248;nsket utviklerene bak Mobx &#229; utfordre. Med et biblotek som lettere &#229; l&#230;re, og ogs&#229; &#248;ker utviklingshastigheten.&#160;<\/p><p>Derimot har Mobx flere fallgruver, s&#230;rlig n&#229;r det gjelder testing.&#160;<\/p><p>Mangelen p&#229; reducers, gj&#248;r det vanskelig &#229; teste funksjonaliteten, da hver state er avhengig av &#229; bli satt av ations, lignende action creators i Redux.&#160;<\/p><p>I tillegg er oppdateringer av states implementert med det de kaller &#34;Observable&#34;, alts&#229; at data blir oppdatert med en event listener, i stedet for &#229; rerendre hele komponenter, p&#229; samme m&#229;te som Redux&#160;gj&#248;r det. Dette blir noe abstrakt, da m&#229;ten &#34;React rerendrer komponenter&#34; er en litt vag m&#229;te &#229; se p&#229; problemet p&#229;, men riktignok ser jeg ikke p&#229; m&#229;ten react implementerer javascript p&#229; i runtime, som en avgj&#248;rende del av pensum, og tenker denne forenklingen er en grei m&#229;te &#229; forklare forskjeller p&#229;.<\/p><p>&#160;<\/p><p>I motsetning til innebygde states, er ikke mobx imutable. En state kan enkelt skrives over av enhver komponent, og gj&#248;r applikasjonen dermed mer s&#229;rbar. I st&#248;rre komplekse applikasjoner mener jeg dermed Mobx kan ha noen ulemper, men det virker &#229; gj&#248;re utviklingen av applikasjoner lettere og raskere.<\/p><p>&#160;<\/p><p><strong>5. Appollo<\/strong><\/p><p>Appollo er et biblotek skrevet for &#229; implementere et GraphQL-interface fra en server p&#229; en enkel m&#229;te. Dette gj&#248;res ved &#229; slippe boilerplate med Redux for &#229; hente data fra GraphQL, hvilket gj&#248;r utviklignen av siden mye raskere ettersom man kun trenger &#229; hente API-et fra Appollo i stedet for &#229; m&#229;tte skrive fetch-implementasjonen selv.&#160;<\/p><p>Dette ser ut til &#229; v&#230;re en fin l&#248;sning dersom man &#248;nsker &#229; bruke GraphQL.<\/p><p>Skulle gjerne skrevet mer om dette, men m&#229; dessverre bevege meg over p&#229; en ny oppgave!<\/p><p>TODO: Skriv mer utfyllende.<\/p><p>&#160;<\/p><p><strong>6. Recoil<\/strong><\/p><p>Skriver mer om dette i oppgave 2<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1794,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state biblotek som bringer native states til flere komponenter i hovedsak.&#160;<\/p><p>Grunnen til at Recoil er blitt utviklet er for &#229; slippe &#229; brukte metodene nevnt tidligere med Mobx, Redux og Context, men heller kunne dele en &#34;komponentstate&#34; i flere komponenter. Dette har recoil implementert med Atoms.<\/p><p>M&#229;ten atoms er implementert p&#229;, gj&#248;r det enkelt og raskt &#229; implementere i komponentene, og s&#248;rger for at alle komponenter som har subscribet til en atom vil v&#230;re oppdatert med siste state for den atomen.&#160;<\/p><p>&#160;<\/p><p>Dette bringer state-logikk tilbake til react komponenter, i motsetning til Redux som skiller dette ut i egne filer.<\/p><p>&#160;<\/p><p>I tillegg til &#229; ha atoms som man kan subscribe til for &#229; hente den faktiske staten, har Recoil ogs&#229; en innebygd selector som gj&#248;r at komponenter kan subsribe til denne for oppdateringer.&#160;<\/p><p>&#160;<\/p><p>Dette er tilsvarende en funksjon for &#229; gj&#248;re endringer p&#229; resultatet av staten n&#229;r det fetches, for eks at i stedet for &#229; returnere 14, s&#229; returnerer den &#34;14px&#34; som i eksempelet til recoil (linket til i oppgaven).&#160;<\/p><p>Selectoren gj&#248;r alts&#229; at komponenter som bare lytter til dette ogs&#229; vil oppdateres n&#229;r denne endres.<\/p><p>&#160;<\/p><p>Fordeler:<\/p><p>- Bringer state logikk tilbake i komponentene, dersom man &#248;nsker det<\/p><p>- Sv&#230;rt likt api som useState-hooken<\/p><p>- Bringer states til forskjellige komponenter uten &#229; m&#229;tte sendes med props eller andre tyngre bibliotek<\/p><p>- Selectors gj&#248;r at du kan gj&#248;re endringer p&#229; presentasjonen av states uten &#229; m&#229;tte gj&#248;re dette komponentvis, som gj&#248;r ulmepe #1 mindre aktuell<\/p><p>- Mindre rerendering da det kun er subscribed components som vil rerenders, og ikke et helt tre av komponenter<\/p><p>- Modul&#230;rt =&#62; det er fint mulig &#229; skrive reducers dersom man &#248;nsker det<\/p><p>- Krever moderne arkitektur<\/p><p>- Testing<\/p><p>- Presistent states<\/p><p>- Boilerplate free<\/p><p>- Open source<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>- Ganske &#229;pent api, s&#229; uten gode konvensjoner kan states bli behandlet i forskjellige komponenter, og kanskje skape forvirring ved st&#248;rre prosjekter (N&#229;r burde man begynne &#229; bruke reducers for eks)<\/p><p>- Nevner&#160;Presistent states i fordeler, men sliter med &#229; se helt hvordan dette er implementert og om dette er like bra som redux. Velger derfor dette som en ulempe dersom det ikke er like godt implementert som i redux, men vanskelig uten &#229; teste. &#197;pen for at dette kan v&#230;re en ulempe<\/p><p>&#160;<\/p><p>S&#230;rlig brukt disse kildene av recoil-docsene: &#160;(hentet 2020-12-01 mellom 10:00 og&#160;11:00)<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1918,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r man bruker RESTApis, lager man endpoints for behanlding av data. Dette er alle forskjellige URL-er som i backenden vil gj&#248;re forskjellige funksjoner. Her er det vanlig &#229; sende med forskjellige type requests, GET, PUT, POST og DELETE er s&#230;rlig de vanligste, og viktigste i et RESTApi.&#160;<\/p><p>&#160;<\/p><p>For &#229; hente forskjellig data er man alts&#229; n&#248;dt til &#229; bruke forskjellige endpoints, og dette resulterer i flere forskjellige URL-er&#160;som alle kan v&#230;re litt vanskelig &#229; holde oversikt over, noe som gj&#248;r frontend-utvikling&#160;vanskeligere enn om man kunne skrevet&#160;kvirien (en query = en&#160;kvirie i besvarelsen min)&#160;for &#229; hente data direkte i frontenden. I tilegg risikerer man &#229; hente mer data enn man egentlig trenger da /foo kan returnere {_id: &#34;uuid{....}&#34;, value: &#34;bar&#34;} for eks, hvor man kanskje kun trengte {value: &#34;bar&#34;}.<\/p><p>&#160;<\/p><p>Dette var grunnen til at Facebook&#160;utviklet GraphQL.&#160;<\/p><p>GraphQL er en teknikk for &#229; hente data fra en server (tjener) hvor kvirien for datafetch skrives direkte i POST-requesten fra frontenden. Grunnen til at man bruker en POST request og ikke GET for &#229; f&#229; data og POST for &#229; hente data, er at man m&#229; sende en kvirie i form av POST data p&#229; hver request. Dette gj&#248;r at man kun trenger ett endpoint for &#229; hente all mulig data fra serveren (backenden), typisk p&#229; /api/graphql.<\/p><p>GraphQL, implementerer med dete ogs&#229; et nytt kviriespr&#229;k, som bruker javascript-objekter for &#229; enkelt fetche, aggregere og sortere data p&#229; en intuitiv m&#229;te, ulikt SQL som typisk er mindre intuitivt.&#160;<\/p><p>&#160;<\/p><p>Dersom man lager en CRUD-app, alts&#229; en simple app hvor backenden hovedsakelig skal skrive til, og lese databasen er min erfaring at GraphQL ofte &#248;ker hastigheten p&#229; utviklingen, ettersom man definierer kun det man trenger av data fra hvor som helst i frontenden.&#160;<\/p><p>&#160;<\/p><p>Derimot er det ofte slik at man mangler litt avgj&#248;rende funksjonalitet ved GraphQL n&#229;r applikasjoner blir av en st&#248;rre kompleksitet. Eksempler p&#229; dette er hvis du trenger avansert logging etter et kall til en database, eller at du vil trigge en e-post dersom en bruker blir opprettet. GraphQL, som kun kan lese eller skrive data til databasen vil dermed ikke funke til dette.&#160;Her vil man trenge &#229; kj&#248;re kode av serveren for &#229; trigge e-posten.&#160;<\/p><p>&#160;<\/p><p>I dette tilfellet vil et RESTApi v&#230;re enklere &#229; bruke, siden&#160;en enkelt kan legge til en e-post trigger dersom endpointet blir kalt. Dermed er det ikke mulig &#229; hente, eller legge til data uten at det blir trigget en e-post.&#160;<\/p><p>&#160;<\/p><p>Et annet aspekt ved endpointsene er Caching.<\/p><p>For et RESTApi kan man legge til Caching av endpointet slik at om noen sp&#248;r om /a/b innen en viss tid, kan man mellomlagre det f&#248;rste kallet, og sende det allerede aggregerte datasettet direkte til brukeren. Man kan faktisk ogs&#229; gj&#248;re st&#248;rre kall i build time. Et eksempel p&#229; dette er det&#160;vi vurderte &#229; gj&#248;re i P3, for&#160;alle movies. Vi hadde 980 filmer, og det tok ca. 90 sekunder &#229; generere /movies for alle filmer, deretter kunne vi mellomlagret dette og sendt alle filmer til frontenden uten &#229; m&#229;tte aggregere fr&#248;st&#160;for &#229; gj&#248;re datafetch meget raskt.<\/p><p>Ettersom dette ikke er en s&#229; relevant for en app i produksjon av typen P3 var, valgte vi &#229; ikke jobbe med dette og heller fokusere p&#229; andre ting. Jeg&#160;ser derimot&#160;potensielle situasjoner hvor ogs&#229; dette kan v&#230;re av interesse med et RESTApi.<\/p><p>For eksempel kunne man gjort om bussruter til adresser i stedet for koordinater ved buildtime. Det&#160;er rett &#229; anta at disse ikke endres over tid. (M&#229; selvf&#248;lgelig legge til logikk dersom noe endres, og igjen, dette vil v&#230;re vanskelig &#229; garantere med GraphQL, men enkelt med REST, gitt argumentasjonen fra avsnitt over).<\/p><p>&#160;<\/p><p>GraphQL har ingen HTTP caching og kan dermed ikke dra nytte av &#229; mellomlagre&#160;data sendt til forskjellige brukere, eller samme brukere for den sags skyld.&#160;<\/p><p>Jeg mener dog at dette, i de tilfeller hvor man bruker GraphQL, ikke n&#248;dvendigvis er en s&#229; stor faktor, ettersom grunnen til &#229; bruke GraphQL burde v&#230;re at man &#248;nsker &#229; lett kunne endre hva slags data man henter, og sjelden hente samme kvirier. Dermed ville man f&#229;tt f&#229; like kvirier, som tar bort mye av fordelen med Caching.<\/p><p>&#160;<\/p><p>I tillegg er det en kjent greie at man ikke &#248;nsker &#229; mellomlagre brukerdata, noe som gj&#248;r at jeg mener mangelen p&#229; http caching ikke er et s&#229; stort problem i GraphQL.<\/p>"}]}],"ext_inspera_totalScore":14,"score":14}},{"result":{"sourcedId":11532912,"ext_inspera_userAssessmentSetupId":7140056,"ext_inspera_userAssessmentId":4842160,"dateLastModified":"2020-12-01T10:31:21Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:31:21Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Langåker Ragnhild Øie (10117)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":4901553,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2921,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I react bygger man opp koden ved &#229; lage kompontenter, disse komponentene kan v&#230;re en klasse eller en funskjon.&#160;Bruk av klasser er mer intuitive og mer forst&#229;lige med tanke p&#229; state og properties.&#160;<\/p><p>&#160;<\/p><p>State og dataflyt:&#160;<\/p><p>&#160;<\/p><p>Man bruker state for &#229; lagre komponentenes data, og som da ikke er en statisk props verdier. Dette gj&#248;r til at man slipper &#229; sende props gjernnom flere komponenter.&#160;State er et objekt med&#160;asynkron oppf&#248;rsel. State endres med setState. P&#229; denne m&#229;ten kan&#160;setState f&#248;lge med p&#229; data som endres og samtidig gj&#248;r at render kalles ved endring. Kan ogs&#229; bestemme ut fra setState hvilke verdier som skal endres, m&#229; ikke endre hele staten. P&#229; denne m&#229;ten kan man endre p&#229; de dataene man &#248;nsker og ikke hele. Det som er med state er at du ender det i run time, alts&#229; n&#229;r applikasjonen kj&#248;rer, og du eks trykker p&#229; en kanpp blir staten oppdatert. Det er alts&#229; en trigger for &#229; oppdatere UI. P&#229; denne m&#229;ten kan du oppdatere alle type ting i din UI.&#160;<\/p><p>&#160;<\/p><p>Dataflyt er den dataen som en applikasjon har.&#160;Om du har en sett med data er det ikke alltid du vil vise alt hele tiden p&#229; siden. Det er derfor man bruker state og behandling av dataflyt. Som om du trykker p&#229; en knapp for mer detaljer blir en funskjon kalt og oppdaterer staten s&#229;nn at den &#248;nsklige dataen vises p&#229; siden. Kan da hente ut &#248;nsklig data i stede for &#229; hente ut alt til en hver tid.&#160;<\/p><p>&#160;<\/p><p>N&#229;r man skriver i TS m&#229; man definere type for state, og disse skal intialisere i konstrukt&#248;ren.&#160;<\/p><p>&#160;<\/p><p>global state: &#160;Det er en state som kan brukes hvor som helst i en app uten &#229; m&#229;tte bli sendt som props gjennom flere komponenter. En m&#229;te &#229; kunne behandle state er &#229; bruke redux. Da er det enklere &#229; holde styr p&#229; kompontenter og states.<\/p><p>&#160;<\/p><p>useState: kan bruke staten<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3048,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et biblotek som brukes i react. Det gj&#248;r til at man kan utf&#248;re andre funksjonaliteter som er vanskelig &#229; f&#229; til med kun bruk av kun React. Recoil er en rask og fleksibel &#34;delig&#34; state, som vil si man har ulike ting som er&#160;&#34;insync&#34; i ulike deler av react treet. M&#229;ten den behandler data og sp&#248;rringer p&#229;, at man endrer states p&#229; en veldig robust m&#229;te&#160;s&#229;nn at man kan v&#230;re raskt og det ikke blir bugs. Har ogs&#229; en &#34;App-wide&#34; state observasjon, som gj&#248;r det lettere &#229; ha kontroll p&#229; eks tidsforskjell da Facebook blir brukt i hele verden.&#160;<\/p><p>Er spesielt designet for &#34;Pure&#34; funskjoner.&#160;&#160;Det ligner litt p&#229; Redux ved at den har &#34;undo&#34; opperasjoner, routing, feils&#248;king i tid&#160;osv.&#160;<\/p><p>&#160;<\/p><p>Facebook m&#229; behandle veldig mye data samtidig, det er veldig mange personer som endrer og bruker denne aplikasjonen samtidig. Recoil skal brukes for &#229; h&#229;ndere states p&#229; en annen m&#229;te som er mer rettet mot h&#229;ndering av bruken av data som facebook har. Da redux og react sin metode &#229; h&#229;ndere states p&#229; ikke ble opptimal.&#160;<\/p><p>&#160;<\/p><p>Man instalerer bibloteket i react og &#34;wrap&#34; rundt&#160;App s&#229; den skj&#248;nner at man skal bruke recoll, med RecoilRoot. Kan importere ulike funksjoner fra recoll som aton og useRecoilState. Aton representerer en del av staten. En hver komponent har mulighet til &#229; lese atom og har ogs&#229; mulighet til &#229; endre den. Om verdien av et atom endrer vil gjengitte komponenter gjengis. Gir atom en key som er unik ogs&#229; i forhold til andre atoms. Og setter en default verdi.&#160;<\/p><p>&#160;<\/p><p>useRecoilState sin funskjon er lik useState. S&#229; i en funskjon bruker man&#160;useRecoilState som kaller p&#229; et atom, for &#229; vite hvordan data man skal bruke i denne funskjonen.&#160;&#160;<\/p><p>&#160;<\/p><p>Selector, brukes om du vil hente ut deler av den &#34;derived&#34; staten. Og for &#229; kunne lese verdien til en selector bruker man&#160;useRecoilValue.&#160;<\/p><p>&#160;<\/p><p>Recoil er en fordel &#229; bruke om det er mange ulike brukere som skal endre ting samtidig. At det er mange oppdateringer og endringer i databasen og fra flere brukere til en hver tid.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3025,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>De er ulike m&#229;ter &#229; hente ut informasjon p&#229;. Du bruker REST API og Graphql der en bruker kan endre data( fetch data eller sende data til databasen)&#160;&#160;eks i en hjemmeside eller en app. Som kommentere et bilde, likes, lage en profil osv.&#160;&#160;Det blir oftes brukt JSON for data overf&#248;ringer for begge og de kan brukes til de fleste spr&#229;k og de er &#34;stateless&#34;.&#160;<\/p><p>&#160;<\/p><p>I REST bruker man GET/users og POST/product, som vil si multiple Endpoints. Du har en client side og en serverside, der serveren har logic, database, accesss osv. Clitenten sender sp&#248;rringer til serveren.&#160;<br />Ser p&#229; et eksempel der man vil hente ut informasjon om brukere som har kommentert p&#229; en brukers side.&#160;&#160;I REST m&#229; man da gj&#248;re et kall for hver, og man f&#229;r masse informasjon man ikke trenger for &#229; gj&#248;re andre kall.&#160;&#160;P&#229; den m&#229;ten f&#229;r man masse informasjon man ikke trenger til akuratt det kallet. Og det blir veldig mange kall. Men fordelen er at REST er lettere &#229; fors&#229;, n&#229;r man sender en get s&#229; henter man informasjon osv, s&#229; REST er mindre komblisert. Kankje best &#229; bruke om det skal v&#230;re mye informasjon (data) per side i applikasjonen din.&#160;<\/p><p><br />I GraphQL har man et kall. Du har en sp&#248;rring i stede for mange s&#229;nn som I REST. Og p&#229; den m&#229;ten f&#229;r du akuratt det du spurte om og ikke s&#229; mye annet. Men kallet i GraphQL m&#229; v&#230;re mye mer spesifikt for &#229; kunne f&#229; ut den informasjonen man &#248;nsker. Bruker kun et endpoint som er bare POST/graphgl. &#160;Kanskje best &#229; bruke om man skal v&#230;re mer spesifikk p&#229; informasjonen man &#248;nsker &#229; hente ut.&#160;<\/p><p>&#160;<\/p><p>S&#229; hovedforskjellen mellom&#160;REST API og Graphql er hvordan man sender sp&#248;rringer til dem. REST bruker ulike URL, som vil si at den er URL-driven. S&#248;prringen inneholder en http verb, en path og en body. Der man kan endre disse ut fra hva funskjon man &#248;nsker. Om man sp&#248;rr etter noe som REST ikke st&#248;tter f&#229;r man tilbake en error.&#160;Og den godtar ulike funskjoner, mens GraphQL kun godtar POST. &#160;S&#229; http vern og path er fixed og kan ikke endres. Det er kun i bodyen i sp&#248;rringen som kan endres og der har man en GraphGL sp&#248;rring.&#160;<\/p><p>&#160;<\/p><p>M&#229; mange m&#229;ter kan man tro at GraphQL er bedre da man kan ha en mer spesifikk sp&#248;rring. Men her kreves det at man l&#230;rer seg et nytt spr&#229;k for &#229; kunne skj&#248;nne hvordan sp&#248;rringen fungerer. Og p&#229; i GraphQl m&#229; man ofte laste ned ulike pakker for &#229; kunne bruke det dette slipper man i REST. Det kan ogs&#229; v&#230;re lettere &#229; bygge REST enn GraphGL, men det finnes 3parts komponenter&#160;som hjelper deg &#229; lage&#160;Graphql som apollo. S&#229; er det jo veldig inviduelt hva man foretrekker.&#160;<\/p>"}]}],"ext_inspera_totalScore":8,"score":8}},{"result":{"sourcedId":11532961,"ext_inspera_userAssessmentSetupId":7139949,"ext_inspera_userAssessmentId":4841450,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Mohn Erik (10033)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34745474,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2528,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React-applikasjoner er state og props grunnlaget for&#160;tilstand og dataflyt. State s&#248;rger for &#229; bevare lokal tilstand av en komponent, mens props brukes for dataflyt mellom komponenter. Ettersom man har to forskjellige m&#229;ter &#229; definere en komponent p&#229;, klasse eller funksjonelle komponenter, er det ogs&#229; forskjellige m&#229;ter &#229; definere og bruke state og props. I klassekomponenter vil man for eksempel sette state i en constructor, mens i funksjonelle komponenter vil man m&#229;tte bruke useState Hook-en for &#229; deklarere en state variable.<\/p><p>&#160;<\/p><p>Dataflyt fungerer relativt enkelt nedover i komponenthierarkiet hvor man sender med props til en komponent eller oppover hvor man kan f&#229; en funksjon (callback) fra forelderkomponenten som man bruker til &#229; sende data opp.&#160;Hvis man skal sende data&#160;til andre deler av komponenttreet vil man derimot&#160;m&#229;tte sende data opp til&#160;en&#160;komponent som er &#39;closest common ancestor&#39; og deretter sende nedover, og dermed muligens g&#229; innom mange forskjellige komponenter.<\/p><p>&#160;<\/p><p>Hvis data skal deles blandt mange komponenter i ulike deler av komponenthierarkiet vil Context API-et v&#230;re gunstig. Med Context slipper man &#229; sende data i hvert lag, man definerer heller en provider slik at alle komponentene innenfor denne, vil ha tilgang p&#229; dataen. I tillegg finnes det flere bibliotek som tar seg av state management som for eksempel Redux eller MobX. Redux fungerer ved at man definerer en &#39;store&#39; slik at all data/state er samlet p&#229; ett sted, ogs&#229; bruker man actions og reducers (og Dispatch i komponenten) til &#229; trygt sette verdier i store og dermed oppdatere state. Mobx er enklere ved oppsett, men man gir fra seg litt av kontrollen i forhold til Redux. MobX fungerer ved at man definerer &#39;observable&#39; verdier som avhenger av hverandre slik at hvis man endrer en verdi, vil de verdiene som er avhengige av den ogs&#229;&#160;sjekke om de m&#229; endres.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2492,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et &#39;state management&#39; bibliotek som s&#248;rger for felles deling og tilgang p&#229; state i React-applikasjoner. Dette gj&#248;res gjennom bruk av &#39;atoms&#39; for state variabler og &#39;selectors&#39; som funksjoner for modifisering av state. En komponent kan i likhet med som i Redux abonnere til en state variabel (her atom), slik at den rerenderer ved ny state. Komponenten kan ogs&#229; abonnere til selectors som ut ifra minimal state i atoms&#160;kan sette avhengige variabler i komponenten. Dette kan sammenlignes med MobX hvor state variables ogs&#229; kan v&#230;re avhengige av hverandre.<\/p><p>&#160;<\/p><p>I motsetning til ved bruk av Context API-et vil Recoil s&#248;rge for at kun n&#248;dvendige komponenter vil rerendere ved oppdatering av state. Recoil har ogs&#229; et mindre komplisert oppsett enn for eksempel Redux, samtidig som det har mye av den samme funksjonaliteten. Recoil kan ogs&#229; brukes godt til asynkroniserte funksjoner som fetch. Recoil er i motsetning til Redux og MobX relativt nytt&#160;bibliotek slik at det kan v&#230;re mer sannsynlig &#229; finne manglende dokumentasjon,&#160;bugs eller mulighet for hjelp. Ettersom det er nytt har det derimot veldig god samhandling med funksjonelle komponenter, som er det mest popul&#230;re fremover. Siden Recoil er et enklere bibliotek enn for eksempel Redux, vil det nok v&#230;re lurt &#229; ikke bruke det p&#229; st&#248;rre prosjekter.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1776,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API er et webgrensesnitt, mens GraphQL er et query language. Med REST API vil man hente data gjennom forskjellige endepunkt. I disse endepunktene vil man bestemme logikk for hva slags data man f&#229;r hentet, og for eksempel for eventuell filtrering, sortering eller paging.&#160;Hvis dataen man vil hente ikke ligger i samme endepunkt vil man m&#229;tte hente data flere ganger med flere sp&#248;rringer. Med GraphQL kan man derimot lage &#233;n sp&#248;rring til kun ett endepunkt og definere strukturen med eksakt innhold i dataen man f&#229;r returnert. P&#229; denne m&#229;ten unng&#229;r man &#229; hente data man ikke trenger, og man har oversikt over hvordan man kan hente verdier i resultatet. I GraphQL vil man definere typer gjennom &#39;schema&#39; slik at det er tydelig hvordan dataen er strukturert. I et&#160;REST API vil det v&#230;re mindre n&#248;dvendig kode for &#229; f&#229; dataen og man vil raskere komme i gang, men man har mindre kontroll slik at det er mer sannsynlig at man opplever bugs senere i prosjektet. GraphQL krever noe mer serverkapasitet.<\/p><p>&#160;<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11532995,"ext_inspera_userAssessmentSetupId":7140075,"ext_inspera_userAssessmentId":4841315,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Salomonsen Simen (10016)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35164482,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2274,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har en hierakisk struktur og tillater hovedsakelig kun dataflyt ned i hierarkiet. Det vil si at dataen kan sendes fra foreldre til barn-komponenter, og som regel ikke oppover igjen uten noen callback-funksjon. Ettersom at det ofte kan v&#230;re nyttig for komponenter lengre ned i hierarkiet &#229; sende informasjon oppover igjen, enten for &#229; for&#229;rsake en endring i rendering eller staten til applikasjonen, s&#229; har React nylig kommet med Context som fungerer slik at det opprettes en global variabel som alle komponenter i hierarkiet kan aksessere og endre ved &#229; bruke set-funksjonen som defineres n&#229;r contextet lages. Dette gj&#248;r det mulig for komponenter lengre ned i hierarkiet til &#229; gj&#248;re endringer p&#229; staten til applikasjonen, slik at de kan h&#229;ndtere den endringen deretter; noe som likner p&#229;&#160;observable/observator-grensesnittet&#160;som er kjent fra objektorientert programmering.&#160;<\/p><p>&#160;<\/p><p>Det er derimot ikke kun React som l&#248;ser dette problemet, og det finnes flere tredjepartsbibliotek som ogs&#229; har som form&#229;l &#229; takle stateh&#229;ndteringsproblemet, deriblant Mobx of Redux. Redux p&#229; sin side er et litt eldre bibliotek enn Mobx og har en funksjonell tiln&#230;rming til l&#248;sningen av problemet gjennom at alle endringer av staten skjer gjennom eksplisitte funksjoner p&#229; staten. Mobx fokuserer i st&#248;rre grad p&#229; &#229; l&#248;se dette mer objektorientert og deler som regel den globale staten opp i flere states. Redux&#160;har v&#230;rt her lenge og har en omfattende dokumentasjon som ogs&#229; oppdateres med &#229;rene. I tillegg har de ogs&#229; vist seg villig til &#229; tilpasse seg bruken av React, blant annet ved at de utviklet hooks i forbindelse med at funksjonelle komponenter er blitt mer vanlig &#229; ta i bruk med React. Dette har ogs&#229; forenklet bruken og gjort oppsettet&#160;enklere, noe som tidligere har v&#230;rt en utfordring for Redux. Mobx er derimot noe enklere &#229; l&#230;re seg og har ikke en like bratt l&#230;ringskurve som Redux, og har en fordel med at den bygger p&#229; prinsipper som mange programmerere er kjent med fra f&#248;r av.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2273,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Som nettsiden nevner er Recoil ogs&#229; et bibliotek for stateh&#229;ndtering i React-applikasjoner.&#160;<\/p><p>Det baserer seg i hovedsak p&#229; to konsepter; atomer og selectors, hvor atomer er enkelte datapakker med en n&#248;kkel og en verdi, og selectors er funksjoner som gj&#248;r endringer p&#229; atomer. For komponenter ser disse like ut, og de har muligheten til &#229; subscribe og ta i bruk disse om hverandre. Dette likner mye p&#229; virkem&#229;ten til Context fra React, men gj&#248;r det ryddigere og kutter en del ned i koden som er n&#248;dvendig for &#229; f&#229; komponenter til &#229; kunne subcribe til atomene eller selectorene som likner litt p&#229; m&#229;ten redux gj&#248;r det p&#229;. Dette igjen gj&#248;r at en kan passe endringer og verdier p&#229; tvers av komponenter p&#229; en mye enklere m&#229;te uten at en trenger &#229; sette deg inn i alt oppsettet rundt.&#160;En annen fordel er at biblioteket etterstreber &#229; likne syntaksen til React, slik at l&#230;ringskurven til biblioteket og terskelen for &#229; ta det i bruk senkes betraktelig.&#160;<\/p><p>&#160;<\/p><p>Dog distribusjonen er en fordel og forenkler bruken av biblioteket&#160;til stateh&#229;ndering, vil det nok ogs&#229; for&#229;rsake noen problemer ved skalering av prosjekter. Ettersom at atomene og selectorene er fullstendig distribuert, vil det kun v&#230;re vanskelig &#229; holde styr p&#229; alle variablene og en del tid vil nok g&#229; tilbake for &#229; lete etter den riktige verdien som trengs. For st&#248;rre prosjekter vil det da kanskje v&#230;re mer naturlig &#229; ta i bruk mobx eller redux som samler den globale staten til applikasjonen i en og samme plass. I tillegg vil m&#229; hver n&#248;kkelverdi for atomer og selectorer v&#230;re unike, og dette, sammen med distribusjonsproblemet, gj&#248;r nok at skalering av prosjekter som tar i bruk Recoil vil v&#230;re den st&#248;rste utfordringen.&#160;<\/p><p>&#160;<\/p><p>En annen utfordring er at det enda er et relativt nytt bibliotek, og st&#248;tten rundt det og dokumentasjonen er ikke enda kommet helt p&#229; samme niv&#229; som redux og mobx, noe som kan gj&#248;re utviklingsprosessen vanskeligere dersom man st&#248;ter p&#229; et problem som ingen andre har v&#230;rt borti f&#248;r.&#160;<\/p><p>&#160;<\/p><p>(Kilde:&#160;https://recoiljs.org/docs/introduction/core-concepts)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2609,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og Graphql er to APIer som har som m&#229;l &#229; gj&#248;re hentingen av informasjon og data fra og til klient og server. REST l&#248;ser dette ved &#229; sette opp flere endepunkter som klientsiden kan bruke til &#229; hente ulike data. Graphql p&#229; sin side har kun et endepunkt som settes opp, og henter data gjennom det. Grunnen til at dette er mulig er at Graphql baserer seg p&#229; sp&#248;rringer som sendes gjennom det ene endepunktet fremfor &#229; ha et endepunkt for hver mulig sp&#248;rring klient-siden kan sende. Dette forutsetter derimot at b&#229;de backend og frontend har muligheten til &#229; h&#229;ndtere Graphql, og Apollo har vist seg som et nyttig verkt&#248;y &#229; bruke ettersom at det kan brukes b&#229;de p&#229; klient- og p&#229; server-side. Endepunktene i REST derimot kan enkelt tas i bruk av en hvilken som helst applikasjon gjennom bruk av grunnbiblioteket AJAX i JavaScript.&#160;<\/p><p>&#160;<\/p><p>Utover det er REST ogs&#229; en del av MERN-stacken; en kjent stack som er mye utpr&#248;vd, og det finnes god ressurser for &#229; komme i gang med APIet. Graphql har ogs&#229; en god dokumentasjon p&#229; nettsidene deres, samtidig som at det for utviklere med bakgrunn innen database og sp&#248;rringer vil v&#230;re mer naturlig &#229; ta i bruk dette APIet, dog dette ogs&#229; kan frast&#248;te utviklere uten kjennskap til sp&#248;rringer fra f&#248;r ettersom at det kan gj&#248;re l&#230;ringskurven veldig bratt. Det at Graphql er basert p&#229; sp&#248;rringer gj&#248;r ogs&#229; at det i st&#248;rre grad kan tilpasses til de sp&#248;rringene som trenges, og eliminerer problemet ved over-fetching dersom man ikke har et endepunkt som er spesielt skreddersydd til det spesifikke behovet (noe man ikke s&#229; ofte har). P&#229; den m&#229;ten f&#229;r man ogs&#229; mer effektiv henting av data, samtidig som at det gj&#248;r utviklingsprosessen enklere senere dersom det er behov for nye sp&#248;rringer ettersom at de bare kan defineres frontend fremfor &#229; m&#229;tte lage nye endepunkt slik som i REST.&#160;<\/p><p>&#160;<\/p><p>(Kilder:&#160;https://graphql.org/learn/)<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533023,"ext_inspera_userAssessmentSetupId":7140072,"ext_inspera_userAssessmentId":4841432,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hjelmeseth Håvard (10225)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37753273,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2228,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I utgangspunktet finnes det to typer datah&#229;ndtering i React-applikasjoner. Props(properties) og State (tilstand), hvor den st&#248;rste forskjellen er at props blir gitt fra foreldrekomponenten, mens state blir h&#229;ndtert inne i selve komponenten. En komponent har alts&#229; ikke selv mulighet til &#229; endre p&#229; sine props (uten &#229; bruke en callback funksjon), mens den st&#229;r fritt fram til endre p&#229; egen state.<\/p><p>&#160;<\/p><p>Ettersom props bare kan gis fra foreldrekomponenten f&#248;rer dette til et velkjent problem hvor React applikasjoner av en viss kompleksitetet ender opp med flere lag av s&#229;kalt &#34;prop drilling&#34;. Komponenter langt nede i komponentetreet skal ha tak i en state som befinner seg h&#248;yt oppe i komponent-treet, og for &#229; f&#229; til dette m&#229; stateten sendes som en prop gjennom flere lag med komponenter. Dette blir fort veldig rotetet, men vi har heldigvis mekanismer for &#229; l&#248;se dette problemet.<\/p><p>&#160;<\/p><p>Noen av disse mekanismene er blant annet Context API&#39;et, som gir oss en m&#229;te &#229; sende data gjennom komponenttreet uten &#229; m&#229;tte gj&#248;re det manuelt gjennom hvert lag. Context API&#39;et er laget for &#229; h&#229;ndtere state som kan regnes for global for hele applikasjonen, som f.eks. spr&#229;kpreferanser. Her kan en context bare h&#229;ndtere en verdi, s&#229; dersom du &#248;nsker flere m&#229; applikasjonen wrappes i flere providers.<\/p><p>&#160;<\/p><p>Blant andre mekanismer for &#229; l&#248;se &#34;prop drilling&#34; problemet har vi Redux og MobX, som begge er tredjeparts biblioteker for global state h&#229;ndtering. Redux og MobX har mange likheter, og i kjernen er de begge bygget for &#229; l&#248;se det samme problemet. I min erfaring er det likevel en del forskjeller p&#229; de to, blant annet p&#229; hvordan de strukturerer dataen. I Redux er den globale staten lagret i en store, som kan oppdateres ved &#229; bruke dispatch metoden med en action. Redux lar deg legge til listeners i form av funksjoner som blir kalt hver gang en action blir dispatchet, men du m&#229; selv implementere hvilke oppdateringer du &#248;nsker basert p&#229; dette. I MobX er derimot dataen lagret som observerbar data, og oppdateringer i avhengige komponenter gj&#248;res automatisk. MobX lar deg ogs&#229; splitte den globale staten inn i flere stores. N&#229;r det kommer til oppsett og l&#230;ringskurve virker det for meg som at MobX er noe bedre enn Redux, som krever mer oppsett med stores og dispatch actions. En annen, ganske vesentlig forskjell mellom de to er at Redux ikke lar deg endre p&#229; staten som er lagret i en store, men heller lar deg bytte ut hele staten med en ny. I MobX er staten som er lagret i stores muterbar.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2965,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state-management bibliotek utviklet av Facebook for React. Hensikten med Recoil er &#229; forenkle tilstandsh&#229;ndtering p&#229; tvers av komponenter i React, liknende det vi finner i Redux, MobX og Context API&#39;et (som alle er deler av pensum).<\/p><p>&#160;<\/p><p>Recoil gjennomf&#248;rer dette med et konsept som baserer seg p&#229; &#34;Atoms&#34; som er hvor staten befinner seg, et slik &#34;atom&#34; er oppdaterbar og &#34;subscribable&#34;, som i prakis betyr at en &#34;subscriber&#34; f&#229;r beskjed n&#229;r staten har endret seg, og kan dermed re-renderes. &#34;Selectors&#34; er et annet konsept i Recoil, og er rett og slett funksjoner som tar inn &#160;&#34;atoms&#34; eller andre selectors som parameter, og re-evalueres n&#229;r disse oppdateres. Slike selectors lar oss derfor unng&#229; &#229; ha overfl&#248;dig state.<\/p><p>&#160;<\/p><p>Uten at jeg selv har benyttet Recoil, har jeg n&#229; satt meg inn i dokumentasjonen og sammenlignet med tilsvarende l&#248;sninger p&#229; l&#230;ringsm&#229;llisten:<\/p><p>For meg virker det som at Recoil l&#248;ser mange av problemene med Redux og MobX. Recoil ser ut til &#229; unng&#229; den bratte l&#230;ringskurven som vi finner i Redux, dette spesielt siden Recoils useRecoilState fungerer veldig likt som en tradisjonell useState hook i React, som burde v&#230;re kjent for en erfaren React utvikler. Recoil virker ogs&#229; til &#229; fungere uten mye boilerplatesetup, som er en av de st&#248;rste kritikkene mot Redux.<\/p><p>&#160;<\/p><p>En annen forskjell mellom de ulike mekanismene er relatert til hvor dataen lagres, som i Redux og MobX befinner seg i stores. Dersom en benytter seg av Recoil trenger en ikke opprette noe stores, men bare opprette et atom, og eksportere dette. Da kan en importere dette atomet i komponenter som vil benytte seg av tilstanden.<\/p><p>&#160;<\/p><p>En sammenligning med Context API ser ogs&#229; ut til &#229; v&#230;re p&#229; sin plass, ettersom begge alternativene er tett knyttet opp til React, og l&#248;ser i utgangspunktet de samme problemene. En av fordelene med Recoil over &#229; bare benytte seg av det innebygde context API&#39;et vil v&#230;re skalerbarehet, hvor en context bare kan h&#229;ndtere en enkelt verdi.<\/p><p>&#160;<\/p><p>Av Redux og MobX vil tro at Recoil i praksis er mer likt MobX, men har som fordel at det er knyttet mer tett opp til React, og vil trolig f&#248;lge utviklingen av React i framtiden. MobX er et generelt state h&#229;ndteringsbibliotek, og kan ogs&#229; benyttes med andre biblioteker og rammeverker. Om dette er en ulempe eller en fordel vil da avhenge om du utvikler eksklusivt med React, eller om du ogs&#229; benytter deg av andre biblitoteker og rammeverker.<\/p><p>&#160;<\/p><p>Alt i alt virker Recoil som et bibliotek som l&#248;ser p&#229; global state h&#229;ndtering p&#229; en bra m&#229;te, med en relativt enkel framgangsm&#229;te.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1982,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API&#39;er har lenge v&#230;rt bransjestandarden, og er et velpr&#248;v og genereisk webgrensesnitt. Rest API&#39;er&#160;er tilstansl&#248;se API&#39;er som er b&#229;de enkle &#229; implementere og bruke.&#160;GraphQL API&#39;er er et nyere konsept, og vokser raskt i popul&#230;ritet. Det kan sees p&#229; som &#34;up and coming&#34;, og benytter seg av et query spr&#229;k for API requests. GraphQL gir flere muligheter til hvordan klient kan kalle p&#229; data, noe som kommer med sine fordeler.<\/p><p>&#160;<\/p><p>REST API&#39;er benytter seg av HTTP metodene for &#229; gj&#248;re kall, og man definerer&#160;flere endepunkter ved utvikling, disse endepunktene er det som brukes for &#229; hente/skrive/endre p&#229; data, og en har et unikt endpunkt for hver ressurs.&#160;En ulempe med dette er at dersom du skal hente data fra flere forskjellige endepunkter, m&#229; du gj&#248;re flere kall, og kan ende opp med mer data enn du beh&#248;ver. Dette er ikke et problem i GraphQL, som gir klienten muligheten til &#229; sende et kall som returnerer n&#248;yaktig den dataen en &#248;nsker, og ikke noe ekstra. Da kan man hente all dataen p&#229; en request, og samtidig unng&#229;r man &#229; laste for mye data. Dette gj&#248;res ved at sp&#248;rringen som sendes til serveren inneholder b&#229;de s&#248;ket, og hvilke data som skal sendes eller endres p&#229;. Dette l&#248;ser alts&#229; problemene som REST API&#39;er har rundt overfetching og underfetching.<\/p><p>&#160;<\/p><p>En fordel med REST API over GraphQL er at du kan benytte caching mekanismen som er innebygd i nettleseren, GraphQL mangler implisitt caching i HTTP-laget.<\/p><p>GraphQL har ogs&#229; valideringsmekanismer i form av schemas som beskriver typer og struktur, noe som tillatter en tettere kobling mellom tjener og server og client.<\/p><p>GraphQL st&#248;tter ogs&#229; bare JSON for utveksling av data,&#160;mens REST API&#39;er st&#248;tter flere typer markup spr&#229;k.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11533048,"ext_inspera_userAssessmentSetupId":7139971,"ext_inspera_userAssessmentId":4842158,"dateLastModified":"2020-12-01T10:31:21Z","ext_inspera_startTime":"2020-12-01T08:00:01Z","ext_inspera_endTime":"2020-12-01T10:31:21Z","ext_inspera_extraTimeMins":30,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rian Emma Valen (10108)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":37466517,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1821,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<h3>State<\/h3><p>React-komponenter er dynamiske, som vil si at de kan umiddelbart endre seg idet du interagerer med dem. Dette gj&#248;res ved &#229; bruke <em><strong>state<\/strong><\/em>, som lagrer en tilstand som kan endre seg og p&#229;virker komponenten. Dersom state endrer seg, vil komponenten re-rendres og oppdateringen vil vises p&#229; nettsiden.<\/p><p>&#160;<\/p><p>Hvordan man h&#229;ndterer state i en komponent kommer an p&#229; om komponenten er en klassekomponent eller en funskjonell komponent.<\/p><p>&#160;<\/p><p><strong>Klassekomponent<\/strong><\/p><p>En klassekomponent kalles stateful, ettersom den holder styr p&#229; state direkte i komponenten. Den definerer state i en constructor, og oppdaterer state ved &#229; bruke setState().<\/p><p>&#160;<\/p><p><strong>Funksjonell komponent<\/strong><\/p><p>En funksjonell komponent kalles stateless, ettersom den bruker <em><strong>hooks<\/strong><\/em> for &#229; h&#229;ndtere state. En hook&#160;lar deg &#34;hekte&#34; deg p&#229; React-funksjoner, som for eksempel state. Ved &#229; bruke hooks slipper man &#229; implementere en klassekomponent med constructor etc. for &#229; inkludere state i komponenten.<\/p><p><strong>Eksempel, deklarere state med useState() hook:<\/strong>&#160;const [count, setCount] = useState(0);<\/p><p>Denne staten kan oppdateres ved &#229; bruke setCount(nyState).<\/p><p>&#160;<\/p><h3>Dataflyt<\/h3><p>React baserer seg p&#229; &#229; dele opp koden i flere komponenter. Dette gj&#248;r at man kan gjenbruke den samme komponenten flere ganger.<\/p><p>&#160;<\/p><p>Det trengs&#160;en smart l&#248;sning for &#229; sende data mellom disse komponentene. Dette kan gj&#248;res via&#160;<strong><em>props<\/em><\/strong>. Props gj&#248;r at du kan sende data til barnekomponenter som en parameter, og barnekomponenten f&#229;r dermed tilgang p&#229; dataen som blir generert/eksisterer i forelderkomponenten. Du kan sende f.eks. en tekststreng eller et tall som props, men du kan ogs&#229; sende variabler. Da m&#229; variabel&#160;wrappes i kr&#248;llparenteser.<\/p><p><strong>Eksempel<\/strong>:&#160;&#60;Person&#160;name={name} /&#62;, der name er definert som en variabel i n&#229;v&#230;rende komponent.<\/p><p>&#160;<\/p><h3>Kilder<\/h3><p>https://www.w3schools.com/react/react_props.asp<\/p><p>https://reactjs.org/docs/components-and-props.html<\/p><p>https://reactjs.org/docs/faq-state.html<\/p><p>https://reactjs.org/docs/state-and-lifecycle.html<\/p><p>https://reactjs.org/docs/hooks-state.html<\/p><p>https://www.geeksforgeeks.org/differences-between-functional-components-and-class-components-in-react/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3846,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. Det er relativt nytt og utvikles og vedlikeholdes av Facebook, som React. Det er fortsatt litt i utviklingsfasen.&#160;Recoil&#160;baserer seg p&#229; Reacts egen h&#229;ndtering av state, men forbedrer dette slik at det blir enklere &#229; kunne ta i bruk state globalt, alts&#229; bruke samme state i mange&#160;komponenter uten &#229; m&#229;tte sende de opp og ned i komponenthierarkiet.&#160;<\/p><p>&#160;<\/p><p>I dette faget har vi hovedsakelig sett p&#229; Reacts innebygde Context API, Redux og MobX for h&#229;ndtering av global state. Recoil ser ut til &#229; v&#230;re et bibliotek som pr&#248;ver &#229; kombinere de positive aspektene med alle disse.&#160;Dette blir n&#248;yere beskrevet senere.<\/p><p>&#160;<\/p><h2>Bruk av Recoil<\/h2><p>Recoil bruker noe som kalles <strong><em>atoms<\/em><\/strong> for &#229; lagre states. Et atom er en state som kan brukes i flere komponenter og alle vil f&#229; endret state ved oppdatering av atomet. Et eksempel p&#229; bruk fra Recoils dokumentasjon:&#160;<em>const [fontSize, setFontSize] = useRecoilState(fontSizeState);<\/em><\/p><p>Som man kan se fra dette tilsvarer stateh&#229;ndtering i stor grad stateh&#229;ndtering via&#160;<strong>React Hooks APIet <\/strong>(via hook<em> useState()<\/em>), bare at her kan staten brukes globalt/i flere komponenter&#160;ved &#229; bruke hooken <em>useRecoilState()<\/em>. To forskjellige komponenter kan bruke denne samme hooken, og n&#229;r staten oppdateres i en av dem, vil begge komponentene f&#229; fornyet state.<\/p><p>&#160;<\/p><p>I tillegg til atoms tar Recoil i bruk funksjoner kalt <strong><em>selectors<\/em><\/strong>. En selector er en &#34;pure function&#34; som tar inn atoms eller selectors som input. Selectors utf&#248;rer beregninger basert p&#229; state, slik at vi kan ha minst mulig overfl&#248;dige states. Et eksempel som brukes i dokumentasjonen til Recoil bygger videre p&#229; fontSize-eksempelet, man kan f.eks. bruke et atom til &#229; definere fontSizeState, og en selector til &#229; formattere denne staten. Selectoren blir lest og lagret til en variabel/const ved &#229; bruke hooken <em>useRecoilValue().<\/em><\/p><p>&#160;<\/p><h2>Recoil vs andre state management bibliotek<\/h2><h4>Recoil vs Redux (og litt MobX)<\/h4><p>I motsetning til Redux og MobX har Recoil ikke behov for en store (flere stores for MobX)&#160;for &#229; lagre states. Det er helt tydelig at Recoil er utviklet for &#229; fungere for&#160;React, i motsetning til&#160;Redux og MobX, som er laget for &#229; fungere p&#229; tvers av ulike JavaScript applikasjoner. De tidligere nevnte &#34;hooks&#34; <em>useRecoilState()<\/em> og <em>useRecoilValue()<\/em> erstatter&#160;bruk av&#160;<em>mapStateToProps<\/em>&#160;and&#160;<em>mapDispatchToProps<\/em> etter &#229; ha koblet til en store i Redux. Dette gj&#248;r globalt state management mer s&#248;ml&#248;st for bruk i React (bedre kompabilitet og enklere). Det er verdt &#229; nevne at Redux og MobX er mer videreutviklet enn helt nye Recoil og derfor vil v&#230;re et tryggere valg dersom man skal finne en l&#248;sning for global state h&#229;ndtering i et stort prosjekt, men med tiden kan dette problemet forsvinne. Recoil vil ogs&#229; kun fungere for React-applikasjoner.<\/p><h4>Recoil vs Context API<\/h4><p>B&#229;de Recoil og Context er tett knyttet opp mot React og baserer seg p&#229; Reacts egen stateh&#229;ndtering. Recoil er utviklet med hensikt &#229; fikse enkelte problemer/begrensninger med&#160;Context. Tre problemer er konkret nevnt i dokumentasjonen, kort oppsummert her.<\/p><ul>\t<li>Context kan kun bli oppdatert ved &#229; sende state opp til en felles forelder, som kan medf&#248;re et stort tre som m&#229; &#34;re-rendres&#34;.<\/li>\t<li>Context kan bare lagre en enkeltverdi, ikke et sett med verdier med sine egne brukere.<\/li>\t<li>Problemene over gj&#248;r det ogs&#229; vanskelig &#229; splitte koden mellom der du definerer state (der staten eksisterer) og der du faktisk bruker den.<\/li><\/ul><p>Recoil gir en l&#248;sning p&#229; disse problemene ved &#229; tilby stateh&#229;ndtering der hver state&#160;kan defineres/eksistere i komponentene du bruker staten i, men samtidig endre state i alle komponentene som tar den i bruk hvis en av disse&#160;endrer seg. Det er f&#229; grunner til &#229; bruke Context over Recoil ettersom begge er skreddersydd for React og Recoil fikser mange problemer med Context. Det eneste er selvf&#248;lgelig at Context (som i punktet over) er et tryggere valg n&#229; i startfasen av Recoil, ettersom det fortsatt er et bibliotek under utvikling og det kan fort skje endringer som man ikke &#248;nsker &#229; ta h&#229;nd om i et st&#248;rre prosjekt.<\/p><h3>Kilder:<\/h3><p>https://recoiljs.org<\/p><p>https://dev.to/chandan/recoil-vs-redux-the-ultimate-react-state-management-face-off-35b<\/p><p>https://www.telerik.com/blogs/how-to-switch-redux-to-recoil<\/p><p>https://redux.js.org/<\/p><p>https://mobx.js.org/README.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3284,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST API og GraphQL legger til rette for kommunikasjon/hente informasjon mellom klient og server. Begge bruker HTTP requests og URL til &#229; hente et resultatsett i f.eks. JSON-format.&#160;Her er noen vesentlige forskjeller mellom dem:<\/p><p>&#160;<\/p><h3>Henting av data, over-/underfetching -&#62; GraphQL bedre<\/h3><p>REST (REpresentational State Transfer) bruker HTTP requests til &#229; hente data via flere endepunkt (endpoints).&#160;Dette er typisk URLer som f.eks. <em>/users/&#60;id&#62;<\/em>, som henter all data fra en bruker med gitt id. Hver gang man gj&#248;r en request i REST f&#229;r man tilbake et fullstendig datasett. Etter man har f&#229;tt tak i riktig data kan man lete gjennom og f.eks. finne informasjon om navnet p&#229; brukeren med gitt id. Dersom navnet p&#229; brukeren var alt du var interessert i har du hentet mye un&#248;dvendig data fra serveren. Dette kalles&#160;<strong><em>overfetching <\/em><\/strong>av data. Du kan ogs&#229; f&#229; et problem med det motsatte - <strong><em>underfetching<\/em><\/strong><span>. Dette problemet oppst&#229;r n&#229;r du gj&#248;r et kall til et endepunkt, men dette kallet gir deg ikke all informasjonen du trenger.<\/span><span>&#160;Du m&#229; da gj&#248;re flere request for &#229; f&#229; tak i n&#248;dvendig informasjon. <\/span><span>REST er alts&#229; designet til &#229; returnere faste datasett fra et gitt endepunkt, som gj&#248;r det veldig vanskelig &#229; skreddersy hvilke deler av dataen du trenger.<\/span><\/p><p>&#160;<\/p><p>GraphQL er i motsetning til REST et sp&#248;rrespr&#229;k, der du kan sende queries til en server og f&#229; et resultat tilbake som matcher innholdet i query-en i JSON-format. En slik query kan modifiseres til &#229; gi akkurat det dataresultatet du trenger, i stedet for &#229; laste inn un&#248;dvendig data. GraphQL bruker kun ett endepunkt, og via queries kan du hente ut dataen du trenger fra dette endepunktet, som inneholder all informasjon. Dette fjerner problemet med over- og underfetching av data og gir mye mer fleksibilitet. Man sparer ogs&#229; mye tid p&#229; &#229; hente ut riktig mengde data med ett kall.<\/p><p>&#160;<\/p><p><strong>Routes vs Schema:&#160;<\/strong>Et REST API bruker en liste med flere endepunkt for &#229; beskrive APIet. N&#229;r du skal hente informasjon bestemmer du deg for hvilket endepunkt du vil bruke.&#160;I GraphQL brukes kun ett endepunkt, og APIet beskrives med et Schema, som beskriver et hierarki av typer. Initielle typer er Mutation (endringer p&#229;/legge til data i databasen) og Query (henting av data i databasen). Feltene innad i undertypene (f.eks. Book, Author) tilsvarer informasjon du henter via REST routene.&#160;<\/p><p><u>Eksempel <\/u>(fra https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/):<\/p><ul>\t<li>Graph QL:&#160;\t<ul>\t\t<li>type Query { book(id: ID!): Book author(id: ID!): Author }<\/li>\t<\/ul>\t<\/li>\t<li>REST:&#160;\t<ul>\t\t<li>GET /books/:id<\/li>\t\t<li>GET /authors/:id<\/li>\t<\/ul>\t<\/li><\/ul><p>&#160;<\/p><h3>Industristandard og modenhet -&#62; REST bedre<\/h3><p>REST har lenge v&#230;rt standarden for &#229; hente data fra API (fra server til klient). Det er brukt i veldig mange industrier og de fleste kjenner til REST API. Ettersom det har v&#230;rt en standard lenge er alt av dokumentasjon, tutorials, tilpassede verkt&#248;y o.l. mer videreutviklet enn for GraphQL.<\/p><p>&#160;<\/p><h3>Kilder<\/h3><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://www.codecademy.com/articles/what-is-rest<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p><p>https://www.apollographql.com/docs/apollo-server/schema/schema/<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533378,"ext_inspera_userAssessmentSetupId":7140118,"ext_inspera_userAssessmentId":4841265,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tveit Herborg Hermansen (10150)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303385,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2609,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React har vi props og state som er variabler, men de brukes litt forskjellig. Props er variabler man kan sette og putte inn i komponenter. I React bruker man useState for &#229; sette states, der&#160;man setter en variabel og funksjonen der man setter variabelen. Hvis man vil endre variabelen i en komponent kaller man p&#229; set&#34;state&#34;&#160;og setter inn det man vil endre staten til. Disse variablene er lokale, og m&#229; sendes opp og nedover i niv&#229;er hvis man skal bruke dem andre steder, noe som fort kan bli tungvindt. Derfor kan man bruke Context API og Redux eller MobX for &#229; fikse dette problemet.<\/p><p>&#160;<\/p><p>For &#229; oppdatere endringer i states og komponenter m&#229; man rendre komponenten. Man kan bruke useEffect() hook som brukes rett etter rendring av en komponent. For eksempel om man har en komponent som teller antall ganger man trykker p&#229; en knapp, s&#229; vil useEffect kunne oppdatere og si til brukeren hvor mange ganger knappen har blitt trykket.<\/p><p>&#160;<\/p><p>Man bruker Context API for &#229; kunne ha globale variabler. Da vil man kunne bruke disse variablene i alle komponenter uten &#229; m&#229;tte sende opp og ned gjennom niv&#229;er.&#160;<\/p><p>&#160;<\/p><p>Redux og Mobx har vi ogs&#229; brukt i prosjektene, og disse brukes ogs&#229; for state mangement. Med disse kan man lagre alle states et sted som gj&#248;r at man som i context slipper &#229; sende nedover i niv&#229;. Fordelen med dette er at man slipper en knotete kode ved &#229; m&#229;tte sende states gjennom niv&#229;er og dette f&#248;rer ogs&#229; til at man gj&#248;r mindre feil.&#160;I Redux bruker man actions og&#160;reducer sette og oppdatere states og actions, mens i Mobx har enklere syntaks, og man ser ikke s&#229; mye av det som skjer visuelt i koden.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2384,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management i React. I prosjektene har vi brukt enten Redux eller MobX for dette.<\/p><p>&#160;<\/p><p>Recoil best&#229;r av atoms og selectors. Atoms er enheter av states, eller states,&#160;og selectors er funksjoner som kan ta inn atoms og andre selectors som input. Man wrapper en RecoilRoot rundt appen slik at man hele tiden har tilgang til det man har globalt,&#160;slik som man gj&#248;r i Redux&#160;og MobX. Hver gang det skjer en oppdatering i atoms eller selectors&#160;vil hver komponent som bruker disse&#160;bli re-rendered ved bruk av funksjoner man importerer fra Recoil biblioteket. Dette er veldig likt hvordan MobX fungerer. MobX re-renderer ogs&#229; ved oppdatering, mens i Redux m&#229; man dispatche n&#229;r det har skjedd en oppdatering.<\/p><p>&#160;<\/p><p>Recoil er likt MobX i at den ikke bruker reducers for &#229; sette states, men bruker heller Atoms og Selectors for dette, i motsetning til Redux der man m&#229; bruke reducers og lage en store som er som en global state. Atoms fungerer som global state uten &#229; lage store. Der Recoil ligner p&#229; Redux i at den har selectors og at man kan bruke atoms og selectors om igjen i selectors.&#160;<\/p><p>&#160;<\/p><p>Har lest litt om Recoil p&#229; denne linken her i tillegg til den som er oppgitt i oppgavebeskrivelsen: https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2086,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den st&#248;rste forskjellen mellom REST API og GraphQL er at GraphQL er spr&#229;k man bruker for &#229; skrive presise sp&#248;rringer til en server. Man bruker skjema der man definerer type og struktur, og man skriver en query ut fra det man har definert.&#160;REST API er et design for kommunikasjon for datainnhenting og lagring av nye data&#160;gjennom &#229; bruke HTTP requests.<\/p><p>&#160;<\/p><p>Fordelen med GraphQL er at man kan hente all data man trenger i en request, siden man spesifiserer sp&#248;rringen sin gjennom og definere s&#248;k og dataen man skal hente. En ulempe er at det kun st&#248;tter json.&#160;<\/p><p>&#160;<\/p><p>Fordelen med REST API er at man kan lagre data som ofte blir brukt gjennom GET og POST requests, noe som blir kalt caching. Dette gj&#248;r at man raskere kan f&#229; tilgang til data som blir mye etterspurt.<\/p><p>&#160;<\/p><p>Begge disse m&#229;tene &#229; hente ut data p&#229; bruker HTTP requests, men p&#229; forskjellige m&#229;ter. Med REST API vil man f&#229; ut et komplett datasett, og kanskje mer data enn man trenger, mens med GraphQL kan&#160;man skrive en spesifiser sp&#248;rring som gj&#248;r at man kan hente ut akkurat det man trenger. Dette er en fordel med GraphQL.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11533678,"ext_inspera_userAssessmentSetupId":7139924,"ext_inspera_userAssessmentId":4841463,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Fossland Ole-Henrik (10195)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":14426368,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2218,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Intro<\/strong><\/p><p>React er bygd opp av komponenter, hvorav man kan bruke komponenter med state (stateful), eller uten state (stateless). State kan sees p&#229; som en variabel innad i komponenten, og brukes til &#229; lagre innformasjon som brukes og endres i komponenten. Det viktige her er at n&#229;r en komponents state endres, vil komponenten opdateres for &#229; reflektere endringer. Med dette kan man ogs&#229; implementere funksjoner for&#160;livssyklus i komponenter, hvor man kan gj&#248;re spesifike endringer ut fra hvilken del av syklusen en komponent er i. Man kan&#160;foreksempel&#160;hente data fra et API n&#229;r komponenten lastes, for s&#229; &#229; lagre dette til en state, hvorav komponenten vil opdateres og bruke nye data for rendrering.<\/p><p>&#160;<\/p><p><strong>Stefull vs Stateless<\/strong><\/p><p>Applikasjoner vil helst ha f&#229; statefull komponeter, dat det er lett &#229; f&#229; en veldig kompleks app ved overbruk. Man har gjerne en hovedkomponenet som holder state for flere stateless&#160;underkomponenter. P&#229; denne m&#229;ten sentraliseres databehandling, og underkomponentene kan fokusere p&#229; visning av data. Data flyter alltid nedover i React, s&#229; underkomponenter vil aldri&#160;m&#229;tte opdateres individuelt, da deres overkomponent vil opdatere underkomponenter ved endrig h&#248;yere i hiriarkiet.&#160;<\/p><p>&#160;<\/p><p>Et eksempel vil v&#230;re ett bibliotek hvor en overordnet komponent, &#34;Library&#34;, som med state laster, lagrer, endrer og vidreformidler data om b&#248;ker via props til underkomponent, &#34;Book&#34;, som kun&#160;har som oppgave &#229; vise data p&#229; en fornuftig m&#229;te.<\/p><p>&#160;<\/p><p><strong>Props<\/strong><\/p><p>Props er et konsept hvor man sender&#160;informasjon fra en komponent nedover i hiriarkiet til en annen. Man kan tenke p&#229; det som &#229; gi argumenter til en funksjon. Props kommer fra parent-komponenten og er alltid uforanderlig for komponenten som mottar.<\/p><p>&#160;<\/p><p><strong>Context &#38; Statemanagers<\/strong><\/p><p>Alt nevnt over er med React uten noen form for tredjeparts bibliotek. Men det finnes mange former for behandling av state som forenkler oppgaven. React selv har for&#248;vrig en form for state manager med Context.<\/p><p>&#160;<\/p><p>Context gir applikasjonen mulighet til &#229; definere &#34;global&#34; variabler&#160;&#248;verst i hiriarkiet, som alle underkomponenter kan bruke uten at man m&#229; sende data nedover via props. Dette er ofte brukt&#160;for globale variabler, som f.eks. tema&#160;eller lignende, hvor mange komponenter vil ha bruk for data.<\/p><p>&#160;<\/p><p>Andre statemangaers fungere generelt p&#229; samme m&#229;te, med en overordnet &#34;provider&#34; som holder p&#229; data, mens underkomponenter bruker, endrer&#160;og oppdateres av states hentet derfra.<\/p><p>&#160;<\/p><p>Kilder:&#160;https://reactjs.org/docs<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3272,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en state-manager for React, utviklet av Facebook, som skal v&#230;re en minimal state-manager med veldig lignende syntax til React&#160;og&#160;tillegssfunksjoner som forbedrer ting som f.eks.&#160;effektivitet&#160;og debugging.<\/p><p>&#160;<\/p><p><strong>Atoms<\/strong><\/p><p>I Recoil definerer de state som Atoms. Disse brukes og fungerer p&#229; samme m&#229;te som vanlig state, og er globale som en delt tilstand. Spesielt for Recoil har disse en &#39;key&#39; som brukes for debugging og lignende.<\/p><p>&#160;<\/p><p>Recoil har et root-provider i likhet med andre state managers, som plaseres &#248;verst i hiriarkiet hvor Recoil skal brukes. Atoms defineres hvor som helst, men gjerne p&#229; et sted hvor det er hensiktsmessig &#229; importere dem for bruk. Atoms kan brukes som helt vanlig state, og syntaxen for dette er n&#230;rmest identisk med vanlig React state. (useState = useRecoilState). Disse kan ogs&#229; defineres med &#39;useRecoilValue&#39; for &#229; v&#230;re read-only.<\/p><p>&#160;<\/p><p><strong>Selectors<\/strong><\/p><p>Selectors er funksjoner som fungerer som state. Disse kan bindes til en Atom, og derav opdateres p&#229; samme m&#229;te som state n&#229;r endringer blir gjort. P&#229; denne m&#229;te unng&#229;r man un&#248;dig behandling av data da det gj&#248;res gjennom Recoil og alle relevante komponenter f&#229;r resultat som om det skulle v&#230;re state.<\/p><p>&#160;<\/p><p>I forhold til l&#248;sninger som Redux, er Recoil veldig simplifisert og likt klassisk React. L&#230;ringskurven er ikke like hard som med redux, og man har veldig fine verkt&#248;y for f.eks. &#229; f&#229; state i url&#160;og debugging.<\/p><p>&#160;<\/p><p><strong>Kilder<\/strong><\/p><ul>\t<li>https://recoiljs.org/docs<\/li><\/ul>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1510,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Rest API<\/strong><\/p><p>Et REST API (Representational State Transfer), er et <em>konsept <\/em>hvor man ved requests til endepunkter p&#229; en server (POST,GET,UPDATE,DELETE) f&#229;r strukturert respons fra, eller manipulerer data p&#229; serveren. Dette er et enkelt og robust system for &#229; h&#229;ndeter overf&#248;ring av data mellom applikasjoner og database.<\/p><p>&#160;<\/p><p>Med Rest sender man en foresp&#248;rsel til en server via http, dette kan v&#230;re en enkelt GET til et endepunkt som f.eks. (http://www.bibliotek.no/api/boker). Man mottar s&#229; en respons med data fra dette endepunktet. Disse dataene levers som definert i Apiet og kan bare manipuleres som lagt til rette for i backend.<\/p><p>&#160;<\/p><p><strong>GraphQL<\/strong><\/p><p>I motsetning til et Rest API er GraphQL en rekke verkt&#248;y, og ikke en form for konsept. GraphQL foresp&#248;rsler gj&#248;res til et endepunkt, gjennom querier definert ut fra hvilke data som er tilgjengelig. P&#229; denne m&#229;ten kan man hente og manipulere&#160;veldig spesifike data med &#232;n request.<\/p><p>&#160;<\/p><p><strong>Sammenligning<\/strong><\/p><p>La oss si at du vil ha en enkel liste med b&#248;ker og deres forfatter&#160;fra et bibliotek. Her vil du bare ha navn p&#229; bok og forfatter. Dersom du skulle hente dette fra et d&#229;rlig definert RestApi ser jeg for meg en l&#248;sning hvor man f&#248;rst m&#229; hente ut b&#248;ker gjennom et endepunkt som /boker/, her vil du en liste med all relevant data som b&#248;ker, inkludert en ID til en forfatter. Deretter m&#229; du sende en foresp&#248;rsel for hver enkelt forfatter til /forfatter/:id: for &#229; f&#229; data p&#229; de relevante forfatterene. Dette er mangle foresp&#248;rsler og mye un&#248;dvendig data for kunn &#229; hente navn p&#229; bok og forfatter. (Dette er urealistisk da ingen Rest API er definert s&#229; d&#229;rlig)<\/p><p>&#160;<\/p><p>I motsetning kan man se p&#229; samme problemstilling fra GraphQL. Her vil vi ogs&#229; ha navn p&#229; bok og forfatter. G&#229;r man&#160;ut fra at dataene er definert med lenker mellom b&#248;ker og fofattere, kan man hente all data man trenger med et kall. Eksempelvis: {Bok{navn,forfatter{navn}}}. Her f&#229;r man&#160;ogs&#229; kun&#160;de data man sp&#248;r etter, og unng&#229;r henting av un&#248;dig data man ikke har bruk for.<\/p><p>&#160;<\/p><p>Rest er industtristandaren for &#248;yeblikket, og fungerer godt dersom endepunktene er godt skrevet. Men GraphQL har fordeler som utveier l&#230;ringskurven som kreves for &#229; sette seg inn i det.<\/p><p>&#160;<\/p><p>Kilder<\/p><ul>\t<li>Rest:&#160;https://en.wikipedia.org/wiki/Representational_state_transfer<\/li>\t<li>GraphQL:&#160;https://en.wikipedia.org/wiki/GraphQL<\/li><\/ul>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11533814,"ext_inspera_userAssessmentSetupId":7140121,"ext_inspera_userAssessmentId":4841274,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Slorer Isabel Sørheim (10223)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35242230,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2503,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er komponenters &#34;tilstand&#34; og er det som gj&#248;r en side interaktiv. Staten til komponenter kan endres med setState() som da vil f&#248;re til ny rendring av komponenten. Ofte &#248;nsker man at komponentene skal snakke med hverandre, og at endring i en komponent skal oppdatere staten i en annen. Man f&#229;r alts&#229; en dataflyt mellom komponentene. En metode &#229; gj&#248;re dette p&#229; er &#229; sende props nedover i komponent hiriarikiet, alts&#229; fra forelder til barn. Props kan brukes til &#229; initialisere states. N&#229;r man sender props nedover vil barne-komponeneten&#160;ha tilgang p&#229; metoder definert i foreldrekomponenten, og kan gj&#248;re &#34;callbacks&#34; for &#229; oppdatere forledres state.<\/p><p>&#160;<\/p><p>Dette kan fort bli tungvindt dersom man har en applikasjon med omfattende state, og &#248;nsker en dataflyt mellom komponenter som ikke ligger n&#230;rme hverandre i komponenthiriarkiet. Det kan da v&#230;re nyttig &#229; bruke en l&#248;sning for state management. Tre forskjellige metoder for dette er: Context, Redux og MobX, som gj&#248;r det mulig &#229; endre states akkruat der man trenger det i komponenthiriarkiet.<\/p><p>&#160;<\/p><p>Context gj&#248;r det mulig &#229; sende data &#34;globalt&#34; i et komponent-tre. For &#229; gj&#248;re dataen tilgjengelig oppretter man en Context med&#160;en provider og en consumer, der provideren gj&#248;r staten tilgjengelig for alle barnekomponenter, og consumeren kan ta i mot dataen fra &#34;provideren&#34;. Man kan bruke &#34;useContext&#34; hooken, som forenkler dette en del. Man kan da lagre denne i en variabel med contexten man har laget som arguemnt, og trenger kun &#229; kalle p&#229; denne variablen for &#229; f&#229; tilgang p&#229; staten. Det finnes ogs&#229; flere hooks som kan benyttes med Context.&#160;Ulemper med context er at det kan v&#230;re vanskelig &#229; vedlikedholde for komplekse applikasjoner, og er ikke id&#233;elt &#229; bruke n&#229;r data kan forandre seg fortl&#248;pende.&#160;<\/p><p>&#160;<\/p><p>Redux og Mobx gj&#248;r det mulig &#229; samle alle states p&#229; en plass. Redux benytter seg av en Store som holder p&#229; statene, Actions som sender med endringen som skal skje, og Reducers som oppdaterer staten basert p&#229; Actionen den tar inn. Mobx benytter seg av flere stores, og g&#229;r mer autmatisk enn Redux, der man m&#229; skrive alt av kode selv. Redux har mye boilerplate og egner seg derfor best til store prosjekter. Mobx har mindre boilerplate og egner seg derfor bedre til mindre prosjekter.&#160;<\/p><p>&#160;<\/p><p>https://blog.logrocket.com/use-hooks-and-context-not-react-and-redux/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2887,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en metode for state management som lar deg lage en &#34;dataflyt-graf&#34; best&#229;ende av atomer&#160;og selectors. Atomer beskrives som&#160;&#34;units of state&#34;. Dette er alts&#229; en delt state, som er tilgjengelig for komponentene og som de kan &#34;abonnere&#34; p&#229;. Atomene&#160;har en global n&#248;kkel som er unik. Selectors er rene funksjoner som kan ta inn atomer eller andre selectors som input. Komponenter kan abonnere p&#229; selectors slik som atomer, og n&#229;r selectoren endres vil atomene bli re-rendret.<\/p><p>&#160;<\/p><p>Generelt gj&#248;r recoil state management&#160;p&#229; en m&#229;te som er bedre tilpasset til react og m&#229;ten det benytter et komponent-tre p&#229;, siden recoil benytter en rettet graf som er iboende og festet til komponenttreet. Tilstandsendringer kan da enkelt flyte fra&#160;atomer (r&#248;ttene), gjennom funksjoner (/selectors) og inn i komponenentene.<\/p><p>&#160;<\/p><p>P&#229; samme m&#229;te som Redux har en store som holder p&#229; states, har Recoil atomer som holder p&#229; states, men dette er kun minimale states. Selectors kan tilpasse og kalkulere akkurat den staten komponentne trenger, med utgangspunkt i de minimale statesene. Dette gj&#248;r at man slipper redundante states, og at man sparer en del arbeid. Man slippper&#160;&#34;boilerplaten&#34;&#160;som gj&#248;r Redux komplisert &#229; sette opp.<\/p><p>&#160;<\/p><p>I forhold til context forenkler Recoil deling av state med at de er&#160;tilgjengelig for alle komponenter, mens i context m&#229; staten ligge i en felles foreldrekomponent for &#229; kunne brukes av barnekomponenter.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1760,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er to forskjellige m&#229;ter &#229; f&#229; tak i dataen man trenger fra en server.<\/p><p>&#160;<\/p><p>Med REST API benytter man seg av endepunkter som er ferdig definert i backend, som&#160;forteller serveren&#160;hva som skal hentes. Man vil da f&#229; tilbake et helt datasett ut fra hvilket endepunkt&#160;(URL)&#160;som ble sendt. GraphQL er derimot et sp&#248;rrespr&#229;k for API, der man definerer hva man &#248;nsker &#229; hente fra serveren gjennom sp&#248;rringen, og vil f&#229; tilbake akkurat det man sp&#248;r om (verken mer eller mindre). Det er alts&#229; kun <strong>ett endepunkt&#160;<\/strong>som det sendes tilpassede sp&#248;rringer til ut fra hva man trenger fra serveren.&#160;REST API benytter seg av GET, POST, PUT og DELETE metodene til HTTP for &#229; hente, opprette, endre eller slette data, mens GraphQL, benytter POST metoden for &#229; sende sp&#248;rringene til serveren. &#160;<\/p><p>&#160;<\/p><p>Fordeler med REST er at det er enkelt &#229; manipulere og forst&#229;, og er det vanligste &#229; bruke. Det kan l&#248;nne seg &#229; bruke dersom man trenger mye informasjon fra en side. Fordel med GraphQl er at man kun for den dataen man trenger, og slipper &#34;overhenting&#34; som man f&#229;r med REST. Ulemper med Graph er at det er mer komplekst &#229; hente dataen, men dette kan likevel l&#248;nne seg i lengden.&#160;GraphQL st&#248;tter kun JSON data, mens REST kan sende data p&#229; flere formater som XML, HTML, tekst, osv. I tillegg er det vanskeligere for GraphQL &#229; utnytte &#34;cashing&#34; med HTTP, som derimot er enklere for REST &#229; utnytte siden REST bruker grenssnittet til protokollene den eksisterer i, og kan da utnytte cashing n&#229;r REST er implementert i HTTP.<\/p><p>&#160;<\/p><p>https://phil.tech/2017/graphql-vs-rest-caching/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533852,"ext_inspera_userAssessmentSetupId":7139996,"ext_inspera_userAssessmentId":4841492,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Johansson Maud (10094)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34517256,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2408,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er komponent basert javascript bibliotek der&#160;komponentene har en egen tilstand som representerer en del av grensesnittet. For &#229; lagre og endre tilstand har React egne og veldig gode mekanismer for h&#229;ndtering av dette:<\/p><p>&#160;<\/p><p>Props og state:&#160;<\/p><p>Dersom du &#248;nsker &#229; lagre en verdi/tilstand lokalt kan man ta i bruk react state som lagrer en tilstand lokalt inne i en komponent. I klassekomponenter initialiseres state i konstrukt&#248;ren, mens for funksjonelle komponenter bruker man react hooks for &#229; sette og endre en state. Funksjonelle komponeneter er egt stateless, og for at de skal kunne bruke state m&#229; de ta i bruk hooks. En endring i state vil f&#248;re til en ny rendring av komponentene, der UI vil oppdatere seg. N&#229;r en tilstand skal deles med andre komponenter sendes den gjennom med props. Dette er en mekanisme som sender data nedover i komponenthierarkiet ved hjelp av dataflyt. Med dataflyt mener vi da at vi sender callback funksjoner som props fra foreldre komponenter til barnekomponenter slik at barnekomponentene kan bruke denne til &#229; sette verdier og ny state p&#229; foreldrekomponentene.&#160;<\/p><p>&#160;<\/p><p>Dersom du har data som skal leses av mange komponenter vil bruk av props og state v&#230;re litt tungvint, da vi vil f&#229; mange callbacks og un&#248;dvendig mye komplisert kode. Da kan man istedenfor ta ibruk metoder for state management som lagrer data globalt. Dette vil v&#230;re praktisk for applikasjoner med mer omfattende state. P&#229; denne m&#229;ten vil vi kunne samle staten p&#229; en plass og hente den ut direkte. For &#229; gj&#248;re staten tilgjengelig for andre komponenter brukes en Provider(ofte i App komponenten da denne ofte er h&#248;yest i hierarkiet).Eksempler p&#229; state management:<\/p><p>&#160;<\/p><p>Redux:<\/p><p>Redux har en relativt kompleks boilerplate. Det er mye kode som m&#229; implementeres, men til gjengjeld vil det v&#230;re praktisk n&#229;r vi f&#229;r st&#248;rre prosjekter. Redux har kun en store som oppdateres av reducers som har en action. N&#229;r en action endrer verdien vi har lagret i store vil UI oppdatere seg. Man kan ikke endre store uten &#229; g&#229; gjennom reducers og actions. Dette gj&#248;res ved &#229; dispatche en action og opprette en type action som du &#248;nsker &#229; gj&#248;re. Denne action vil da ha en verdi som g&#229;r gjennom reduceren og oppdateren staten i store.&#160;<\/p><p>&#160;<\/p><p>MobX:<\/p><p>Har en action som som oppdaterer en state/observat&#248;r og ved en oppdatering vil det skapes en reaksjon hos de observerte komponentene slik at UI endres. MobX er enklere &#229; starte med da den ikke har like mye boilerplate som redux. Ved bruk av mobX vil vi ogs&#229; kunne ha flere stores og mer fleksibilitet n&#229;r det kommer til endring av store. Her vil staten v&#230;re foranderlig og det vil dermed v&#230;re lettere &#229; oppdatere staten.&#160;<\/p><p>&#160;<\/p><p>Context:&#160;<\/p><p>Context kan brukes dersom man har data som ikke endres s&#229; mye, alts&#229; relativt statisk data. For hver del av dataen som skal v&#230;re tilgjengelig vil vi lage en ny context.&#160;Context&#160;kan v&#230;re vanskelig &#229; vedlikeholde dersom vi har veldig komplekse applikasjoner og fortl&#248;pende foranderlig data. Da vil det v&#230;re bedre &#229; bruke mobX og Redux, men dersom vi har en litt mindre og enklere applikasjon vil context funke fint.&#160;<\/p><p>&#160;<\/p><p>&#160;&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2342,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for react. Komponentene som skal bruke recoil state trenger en RecoilRoot i foreldrekomponenten. Denne fungerer p&#229; samme m&#229;te som en Provider som nevnt i oppgave 1. Man wrapper gjerne recoilroten rundt hele App komponenten da denne gjerne er h&#248;yest i komponenthierarkiet. Dersom vi har en komponent som er enda h&#248;yere i hierarkiet kan vi heller wrappe recoilroten rundt denne.&#160;<\/p><p>Recoil bruker en atom som representerer en del av staten. Atoms kan bli lest fra og skrevet til fra andre komponenter og fungerer litt&#160;som en store som inneholder en global state. Komponentene som leser fra disse atom verdiene vil implisitt bli knyttet sammen med dette atomet slik at dersom atomet endrer seg vil alle komponentene som leser eller skriver til dette atomet rendres p&#229; nytt. For &#229; kunne bruke atom verdiene m&#229; komponentene ha en useRecoilState() som fungerer litt p&#229; samme m&#229;te som useDispatch(). Denne brukes for &#229; kunne lese og skrive til selve atomet. Recoil bruker ogs&#229; selector som representerer en form for transformasjon av state der vi vil f&#229; ut den nyere og oppdaterte staten. useRecoilValue() kan brukes for &#229; lese verdien satt av selector.&#160;<\/p><p>&#160;<\/p><p>Vi ser at Recoil fungerer litt p&#229; samme m&#229;te som metodene for statemanagement som vi har nevnt i oppgave 1. Vi har en recoilroot som gir tilgang til atom verdiene p&#229; samme m&#229;te som Provider gir tilgang til verdier i store.&#160;Vi har et atom som inneholder staten p&#229; samme m&#229;te som vi i f.eks redux og mobX har en store som inneholder staten. N&#229;r en state vil bli oppdatert vil komponentene som bruker atom verdien eller store verdien rerendres. B&#229;de redux,mobX og recoil har en selector som returnerer den oppdaterte og nye staten som du &#248;nsker &#229; f&#229; ut. Siden man kan lese og skrive til atom direkte vil den fungere litt mer som mobX ettersom mobX er litt mer fleksibel p&#229; endring i state i forhold til redux.&#160;<\/p><p>&#160;<\/p><p>Recoil fungerer p&#229; samme m&#229;te som redux, mobX og context som en form for erstatter for usestate. Dersom du allerede har en React app vil det kunne v&#230;re enklere &#229; implementere recoil. Ettersom recoil er nye<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2436,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest<\/p><p>-Overordnet arkitektur for klient/tjener kommunikasjon der man leser,skriver og endrer p&#229; ressurser som identifiseres med en URL.&#160;<\/p><p>-bruker flere endepunkter med HTTP foresp&#248;rslene; GET, POST,PUT.., for &#229; lese, skrive og endre p&#229; data. N&#229;r vi har mange endepunkter vil vi kunne f&#229; mye oppdateringer og mye overfetching.&#160;<\/p><p>-Siden vi har flere endepunkter med Rest kan vi ende opp med veldig mange kall og mye overfl&#248;dig data.&#160;<\/p><p>-REST definerer hvilke data som skal returneres og du vil alltid f&#229; et komplett datasett<\/p><p>-Ved bruk av REST kan man f&#229; nytte av caching mekanismen som st&#248;ttes av alle weblesere.&#160; Dette kan v&#230;re viktig for effektivitet og skalerbarhet.&#160;<\/p><p>-Rest blir ofte brukt for &#229; lage nye API<\/p><p>&#160;<\/p><p>&#160;<\/p><p>GraphQL:<\/p><p>-prim&#230;rt et sp&#248;rrespr&#229;k som bygger p&#229; queries&#160;<\/p><p>-Graphql bruker kun et endepunkt som inneholder Queries&#160;<\/p><p>-Ettersom vi kan spesifisere feltene man &#248;nsker &#229; hente ut vil man ikke ende opp med &#229; f&#229; noe under eller over fetching av data, som man kan f&#229; ved bruk av REST. Vi vil alts&#229; f&#229; minde overfl&#248;dig data<\/p><p>-Har en mangel p&#229; implisitt caching i HTTP laget som bidrar til vanskeligheter for &#229; cache.<\/p><p>-St&#248;tter kun JSON data.<\/p><p>-vil f&#229; en mindre og mer konsis kode som til gjengjeld gir en renere arkitektur&#160;<\/p><p>-Graphql bruker et typesystem som hjelper med &#229; fange opp feil.<\/p><p>-Vi vil ogs&#229; f&#229; en kjappere feedback<\/p><p>-mesteparten av arbeidet med queries vil bli liggene p&#229; serversiden. Man sender sp&#248;rringer til en server hvor du definerer s&#248;k og hvilke data som skal returneres.&#160;<\/p><p>-GraphQL blir ofte brukt til optimalisering og forbedering av API&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11533922,"ext_inspera_userAssessmentSetupId":7139929,"ext_inspera_userAssessmentId":4841498,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Flaarønning Haakon Trøstheim (10194)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33588148,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2433,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Innad i komponenter:<\/p><p>For funksjonelle komponenter brukes useState-hooken for &#229; holde p&#229; state i komponenten. Da spesifiserer man en variablen sammen med en setter-funksjon som endrer staten til denne variablen. For klassekomponenter definerer man gjerne et state-objekt i constructor. I tillegg blir gjerne gettere og settere definert i constructor som kan bli kalt andre steder for &#229; endre state i klassekomponenten.<\/p><p>&#160;<\/p><p>Dataflyt og global state h&#229;ndtering:<\/p><p>Dataflyten i react baserer seg p&#229; muligheten til &#229; sende properties&#160;fra en komponent (forelder) til en annen (barn) ved definering av en ny komponent. Slik leder man dataflyt nedover i hierarkiet. For &#229; sende dataflyt oppover i hierarkiet (ved at en barn-komponent endrer state til en forelder) kan man sende callback-funksjoner ned til barnet, som kan bli kalt i barn-komponenten, som deretter endrer state i forelderen og re-rendrer ber&#248;rte komponenter.<\/p><p>&#160;<\/p><p>Problemet oppst&#229;r n&#229;r man blir n&#248;dt til &#229; sende props gjennom mange komponenter for &#229; f&#229; data ned til komponenten som skal anvende den. Da er det bedre med en mekanisme som st&#229;r for global state h&#229;ndtering. Redux, mobX og context er eksempler p&#229; disse:<\/p><p>&#160;<\/p><p>Redux:<\/p><p>Redux gir mulighet til &#229; lagre data p&#229; et sted, som kan bli gjenbrukt p&#229; flere forskjellige steder i prosjektet. Med redux har man en &#34;store&#34; med flere&#160;&#34;reducere&#34; som innehar de globale variablene du vil lagre. For &#229; gj&#248;re endringer p&#229; disse variablene dispatcher man en action (som har en type og spesifisering av variablene som skal endres), som n&#229;r reduceren som igjen oppdaterer storen. Til slutt f&#248;rer dette til en re-render av komponentene som ble p&#229;virket av endringen i redux. Med redux gj&#248;res alt manuelt - man har mulighet til &#229; sette opp store, reducers og actions helt selv noe som gj&#248;r det veldig p&#229;litelig (men krever en del arbeid).<\/p><p>&#160;<\/p><p>MobX:<\/p><p>MobX fungerer litt annerledes: Med mobX setter man datastrukturer til observerbare (observable), og komponenter til observat&#248;rer. N&#229;r verdien til en &#34;observable&#34; blir endret for&#229;rsaker det en re-render av komponentene som ble p&#229;virket av endringen. I mobX er det&#160;ingen &#34;store&#34;, eller dispatching av actions - man endrer bare en verdi, s&#229; gj&#248;r mobX resten for deg. MobX anses derefor som mer automatisk, som gj&#248;r det lettere &#229; ta i bruk, men er&#160;mindre p&#229;litelig i og med at du ikke styrer hele prosessen selv.<\/p><p>&#160;<\/p><p>Context:&#160;<\/p><p>Context APIet er en tredje metode for &#229; dele verdier p&#229; tvers av prosjektet uten &#229; eksplisitt m&#229;tte sende properties gjennom hvert niv&#229; i komponent-hierarkiet. I context lager man en &#34;provider&#34; for hvert context objekt,&#160;som har en &#34;value&#34; property som inneholder verdien vi vil ha globalt tilgjengelig. P&#229; lik m&#229;te som for redux og mobx vil alle komponenter som er etterkommere av en &#34;provider&#34; bli re-rendret n&#229;r verdien til provideren endres.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3766,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en annen state h&#229;ndtering mekanisme som gj&#248;r det enkelt &#229; bruke og endre verdier i ulike komponenter i prosjektet. P&#229; den m&#229;ten ligner det redux, mobX og context i at den gj&#248;r det mulig &#229; slippe &#229; sende props langt nedover i komponent-hierarkiet.&#160;<\/p><p>&#160;<\/p><p>Recoil har fokusert p&#229; &#229; lage en state h&#229;ndteringsmekanisme som ligner p&#229; tradisjonelle react hooks, s&#230;rlig useState-hooken. I recoil lager man &#34;atoms&#34; som inneholder en unik key og en default verdi. useRecoilState-hooken er brukt p&#229; lik m&#229;te som useState-hooken, ved at man definerer hvilken atom man skal hente ut (subscribe til), sammen med en funksjon som brukes til &#229; endre verdien til atomet. Forskjellen fra &#229; bruke den ordin&#230;re useState-hooken er at denne staten kan bli delt p&#229; tvers av komponenter.&#160;<\/p><p>&#160;<\/p><p>I tillegg har recoil &#34;selectors&#34; som er rene funksjoner (basert p&#229; funksjonell programmering med deklerativ kode og immutable verdier). En selector tar et atom eller en annen selektor som input, sender den gjennom en ren funksjon som modifiserer staten. Et eksempel kan v&#230;re en selektor som tar inn et atom som best&#229;r av en liste med filmer, og returnerer den samme listen, men sortert alfabetisk.&#160;N&#229;r et atom eller en selektor oppdateres vil komponentene som avhenger av dem bli re-rendret.<\/p><p>&#160;<\/p><p>Fordeler med recoil vs redux/mobx/context:<\/p><p>- Ligner den innebygde useState-hooken til React. Det gj&#248;r det lettere &#229; sette seg inn i, i motsetning til redux, mobX og context som krever mer &#34;ny&#34; implementasjon.<\/p><p>- Man kan lage atomer under kj&#248;ring av applikasjonen. Disse trenger alts&#229; ikke v&#230;re initialisert ved start av kj&#248;ring. Dette er til forskjell fra data i redux/mobx/context som m&#229; bli initialisert ved start.<\/p><p>- Benytter seg av funksjonell programmering med rene funksjoner. Det reduserer kompleksitet og&#160;gj&#248;r koden lettere &#229; forst&#229;. Actions i redux og mobX baserer seg i st&#248;rre grad p&#229; imperativ programmering.<\/p><p>- Mindre &#34;setup&#34;. Man trenger ikke lage store, reducers, actions, providers, observables etc&#160;og koble disse til hele prosjektet slik man gj&#248;r for redux, context, mobx. Med recoil lager man kun&#160;atomer og selectors som kan bli anvendt p&#229; tvers av komponenter.<\/p><p>- Mer effektiv re-rendering: Atomene fungerer p&#229; en m&#229;te som en egen store (som man ser i redux). Med mange stores istedenfor en felles store blir det&#160;lettere &#229; identifisere hvilke komponenter som skal oppdaters:&#160;Kun komponenter som er subscribet til en atom eller selektor blir&#160;re-rendret ved endringer i atomet/selektoren.<\/p><p>- Innebygd st&#248;tte for async operasjoner,&#160;i motsetning til&#160;redux.<\/p><p>&#160;<\/p><p>Ulemper med recoil:<\/p><p>- Mindre kontroll enn med eksempelvis redux. I redux oppretter man alt manuelt, og har mer kontroll over hele prosessen. Oppdatering av state skjer mer automatisk i recoil, som gj&#248;r det noe mindre p&#229;litelig.<\/p><p>- Recoil er et relativt nytt state h&#229;ndteringssystem som essensielt gj&#248;r det samme som allerede etablerte og fungerende state h&#229;ndteringsmekanismer (redux/mobx/context). Det er mindre testet og dokumentert.<\/p><p>- Kan bli rotete og vanskelig &#229; skille Recoil hooks fra React hooks. Med redux, mobX er global state h&#229;ndtering tydelig avskilt fra &#34;lokal&#34; state h&#229;ndtering.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":954,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>1. Med REST definerer man enkepunkter for &#229; utf&#248;re CRUD-operasjoner&#160;p&#229; entiteter/ressurser ved hjelp av URI og HTTP operasjoner (GET/POST/PUT/DELETE...). Med GraphQL sender man sp&#248;rringer til en server, hvor sp&#248;rringen beskriver selve s&#248;ket og hvilke data som skal returneres/slettes/oppdateres. REST er alts&#229; ressurs-basert, mens graphQL er query-basert.<\/p><p>2. GraphQL har et innebygd typesystem som gj&#248;r det mulig &#229; utf&#248;re validering p&#229; queries. Dette er ikke innebygd for REST, og m&#229; implementeres manuelt.<\/p><p>3. Kobling mellom tjener og server er tettere for graphQL, da man definerer skjemaer med struktur og typer. REST, p&#229; den andre siden,&#160;er tilstandsl&#248;s, og har ingen spesiell kobling mellom tjener og klient.<\/p><p>4. REST benytter seg av nettleserens innebygde mekanisme for caching, noe graphQL ikke gj&#248;r.<\/p><p>5. GraphQL bruker kun JSON for utveksling av data. REST har st&#248;tte for andre typer, og der er blant annet vanlig &#229; bruke XML i responsdata.<\/p><p>6. For store prosjekter er man gjerne n&#248;dt til &#229; opprette mange endepunkter for &#229; ha mulighet til &#229; hente ut all informasjonen man trenger. Det gj&#248;r at prosjektet blir stort, og det f&#248;rer gjerne til overfetching, hvor man henter ut mer data enn det man egentlig trenger. Eksempelvis har man kanskje et endepunkt for &#229; hente ut all informasjon om en gitt bruker: GET /users/:id. Dersom man kun trenger &#229; hente ut navnet til en gitt bruker, bruker man gjerne dette endepunktet selv om den henter ut mye mer informasjon enn man trenger. Det er d&#229;rlig praksis og kan utgj&#248;re en risiko for at informasjon skal komme p&#229; avveie. Med graphQL lager man derimot en sp&#248;rring som spesifiserer eksakt hvilken data man skal hente ut, noe som gj&#248;r at man unng&#229;r problemet med overfetching.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11533932,"ext_inspera_userAssessmentSetupId":7140031,"ext_inspera_userAssessmentId":4841433,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Solberg Anders (10215)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330941,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3179,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En av de enkleste m&#229;tene &#229; h&#229;ndtere state i React-applikasjoner er i og gjennom komponentene med &#34;props&#34;. Dette er data som du sender med en komponent n&#229;r du oppretter den fra forelder. Om jeg har en film-komponent som har hentet og lagret data om en film, og s&#229; bruker jeg kanskje en tittel-komponent for &#229; vise tittelen p&#229; en fancy m&#229;te, da ville jeg sendt tittel-strengen til tittelkomponenten som en prop fra film-komponenten n&#229;r jeg oppretter tittel-komponenten.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; bruke props for &#229; p&#229;virke foreldre-komponenter fra barn. Da kan man som forelder lage en funksjon som gj&#248;r de endringene man vil, og s&#229; sende selve den funksjonen som en prop til barn-komponenten. Dette kalles en callback-funksjon.&#160;<\/p><p>&#160;<\/p><p>Selv om props og callback funksjoner er veldig kraftfult og du kan f&#229; mye gjort med de, s&#229; kan det fort bli veldig komplisert og innviklet. Noen ganger er det state som flere komponenter skal bruke, og det hadde v&#230;rt greiere &#229; la den v&#230;re global. Til dette kan man bruke state-h&#229;ndterings rammeverk som Redux eller Mobx. Dette er rammeverk som lar det ha global state, som gj&#248;r at man slepper noen av de mest innviklede props-flytene og callback-funksjonene, og kan heller la props omhandle de litt mer enklere flytene.&#160;<\/p><p>&#160;<\/p><p>I Redux s&#229; har man en &#34;store&#34; som inneholder global state. I tillegg defineres forskjellige &#34;actions&#34; som kan trigges/dispatches, som igjen kj&#248;rer noe som heter&#160;&#34;reducer&#34;-funksjoner som endrer staten. Man kan&#160;spesifisere&#160;&#34;selectors&#34; som kobler seg p&#229; spesifikke verdier i den globale staten, s&#229; du kan bruke de&#160;i komponentene.&#160;<\/p><p>&#160;<\/p><p>For state h&#229;ndtering inne i komponentene bruker vi noe som kalles &#34;hooks&#34;, og mer spesifikt useState-hooken. Med den kan vi lagre variabler som states, og lage funksjoner som skal oppdatere de variablene. Man kan ogs&#229; legge til effects som skal skje n&#229;r disse blir endret, og for &#229; re-rendre komponentene.&#160;<\/p><p>&#160;<\/p><p>I tillegg er det mulig &#229; bruke Localstorage og Sessionstorage og Context-APIet. Man kan tenke p&#229; Context-apiet som en lightweight m&#229;te &#229; h&#229;ndtere global state. Localstorage og Sessionstorage handler mer om &#229; lagre data hos klienten enn &#229; h&#229;ndtere state, men det er mulig &#229; bruke det til dette ogs&#229;. Localstorage lagrer lokalt hos klienten, og det forsvinner ikke selv om man g&#229;r ut og inn av siden. Sessionstorage er bare midlertidig lagring som forsvinner om man g&#229;r ut av fanen.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2187,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Dette er et state-h&#229;ndterings bibliotek, og det ser ut som det er litt som en miks mellom hooks og global state h&#229;ndtering (som Redux/Mobx).&#160;<\/p><p>&#160;<\/p><p>Man kan definere global state-variabler som kalles &#34;atomer&#34;, og med hooks kan man koble seg p&#229; denne globale staten (subscribe) istedenfor lokal state ved &#229; bruke useRecoilState(n&#248;kkel til global state)&#160;istedenfor useState(lokal state variabel).&#160;<\/p><p>&#160;<\/p><p>N&#229;r den globale staten endres, vil alle komponenter som er subscribet re-rendres.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; noe som heter &#34;selectors&#34; som fungerer som funksjoner som kalkulerer data ut ifra atomene (litt som computeds i MobX). P&#229; denne m&#229;ten slipper man &#229; lagre un&#248;dvendig mye state, ettersom mye man bruker ofte kan kalkuleres ut ifra annen state. N&#229;r atomene som en selector er avhengig av endres, s&#229; vil ogs&#229; funksjonen inni selectoren som gj&#248;r kalkulasjonen kj&#248;res p&#229; nytt, og alts&#229; gi selectoren en ny verdi.&#160;<\/p><p>&#160;<\/p><p>I komponenten kan man subscribe p&#229;&#160;selectoren nesten p&#229; samme m&#229;te som atomet, men man bruker useRecoilValue istedenfor useRecoilState, siden selectoren er read-only.&#160;<\/p><p>&#160;<\/p><p>Utenom selector-delen s&#229; fungerer dette nesten helt likt som state-h&#229;ndtering med useState-hooken, bare at istedenfor lokal state s&#229; bruker man global state. Om vi sammenligner med global state-h&#229;ndtering som Redux er det en vesentlig forskjell i hvor &#34;enkelt&#34; det er &#229; sette opp. Redux krever ganske mye boiler-plate kode for &#229;&#160;sette opp en store og actions og reducers osv., mens med Recoil er det bare &#229; definere et atom (som er nesten like enkelt som &#229; definere en variabel), og s&#229; subscribe&#160;med useRecoilState-hooken, som er like lett som &#229; koble seg til med useState-hooken.<\/p><p>&#160;<\/p><p>Ut ifra &#229; lese gjennom n&#229; vil jeg si at dette biblioteket gir mye potensielle fordeler i utviklingen. Det bruker mye deler av hooks-m&#229;ten &#229; programmere p&#229;, som de fleste som utvikler i React vil v&#230;re godt kjent med. Dermed blir det ikke en veldig bratt l&#230;ringskurve. Samtidig s&#229; er det veldig lite boiler-plate kode &#229; sette opp, og man kan ha et fungerende eksempel oppe p&#229; veldig kort tid (som de viser i&#160;https://recoiljs.org/docs/introduction/getting-started).<\/p><p>&#160;<\/p><p>Det er relativt nytt, og omtaler seg selv fortsatt som &#34;an experimental set of utilities for state management with React.&#34; (fra&#160;https://github.com/facebookexperimental/Recoil), s&#229; det vil forsatt skje endringer fremover, som vil gj&#248;re det litt risikabelt &#229; implementere det i produksjons-applikasjoner p&#229; dette statiet (som vi ogs&#229; kan se her:&#160;https://recoiljs.org/docs/guides/dev-tools: &#34;This API is currently under development and will change. Please stay tuned...&#34;). Men om man har et prosjekt som ikke er alt for stort, og som man kan tolerere litt api-endringer i underveis s&#229; virker dette som et utrolig spennende bibliotek som kan gj&#248;re state-h&#229;ndtering i React til en mye greiere jobb enn det er i dag.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1769,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API benytter seg av mange forskjellige endepunkt, som alle har spesifikke oppgaver. I en film-database kan det f.eks. v&#230;re ett endepunkt for &#229; hente alle filmer, mens ett annet endepunkt for &#229; hente en spesifikk film, og kanskje til og med et annet endepunkt for &#229; hente bare skuespillere fra den spesifikke filmen.<\/p><p>&#160;<\/p><p>Graphql skiller seg ganske tydelig ut her ved &#229; bare benytte ett endepunkt for alle sp&#248;rringer, men lar deg spesifisere i sp&#248;rringen akkurat hva slags data du har lyst til &#229; hente ut. S&#229; istedenfor &#229; g&#229; til et spesifikt endepunkt for skuespillere for en spesifikk film, s&#229; g&#229;r du til graphql-endepunktet, og spesifiserer der at du vil hente ut skuespillerne fra den filmen.&#160;<\/p><p>&#160;<\/p><p>Denne forskjellen gj&#248;r at REST og Graphql er ganske ulike i forhold til hvem som f&#229;r st&#248;rsteparten av arbeidet. REST gir mest &#229; gj&#248;re for backend, ettersom de m&#229; spesifisere alle forskjellige endepunkt, og hvilke data det skal returnere. Graphql derimot gir fort mer arbeid for frontend, ettersom det n&#229; er herfra man velger hvilke data man vil ha.&#160;<\/p><p>&#160;<\/p><p>REST er en arkitektur, en m&#229;te &#229; legge opp sp&#248;rringer p&#229;. Det vil si at man kan lage et REST-api i mange spr&#229;k og systemer, s&#229; lenge strukturen er den samme.&#160;Graphql er et spr&#229;k og en runtime for &#229; kj&#248;re sp&#248;rringer. Man kan ogs&#229; implementere dette i mange rammeverk og systemer, men spr&#229;ket man skriver selve graphql-definisjonene i er det samme, og runtimen som kj&#248;rer de.&#160;<\/p><p>&#160;<\/p><p>Graphql er ogs&#229; typet, som vil si at man alltid er sikker p&#229; at man f&#229;r den dataen man vil i den formen man vil, og om man ikke gj&#248;r det s&#229; blir det error. Det er mulig &#229; sette opp typesjekking i REST APIer ogs&#229;, men det er ikke innebygget p&#229; samme m&#229;te.&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533950,"ext_inspera_userAssessmentSetupId":7140084,"ext_inspera_userAssessmentId":4841160,"dateLastModified":"2020-12-01T10:01:24Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:24Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Belsvik Moira Charlotte Reinholdt (10119)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35303436,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2101,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Props er en react-mekanisme som kan brukes til &#229; sende data nedover i komponenthierarkiet ved at data flyter fra foreldre til barn. N&#229;r en komponent opprettes f&#229;r properties&#39;ene (navngitte dataverider) input.&#160;Props er immutable, som vil si at verdiene som en komponent mottar ikke kan endres.<\/p><p>En komponent best&#229;r av variabler som forteller noe om state&#39;en til komponenten. Disse kan endres ved &#229; bruke setState() i React. State har asynkron oppf&#248;rsel og dersom det skjer en endring i state&#39;en til en komponent vil dette gjerne f&#248;re til at komponenten rendres p&#229; nytt.<\/p><p>Konsistens og&#160;redundans er to av utfordringene man har n&#229;r det kommer til &#229; h&#229;ndtere tilstand i React-applikasjoner. For selv om flyten av data i react er grei nok, og kan brukes i enkle apper, kan den fort bli uoversiktlig dersom state brukes i flere greiner i komponenttreet. Dersom man lager en applikasjon med et visst omfang kan dette f&#248;re til at det blir vanskelig &#229; vedlikeholde state fordi man gjerne ender opp&#160;med veldig mange &#34;callbacks&#34; der staten ofte ikke ender den den kanskje burde ende. Callbacks kan man bruke for &#229; implementere dataflyt oppover i et komponenthierarki der barnekomponentene kan sette foreldrenes state ved hjelp av funksjoner sendt til dem fra foreldrene.<\/p><p>For &#229; l&#248;se problemet med at state ikke havner der den burde, kan man ta i bruk for eksempel Redux eller Mobx som et&#160;global state management. Disse gir det muligheten til &#229; ha state p&#229; ett sted, i tillegg til de mekaniskmene som du trenger for &#229; kunne lese state&#39;en. Disse er dog ikke en del av React, men h&#229;ndteres eksternt.<\/p><p>Det g&#229;r ogs&#229; an &#229; bruke Context API&#39;et som en m&#229;te &#229; sende data til de forskjellige komponentene i treet uten at man skal m&#229;tte sende props gjennom hvert eneste niv&#229;. Context API&#39;et brukes alts&#229; n&#229;r man har &#34;globale&#34; data som det er mange komponenter som m&#229; lese.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2846,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for react som gj&#248;r at du kan lage en datafly-graf slik at du kan sende state til de andre komponentene i applikasjonen din. Grafen best&#229;r av atomer, der staten deles med andre komponenter, og disse komponentene rendres p&#229; nytt n&#229;r atomet blir oppdatert. Grafen har ogs&#229; selectors som er reine funksjoner som tar inn atomer eller andre selectors. Selectorene vil kj&#248;res n&#229;r inputen dens endres, og atomer har muligheten til &#229; f&#248;lge visse selectors slik at disse rendres p&#229; nytt n&#229;r selectoren kj&#248;res.<\/p><p>I likhet med hvordan man kan bruke useState() i React, kan man med recoil bruke hooket useRecoilState() for &#229; lese fra og skrive til et atom. Det som useRecoilState() kan som ikke useState() kan er &#229; dele denne endringer med andre komponenter.<\/p><p>Siden recoil er et react bibliotek, vil det i motsetning til for eksempel Mobx og Redux kunne ha&#160;tilgang til reacts sin &#34;indre timeplan&#34;. Mobx er et enkelt og skalerbart bibliotek, som ikke p&#229;virker koden man skriver noe s&#230;rlig. Mobx bruker observable state, der datastrukturene blir mulig &#229; observere, mens komponentene blir de som observerer.&#160;Redux er et verkt&#248;y for&#160;global state management som lagrer state et sted, som kalles for store. Redux Store kan kun leses fra og eneste mulighet for &#229; endre p&#229; store er via actions.Et&#160;problem med Redux, er at det krever veldig mye oppsett selv om man bare trenger en veldig enkel store. Med recoil slipper du i skrive s&#229; mye&#160;boilerplate kode, som er en fordel. Redux og mobx er to veldig godt etablerte verkt&#248;y og sammenlignet med dem vil du med recoil m&#229;tte implementere logikk og design p&#229; egenh&#229;nd. S&#229;nn sett ligner mobx en del p&#229; recoil ettersom man ikke tvinges til &#229; bruke en helt bestemt arkitektur. Det som ogs&#229; er fint med recoil er at man ikke trenger &#229; installere mange andre pakker.<\/p><p>Context API&#39;et, som er en l&#248;sning for deling av state i react, har ogs&#229; problemer med at alle komponenter som &#34;f&#248;lger&#34; et context vil re-rendres selv om den bare delvis bruker noe av data&#39;en context inneholder. Dette kan s&#229;klart l&#248;ses med mange forskjellige context, men det blir vanskelig dersom man vil ha mulighet til &#229; legge til mer data som da vil f&#248;re til at nye context m&#229; lages som s&#229; endrer komponenttreet slik at dette m&#229; rendres p&#229; nytt. Recoil derimot gir deg muligheten til &#229; &#34;f&#248;lge&#34; akkurat den dataen du trenger, og man kan derfor unng&#229; un&#248;dvendige re-renderinger.<\/p><p>En fordel med Recoil er ogs&#229; at den&#160;virker&#160;enkelt &#229; sette seg inn i, spesielt hvis man er godt kjent med hooks.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://medium.com/swlh/recoil-another-react-state-management-library-97fc979a8d2b<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2191,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>F&#248;rst og fremst kan man skille mellom REST og GraphQL p&#229; det at Rest er en overordnet arkitektur for nettbasert software, mens grapgql er et spr&#229;k der man utf&#248;rer sp&#248;rringer.<\/p><p>&#160;<\/p><p>I Rest API bruker man et eller flere endepunkter slik at man kan lese/skrive/endre p&#229; for eksempel en database ved &#229; bruke URI og Http foresp&#248;rsler. Dataen som du f&#229;r tilbake fra f.eks. databasen er definert. Rest er alts&#229; representational fordi den forteller hvordan vi representere ressursene vi har. Et problem med m&#229;ten Rest henter data, med et endepunkt som gj&#248;r en oppgave, er at du alltid vil f&#229; et helt datasett. &#197; hente ut kompleks informasjon kan da f&#248;re til overfetching, alts&#229; at du henter mer data enn du trenger. I graphql er du n&#248;dt til &#229; definere b&#229;de s&#248;k og hvilken data som skal returneres n&#229;r du &#248;nsker &#229; hente noe fra serveren. Siden graphql er basert p&#229; sp&#248;rringer kan du spesifisere akkurat hva du &#248;nsker &#229; hente ut, og dette gj&#248;r at man unng&#229;r overfetching. Rest kan ogs&#229; f&#248;re til underfetching, som graphql ikke kan. Man kan si det s&#229;nn at n&#229;r det kommer til fetching i Rest defineres objektet i backend, mens i graphql gj&#248;res det i frontend.<\/p><p>&#160;<\/p><p>En annen forskjell er at ved bruk av Rest kan man benytte seg av den innebygde cache-mekanismen som alle nettlesere har. Caching er viktig for skalerbarhet og effektivitet. GraphQl har derimot ikke noen implisitt caching.<\/p><p>&#160;<\/p><p>En ulempe med graphql er at den kun bruker JSON for &#229; sende data fram og tilbake, denne limitasjonen har ikke Rest API&#39;et.&#160;Det er ogs&#229; enklere &#229; h&#229;ndtere errorer i rest, da grapgql vanligvis gir en 200 ok status kode.<\/p><p>&#160;<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533133,"ext_inspera_userAssessmentSetupId":7139959,"ext_inspera_userAssessmentId":4841272,"dateLastModified":"2020-12-01T10:01:31Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:31Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Luong Jonny Ngo (10182)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":48647499,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2803,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-applikasjoner er designet med et konsept kalt for &#34;unidirectional data flow&#34; som sin&#160; dataflyt, dvs.&#160;at underordnede komponenter er koblet opp mot&#160;overordnede komponenter.&#160;Generelt betyr dette konseptet at data tilstander (states) bare har en&#160;m&#229;te &#229; blir overf&#248;rt til andre deler av applikasjonen p&#229;. At tilstander (states) blir sendt gjennom overordnede (parent) komponenter&#160;til underordnede (child) komponenter.<br /><br />Prinsippet er dermed det at den overordnede komponenten holder styr p&#229; tilstands dataene som videre blir sendt nedover til sine underordnede komponenter gjennom det vi ofte vil kalle for props (tilstandsdataer som blir sent fra parent til child). Og ved hjelp av React Hooks samt Context f&#229;r vi&#160;muligheten&#160;&#229; dele tilstandslogikken p&#229; tvers av komponenter, b&#229;de i komponenter (lokalt) og i et eget rammeverk (globalt).&#160;Noe videre mekanismer og teknikker som brukes for &#229; bedre implementasjonen til tilstand (state) og&#160;dataflyt i React-applikasjoner er da &#34;state managements&#34; rammeverker som for eksempel Redux og Mobx for &#229; holde kontroll p&#229; komplekse tilstandslogikker p&#229; tvers av komponenter.<\/p><p>&#160;<\/p><p>Redux holder f&#248;rst og fremst sterk p&#229; prinsippen &#34;unidirectional data flow&#34; til React. M&#229;ten Redux funker p&#229; er gjennom bruk av bare en sentral store klasse som holder alt av tilstandlogikken i applikasjonen. Hver komponent blir da gitt tilgang til den lagrede tilstanden uten &#229; m&#229;tte sende det nedover som en prop fra en parent komponent til en annen child komponent. Dette blir gjort gjennom Redux sin: &#34;store&#34; (state/datahandling), &#34;actions&#34; (eventhandling) og &#34;reducers&#34; (funksjonshandling) som er ulike tilstandslogikker&#160;bygget opp av JavaScript objects.<\/p><p>&#160;<\/p><p>Mobx&#160;st&#248;tter ogs&#229; prinsippen &#34;unidirectional data flow&#34;, men lar oss heller lagre tilstandsdater i flere &#34;stores&#34; noe som gir oss en fordel innen gjenbruk mtp. at&#160;noen av tilstandslogikkene kan st&#229; selvstendigt. Forskjellen mellom Mobx og Redux er da med at &#34;actions&#34; kan endre tilstandene uten behov for en &#34;reducer&#34;, og at tilstandsdataene er observerbare. Dette vil si at&#160;n&#229;r dataene endres i tilstand, utl&#248;ser det automatisk en re-render av komponenter, noe som i helhet gir en lightweight og rask ytelse. Mobx er dermed en lettere utgave av &#34;state management&#34; og er for det meste lagd med&#160;simpelhet i tanken framfor redux sin skalerbarhet.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1943,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et Facebook open source &#34;state management&#34;-bibliotek for React&#160;som bygger mye p&#229; den eksisterende React konseptet React Hooks. Det RecoilJS pr&#248;ver&#160;&#229; oppn&#229; er &#229; gj&#248;re det&#160;enklere &#229; implementere fleksible&#160;&#34;state management&#34; p&#229; tvers av komplekse applikasjoner mtp. React sin &#34;unidirectional data flow&#34; konsept. For &#229; oppn&#229; dette definerer Recoil en &#34;Data Flow Graph&#34; som mapper&#160;til React-komponent-treet i en applikasjon, der endring av tilstandene&#160;fra s&#229;kalte &#34;atomer&#34; (unike states med verdier som fungerer som r&#248;ttene til grafen) er koblet til&#160;komponenter gjennom &#34;selektorer&#34; (funksjoner som h&#229;ndterer atomer).<br /><br />Noe vi kan se er at RecoilJS har mye likhet til state managementet MobX, hvor begge&#160;f&#229;r til en global tilstandslogikk gjennom bruken av&#160;&#34;Context&#34; for &#229; binde&#160;sammen komponentene med states/stores med en Provider som det&#160;h&#248;yeste ordens komponentet. Forskjellene mellom RecoilJS, MobX og Redux er da datatypen tilstandene blir lagret som (atoms vs observable vs plain data), og da at RecoilJS har mye likhet til MobX. Mulige fordeler ved dette biblioteket er da dermed ganske lik som MobX, simpelheten og en lett l&#230;ringskurve innen utvikling og virker som et godt kompromiss mellom enkelhet og ytelse. Gjennom dokumentasjonen kan vi kanskje fort ogs&#229; se noen ulemper innen utvikling mtp. at det ikke er s&#229; egnet til komplekse applikasjoner. Biblioteket har da ogs&#229; mindre popularity, noe som gj&#248;r det vanskelig &#229; f&#229; hjelp/finne informasjon p&#229; nettet ang&#229;ende feil og errors, samt vil Redux sine &#34;pure functions&#34; v&#230;re best til &#229; vedlikeholdbar kode, og dermed best skalerbar framfor MobX eller RecoilJS.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2429,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API eller&#160;Representational State Transfer Application Programming Interface er et programmeringsgrensesnitt&#160;som lar spesifikke deler til en&#160;applikasjon kommunisere med en annen applikasjon. Det betyr endringer og&#160;behandling av&#160;data i en st&#248;rre kontekst gjennom HTTP-protokollprinsippene for &#229; gi forskjellig funksjonalitet basert p&#229; metoden som brukes gjennom CRUD operasjonene GET, POST, PUT og&#160;DELETE. Disse metodene sendes gjennom flere &#34;endpoints&#34; som settes opp i en server ved URL Routes.<\/p><p>&#160;<\/p><p>GraphQL, er derimot et query-spr&#229;k for APIer som et alternativ til REST APIet.&#160;GraphQL sendes gjennom et enkelt endpoint, og gjennom det kan vi eksplisitt sp&#248;rre om bare informasjonen man trenger. Forskjellen mellom REST API og GraphQL er da at REST er et konsept/modell som brukes til &#229; designe og implementere APIer gjennom flere endepunkter, mens&#160;GraphQL er helhetlig et&#160;standardisert query-spr&#229;k som kommuniseres gjennom et&#160;endepunkt ved &#34;GraphQL Schema&#34;-er.&#160;Dette hjelper med &#229; spare ressurser p&#229; serveren.<br /><br />REST API og GraphQL bygger p&#229; det samme fundamentalle konseptet til APIer, hvor GraphQL er da lagd med behovet for mer fleksibilitet og effektivitet som forenkler prosessen med &#229; lage store komplekse applikasjoner ovenfor REST API sine enkle implementasjoner, noe som egner seg mindre applikasjoner.<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11533265,"ext_inspera_userAssessmentSetupId":7140046,"ext_inspera_userAssessmentId":4841496,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Nguyen Katrine (10237)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":32822492,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1690,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Props/properties er navngitte dataverdier som gis som input n&#229;r en komponent kalles eller opprettes. Props er uforanderlig, som vil si at de ikke kan endres og dataen den sender flyter fra foreldre til barn. Denne react-mekanismen er for &#229; sende data nedover i konsepthierarkiet. Det vil si at vi kan sende s&#229;kalte &#34;callback&#34; funksjoner som props fra foreldre til barn. P&#229; den m&#229;ten kan barnekomponentene bruke funksjonen de mottar til &#229; sette state p&#229; foreldrekomponenten.&#160;<\/p><p>&#160;<\/p><p>Tilstand (state) er interne variabler i en komponent som kan endres med setState(). En typisk endring av en state vil f&#248;re til en ny rendring av den komponenten man er i, i tillegg til barn av denne. Vi har eksempelvis klassekomponenter som er stateful, som vil si at det implementerer logikk og state. Ogs&#229; har vi funksjonelle kompnenter som er stateless som vil si at de aksepteter data og viser dem i form av rendering UI og gir deg en l&#248;sning uten &#229; bruke state.<\/p><p>&#160;<\/p><p>Innenfor sistnevnte, funksjonelle komponenter, tar man i bruk hooks. Dette lar deg gi funksjonalitet som erstatning for det du f&#229;r i klassekomponenter ved setState(). Hooks som feks useState() som tar inn en default verdi, og hver gang man bruker useState returnerer den en mengde verdier. useStaten har en getter og en setter, eksempel; [name, setName]. Den vil da lage en ny state med variabel &#34;name&#34; og setter defaulten verdien satt som parameter. Deretter vil den returnere den nye staten med setter funksjonen.&#160;Ved bruk av mange useStates i funksjonelle klassekomponenter vil det v&#230;re gunsitg &#229; ta i bruk en useReducer().&#160;<\/p><p>&#160;<\/p><p>En annen mekanisme for tilstand er basert p&#229; properties som du sender inn i en komponent n&#229;r den opprettes. Ved komplekse applikasjoner med flere komponenter hvor for eksempel den samme dataen skal brukes flere steder eller at data skal sendes p&#229; tvers av hierarkiet er det gunstig med en global state. Global state vil si at all dataen lagres ett sted hvor man setter opp en automatisk oppdatering av ber&#248;rte komponenter n&#229;r data endres. Eksempler p&#229; dette&#160;er Contex, Mobx og Redux som er former for state management. Ved bruk av disse vil store applikasjoner med omfattende state v&#230;re lettere &#229; vedlikeholde. State management lar deg samle alle statesene p&#229; en plass og gir deg maknaisme for &#229; endre og lese state der det er n&#248;dvendig i hierarkiet.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3417,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en eksperimentell&#160;state management for React laget av Facebook. Recoil hjelper deg &#229; eliminere un&#248;dvendige re-renders som skjer n&#229;r du bruker for eksempel Contex API eller Redux. Recoil har Atoms som states som kan subscribes p&#229;, slik som flere state management systemer. N&#229;r en atom opdateres vil hver komponent som f&#248;lger den&#160;ogs&#229; oppdateres. Recoil har ogs&#229; selector som tar inn Atoms eller andre selectios som input. N&#229;r disse input verdiene blir oppdatert, vil selectorfunksjonen bli re-renderet. I korte trekk kan vi si at selectoren endrer Atomstaten enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Fordelen med Recoil iforhold til for eksempel Redux er at det ikke krever noe boilerplate. Det vil si at det er mindre setup og konfigurasjon. Redux har mye setupkode som m&#229; implementeres, men jo st&#248;rre prosjektet er, jo bedre. Og med mye erfaring bak seg, gj&#248;r Redux mye lettere pga mengden av boilerplate som kan gjenbrukes. I f&#248;lge Recoil sin dokumentasjon nevner de at Recoil er en boilerplate-fritt API der man kan dele states globalt p&#229; samme m&#229;te som man ville gjort lokalt. Dette gir Recoil en fordel b&#229;de mot Redux som har mye konfigurasjon, til MobX og Contex med litt mindre konfigurasjon.&#160;<\/p><p>&#160;<\/p><p>En annen fordel med bruk av Recoil er deling og oppdatering av states/atoms. Det er mulig &#229; dele states i forskjellige komponenter i React treet. Contex APIet eksempelvis, n&#229;r en state endres&#160;vil alle komponene som dataen ikke engang bruker bli re-rendret. Ved bruk av Recoil og Atom som er en individuell state komponentene kan subscripe p&#229;, vil kun komponentene som f&#248;lger staten bli re-renderet.<\/p><p>&#160;<\/p><p>Recoil tar i bruk useRecoilState() vs useState, der&#160;useRecoilState() kan dele states p&#229; tvers av komponenter. Dette gir Recoil en fordel mot feks Contex som ikke er spesielt designet for forl&#248;pende foranderlig data.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av Redux oppretter vi en store som h&#229;ndterer alle de globale statene i applikasjonen v&#229;r, og i MobX brukes det flere stores. Ved bruk av Recoil trenger vi ingen store i det hele tatt, som gj&#248;r alt mye lettere.&#160;<\/p><p>&#160;<\/p><p>Recoil gj&#248;r state management veldig mye lettere, og sparer utviklere for mye tid. En liten ulempe jeg kan se med Recoil, er at det er veldig nytt i forhold til andre statemanagements som Redux, Mobx og Context.&#160;Det vil si at det er mye &#229; eksperimentere men fortsatt deler som m&#229; videreutvikles med tid. Det vil derfor ikke v&#230;re like mye dokumentasjon rundt Recoil og vanskeligere &#229; finne andre som har samme problem som deg siden ikke like mange har testet/brukt det.&#160;<\/p><p>&#160;<\/p><p>I f&#248;lge kilde 2. (nederst i besvarelsen) nevner de ogs&#229; at Recoil har mangel p&#229; debugging tools, noe som ogs&#229; er en ulempe ved bruk av Recoil. Dette er litt likt som Contex, som er vanskelig &#229; vedlikeholde i store, komplekse applikasjoner. Redux derimot er lettere &#229; debugge siden de mottar en state og action, der det blir returnert en ny state. Dette gj&#248;r Redux mer forutsigbar enn feks MobX og Recoil da b&#229;de MobX og Recoil tillater at states/atoms kan oppdateres og overskrives med nye verdier. Dette gj&#248;r det lettere &#229; implementere men f&#248;rer til at testing og vedlikehold kan bli vanskelig pga uforutsett output.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;<\/p><p>&#160;<\/p><p>1. https://medium.com/javascript-essentials/understanding-recoil-the-state-management-system-for-react-6ef75b63f851&#160;<\/p><p>2. https://bigcheeseapp.com/2020/07/12/recoil-vs-redux-react-state-management-2020/<\/p><p>3.&#160;https://recoiljs.org/docs/introduction/motivation&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2079,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og Graph Ql er to l&#248;sninger for klient-server kommunikasjon i webapplikasjoner&#160;<\/p><p>&#160;<\/p><p>Vesentlige forskjeller mellom disse to er f&#248;rst og fremst at REST h&#229;ndterer mer kompleks informasjon ved at det er ett eller flere endepunkter vha URI og HTTP request i forhold til GraphQL som kun har ett endepunkt.&#160;Siden det er flere endepunkt i REST vil det v&#230;re flere kall for &#229; hente ut data, og kan i noen tilfeller bli hentet ut litt for mye un&#248;dvendig data man ikke trenger (overfetching). Ved bruk av GraphQL, som bare har ett endepunkt, definerer sp&#248;rringene til server hva som skal oppdateres/returneres gjennom en query som forteller hva en vil ha ut. P&#229; den m&#229;ten vil man spesifisere hva man &#248;nsker, og overfetching vil v&#230;re unng&#229;tt.&#160;<\/p><p>&#160;<\/p><p>REST bruker HTTP foresp&#248;rslene GET, PUT, POST, DELETE for &#229; lese, endre, opprette eller sletter ressurser, mens GraphQL spesifiserer i JSON hva en vil hente og hvilke data en vil ha. REST knyttes ofte mot&#160;MERN stacken av rammeverk som st&#229;r for MongoDB, Express, React, Node.js kombinert. GraphQL kan blant annet knyttes mot GRAND stacken st&#229;r for GraphQL, React, Aplollo og Neo4j Databas<\/p><p>&#160;<\/p><p>REST er det vanligste &#229; bruke og hensiktsmessig dersom man vil ha mye informasjon fra en side og du kan dra fordel av caching mekanismen som default st&#248;ttes av alle weblesere. Med&#160;flere endepunkter vil det f&#248;re til flere og st&#248;rre oppdateringer da alt m&#229; oppdateres hver gang. Et eksempel er at du skal hente ut en film fra et movie API, og du vil kun ha ut tittel og rating. APIet best&#229;r av flere felter som feks skuespillere, varighet, beskrivelse, sjanger osv. Hver gang du da kaller p&#229; databasen for &#229; hente ut filmer vil den hente ut alle de feltene du ikke trenger ogs&#229;. Ved bruk av GraphQL kan du spesifisere i queriet ditt hvilke felter du &#248;nsker. Du kan p&#229; den m&#229;ten f&#229; ut akkuratt det du vil uten &#229; overfetching. Ved datasett med veldig mange felter der du kun skal ha ut et f&#229;tall av disse, har GraphQL en veldig stor fordel.&#160;<\/p><p>&#160;<\/p><p>GraphQL har en renere arkitektur ved at mindre kode er konsis. Tjener og klient har noe tettere kobling siden det blir tatt i bruk et skjema som definerer struktur og typer, som kan v&#230;re en fordel siden det muliggj&#248;r validering.&#160;Men en ulempe er amngel p&#229; implitsitt caching i HTTP-laget og at det kun st&#248;tter JSON-data. I tillegg flytter GraphQL mye ar arbeidet som blir spart p&#229; overfetching, til arbeidet med dataquery til serversiden. Dette legger kompleksitet for serverutviklere. &#160;<\/p><p>&#160;<\/p><p><br />&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11534506,"ext_inspera_userAssessmentSetupId":7140008,"ext_inspera_userAssessmentId":4841484,"dateLastModified":"2020-12-01T10:01:45Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:45Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hansen Benedicte Kaltoft (10127)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34405795,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2350,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En React komponent kan ha en &#34;lokal/privat&#34; state. I en class-komponent vil dette v&#230;re State som settes i konstrukt&#248;ren, og denne staten oppdateres med setState. I en funksjonell-komponent, som er stateless og ikke kan &#34;ha&#34; en egen state, brukes Hooks til dette. Da brukes useState for &#229; lage ulike states i komponenten og for &#229; oppdatere disse.<\/p><p>&#160;<\/p><p>Dersom en komponent trenger &#229; dele sin private state med andre komponenter i komponenthierarkiet, kan dette gj&#248;res ved &#229; sende staten gjennom hierarkiet med Props. Props er &#34;read-only&#34; for komponentene som mottar de. Props tas inn som input i komponentene. Props sendes nedover i komponenthierarkiet, fra foreldrekomponenter til barn.&#160;<\/p><p>&#160;<\/p><p>Dersom en state skal brukes av mange komponenter som ligger p&#229; ulike steder i komponenthierarkiet, vil det v&#230;re l&#248;nnsomt &#229; bruke Context istedenfor &#229; sende Props manuelt&#160;gjennom store deler av hierarkiet. Context kan sees p&#229; som en global state. En Context bruker en Provider som legges rundt en komponent i React, og dermed kan den komponenten og alle komponentene lenger ned i hierarkiet aksessere Context-en.&#160;<\/p><p>&#160;<\/p><p>Det er ogs&#229; mulig &#229; flytte state management ut av React og bruke et eksternt bibliotek for &#229; h&#229;ndtere state i applikasjonen. Det er flere mulige biblioteker &#229; bruke til dette. Ett av de er Redux. Redux har en store som inneholder de ulike statene til en applikasjon. I tillegg lager man actions og actionCreators som kan dispatches fra React komponetene for &#229; gj&#248;re endringer p&#229; statene. Actions og ActionCreators forteller hvilken endring som skal gj&#248;res (type) og tar inn input fra React komponenten og sender den videre som payload (sammen med type)&#160;til en Reducer. I Reduceren utf&#248;res endringen p&#229; states. Her kan man lage flere caser som utf&#248;rer ulike endringer, og&#160;det er ulike actions (types) som avgj&#248;r&#160;hvilken case som skal utf&#248;res. Reduceren utf&#248;rer da endringen og returnerer en ny state. Dette f&#248;rer til at storen med states oppdateres. Siden en Redux store er &#34;immutable&#34;, m&#229; det lages en ny store med de oppdaterte statene.&#160;<\/p><p>&#160;<\/p><p>Et annet bibliotek man kan bruke for state management i applikasjonen er MobX. MobX skiller seg fra Redux ved at man ikke skriver like mye av koden for &#229; h&#229;ndtere endringer selv, den er mer automatisert. Dette f&#248;rer til mindre boilerplate, som gj&#248;r at MobX kan v&#230;re et bedre alternativ spesielt for mindre applikasjoner. I MobX har man flere stores som holder p&#229; states. Stores i MobX er foranderlige og kan overskrives med nye verdier. Ved &#229; spesifisere hvilke deler av applikasjonen&#160;som skal observere/lytte til en state, vil MobX selv fikse at disse delene av applikasjonen&#160;ogs&#229; oppdateres n&#229;r storen blir oppdatert.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2100,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management i React, og kan derfor brukes istedenfor f.eks. Redux og MobX som vi har hatt som l&#230;ringsm&#229;l. Recoil er bygget opp av to hoved komponenter, Atoms og Selectors. Atoms er en state, og atmos i Recoil er foranderlige og det er mulig &#229; observe&#160;de slik at alle som observer en atom vil renderes p&#229; nytt n&#229;r atom-et blir oppdatert med en ny verdi. Selectors er funksjoner som tar inn atmos eller andre selectors som input.&#160;<\/p><p>&#160;<\/p><p>Recoil ligner ganske mye p&#229; m&#229;ten man ville brukt useState Hook-en i React komponenter, og vil dermed v&#230;re enklet &#229; sette seg inn i for de som har brukt det f&#248;r.&#160;<\/p><p>En fordel med Recoil er derfor at det er enklere &#229; sette seg inn i. Det er ogs&#229; mye mindre boilerplate i Recoil enn i f.eks. Redux, som ogs&#229; gj&#248;r det enklere &#229; l&#230;re seg og f&#248;rer til mindre set-up som er hensiktsmessig spesielt i mindre prosjekter.&#160;<\/p><p>&#160;<\/p><p>Recoil vil v&#230;re nyttig n&#229;r man trenger at utvalgte states er globale. Alts&#229; hvis de skal brukes av mange komponenter, p&#229; ganske ulike steder i komponenthierarkiet. Det vil da v&#230;re nyttig &#229; kunne bruke Recoil framfor lokale states som tilh&#248;rer en komponent og sendes til andre komponenter med props. I dette tilfellet kunne man brukt Context APIet til React, men Recoil kan v&#230;re et bedre alternativ siden det l&#248;ser noen av problemene med Context.<\/p><p>&#160;<\/p><p>Et av disse problemene som Context har er at det kun kan lagre enkelt verdier, ikke en ubestemt mengde med verdier som skal ha egne &#34;consumers&#34;. Dette kan man gj&#248;re med Recoil.&#160;<\/p><p>&#160;<\/p><p>Noe annet som kan v&#230;re problematisk med Context, og en grunn til &#229; velge Recoil over Context, er at hvis du legger en store (som er en samling av flere states) inn i en Provider, og en av verdiene i denne endres, s&#229; vil alle komponentene som bruker verdien i denne Provideren oppdateres. Dette skjer med alle komponentene som bruker denne Provideren uansett om de kun bruker deler av verdien.&#160;<\/p><p>&#160;<\/p><p>En mulig ulempe med Recoil er at det fortsatt er i en utviklingsfase, og er mindre etablert enn andre alternativer som Redux, Context API et eller MobX. Det kan dermed v&#230;re mer uforutsigbart, og det kan endres raskere.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org/<\/p><p>https://dev.to/alexandrzavalii/recoil-ideal-react-state-management-library-1203<\/p><p>https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2701,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den st&#248;rste forskjellen p&#229; REST API og GraphQL er endepunktene. I REST har man flere endepunkter. I backend bestemmes det hvilke endepunkter man har, og hva av data som skal sendes ved bruk av de ulike endepunktene. I frontend m&#229; man dermed bruke disse ferdig definerte endepunktene. Dette kan f&#248;re&#160;til overfetching, fordi man ikke alltid kan hente ut kun den dataen man &#248;nsker. Men samtidig gir det forutsigbarhet for frontend, og det kan v&#230;re enklere for frontend-utviklerene&#160;fordi man ikke trenger &#229; vite mer om backend og databasen enn hvilke endepunkter som eksistere og hvilken data de gir.&#160;<\/p><p>&#160;<\/p><p>I GraphQL er det kun ett endepunkt. Ved bruk av dette i frontend sender man med informasjon i &#34;body&#34;-en om akkurat hvilken data man &#248;nsker &#229; f&#229; tilbake. Dette f&#248;rer til at man alltid kun f&#229;r tilbake akkurat den dataen med akkurat de attributtene&#160;man trengte. Ved bruk av GraphQL vil man dermed unng&#229; problemet med overfetching. GraphQL beskriver dataen med typer, som er det som gj&#248;r det mulig &#229; kun be om bestemte attributter til et dataobjekt. Dette gir ogs&#229; mulighet for &#229; validere typer.&#160;<\/p><p>&#160;<\/p><p>REST bruker ulike HTTP metoder i sine endepunkt URL-er (som f.eks. GET, POST, PUT), som gj&#248;r det tydelig &#229; vite i frontend hva endepunkt URL-en gj&#248;r (henter data, skriver til databasen osv.). GraphQL kun har ett endepukt, bruker ikke disse HTTP metodene i sin URL.<\/p><p>&#160;<\/p><p>REST klarer &#229; utnytte caching-mekanismen&#160;som st&#248;ttes av browsere, dette gj&#248;r ikke GraphQL.<\/p><p>&#160;<\/p><p>GraphQL st&#248;tter kun JSON formatert data, som gir&#160;en begrensning som man ikke har med REST.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11534678,"ext_inspera_userAssessmentSetupId":7140134,"ext_inspera_userAssessmentId":4841313,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Holm Katrine Norheim (10160)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331103,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2077,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>For enkle applikasjoner er et vanlig hierarkisk dataflyt i react mulig &#229; gj&#248;re med sending av props. React har ogs&#229; innebygd hooks som enkelt kan endre p&#229; state i enkelte komponenter.&#160;Applikasjoner&#160;med en mer omfattende state kan fort bli uoversikltig og vanskelig &#229; vedlikeholde, da det kan bli mange un&#248;dvendige callbacks, og det kan v&#230;re at state havner der p&#229; steder det ikke er&#160;logisk &#229; v&#230;re n&#229;r de flyttes oppover til felles foreldrekomponenter. L&#248;sningen p&#229; slike omfattende applikasjoner er &#229; ha lokale komponent-stater (usestate med hooks) der state er lokal, og ellers&#160;ha en global state managemenet. Ulike l&#248;sninger for state management som vi har l&#230;rt i dette faget er&#160;Redux, MobX og Context.&#160;<\/p><p><br />Redux og MobX er eksterne biblioteker, mens Context er innebygd i react.&#160;<br />&#160;<\/p><p>N&#229;r man bruker redux har man en samlet staten p&#229; en plass (Store), og man har mulighet til &#229; endre og lese state der det trengs i komponenttreet, dette er fordelaktig dersom flere komponenter skal ha aksess til samme staten. State kan kun endres ved at en action creater kalles, action createren lager en action som dispatches til en reducer. Reduceren tar inn action som et argument og endrer tilstanden.&#160;Tilstanden i Storen&#160;&#34;immutable&#34;. Det betyr at tilstanden er &#34;read-only&#34;, og kan kun endres av en reducer dersom en action &#34;dispatches&#34;. Reducerene er rene(&#34;pure&#34;)&#160;funksjoner, som betyr at de mottar en state og action og returnerer en ny state. Det er sv&#230;rt forutsigbar, og kan ikke skje p&#229; en annen m&#229;te.&#160;Redux er mye &#229; sette seg inn i, samt en del boilderplate kode, men n&#229;r det f&#248;rst er blitt l&#230;rt er det et lett &#229; holde oversikt over og teste.<\/p><p>&#160;<\/p><p>MobX&#160;er et alternativ til redux, som har 2 eller&#160;flere stores (En store for UI state og en&#160;eller flere&#160;stores for domain state). States i Mobx er ikke rene(alts&#229;&#160;&#34;inpure&#34;), s&#229; her kan states lett oppdateres og bli overskrevet av nye verdier. Det er mye som skjer bak scenen som utvikleren ikke trenger &#229; bry seg om, og medf&#248;rer at det er lett &#229; implementere. Det negative med MobX er at outputs fra funksjonene kan v&#230;re lite forutsett n&#229;r state kan oppdateres/overskrevet s&#229; lett, og det blir dermed vanskelig &#229; teste dersom det skulle v&#230;re errors. Dermed er det ikke like forutsigbart som redux.&#160;<\/p><p>&#160;<\/p><p>Med context gir det mulighet &#229; sende data gjennom komponenttreet, der man slipper &#229; sende props manuelt gjennom hvert level. Derimot vil dette kreve mye rerenders.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2422,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et&#160;&#229;pent&#160;kilde bibliotek for react der folk kan implementere koden i egne prosjekter i react, samt forbedre recoil-koden ved &#229; pushe. Recoil brukter atom som er mindre enheter av state. Atoms (shared state) og selectors(pure functions)&#160;er hovedkomponentene i recoil. Selecteren kan hente ut og endre p&#229; tilstanden i en atom. Hvis tilstanden i et atom endres, vil selecteren oppdateres og eventuelt komponentene som f&#248;lger med vil rerederes.&#160;<\/p><p>&#160;<\/p><p>Med recoil kommer det med state management for react, som er ganske ulikt redux, et&#160;eksternt bibliotek for&#160;state management fra pensum.&#160;Redux har ekstern global state i&#160;egne filer, og krever&#160;mye boilerplate-kode.&#160;Recoil gj&#248;r det mulig &#229;&#160;behandle state rett i komponentene, og dokumentasjonen st&#229;r det at de er&#160;&#34;boilerplate-free&#34;. Denne mekanismen likner veldig p&#229; &#34;usestate&#34; som kommer med hooks i react.&#160;<\/p><p>&#160;<\/p><p>I dokumentasjonen st&#229;r det at recoil ikke kan transpilere til ES5. Dersom det er nettlesere som st&#248;tter ES5 og ikke nyere versjoner, vil ikke koden kj&#248;re p&#229; nettleseren. Dette er en ulempe da det kan v&#230;re folk som for eksempel har en gammel mobil ikke f&#229;r muligheten til &#229; g&#229; inn p&#229; nettsiden der dette er blitt brukt. Heldvigvis st&#248;tter de aller fleste nettlesere ES6.&#160;<\/p><p>&#160;<\/p><p>S&#229;nn jeg tolker det virker det som at recoil kun funker for react og ingen andre biblioteker, imotsetning til andre state-managemenet-biblioteker som redux og mobX som funker p&#229; flere biblioteker.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2690,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Rest API er en arkitekturstil som fokuserer p&#229; at det skal v&#230;re enkelt for systemer &#229; kommunisere med hverandre. Det blir definert et eller flere endepunkter der man kan legge til, endre eller hente ressurser. Dette gj&#248;res med URI og HTTPS-requester. GraphQL er derimot&#160;et query-spr&#229;k som opererer over et enkelt endepunkt ved hjelp av HTTP.<\/p><p>&#160;<\/p><p>Rest skiller tydleig p&#229;&#160;client og server, og s&#229; lenge begge sider er inneforst&#229;tt med meldingene som sendes trenger de ikke &#229; vite noe s&#230;rlig annet. I GraphQL er&#160;koblingen&#160;mellom client og serveren&#160;noe tettere&#160;siden man definerer struktur og typer i skjema. Dette er fors&#229;vidt&#160;fordelaktig siden det gj&#248;r det mulig for validering.<\/p><p>&#160;<\/p><p>N&#229;r man skal hente informasjon gjennom rest vil den gi tilbake et komplett datasett, og dersom du vil ha informasjon fra flere objekter m&#229; du sende foresp&#248;rsel til flere endepunkter. Dette kan v&#230;re&#160;en ulempe med rest, da man i&#160;verste fall m&#229; gj&#248;re&#160;mange kall for &#229; hente den dataen man &#248;nsker, og kan medf&#248;rer at man&#160;da ogs&#229; f&#229;r mye&#160;un&#248;dvendig informasjon som man&#160;ikke trenger. Dette kalles overfecthing. GraphQL kan derimot sende en konkret foresp&#248;rsel som gir akkurat den dataen man &#248;nsker fra flere endepunkter. Man definerer alts&#229; b&#229;de s&#248;k og hvilke data som returneres.&#160;Dette kan v&#230;re sv&#230;rt effektivt i dersom du vet hvordan du bruker det. GraphQL-sp&#248;rringer kan v&#230;re en del &#229; sette seg inn i, men veldig fordelaktig i store applikasjoner. Dersom man har en mindre kompleks applikasjon kan det v&#230;re greit med Rest API som er lett &#229; forst&#229; fort&#160;med tanke p&#229; man kun kan sende til et&#160;endepunkt n&#229;r man sender en request.&#160;<\/p><p>&#160;<\/p><p>En stor fordel med Rest er at den har HTTP-cache-muligheter som st&#248;ttes default av alle nettlesere. Dette gj&#248;r at foresp&#248;rsler kan bli h&#229;ndtert raskere i fremtiden. GraphQL har ikke den samme HTTP-cache-muligheten da den bruker spesifiserte foresp&#248;rsler.&#160;<\/p><p>&#160;<\/p><p>De siste &#229;rene har bruksomr&#229;det til RESt for det meste&#160;v&#230;rt &#229; lage nye APIer, mens GraphQL har fokyusert p&#229; &#229; optimalisere seg for h&#248;yere ytelse og fleksibilitet.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534146,"ext_inspera_userAssessmentSetupId":7140016,"ext_inspera_userAssessmentId":4841413,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Dalaaker Nicolai Andre (10065)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35013368,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1253,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Det finnes flere mekanikker og teknikker for &#229; h&#229;ndtere stat og dataflyt. Staten kan lagres internt i komponentet med useState hooken, eller ved &#229; benytte this.state i et klassekomponent(merk at klassekomponenter er soft-depricated).<\/p><p>Denne staten kan bli sent til underliggende komponenter som props, som kan for&#248;vrig sende den videre ned.<\/p><p>Om man &#248;nsker dataen ett annet sted i hiarkiet, s&#229; kan man bruke teknikken &#229; l&#248;fte staten opp til et felles forelderkomponent.<\/p><p>&#160;<\/p><p>&#197; flytte dataen som props kan fort bli kronglete, spesielt om dataen m&#229; flyttes gjennom mange komponenter langt opp eller ned.&#160; For &#229; unng&#229; dette kan man benytte React sitt Context API eller et eksternt bibliotek som Redux eller Mobx for &#229; h&#229;ndtere stat. Staten lagret i context (eller f.eks en redux slice) kan bli da akksesert for alle kompnenter som ligger under provider elementet til context/redux staten, ved hjelp av getContext eller redux hooks.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3389,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state-management bibliotek, med filosofien &#229; oppf&#248;re seg s&#229; &#39;reactete&#39; som mulig[0]. Det kan bli sammenliknet med Redux og Mobx, som ogs&#229; h&#229;ndterer global stat. Hovedtankegangen med Recoil er at man kan lage en data-flow graf som flyter fra felles stat, gjennom &#39;pure functions&#39; (selectors) til React komponenter. Staten er delt inn i &#39;atomer&#39; som komponenter kan abonnonere p&#229;, og oppdaterer dem n&#229;r de forrandres.[1]<\/p><p>&#160;<\/p><p>Dette minner veldig om Redux, hvor staten er lagret i &#39;slices&#39;, som minner om atoms. Slicene kan oppdateres gjennom &#229; bruke reducers, som har liknende synergi som selectors, bare motsatt vei. Staten i slicen kan benyttes av react komponenter,<\/p><p>&#160;<\/p><p>Til tross for likhetene, s&#229; ser det ut i fra eksempelkode [2] s&#229; er det mye mindre &#39;boilerplate&#39; for Recoil i kontrast til Redux, som reduserer muligheten for feil, og gj&#248;r koden mer oversiktlig. Filosofien bak Recoil fokuserer ogs&#229; p&#229; &#229; samsvare med React, i kontrast til Redux og Mobx, som er et generelt state-management bibliotek. Den st&#248;rste ulempen med Recoil er at det er nytt og lite utbredt. Dette gj&#248;r at det er mindre ressurser, dokumentasjon og st&#248;tte, som kan gj&#248;re det vanskeligere &#229; bruke. Det vil ogs&#229; v&#230;re mindre ekstraverkt&#248;y som f.eks Redux devTools, som lar deg observere staten under utviklingen.[3] Dette kan gj&#248;re det vanskeligere &#229; feils&#248;ke enn med andre mer popul&#230;re bibloteker.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>[0] https://recoiljs.org/docs/introduction/motivation<\/p><p>[1] https://recoiljs.org/docs/introduction/core-concepts<\/p><p>[2] https://dev.to/chandan/recoil-vs-redux-the-ultimate-react-state-management-face-off-35b<\/p><p>[3]: https://medium.com/better-programming/recoiljs-current-landscape-of-developer-tools-2e242d4509ae<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2496,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og Graphql er begge to konsepter p&#229; hvordan data kan sendes mellom systemer. I kontrast, s&#229; har Graphql ogs&#229; et definert sp&#248;rrespr&#229;k, og en h&#229;ndfast spesifikasjon beskrevet av facebook. [0]<\/p><p>&#160;<\/p><p>B&#229;de REST API og Graphql legger til rette for at en klient kan hente data fra endepunkter. Den st&#248;rsteforskjellen er at en klient kan spesifisere hvilken strukturen og hvilken data den vil ha fra et graphql endepunkt. I kontrast til et REST API, hvor man risikerer &#229; &#39;overhente&#39; data, om man kun er interesert i et attributt.<\/p><p>For eksempel, om man skal hente all dataen om personer fra et endepunkt, og bare er interesert i personnummer, s&#229; kan dette spesifiseres med en sp&#248;rring til et graphQL endepunkt, mens en sp&#248;rring til et REST API m&#229; ta til takke med hva enn REST APIet har definert p&#229; endepunktet.<\/p><p>&#160;<\/p><p>Dette gj&#248;r at graphql er mer effektivt. En annen effekt er at ett endepunkt med graphql kan benyttes for flere ting, mens man med er REST API m&#229; spesifisere mange forskjellige endpunkt om man skal kunne presentere dataen forskjellig. En konsekvens av spesifikasjonen er at graphql st&#248;tter kunn json, i kontrast til REST API som kan bruke flere forskjellige datatyper(json, xml)<\/p><p>&#160;<\/p><p>En annen vesentlig forskjell er at REST APIer har v&#230;rt standarden lenge f&#248;r graphql kom p&#229; banen, og er derfor mye mer utbredt. Dette gj&#248;r at det finns mye mer resurser om REST API. L&#230;ringskurven er ogs&#229; laverer for REST API, ettersom det er simplere og ikke benytter et eget sp&#248;rrespr&#229;k.<\/p><p>&#160;<\/p><p>Det er ogs&#229; forskjeller med tanke p&#229; caching. Med REST API, s&#229; vil dataen kunne caches i nettleseren uten &#229; m&#229;tte konfigurerer noe. Med Grapqhl derimot, s&#229; m&#229; dette implementeres selv. Heldigvis finnes det verkt&#248;y som f.eks Apollo client, som gj&#248;r dette lettere.<\/p><p>&#160;<\/p><p>[0]<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534201,"ext_inspera_userAssessmentSetupId":7140105,"ext_inspera_userAssessmentId":4841436,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:02Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Lu Royce (10079)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34210955,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1712,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React har forskjellige mekanisme og teknikker som brukes for tilstand (state) og dataflyt.<\/p><p>&#160;<\/p><p><strong>Props <\/strong>(properties)<\/p><p>Props er dataverdier&#160;sendes inn i en komponent, og bidrar til at dataflyten sendes nedover i kompononenthierarkiet. De er immutable, som vil si dataverdiene komponentene som mottar dataverdiene kan ikke endre p&#229; verdiene. Props sendes fra foreldrekomponentet til barnekomponentet som parametere, og n&#229;r barnekomponentet skal bruke props referer den til dataverdien ved &#229; skrive props.xx (navnet p&#229; props).<\/p><p>&#160;<\/p><p><strong>State<\/strong><\/p><p>Et&#160;eksempel p&#229; &#229; h&#229;ndtere tilstand er bruken av&#160;useState(), hvor utvikleren kan oppdatere tilstanden med setState(). Hensikten med det er &#229; h&#229;ndtere&#160;og lagre endringer i&#160;komponentenes tilstand. Staten holder p&#229; tilstanden inni en&#160;komponent, og oppf&#248;rer seg asynkront. Det er nyttig n&#229;r man trenger &#229; holde p&#229; informasjon mens komponenten rendrer.<\/p><p>&#160;<\/p><p>&#160;<\/p><p><strong>&#34;Callback&#34;-funksjoner<\/strong><\/p><p>&#34;Callback&#34;-funksjoner er nyttig om man &#248;nsker &#229; sende data oppover i komponenthierarkiet. Den brukes ved at foreldrekomponentet sender funksjonen&#160;til barnekomponentet som en props. Barnekomponentet kan da bruke &#34;callback&#34;-funksjonen, blant annet &#229; sende en variabel som et argument i funksjonen,&#160;&#160;til &#229; sette state i foreldrekomponentet.<\/p><p>&#160;<\/p><p><strong>State management<\/strong><\/p><p>MobX og Redux er eksempler p&#229; state management l&#248;sninger, som samler alle statene p&#229; en plass. I en komplisert applikasjon kan det v&#230;re vanskelig &#229; holde styr p&#229; alle statene. Bruk av state management gj&#248;r at man slipper &#229; ha mange &#34;callback&#34;-funksjoner og lange kjeder med props, samt&#160;mange stater som sendes opp og ned komponenthierarkiet. State management gir ogs&#229; mulighet til &#229; endre og lese staten der man trenger det, siden dataverdiene er globale.<\/p><p>&#160;<\/p><p>(Kilder: forelesningsnotater, https://reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props)<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3255,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er, i f&#248;lge hjemmesiden sin, et &#34;state management&#34;-bibliotek for React. I likhet med andre &#34;state mangamgent&#34;-biblioteker, bidrar Recoil til rask og fleksible deling av state i applikasjonen. Den best&#229;r av to komponenter - atoms og selectors. Atom er stateenheter som er b&#229;de oppdaterbare og mulig skrive dataverdier til, og kan brukes istedenfor lokale React-statekomponenter. Selectors er funksjoner som tar inn et atom som input, og som oppdaterer / endrer statene i Atom.<\/p><p>&#160;<\/p><p>Sammenligner man Recoil med MobX, kan man se b&#229;de noen likheter og forskjeller. N&#229;r observat&#248;rene (observable) i MobX&#160;observerer en endring i statene, vil komponentene som avhenger av staten&#160;re-rendres. Det samme gjelder for Recoil sin atom, som ogs&#229; vil re-rendre alle kompontenter som bruker det oppdaterte atomet.<\/p><p>&#160;<\/p><p>Alle state-endringene i MobX spores i runtime, mens Recoil kan settes synkront eller asynkront ved hjelp av selector. Andre likheter er at man m&#229; importere&#160;bibliotekene&#160;til React-applikasjonen n&#229;r man skal ta bruk biblioteket, ofte ved hjelp av npm eller yarn. Mens man i MobX ogs&#229; m&#229; installere mobx-react for &#229; &#34;binde&#34; sammen mobx og React, slipper man &#229; gj&#248;re det i Recoil.<\/p><p>&#160;<\/p><p>Som et &#34;state management&#34;-bibliotek, har Recoil det samme form&#229;let som blant annet Redux og MobX, nemlig h&#229;ndtering av globale stater (tilstander). Felles for dem alle er at rotkomponentet trenger en &#34;provider&#34;-komponent. Forskjellen er at mens MobX trenger en&#160;StoreProvider med en spesifikk store som props,&#160;for &#229; lagre statene globalt, er ikke behovet det samme for Recoil. Recoil bruker bare &#60;RecoilRoot&#62;, hvor man ikke trenger &#229; deifnere en spesifikk store.&#160;Det gj&#248;r at man slipper &#229; sende en kjede av props nedover i komponenttreet, men kan heller ta i bruk statene der man trenger det i komponenttreet. Recoil sine atomer lagrer state med en unik n&#248;kkel, som brukes om man &#248;nsker &#229; hente eller oppdatere staten i atomet. Ulempen er at n&#248;kkelstrengen m&#229; v&#230;re global unikt i hele applikasjonen, slik at man m&#229; man m&#229; alltid ha kontroll over hvilke n&#248;kkelnavn som er brukt.<\/p><p>&#160;<\/p><p>I MobX, n&#229;r man skal lese eller oppdatere&#160;en gitt state, m&#229; man hente staten og dens respektive funksjon&#160;fra Store. Derimot, minner Recoil sin m&#229;te mer som React sin useState-hook, bare at den bruker useRecoilState istedenfor. Bruk av Recoil gj&#248;r man slipper &#229; gj&#248;re de st&#248;rste endringene eller l&#230;re seg en helt ny m&#229;te &#229; hente eller oppdatere stater&#160;p&#229;.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>(Kilde:&#160;https://recoiljs.org/, https://recoiljs.org/docs/introduction/core-concepts, https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/, https://blog.logrocket.com/refactoring-redux-app-to-use-recoil/, https://mobx.js.org/installation.html)<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2184,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL er to m&#229;ter for databasen (backend/tjener) og applikasjonen (frontend/klient) &#229; kommunisere sammen p&#229;, alts&#229; et sp&#248;rrespr&#229;k for &#229; utf&#248;re sp&#248;rringer. Selv om de brukes til samme hensikt, har de noen vesentlige forskjeller som skiller dem fra hverandre.<\/p><p>&#160;<\/p><p><strong>Kommunikasjon<\/strong><\/p><p>REST&#160;er en l&#248;sning&#160;som kommuniserer ved bruk av fetching av URI og HTTP-foresp&#248;rsler. En ulempe er at om man &#248;nsker &#229; hente ut mye kompleks informasjon (med mange endepunkter), kan det f&#248;re til at man&#160;m&#229; sp&#248;rre flere ganger. Videre kan det f&#248;re til&#160;at man henter mer data enn man trenger&#160;data. I noen tilfeller kan man ogs&#229; risikere underfetching, at man henter for lite data. REST henter, legger inn, oppdaterer og sletter data med operasjonene GET, POST, PUT og DELETE. Med GraphQL, derimot, trenger man bare &#229; sende en enkel sp&#248;rring, hvor man definerer s&#248;ket og dataene/oppdateringene man &#248;nsker, og man f&#229;r de dataene man trenger. Da slipper man &#229; risikerer &#229; laste inn for mye data, grunnet en endepunkt.<\/p><p>&#160;<\/p><p><strong>Caching i HTTP-laget<\/strong><\/p><p>Mens REST API har en implisitt cahing-mekanisme, har ikke GraphQL noen implisitt caching. Det gj&#248;r at REST kan v&#230;re mer effektiv og skalerbar.<\/p><p>&#160;<\/p><p><strong>Feilh&#229;ndtering<\/strong><\/p><p>Ved bruk av REST f&#229;r man responser i statuskoder, som forteller klienten om statusen. Typisk vil man m&#248;te p&#229;&#160;kode 200&#160;OK (foresp&#248;rselen er suksessfull)&#160;og 404 NOT FOUND (foresp&#248;rselen finner ingenting). I GraphQL returneres feilmeldinger med informasjon om hva og hvor feilen er som JSON.<\/p><p>&#160;<\/p><p><strong>Syntaks og struktur<\/strong><\/p><p>GraphQL sitt sp&#248;rrespr&#229;k er inspirert av JSON, og resultatet vil alltid returneres som&#160;JSON. I tillegg bruker den skjema som definerer typer og struktur, slik at man alltid har kontroll over hva som er gyldige sp&#248;rringer. REST derimot bruker fetch-funksjon for &#229; hente/oppdatere dataverdier. Resultatene som returneres med REST avhenger av hva slags content-type utvikleren kan har valgt, og kan v&#230;re for eksempel JSON, HTML, XML, CSV osv.<\/p><p>&#160;<\/p><p>(Kilde: forelesningsnotater, https://www.howtographql.com/basics/1-graphql-is-the-better-rest/,&#160;https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083)<\/p>"}]}],"ext_inspera_totalScore":13,"score":13}},{"result":{"sourcedId":11534217,"ext_inspera_userAssessmentSetupId":7140042,"ext_inspera_userAssessmentId":4841429,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Ådlandsvik Ferdinand Ward (10198)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331062,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3116,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For &#229; vedlikeholde en state i en React-applikasjon, kan vi bruke ulike mekanismer og teknikker. F&#248;rst og fremst er det naturlig &#229; snakke om hvordan state i en komponent blir h&#229;ndtert (lokal state). Dette er mulig &#229; h&#229;ndtere med en useState()-hook, der man deklarerer en konstant med staten og en metode for &#229; endre staten, og setter denne lik useState(initialverdi). N&#229;r vi da skal endre staten, kaller vi p&#229; setState(ny_verdi), og vi f&#229;r endret den lokale staten. Det &#229; ha en lokal state er vel og bra, men om det er flere komponenter som er interessert i denne staten, m&#229; vi finne p&#229; noe lurt. Det som er mulig er &#229; sende med denne staten som props nedover i komponenttreet, fra forelderkomponenter til child-komponent (eller motsatt). Dette kalles prop-drilling/threading.&#160;Dette funker fint men det kan fort bli mye ekstraarbeid ved h&#248;ye tr&#230;r. Derfor&#160;har vi ogs&#229; mekanismer og teknikker som gj&#248;re det mulig &#229; sende data gjennom komponenttreet uten &#229; m&#229;tte &#34;passe&#34; props nedover manuelt for hvert level av treet. I tillegg finnes det biibliotek som ved bruk gj&#248;r at vi kan sende state fra et sted i et komponent-tre til en annen komponent som ikke er i samme komponenttre. Dette kommer jeg til n&#229;.<\/p><p>&#160;<\/p><p>Noe vi har l&#230;rt dette semesteret er hvordan &#229; h&#229;ndtere en global state. Dette kan gj&#248;res p&#229; flere m&#229;ter i en React-applikasjon. Blant annet kan Context API-et bli brukt til dette.&#160;<\/p><p>&#160;<\/p><p>Ved bruk av Context API-et slipper man &#229; &#34;passe&#34; props nedover manuelt for hvert level av komponent-treet.&#160;Context API-et er en fin m&#229;te &#229; h&#229;ndtere en global state, men det er ikke s&#229; effektivt for state som endres ofte, eller state som er kompleks. Context API brukes ofte for &#229; dele data som er globale, som for eksempel n&#229;r man skal ha et gjennomg&#229;ende tema for en applikasjon, eller spr&#229;k, der alle komponenter skal ha samme tema/spr&#229;k. For &#229; holde p&#229; den globale staten, m&#229; vi ha en sentral store. Derfor har man ofte en context.ts, der man lager et context object, der man kan skrive inn en default verdi for contexten. Etter &#229; ha laget en context vil man ha to komponenter, en Provider og en Consumer. Provideren gj&#248;r at alle komponentene i komponenttreet har tilgang til context-dataen. (Forelderkomponenten m&#229; wrappes med Provideren for at dette skal funke). For &#229; aksessere denne dataen som er lagret i Context, m&#229; vi wrappe det som skal ha tilgang til dataen i en Consumer.&#160;<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; h&#229;ndtere en global state p&#229;, alts&#229; en state som alle komponenter har tilgang til (forutsetter at komponenten er wrappet i en &#60;Provider&#62; i v&#229;r app.tsx/app.js.), er med React Redux. Med Redux har vi &#233;n Store, der den globale staten for applikasjon vil bli lagret. Derfor kan vi si at vi har en &#34;Single Source of truth&#34;, nemlig den nevnte Store. Vi kan se p&#229; Store som et tre, alts&#229; &#233;n datastruktur.&#160;<\/p><p>Vi har at Store i Redux er read-only. For &#229; endre staten lagret i Store, m&#229; vi bruke det som kalles Actions, som er et objekt som beskriver hvilken endring som skal gj&#248;res. Vi m&#229; videre bruke en metode, dispatch(Action), som tar inn actions, og sender denne Action til en Reducer. Det er i Reduceren vi ser p&#229; hvilken Action som har blitt kalt for &#229; endre den globale staten, for deretter &#229; oppdatere store med en ny state. Dette gj&#248;r Reduceren avhengig av hvilken Action&#160;og hvilken payload (Data som blir sendt med Action) som har blitt sendt med dispatch()-metoden. Denne nye staten erstatter da den tidligere staten som var i Store p&#229; gitte verdi. For &#229; f&#229; tilgang til den global staten fra Store, kan man blant annet bruke useSelector-hooken, eller man kan lage en funksjon mapStateToProps(state), som tar inn hele Redux Store Staten som argument, og gj&#248;r det mulig &#229; f&#229; tilgang til State om man &#34;connecter&#34; med connect(mapStateToProps)(komponent_navn)<\/p><p>&#160;<\/p><p>En tredje m&#229;te &#229; h&#229;ndtere en global State er ved bruk av MobX, som er et bibliotek som gj&#248;r global state management enkelt. I MobX kan komponenter gj&#248;res til observat&#248;rer, og datastrukturer gj&#248;res observerbare for disse komponentene. I motsetning til Redux, vil ikke MobX ha like stor p&#229;virkning p&#229; koden din. Dette handler om at i Redux har vi mye boilerplate-kode, kode som m&#229; skrive i oppstarten&#160;for i det hele tatt f&#229; det til &#229; fungere. I tillegg vil vi i motsetning til Redux ha flere Stores for &#229; holde p&#229; dataen.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2420,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for state management i React. Recoil best&#229;r hovedsaklig av to ting, &#34;Atoms&#34; og &#34;Selectors&#34;. Vi har at &#34;Atoms&#34; er enheter med state, som komponenter kan &#34;abonnere&#34; p&#229; (Det vil si f&#248;lge med p&#229;). &#34;Selectors&#34; gj&#248;r om staten i &#34;Atoms&#34;. Dette kan gj&#248;res enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Som nevnt i oppgave 1 har vi v&#230;rt gjennom flere m&#229;ter &#229; h&#229;ndtere global state i React-applikasjoner dette semesteret.&#160;<\/p><p>I motsetning til b&#229;de Redux og Mobx trenger vi med Recoil ikke &#229; lage noen separat store. Dette fordi staten er delt opp i mange forskjellige Atoms, i motsetning til &#229; ha en/eller flere stores der all&#160;av staten ligger.&#160;<\/p><p>Vi kan sammenligne det &#229; oppdatere en global state i Recoil, med det &#229; oppdatere en lokal&#160;state, ved &#229; bruke useRecoilState (setState brukes n&#229;r lokal state settes). Dermed er det like lett &#229; sette state med Recoil, som &#229; endre en lokal state. Alle komponenter som subscriber p&#229; et atom vil re-rendres hvis staten i dette atomet endres.&#160;Dette er ikke like lett i MobX og Redux for eksempel.&#160;<\/p><p>&#160;<\/p><p>I likhet med Redux, MobX og Context API-et, vil Recoil kun re-rendre n&#248;dvendige komponenter.&#160;<\/p><p>En annen fordel med Recoil er at man ved bruk av Recoil har en m&#229;te &#229; h&#229;ndtere b&#229;de synkrone og asynkrone funksjoner, uten for mye boilerplate.&#160;<\/p><p>&#160;<\/p><p>Recoil er forstatt i en eksperimentell fase, men det virker som at det er god hype rundt dette nye biblioteket for global state management (10800 stars p&#229; Github allerede). Det har blitt uttalt av Sebastian Markbage(React team-medlem), at det nye Context API-et som kom med React 16.3 ikke var bygget for h&#248;y-frekvens oppdateringer. I tillegg hadde det ogs&#229; noen begrensninger med det &#229; splitte kode, og &#229; lagre uendelig mange verdier. Dette er noe Recoil skal v&#230;re bedre p&#229;, s&#229; det vil absolutt v&#230;re mulighet for at Recoil er det nye store.<\/p><p>I og med at det n&#229; kun er i en eksperimentell fase, gj&#248;r at det kan v&#230;re mindre &#34;online community support&#34;, enn allerede etablerte bibliotek som MobX og Redux. Dette kan v&#230;re en ulempe om man begynner &#229; ta det i bruk n&#229;.&#160;<\/p><p>Noe som taler for at Recoil er p&#229;litelig, er at Facebooks egne ansatte bruker dette biblioteket internt.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://recoiljs.org/<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p><p>https://github.com/facebookexperimental/Recoil<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1596,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En vesentlig forskjell mellom REST API og GraphQL handler om endepunkter. Ved bruk av REST vil man ha ett endepunkt for hver &#34;oppgave&#34;, det vil si at hvis man bruker&#160;endepunkt X, f&#229;r man X data, med endepunkt Y, f&#229;r man Y data osv. I motsetning vil man med GraphQL bare ha ett endepunkt X, og dataen man f&#229;r ut vil avhenge av hva man har i sp&#248;rringen.&#160;<\/p><p>&#160;<\/p><p>En annen forskjell er at man ikke kan begrense feltene man f&#229;r fra et endepunkt, ved bruk av REST API. Her vil man vil alltid f&#229; et komplett datasett (&#34;over fetching&#34;). I tillegg vil man risikere &#229; ikke f&#229; nok informasjon ved et kall til REST API-et, og dermed m&#229; man ha flere sp&#248;rringer.&#160;<\/p><p>Med GrapghQL kan man spesifisere hvilken informasjon man vil ha ut (hvilke felter man &#248;nsker). Med GraphQL f&#229;r man ogs&#229; ut forespurt&#160;informasjon, uten &#229; ha flere kall.&#160;<\/p><p>Her ser vi en vesentlig forskjell.&#160;<\/p><p>&#160;<\/p><p>Hvis jeg f&#229;r lov til &#229; ta meg friheten til &#229; synse litt rundt mine egne erfaringer rundt forskjeller mellom REST API og GraphQL, opplever jeg at GraphQL hadde en brattere l&#230;ringskurve enn REST, s&#229; man kan jo si at dette ogs&#229; er en vesentlig forskjell.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://back4app.medium.com/graphql-vs-rest-62a3d6c2021d<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11534231,"ext_inspera_userAssessmentSetupId":7140119,"ext_inspera_userAssessmentId":4841506,"dateLastModified":"2020-12-01T10:01:47Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:47Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Barkbu Snorre Gjertsen (10144)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35191181,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2403,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React insisterer p&#229; enveis/ensrettet dataflyt, noe som tillater flere teknikker og mekanismer til b&#229;de tilstandsh&#229;ndtering og dataflyt i React-applikasjoner. De viktigste to tingene &#229; redegj&#248;re for er Props og State:&#160;<\/p><p>&#160;<\/p><p>Props er kort for Properties. Props&#160;er dataverdier som gis som input n&#229;r en komponent kalles/opprettes, og disse dataverdiene&#160;er immutable, alts&#229; ikke mulig &#229; endre i komponenten som f&#229;r inn propsen. Props flyter fra parent til child, og props&#160;kan endres vha callback funksjoner&#160;som da sender handlinger fra child til parent.<\/p><p>&#160;<\/p><p>State er interne variabler i komponenten som kan endres med setState(). En&#160;endring i state vil vanligvis f&#248;re til en ny rendring av komponenten (og barn av denne). State&#160;er komponentens tilstandsdata som kan endres i kj&#248;retid.<\/p><p>&#160;<\/p><p>Grunnen til at dette er viktig er fordi man&#160;i React n&#248;ster/wrapper komponenter inni hverandre. &#34;Underordnede&#34;&#160;komponenter, child-components,&#160;wrappes&#160;i&#160;komponenter av h&#248;yere orden, parent-components. Dette skaper et hierarki av komponenter, og siden Reacts dataflyt er enveis gj&#248;r det at informasjon kan sendes nedover som props, og handlinger kan sendes oppover. Dette, kombinert med tilstander som kan endres i en komponent (og ogs&#229; kan sendes nedover til sine child-components som props) gj&#248;r at man kan ha mange tilstander som det er vanskelig &#229; holde styr p&#229;. Ved mange forskjellige states og mye data som sendes som props kan man risikere at tilstander i applikasjonen endres uten at det er det man &#248;nsker.<\/p><p>&#160;<\/p><p>Her kommer Context API, Redux og Mobx inn. Dette er&#160;biblioteker som forenkler tilstandsh&#229;ndtering og dataflyt i komplekse javascript applikasjoner. Kort forklart er forskjellen mellom disse ganske kompleks: De l&#248;ser alle samme problemstilling p&#229; forskjellige m&#229;ter, og har forskjellige fordeler og ulemper.&#160;<br /><br />React applikasjoner tillater b&#229;de klasse- og funksjonelle-komponenter. Funksjonelle komponenter hadde tidligere ikke muligheten til &#229; bruke tilstander, men vha useState()-hooket har ogs&#229; disse f&#229;tt tilgang p&#229; tilstander. I klasse-komponenter brukes livssyklusmetoder som componentDidMount() til &#229; h&#229;ndtere bivirkninger/resultater av tilstandsendringer. I funskjonelle komponenter oppn&#229;s dette vha useEffect(). Hooks kan idag ogs&#229; brukes for &#229; lage et tilstandsh&#229;ndterings-verkt&#248;y som skiller handlinger fra komponenter, som gj&#248;r at komplekse applikasjoner i teorien ikke trenger &#229; bruke Mobx, Redux eller Context for &#229; h&#229;ndtere komplekse state-tr&#230;r.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3215,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tilstandsh&#229;ndterings bibliotek. Det best&#229;r av Atoms, state-enheter/beholdere, og Selectors, funksjoner som velger state og sender det ned til komponenter.<\/p><p>&#160;<\/p><p>Atoms er delte, skrivbare&#160;Recoil-tilstander som inneholder et&#160;stykke data som den administrerer. Atomsene innholder en minimal tilstand, da bare noe trengs &#229; endres i atoms, og resten kan beregnes andre steder.&#160;Komponenter kan lytte p&#229;&#160;Atoms&#160;og vil re-rendres&#160;n&#229;r relaterte Atoms endres, og flere komponenter kan lytte p&#229; samme Atom. Et Atom har to props:<\/p><p><strong>key<\/strong>: En UNIK streng som brukes til &#229; identifisere Atomet internt.<\/p><p><strong>default<\/strong>: Den opprinnelige verdien til et Atom.<\/p><p>Atoms har ogs&#229; en rekke hooks som tillater &#229; lese og/eller skrive til Atomet.<\/p><p>&#160;<\/p><p><span style=\"background-color:transparent\">Selectors&#160;<\/span>er rene funksjoner&#160;som godtar atomer eller andre Selectorssom inngang.&#160;N&#229;r disse oppstr&#248;ms Atomene&#160;eller Selectorene&#160;oppdateres, vil Selectoren evalueres&#160;p&#229; nytt og oppdateres ihht tilstanden den ender opp med.&#160;Komponenter kan abonnere p&#229; Selectorer&#160;akkurat som Atomer, og vil rerendres ogs&#229; ved oppdatering av Selectorene.&#160;Selectorer&#160;beregner tilstand som en funksjon av den minimale tilstanden som er lagret i Atomene og sine oppstr&#248;ms Selectorer.&#160;Siden Selectorene holder oversikt over hvilke komponenter som trenger dem og hvilken tilstand de er avhengige av, er tanken at Selectorene skal gj&#248;re funksjonelle tiln&#230;rmingen veldig effektiv.<\/p><p>&#160;<\/p><p>Fra en Komponents synspunkt har Selectorer og Atomer samme grensesnitt og kan derfor erstattes med hverandre.<\/p><p>&#160;<\/p><p>I tillegg til dette utvikles det idag ogs&#229; funksjonalitet for debugging i Recoil.<\/p><p>&#160;<\/p><p>Problemer med Context er at tilstander bare kan deles ved &#229; skyve den opp til felles forfedre/foreldre-komponenter. Dette kan inkludere et stort tre som deretter m&#229; gjengis p&#229; nytt.<\/p><p>Context kan bare lagre en enkelt verdi - ikke et ubestemt verdisett, hver med sine egne forbrukere.<\/p><p>Begge disse gj&#248;r det utfordrende &#229; splitte&#160;toppen av tilstands-treet (der tilstanden finnes/bor) fra bladene p&#229; treet (der tilstanden brukes).<\/p><p>&#160;<\/p><p>Redux er en forutsigbar tilstandsh&#229;ndterer&#160;for JavaScript-applikasjoner. Redux har en store/tilstandskilde, og&#160;tilstandene er skrivebeskyttet. Endinger p&#229; tilstanden gj&#248;res med rene funksjoner, som gj&#248;r endringer oversiktlige.&#160;Redux har ogs&#229; en god web debugger.&#160;Ulempen er at Redux har mye kompleks boilerplate, og at det i fremtiden kan ende opp med &#229; ikke v&#230;re kompatibelt med nye versjoner av React.<\/p><p>&#160;<\/p><p>Mobx er relativt likt redux, men har flere Stores og mindre oversiktlig state-oppdatering.<\/p><p>&#160;<\/p><p>Fordeler med Recoil:<\/p><p>- Utvikles av facebook, som ogs&#229; utvikler react. Dette vil minimere sannsynligheten for at react oppdateringer vil p&#229;virke funksjonailtet i apper som bruker recoil, og vil i st&#248;rre grad tillate bruk av siste versjon av React.<\/p><p>- Biblioteket vedlikeholdes aktivt (det er under utvikling) som vil si at issues ved bruk av recoil som oppdages vil fikses.<\/p><p>- Det l&#248;ser i stor grad problemene ved b&#229;de Redux og Context<\/p><ul>\t<li>Mindre boilerplate<\/li>\t<li>Kan lagre et ubestemt verdisett (vha&#160;Selectorene)<\/li>\t<li>Tilstand kan deles p&#229; tvers av komponenthierarkier uten at alle komponentene i hierarkiet&#160;m&#229; rerendres ved en oppdatering (hvis de ikke lytter til tilstanden som oppdateres)<\/li>\t<li>Tilstandsoppdateringer virker oversiktlig og gj&#248;res vha &#34;cleane&#34; funskjoner<\/li><\/ul><p>&#160;<\/p><p>Ulemper:<\/p><p>- Biblioteket er under utvikling, og ny funksjonalitet skal legges til<\/p><ul>\t<li>Kan kreve mer arbeid under utvikling og vedlikehold siden endringer i biblioteket vil kreve endringer i koden man skriver<\/li>\t<li>Deler av funksjonaliteten man kan trenge&#160;eksisterer ikke<\/li><\/ul><p>- Det er et nytt bibliotek som kanskje ikke er kompatibelt med andre biblioteker som man bruker allerede<\/p><p>- Recoil fungerer forskjellig fra context og redux, som vil gj&#248;re det vanskeligere &#229; bytte fra recoil til context/redux, eller fra redux/context til recoil.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1548,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Kort definert er REST og GraphQL&#160;to forskjellige l&#248;sninger for klient-server kommunikasjon i webapplikasjoner.<\/p><p>&#160;<\/p><p>REST er ende-til-ende definert: Ett eller flere endepunkter defineres for &#229; lese, skrive eller endre p&#229; &#171;entiteter/ressurser&#187; vha URI og HTTP requests, og det defineres ogs&#229; hvilke data som skal returneres for en entitet/ressurs. Caching-mekanismen til REST&#160;st&#248;ttes av alle weblesere. REST er i tillegg en&#160;arkitektur stil, i stor grad sett p&#229; som en konvensjonell standard for utforming av APIer.<\/p><p>En ulempe med REST er at ved kompleks informasjon (mange endepunkter), kreves det flere kall for &#229; hente dataen som trengs, og man henter kanskje mer data enn det som&#160;trengs&#160;(overfetching). Dette er fordi REST har en server-driven utvelgelse.<\/p><p>&#160;<\/p><p>I GraphQL sender man en sp&#248;rring til en server hvor man definerer&#160;s&#248;k og hvilke data som skal returneres, eller hva som skal oppdateres. Fordelene er at all&#160;data hentes i en request og man unng&#229;r overfetching. I tillegg er det et typesystem, og dette gj&#248;r det mulig &#229; validere dataen. GraphQL er dermed et&#160;sp&#248;rrespr&#229;k som gir effektivitet og fleksibilitet for &#229; l&#248;se vanlige problemer n&#229;r du integrerer APIer. Ulempene ved GraphQL&#160;er mangel p&#229; implisitt caching i HTTP-laget og at GraphQL kun st&#248;tter data p&#229; JSON-format. Utover dette kan koblingen mellom tjener og klient&#160;v&#230;re noe tettere&#160;ved bruk av GraphQL siden det brukes skjema som definerer struktur og typer. Dette kan ogs&#229; vurderes som en fordel siden det muliggj&#248;r validering.<\/p><p>&#160;<\/p><p>Utifra det som er skrevet over kan man konkludere med et par ting:<\/p><p>GraphQL kan utnyttes i mye st&#248;rre grad hvis en applikasjon har mange domeneobjekter. Da kan et kall fra<\/p><p>GraphQL hente dataen man trenger, men REST kan ende opp med mange kall, og hente for mye/for lite data.<\/p><p>&#160;<\/p><p>REST har automatisk hurtigbuffring, noe GraphQL mangler. Dette gj&#248;r REST mer p&#229;litelig mtp at man f&#229;r sikrere flyt av data fra REST.<\/p><p>&#160;<\/p><p>REST&#160;har en serverdreven arkitektur, mens GraphQL har en klientdreven arkitektur.&#160;<\/p><p>&#160;<\/p><p>REST st&#248;tter flere dataformater, api-versjoner, og feils&#248;king ved bruk av HTTP-statuskoder. GraphQL st&#248;tter ingen av disse bortsett fra feils&#248;king ved bruk av HTTP-statuskoder, og vanskeliggj&#248;r dette<\/p><p>&#160;<\/p><p>GraphQL tillater en friere designstil, mens REST er et mer velpr&#248;vd verkt&#248;y, som sees p&#229; som en standard. Problemer med REST er derfor godt dokumentert, men man kan ha flere design-muligheter ved bruk av GraphQL. RIktignok har&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11534237,"ext_inspera_userAssessmentSetupId":7139923,"ext_inspera_userAssessmentId":4841504,"dateLastModified":"2020-12-01T10:01:47Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:47Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Bruns Lisa Chanel (10064)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":23517739,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":990,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I React s&#229; er en komponent rotnoden mens resten forgrener seg ut fra denne. Komponentene i React styres av &#34;states&#34; og &#34;props&#34;. Props bidrar til kommunikasjon p&#229; tvers av noder. Dataflowen foreg&#229;r alltid&#160;fra forelder til barn. Dette er kjent som unidirectional dataflow. Dette kan gj&#248;re programmet mer oversiktlig og effektivt. Dataflow som et barn motar fra en forelder kan ikke endres. Dermed s&#229; vil en endring av propi i en komponent aldri p&#229;virke komponenter untenom de som er barn. Callback funksjonen brukes for &#229; flytte informasjon fra barn til forelder. Da kan resten av logikken gjennomf&#248;res hos forelderen, og staten oppdateres. N&#229;r det kommer til deling av data mellom komponenter som ikke har en direkte kobling s&#229; gjelder det &#229; finne felles forelderen og oppdatere denne. Med props blir et nytt view laget og holder seg slikt statisk.&#160;<\/p><p>&#160;<\/p><p>Selv om props har mange fordeler kan det v&#230;re tungvindt &#229; bruke dersom veldig mange komponenter skal ta det i bruk. Ved &#229; ta i bruk Context kan data deles uten &#229; manuelt sende props manuelt gjennom hvert niv&#229;. Det kan brukes n&#229;r dataen skal v&#230;re global, alts&#229; for hele komponent treet. Context kan kringkaste til alle komponenter som er nedenfor. Den gir ogs&#229; muligheter til &#229; skape tuneller til komponenter lenger nede.&#160;<\/p><p>&#160;<\/p><p>I motsetning til props s&#229; kan states endre seg der det ogs&#229; er mulighet &#229; holde styr p&#229; mulige endringer som foreg&#229;r i minnet. Det er mulig med b&#229;de read og write. En stateful komponent kan inneholde kunnskap om tidligere og mulige tilstander. States kan bare brukes i klasse komponenter. Endringer i states er uavhengige av hverandre. F&#229;r &#229; gj&#248;re endringer i en state brukes this.setState(). States kan gj&#248;re applikasjonen interaktiv. Og brukes for &#229; vise fram dynamisk informasjon. Du kan endre en eller flere attributter i en state ved hjelp av state(singular) og states(plural). Et eksempel p&#229; en state kan v&#230;re en checkbox.<\/p><p>&#160;<\/p><p>Det er ulike former for states,&#160;lokale states, globale states (i React) og globale (i et tredjeparts bibliotek). UseState brukes for &#229; generere n&#229;v&#230;rende state og en oppdateringsfunksjon. UseReducer tar inn en state og handling og returnerer en ny state.&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://www.geeksforgeeks.org/reactjs-state-react/<\/p><p>- https://www.w3schools.com/react/react_state.asp<\/p><p>- https://reactjs.org/docs/context.html<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3558,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et&#160;state management bibliotek&#160;for React. Det er to hovedkonsepter&#160;i Recoil: atomer og selektorer.<br />Et atom er et stykke &#34;state&#34;. Du kan lage et atom ved &#229; definere en &#34;cache&#34; n&#248;kkel og sende standarddataene. Komponentene dine kan bruke atomer og&#160;endringene i den. Det minner om React sin&#160;useState. &#34;Selectors&#34; brukes for avledede data, og&#160;ligner p&#229; atomer. Her kan du konsumere atomer og andre &#34;selectors&#34;. Det er ogs&#229; mulig &#229; utf&#248;re asynkroniseringsoperasjoner i &#34;selectoren&#34;. Resten er den samme som atomer. Komponentene dine kan bruke atomene og endringer i dem.<\/p><p>&#160;<\/p><p>Recoil egner seg veldig bra n&#229;r du&#160;trenger &#229; dele en del av staten i flere komponenter, og n&#229;r du m&#248;ter ytelsesproblemer relatert til det. Problemet med&#160;denne tiln&#230;rmingen&#160;er un&#248;dvendige &#34;re-renders&#34;. N&#229;r du sender en &#34;state&#34;&#160;oppover i kode hierarkiet&#160;blir&#160;alle &#34;child&#34; komponentene gjengitt. Recoil er et bra bibliotek, men det er ikke alle applikasjoner som vil dra nytte av det. Du kan for eksempel&#160;bruke Recoil delvis hvis du vil og du&#160;trenger ikke v&#230;re helt avhengig av den. Recoil&#160;gir ogs&#229; noen artige funksjoner som for eksempel tidsreiser og&#160;vedvarende tilstand.<\/p><p>&#160;<\/p><p>Context er enkelt &#229; bruke. Det egner seg bra&#160;for statiske data, siden de ikke oppdateres like ofte som Redux.<br />Det har lav inngangsbarriere p&#229; grunn av minimal konfigurasjon. Det har god&#160;dokumentasjon for React-segmentet. Context gj&#248;r det mulig for appen &#229; inkludere flere lokale sammenhenger for separate logiske oppgaver. Ulempene er at det ikke er designet for data som&#160;oppdateres&#160;eller endres ofte. Det kan v&#230;re vanskelig &#229; vedlikeholde&#160;komplekse apper, s&#230;rlig hvis vi bruker ikke-standardiserte l&#248;sninger. Feil overf&#248;rte data / parametere til komponenter kan gj&#248;re det vanskelig/umulig &#229; bruke dem utenfor React-Context.<\/p><p>&#160;<\/p><p>Redux er en&#160;kombinasjon av&#160;Flux og funksjonelle programmeringskonsepter. Noe som kjennetegner&#160;Redux er at Redux har &#233;n&#160;&#34;store&#34;, &#34;staten&#34; i &#34;storen&#34; kan ikke endres, med handlinger m&#229; man gj&#248;re endringer i &#34;store&#34;n. Redux er ogs&#229; lett &#229; teste, har<span>&#160;en god React Redux-pakke for integrering av React, har g<\/span>od feils&#248;king, fin kodestruktur,&#160;er designet for data som&#160;oppdateres&#160;/ endres ofte og det eliminerer un&#248;dvendige gjengivelser, og utsikten oppdateres n&#229;r du endrer et bestemt objekt i &#34;storen&#34;.&#160;Ulempene er at det ikke er innebygd React, det har skjuldt logikk og bruker Redux Toolkit, noe som kan v&#230;re forvirrende for&#160;nybegynnere, det krever mer konfigurasjon enn Context API, og det er mer terminologi &#229; l&#230;re.<br />&#160;<\/p><p>MobX er en state management som hjelper deg &#229; administrere den lokale staten i appen din. Noe som kjennetegner MobX er at den kan ha flere &#34;stores&#34; for &#229; lagre applikasjonens &#34;state&#34;, alt som kan utledes fra &#34;staten&#34;&#160;uten kommunikasjon&#160;er en avledning, all kode som kan endre &#34;staten&#34; er en handling og alle endringer i &#34;staten&#34; oppdaterer avledninger&#160;automatisk og atmoisk.<br />&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://blog.logrocket.com/redux-vs-mobx/<\/p><p>-&#160;https://fireup.pro/blog/redux-vs-react-context-which-should-you-use?GA_redux_context&#38;gclid=CjwKCAiA8Jf-BRB-EiwAWDtEGpdcx4o0uyRPE4F37qFgsYlE7xFKdf3lJ2qiUtVib7zsVHBs8nsItxoCVN0QAvD_BwE<\/p><p>-&#160;https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2597,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;de REST og GraphQL er APIer. N&#229;r du sender en HTTP request til REST kan den se ut som noe i denne duren:&#160;<\/p><p>&#160;<\/p><p>GET /api/user?id=007<\/p><p>&#160;<\/p><p>og som HTTP respons vil du f&#229; noe i denne duren:<\/p><p>&#160;<\/p><p>{<\/p><p>&#160; &#160;&#34;id&#34;: 007<\/p><p>&#160; &#160;&#34;name&#34;: James Bond<\/p><p>&#160; &#160;&#34;age&#34;: 47<\/p><p>}<\/p><p>&#160;<\/p><p>Alts&#229; du vil f&#229; ut den dataen som er lagret om personen med id 007. Men hvis det er lagret et sykehus koblet til denne personen med mer informasjon under seg, m&#229; du sende inn en ny HTTP request for &#229; hente det ut.&#160;<\/p><p>&#160;<\/p><p>N&#229;r du sender en HTTP request inn i QraphQL ber du om akkurat det du vil ha ut, og en HTTP request kan se noe slik ut:<\/p><p>&#160;<\/p><p>query {<\/p><p>&#160; &#160;user (id:007) {<\/p><p>&#160; &#160;id<\/p><p>&#160; &#160;name<\/p><p>&#160; &#160;age<\/p><p>&#160; &#160;hospital {<\/p><p>&#160; &#160; &#160; name<\/p><p>&#160; &#160; &#160; date<\/p><p>&#160; &#160;}<\/p><p>}<\/p><p>&#160;<\/p><p>Og du vil f&#229; en HTTP respons som ser ut som noe i denne duren:<\/p><p>&#160;<\/p><p>{<\/p><p>&#160; &#160;&#34;user&#34;: {<\/p><p>&#160; &#160; &#160; &#34;id&#34;: 007<\/p><p>&#160; &#160; &#160; &#34;name&#34;: &#34;James Bond&#34;<\/p><p>&#160; &#160; &#160; &#34;age&#34;: 47<\/p><p>&#160; &#160; &#160; &#34;hospital&#34; {<\/p><p>&#160; &#160; &#160; &#160; &#160;&#34;name&#34;: &#34;The USA hospital&#34;<\/p><p>&#160; &#160; &#160; &#160; &#160;&#34;date&#34;: 07-07-77<\/p><p>&#160; &#160; &#160; }<\/p><p>}<\/p><p>&#160;<\/p><p>Alts&#229; du f&#229;r ut akkurat det du sendte inn en &#34;request&#34; for. Alts&#229; du har ikke overfetcha: hentet ut for mye informasjon, eller underfetcha: hentet ut for lite informasjon. Med GraphQL kan du be om akkurat den informasjonen du vil.&#160;<\/p><p>&#160;<\/p><p>Begge disse er eksempler p&#229; hvordan APIene &#34;fetcher&#34; data. I GraphQL bruker du &#34;mutation&#34; til &#229; b&#229;de lage, oppdatere og slette data. I REST APIet bruker du derimot &#34;POST&#34; for &#229; lage data, &#34;PUT/PATCH&#34; for &#229; oppdatere data og &#34;DELETE&#34; for &#229; slette data.&#160;<\/p><p>&#160;<\/p><p>Med REST APIer er det vanlig &#229; strukturere endepunktene i henhold til visningene du har i appen din. Dette er praktisk fordi det gj&#248;r det mulig for klienten &#229; f&#229; all n&#248;dvendig informasjon for en bestemt visning ved &#229; f&#229; tilgang til det tilsvarende endepunktet. Ulempen med dette er at den ikke tillater raske iterasjoner p&#229; frontenden. Alle endringer som gj&#248;res i brukergrensesnittet gir&#160;risiko for at det kreves mer/mindre&#160;data enn f&#248;r. Derfor m&#229; backend ogs&#229; justeres for &#229; ta hensyn til de nye databehovene. Dette sakter ned&#160;produktiviteten og reduserer spesielt muligheten for &#229; innlemme bruker tilbakemeldinger i et produkt. GraphQL derimot er mer fleksibel&#160;GraphQL og&#160;kan gj&#248;re endringer p&#229; klientsiden gj&#248;res uten ekstra arbeid p&#229; serveren. Siden klienter kan spesifisere de eksakte datakravene, trengs det ingen justeringer p&#229;&#160;backenden&#160;n&#229;r design- og databehovet p&#229; frontend endres.<\/p><p>&#160;<\/p><p>GraphQL gir deg&#160;innsikt om dataene som ligger p&#229; backend. Siden klienten spesifiserer n&#248;yaktig hvilken informasjon den er interessert i, er det mulig &#229; f&#229; en dyp forst&#229;else av hvordan tilgjengelige data blir brukt. Dette kan blandt annet&#160;hjelpe til med &#229; utvikle et API og avskrive spesifikke felt som ikke blir bedt om av noen klienter lenger. Med GraphQL kan du ogs&#229; gj&#248;re ytelsesoverv&#229;king p&#229; lavt niv&#229; av foresp&#248;rslene som behandles av serveren din. GraphQL bruker konseptet med resolverfunksjoner for &#229; samle inn data som kunden ber om. Instrumentering og m&#229;ling av ytelse til disse resolverne gir viktig innsikt om &#34;bottlenecks&#34;&#160;i systemet ditt.<\/p><p>&#160;<\/p><p>GraphQL bruker et sterkt system for &#229; definere mulighetene til et API. Alle typene som blir eksponert i et API er skrevet ned i et skjema ved hjelp av GraphQL Schema Definition Language (SDL). Dette skjemaet fungerer som en kontrakt&#160;mellom klienten og serveren for &#229; definere hvordan klienten skal f&#229; tilgang til dataene. Siden strukturen p&#229; dataene blir forh&#229;ndsbestemt blir det mye enklere for en gruppe &#229; ha frontend developers og backend developers som ikke kommuniserer. Frontend-team kan enkelt teste applikasjonene sine ved &#229; spotte de n&#248;dvendige datastrukturene.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>-&#160;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11534926,"ext_inspera_userAssessmentSetupId":7140039,"ext_inspera_userAssessmentId":4841422,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Tønsberg Conrad Wilhelm (10037)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33614149,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2877,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For h&#229;ndtering av&#160;tilstand (state) og dataflyt er det en rekke mekanismer og teknikker i React applikasjoner.<\/p><p>Sending av props, callbackfunksjoner, bruk av Context API&#39;et, samt state management systemer som REDUX og MOBX er blant de overnevnte teknikkene og mekanismene. For kommunikasjon av data (dataflyt) mellom f.eks. frontend og backend kan man for eksempel REST API settes opp eller bruke&#160;GraphQL.<\/p><p>For setting av verdier benyttes variabel state og setstate i klasse-komponenter og i funksjonelle benyttes useState hooken.<\/p><p>&#160;<\/p><p>Props st&#229;r for properties og er &#34;egenskaper&#34; man sender fra en komponent til sine &#248;nskede &#34;children&#34;-komponenter. P&#229; denne m&#229;ten kan man sende informasjon igjennom komponenttreet ved &#229; &#34;drille&#34; props (propdrilling) igjennom komponenter. Det er ugunstig da man m&#229; s&#248;rge for at det er tilrettelagt i hver komponent.<\/p><p>For &#229; sende informasjon fra en &#34;child&#34;-komponent til en &#34;parent&#34;-komponent kan callback-funksjoner benyttes, der parent-komponenten sender en funksjon til child-komponenten, som da sender resultatet tilbake til parent-komponenten.<\/p><p>&#160;<\/p><p>Da propdrilling er lite gunstig benytter man gjerne andre l&#248;sninger for &#229; sende informasjon som skal n&#229; en st&#248;rre mengde komponenter. Da kan man for eksempel benytte seg av Reacts Context API. Context API&#39;et gj&#248;r at man kan sette opp hvilke komponenter som mottar informasjon, og hvilke som kan endre. Ved mer komplekse States, data og komponenthierarki blir Context raskt lite gunstig da &#34;subscribers&#34; til contexten vil rerendres ved endring av contextens state selv om de ikke n&#248;dvendigvis er interesserte i informasjonen endret.<\/p><p>F.eks. komponent som forteller antall likesOgComments, komponent som forteller antall Likes, knapp som legger til like, knapp som legger til comment, contexten inneholder en&#160;tuppel med antall likes og antall comments. hver gang comment &#248;ker med 1 blir komponenten som bare forteller antall likes oppdatert siden contexten endrer seg.<\/p><p>&#160;<\/p><p>For mer avanserte states og dataflyt anbefales 3. parts biblioteker for state management som REDUX og MOBX. De tilbyr global State som inneholder data &#248;nsket, som kan sende den spesifikke dataen &#248;nsket til de komponentene man &#248;nsker. Det l&#248;ser problemet nevnt under Context (kun et eksempel, finnes andre l&#248;sninger, men er for illustrasjon).<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3193,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>RecoilJS er et bibliotek med form&#229;l &#229; simplifisere state management i React. For &#229; s&#248;rge for statemanagement benytter recoil seg av dataflyt fra atoms (states), gjennom selectors (som er rene funksjoner) og inn i komponenter. Komponenter m&#229; ikke n&#248;dvendigvis motta informasjon gjennom en selector. Atoms representerer en state og kan skrives og leses til fra en hvilken som helst komponent som er wrappet av RecoilRoot&#39;en (som oppf&#248;rer seg som en provider for children-komponenter). Subscribers, lesere,&#160;av atoms vil oppdateres n&#229;r atomet oppdateres.<\/p><p>Da recoil, utviklet av facebook (som ogs&#229; utviklet react), &#248;nsker &#229; simplifisere state management, er bruken relativt lik bruken av hooks og dermed enkelt &#229; sette seg inn i for React-utviklere.<\/p><p>For &#229; hente eller oppdatere atomer benyttes hooken useRecoilState().<\/p><p>Selectors kan ta inn atoms eller andre selectors og ved oppdatering av disse updatene vil selectoren re-evalueres for &#229; s&#248;rge for at data propagerer riktig. Naturligvis nok re-rendres da komponenter som lytter til selectoren for &#229; s&#248;rge for at UI&#39;et viser korrekt informasjon.&#160;For &#229; lese fra en selector benyttes useRecoilValue() hooken.<\/p><p>I dokumentasjonen til RecoilJS, under core concepts st&#229;r det nevnt at selectors har mulighet til &#229; minimere redundans av states. Dette da selectors kan gi informasjon uthentet av states som da gj&#248;r at man ikke trenger &#229; benytte seg av s&#229; mange states. En problematikk som kan oppst&#229; ved feil bruk av recoil er samme problematikken som nevnt under context i oppgave 1. Ved feil bruk kan man ende med en side som rerendrer komponenter un&#248;dvendig, men igjen er det ved ikke gunstig implementasjon av recoil.<\/p><p>&#160;<\/p><p>recoil l&#248;ser de samme problematikkene som redux og mobx, se gjerne oppgave 1 for tilleggsinfo om state management. Alts&#229; i likhet med REDUX og MOBX s&#248;rger Recoil for at riktig data, behandles riktig og sendes til riktige steder, og komponenters reaksjon p&#229; endringer er korrekt. Der recoil virkelig gj&#248;r seg relevante er ved at det er sv&#230;rt hurtig &#229; ta i bruk, det er ingen krav til boilerplate, som er et stort problem ved redux (for mange under oppstart), skrivem&#229;ten er kjent for react-utviklere. I for eksempel redux er boilerplate kravet en stor ulempe der actions og reducers m&#229; skrives for hver funksjonalitet.<\/p><p>&#160;<\/p><p>problemet med recoil i forhold til mobx og redux er at b&#229;de mobx og redux er sv&#230;rt etterpr&#248;vde og er &#34;industriledere&#34;. Redux og MOBX er blitt tunggrodde i utviklermilj&#248;, deres positive og negative sider er kjente, s&#229; hvorfor man skal utf&#248;re en overgang blir vanskelig &#229; se for mange selskaper. En st&#248;rre grunn potensielt er at, I tillegg er recoil fremdeles sv&#230;rt nytt er det naturligvis noen mangler. Debugging-tools og&#160;offisiell st&#248;tte av server-side rendering er ikke gitt ut.<\/p><p>&#160;<\/p><p>Kilder brukt her er:<\/p><p>Recoils dokumentasjon p&#229;: https://recoiljs.org<\/p><p>Samt en artikkel som omhandler Recoil og Redux: https://bigcheeseapp.com/2020/07/12/recoil-vs-redux-react-state-management-2020/?fbclid=IwAR1U8l_zk_NjGlSUm24tWLwoooTPZo1zJ43XAa7FpQdPVYYtnsIh8tOWt0Y<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1054,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Den f&#248;rste vesentlige forskjellen mellom REST API og Graphql er at i REST API defineres ett eller flere endepunkter for &#229; lese, skrive, oppdatere, slette etc. mens det i Graphql kun er ett endepunkt som man sender en sp&#248;rring (&#34;query&#34;) til der det defineres s&#248;k, hva slags data som skal leses, skrives, oppdateres, slettes, etc.<\/p><p>P&#229; denne m&#229;ten fungerer Graphql mer som et sp&#248;rrespr&#229;k, mens sp&#248;rringene ved REST API er &#34;splittet opp&#34; / definert vha. URI&#39;en og HTTP requests.<\/p><p>En annen forskjell p&#229; REST API og Graphql er at REST API&#39;et har fordel i caching mekanismen i HTTP laget, som er en mangel hos Graphql og caching m&#229; dermed implementeres for &#229; f&#229; samme mulighet.<\/p><p>En stor fordel med Graphql kontra REST er at i Graphql sp&#248;rringen kan du spesifisere akkurat det du &#248;nsker, p&#229; denne m&#229;ten s&#248;rger effektiv bruk av Graphql at en unng&#229;r &#229; laste un&#248;dvendig data, noe som er en ulempe i REST ved mer kompleks informasjon. Ved kompleks informasjon kan REST og ha den ulempen at mange kall m&#229; utf&#248;res for &#229; f&#229; hentet &#248;nsket informasjon.<\/p><p>&#160;<\/p><p>Graphqls implementasjon gj&#248;r at rommet mellom backend og frontend innskrenkes. Dette skaper en mer flytende overgang mellom dem, noe noen ser p&#229; som fordel og andre som ulempe. implementasjon av skjema for struktur og typer s&#248;rger og for muligheten til &#229; dra fordel av valideringsmulighet og typesjekking av data.<\/p><p>&#160;<\/p><p>En negativ side ved graphql er at REST er mer brukt og oppsett kan v&#230;re noenlunde mer krevende. N&#229;r det er sagt s&#229; finnes det sv&#230;rt mange rammeverk som simplifiserer dette. ved bruk av Grand stacken med apollo, neo4j med neo4j-graphql-js f&#229;r man det meste av oppsett relavtivt gratis. i tillegg har graphql kun st&#248;tte for JSON utveksling av data.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535247,"ext_inspera_userAssessmentSetupId":7140112,"ext_inspera_userAssessmentId":4841442,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Mohr Solveig Jørgensen (10083)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330983,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2111,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I react applikasjoner kan en benytte redux, mobx, context, props og state for statemanagement og dataflyt.&#160;<\/p><p>&#160;<\/p><p>Lokal state innad i en komponent kan gj&#248;res ved &#229; opprette variabler som oppdateres. I funksjonelle komponenter benyttes hooks:&#160;useSate og useEffect, mens i klasse-komponenter benyttes this.state. For &#229; dele staten med andre komponenter kan en benytte props.&#160;<\/p><p>&#160;<\/p><p>Props er variabler/funksjoner som sendes inn i komponentene fra parent-komponenten. Det problematiske med dette er at dersom nettsiden er bygget opp av mange lag og staten er lagret i &#248;verste lag, vil en m&#229;tte sende props gjennom flere komponenter for &#229; n&#229; den &#248;nskede child-komponenten.<\/p><p>For &#229; oppdatere states i parent fra en child-comp m&#229; en sende setState funksjonen som prop hele veien ned.&#160;<\/p><p>Denne sendingen er ikke bare kompleks, og gir uoversiklig kode, men vil ogs&#229; lage et stort tre av avhengig kode som kan gj&#248;re&#160;at mye kode m&#229; re-rendre dersom noe endres i en komponent.<\/p><p>&#160;<\/p><p>Context l&#248;ser problemet med lagvis oppbygde nettsider, og oppf&#248;rerer seg som en global state. Komponentene vil kunne akksessere context apiet uten &#229; f&#229; det sendt nedover. Men hvert context kan kun lagre en state.<\/p><p>&#160;<\/p><p>Redux og mobx er bra dersom en har mange states &#229; h&#229;ndtere. Det lar states samles&#160;p&#229; samme sted, og gj&#248;r koden mer oversiklig. En vil slippe &#229; m&#229;tte sende states frem &#229; tilbake mellom komponenter. Men det er litt mer komplekst enn contex og props.&#160;<\/p><p>&#160;<\/p><p>Med Redux oppretter man en reducer som holder kontorol p&#229; states, for s&#229; &#229; benytte dispatch i de forskjellige komponentene som endrer p&#229; staten. Dette gj&#248;r at dersom en endring blir triggered i en komponent vil alle komponentene oppdateres,&#160;da states er h&#229;ndtert av reduceren.&#160;<\/p><p>&#160;<\/p><p>Mobx fungerer slik som redux uten behov for en reducer. N&#229;r data endres i mobx vil alle komponentene re-rendere for &#229; vise den oppdaterte dataen p&#229; siden. Mobx er enklere syntaxmessig. Siden den ikke har en reducer, skjuler den en del av funskjonaliteten.<\/p><p>&#160;<\/p><p>Mobox er godt egnet for enklere applikasjoner, da Mobx er enklere syntaks messig og mer abstrakt enn redux. Men for mer komplekse applikasjoner kan Redux v&#230;re et bedre alternativ, da det gir deg mer oversikt over hva som skjer i dataflyten, noe som gj&#248;r det enklere &#229; dekode.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1663,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for statemanagement, slik som redux og mobx som vi har l&#230;rt om.&#160;<\/p><p>Recoil baserer seg p&#229; atoms (state) og selectors (funksjoner). Komponenter vil &#34;subsribe&#34; (f&#248;lge med p&#229;) atomsene, og n&#229;r de oppdateres vil alle f&#248;lgerne re-rendre med&#160;den oppdaterte verdien. Selectors brukes for &#229; endre atomene. Komponenter kan f&#248;lge selectorene ogs&#229;, s&#229; dersom en av selcetorene endres, vil komponentene som f&#248;lger re-rendre.&#160;<\/p><p>&#160;<\/p><p>I Recoil er det ikke behov for en reducer og store, slik det er i redux. I stedet for en reducer vil man i recoil opprette disse atomene som konstanter, og de vil v&#230;re staten som deles mellom komponentene.&#160;<\/p><p>&#160;<\/p><p>I Redux oppdateres og endres state ved bruk av &#34;dispatch&#34;, mens in recoil er dette oppgaven til selectorene.<\/p><p>&#160;<\/p><p>For &#229; benytte reduceren i Redux m&#229; komponentene benytte hooks &#34;useSelector&#34; og &#34;useDispatch&#34;. En kan ogs&#229; lagre state som props og dele den videre ved &#229; benytte mapStateToProps og mapDispatchToProps.<\/p><p>I recoil kan en direkte f&#229; tilgang til atomene (states) p&#229; samme m&#229;te som en er vant til med useState og setState. Her bruker en da funksjonene useRecoilValue som tar inn en selector og useRecoilState som tar inn et atom.&#160;<\/p><p>&#160;<\/p><p>B&#229;de redux og recoil trenger en wrapper i Appfilen, helt &#248;verse parent komponent. I redux benyttes Provider, mens i recoil benyttes RecoilRoot. Disse fungerer p&#229; samme m&#229;te, bortsett fra at redux provideren tar inn store (der reduceren er eksportert som en store).<\/p><p>&#160;<\/p><p>Et negativt aspekt&#160;ved recoil er at det baserer seg p&#229; hooks, derfor vil det kun fungere med funksjonelle komponenter og ikke klassekomponenter.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://recoiljs.org<br />https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee&#160;<\/p><p>https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2031,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API og GraphQL brukes for&#160;nettsider som krever innhenting og oppdatering av data. REST API er en arkitektur som definerer &#34;contsraint&#34; for hvordan &#229;&#160;bruke data p&#229; en nettside. GraphQL er ogs&#229; en API arkitektur, men ogs&#229; et &#34;query langauge&#34; som kan brukes for &#229; sp&#248;rre om data fra et api.&#160;<\/p><p>&#160;<\/p><p>Rest api benytter URI&#160;og HTTP request til endpoints (eks: &#39;https://poetrydb.org/author/shakespeare&#39;) for &#229; lese eller skrive eller oppdatere data. Da vil en f&#229; den dataten som ligger p&#229; dette endpointet. REST API er &#34;cacheable&#34; noe som gj&#248;r at nettleseren kan cache data og gj&#248;re nettsiden din raskere. Det negative askpektet med REST, er at en f&#229;r alt innholdet p&#229; endpointet, hele datasettet,&#160;noe som kan f&#248;re til over fetching. Om en kun &#248;nsker tittelen p&#229; et dikt, vil en uansett ogs&#229; f&#229; forfatter, antall linjer etc.<br />En annen negativ ting er at dersom ting en &#248;nsker er lagret p&#229; forskjellige endpoints (du &#248;nsker dikt fra b&#229;de Shakespeare og Dickinson) m&#229; en fetche fra begge endpointsene. Dette vil da kreve to requests til REST APIet.&#160;<\/p><p>&#160;<\/p><p>GraphQL som er et query langauge gir deg muligheten til &#229; gj&#248;re sp&#248;rringer til serveren. Da kan en definere hvilke data en &#248;nsker eller hva en &#248;nsker &#229; oppdatere. Dette gj&#248;r at du slipper unna overfetching, slik REST kan gi. Du vil ogs&#229; slippe flere endpoints fetches (kan sp&#248;rre dirkete om begge forfatterne, og slipper &#229; skrive to requests).&#160;Ulempen er at det ikke st&#248;tter HTTP chaching.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11537662,"ext_inspera_userAssessmentSetupId":7139980,"ext_inspera_userAssessmentId":4841524,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Joner Mikkel Angelo Anchissi (10164)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":18766573,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3257,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State i React kan man se p&#229; som tilstand til en React komponent. Det er m&#229;ter at enten komponenter kan lagre data selv.<\/p><p>&#160;<\/p><p>Man kan se p&#229; det som en m&#229;te &#229; lagre data p&#229; som React bruker til &#229; for eksempel rendre statebaserte/custom komponenter.<\/p><p>&#160;<\/p><p>Den enkleste formen &#229; lagre states i de respektive elementene hvor man bruker staten er ved hjelp av Hooks som useState.&#160;Hvis et state til en komponent ikke er synlig eller brukes av andre komponenter er det naturlig &#229; lagre staten i de respektive komponentene.&#160;En annen hook som er viktig er useEffect som re-rendrerer komponenter n&#229;r en state oppdateres og brukes ofte sammen med useState.<\/p><p>&#160;<\/p><p>React baserer seg p&#229; prinsippet at man kun kan sende data fra foreldrekomponent til komponent, s&#229; det vil st at dersom data/state i en komponent skal kunne endres av andre komponenter, f.eks hvis du har en counter app hvor en counterComponent&#160;viser counter verdi og en annen komponenet IncrementComponent&#160;rendrere en knapp som skal &#248;ke verdien til counteren vil det v&#230;re lettere &#229; &#34;l&#248;fte&#34; counterState til komponenten som rendrer b&#229;de incrementComponent og counterComponent. Her holder den p&#229; verdien og sender som props til&#160;passer og m&#229; ha en funksjon onClickHandler som den &#34;passer&#34;/sender til incrementComponent som props.&#160;<\/p><p>&#160;<\/p><p>&#197; &#34;l&#248;fte&#34; state er et hovedkonsept i React App&#39;er, men et problem som kan oppst&#229; er hvis dersom hovedkomponenet (vi kaller den App), har veldig mange barnekomponenter og m&#229; holde p&#229; staten til mange barnekomponenter og m&#229; lage mange funksjoner for &#229; oppdatere de. En l&#248;sning p&#229; dette er Context.&#160;<\/p><p>&#160;<\/p><p>En annen hook som er viktig for statemanagement&#160;er useContext. Vanligvis s&#229; sendes states som props ned komponenttreet for at de aller nederste barnekomponenten skal kunne n&#229; det. Med context s&#229; kan man lagre verdier som mange komponenter bruker slik at disse verdiene&#160;kan n&#229;s av alle komponenter uten &#229; m&#229;tte traversere igjennom hele komponenttreet. Man kan si at man har l&#248;ftet states til en global state.<\/p><p>M&#229;ten man bruker context p&#229; er &#229; bruker en Provider. Provider React komponent som gj&#248;r at komponenter kan abonnere p&#229; endringer i context. Deretter spesiferer man hvilke komponenter som er Consumers, dvs hvilke komponenter som skal reagere p&#229; endring til context som knyttet til Provideren.<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; h&#229;ndtere state management er &#229; bruke en design pattern/designm&#248;nster ved navn Flux og da f.eks. implementasjonene MobX eller Redux. Til forskjell for context s&#229; er redux og mobx et tredjeparts bibliotek. P&#229; samme m&#229;te som context er det en m&#229;te &#229; skape et globalt state som komponenter kan interagere med og hente data fra. M&#229;ten det fungerer p&#229; er at man lager en Store som som holder p&#229; all dataen og skaper s&#229; Actions og Actiontypes som sier hvilke endringer og p&#229; hvilken m&#229;te Store&#39;en skal reagere p&#229;. Da bruker Storen en reducer til &#229; dispatcha actionen.<\/p><p>Mobx er en annen m&#229;te &#229; h&#229;ndtere globalt state&#160;<\/p><p>Mobx krever mindre boilerplate, er lettere og i tillegg har Mobx flere Stores, mens redux har en stor store hvor alle states ligger. Det er for&#248;vrig lettere &#229; debugge med Redux enn med Mobx ettersom Mobx er inpure, som betyr at verdier i MobX&#160;kan bli overskrevet.<\/p><p>&#160;<\/p><p>P&#229; overflaten kan det virke som om context er bedre &#229; bruke enn Redux ettersom det krever mindre boilerplate kode og er lettere &#229; bruke. Et argument for &#229; bruke Redux er at dersom man skal ha en app/nettside/etc hvor det gj&#248;res hyppige endringer, man vil ha mer controll over hvordan data traverserer og endres p&#229; og n&#229;r du ikke vil at server respons skal direkte endre statene i appen din. React Context vil trigge en re-rendring av app/siden din hver gang den oppdateres og dette kan v&#230;re ugunstig i mange tilfeller&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1572,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state-management bibliotek for React.<\/p><p>Recoil lar deg&#160;skape data-fly graf som flyter fra Atomer ( som er delt states) til selectors (som er pure functions) og s&#229; ned til react componenter. Atoms er states som komponenter kan subscribe til og oppdatere. Alle komponenter som abonnerer p&#229; atom&#8217;et vil re-rendre med ny verdi. Dette er da fordelen med Recoil, at kun de komponentene som er eksplisitt bindet til atom&#39;et re-rendres. I tillegg har Recoil betydlig mindre boilerplate kode.<\/p><p>&#160;<\/p><p>En potensiell ulempe er at Recoil h&#229;ndterer state management p&#229; UI niv&#229; framfor Redux som h&#229;ndterer det ved hjelp av reducers og actions. Dette kan gj&#248;re det vanskeligere &#229; debugge.&#160;<\/p><p>&#160;<\/p><p>Recoil kan minne om Context, Redux og Mobx p&#229; den m&#229;ten at isteden for &#229; ha et globalt state i hovedkomponenten s&#229; flyttes det til noe eksternt som individuelle komponenter kan interagere og hente data fra.&#160;<\/p><p>&#160;<\/p><p>En fordel med Recoil framfor Context er at det er kun de elementene som som subscriber til et Atom som re-rendres n&#229;r verdien til et atom endres. Framfor med Contex hvor alt re-rendres. Redux er litt bedre enn context p&#229; un&#248;dvendig Re-renders, men kan ogs&#229; gj&#248;re at hele appen/siden m&#229; re-rendres dersom implemtasjonen av Redux kobler veldig store komponenter til storen.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2358,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I mange apper er det behov for mer enn &#229; bare vise statisk HTML. Apper er ofte koblet til en database som skal oppdateres n&#229;r ting<\/p><p>Interageres med og de sendes data inn. Mange apper trenger st&#248;tte for CRUD, (Create, Read, Update and delete) funksjonalitet som gj&#248;r at man trenger en m&#229;te &#229; definere hvordan data skal sendes, n&#229;r den skal sendes osv.&#160;<\/p><p>&#160;<\/p><p>REST er en designstil for web-baserte client server kommunikasjon som baserer seg p&#229; at man definerer endepunkter som kommuniserer med bakenden. I rest&#160;tar man bruk av URI og HTTP requests for &#229; definere hvilken data som skal returneres.&#160; &#197; kunne cache data, som st&#248;ttes default av alle webleser er en fordel, men en ulempe kan v&#230;re overfetching som vil si at man m&#229; gj&#248;re mange kall for &#229; hente ut data man trenger, dette gj&#248;re nettsiden treigere fordi den m&#229; gj&#248;re mange kall som returnerer for mye data.<\/p><p>&#160;<\/p><p>Prinsippene til REST er at det skal v&#230;re Stateless som vil si hver request skal inneholde all den n&#248;dvendige dataen for &#229; kunne forst&#229; requesten og bruker ikke noen lagrede tilstander til serveren. Et annet prinsipp er at det skal v&#230;re cacheable som vil si at man kan bruke cachemekanismen som gj&#248;r det raskere &#229; hente ut data som ofte s&#248;kes p&#229;.<\/p><p>&#160;<\/p><p>GraphQL er et query-spr&#229;k og et runtime.&#160;<\/p><p>M&#229;ten dette brukes p&#229; er at man definerer s&#248;k og data som skal returneres fra en sp&#248;rring til en server.&#160;<\/p><p>Hovedmotivasjonen til at GRAPHQL ble utviklet var &#229; l&#248;se problemet med overfetching. M&#229;ten den gj&#248;r dette er ved &#229; definere s&#248;k og hvilken data som skal returneres slike at man kan gj&#248;r en enkel request til backenden og laster ikke un&#248;dvendig data.&#160;<\/p><p>&#160;<\/p><p>Graphql er organisert ved help av types og fields og ikke endepunkter. GRAPHQL bruker types til &#229; gj&#248;re at Apper kun requester det som er mulig og p&#229; denne m&#229;ten er det mulig &#229; validere. Ved hjelp av dette og skaper det en tettere kobling mellom tjener og klient.<\/p><p>&#160;<\/p><p>Ulemper er feks at GRAPHQL ikke st&#248;tter implisitt caching I HTTP-laget p&#229; samme m&#229;te som REST API.<\/p><p>I tillegg st&#248;ttter det kun JSON-data som kan v&#230;re problematisk dersom man ikke har kjennskap til JSON.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11535101,"ext_inspera_userAssessmentSetupId":7140069,"ext_inspera_userAssessmentId":4841423,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Le William Huy (10219)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":26413738,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1523,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State kan lages p&#229; forskjellige m&#229;ter i React. For klassebaserte komponenter er det nok &#229; initalisere state={variabel:verdi}&#160;og oppdatere ved bruk av setState() og componentDidUpdate(). I funksjonellebaserte komponenter s&#229; tas det i bruk React Hooks. Dette inneholder blant annet useeffect og usestate for &#229; h&#229;ndtere state og oppdatere komponenten.<\/p><p>&#160;<\/p><p>En annen m&#229;te &#229; lagre state er &#229; bruke Redux. Redux lagrer statene for komponenter i en store. Denne er da tilgjengelig globalt slik at alle komponenter som har nytte av staten har tilgang til dette.<\/p><p>Det er ogs&#229; verdt &#229; nevne React sin Context API som gj&#248;r det mulig &#229; sende data til en komponent uten &#229; m&#229;te sende den gjennom hver parent-component til komponenten.<\/p><p>&#160;<\/p><p>Dataflyten i react g&#229;r ut p&#229; at en endring(action) fra bruker har muligheten til &#229; endre p&#229; state. Endring av state vil f&#248;re til at applikasjonen oppdaterer seg og renderer p&#229; nytt. De viktigste konseptene innenfor dataflyt er props, state og components. Kort sagt s&#229; deler vi funksjonaliteten til en applikasjon i komponenter. Komponentene&#160;kan sende data mellom hverandre ved bruk av prop systemet.<\/p><p>&#160;<\/p><p>For eksempel hvis har en applikasjon som legger til 1 fra 0 hver gang vi trykker p&#229; en knapp. S&#229; vil trykking av knapp f&#248;re til at staten (alts&#229; den lagrede verdien 0) oppdatere seg. Kun verdien som endres p&#229; vil forandres og vises til brukeren. Vi slipper alts&#229; &#229; refreshe hele vinduet p&#229; nytt hver gang verdien endrer seg.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://flaviocopes.com/react-unidirectional-data-flow/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3404,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek utviklet spesielt for React. Recoil h&#229;ndterer state slik at det blir mulig &#229; aksessere og oppdatere den fra hvilken som helst komponent. Recoil har to hovedkonsepter som de kaller Atoms og Selectors. Atoms er en m&#229;te &#229; lage state p&#229;. De som bruker en atom er &#34;abonnert&#34; til denne. Det vil si at dersom endringer&#160;skjer i staten s&#229; vil komponentene oppdatere seg automatisk. En selector er en funksjon som tar inn state fra atoms eller andre selectors. Denne funksjonen kan brukes for &#229; modifisere p&#229; staten.&#160;Alts&#229; staten blir ikke endret, men bare modifisert slik at funksjonen kan brukes der det er relevant (derived state). Ut i fra det vi har l&#230;rt gjennom prosjektene s&#229; er gj&#248;r for eksempel Redux, MobX og Context API utviklet for &#229; gj&#248;re mye av det samme.&#160;<\/p><p>&#160;<\/p><p>Sammenligner vi Recoil med Redux s&#229; ser vi at det er en overhead for &#229; konfigurere Redux. Vi m&#229; i Redux lage store, reducer og dispatch. I Recoil holder det &#229; lage atoms og selectors, koden her er ogs&#229; mye mer kompakt og kan p&#229;virke ytelsen positivt. I tilleg s&#229; vil bruken av selector reduserer redundanse i koden. Komponenter kan lage sin egen &#34;versjon&#34; av en state.<\/p><p>&#160;<\/p><p>Recoil er relativt nytt og fortsatt i eksperimentfasen. Den kan fint brukes i hobbyprosjekter for &#229; rask implementasjon. I st&#248;rre prosjekter for bedrifter inneb&#230;rer dette st&#248;rre risiko fordi hvordan Recoil fungerer kan fortsatt endre p&#229; seg siden den er i eksperimentfasen. Redux er derfor et tryggere valg da den har v&#230;rt p&#229; markedet lenge og er bedre integrert.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2012,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Aller viktigste forskjell mellom REST API og GraphQL er hvordan de henter ut data ved sp&#248;rring. Ved &#229; hente data med REST s&#229; vil du f&#229; ut verdien&#160;til alle feltene uansett om du kun trenger verdien av et felt. I GraphQL derimot kan du spesifisere akkurat de feltene du &#248;nsker. Dette vil f&#248;re til at vi unng&#229;r noe som kalles overfetching.&#160;<\/p><p>&#160;<\/p><p>En fordel med GraphQL er at sp&#248;rringen kan hente ut all n&#248;dvendig data fra kun en sp&#248;rring. I&#160;REST s&#229; kan du m&#229;tte lage flere relaterte sp&#248;rringer for &#229; hente ut samme n&#248;dvendig data. Dette er ogs&#229; kjent som underfetching.&#160;<\/p><p>&#160;<\/p><p>En annen forskjell er at REST beskriver en API som en liste med endepunkter. Som for eksempel&#160;GET /books/:id, GET /authors/:id osv. Mens i GraphQL s&#229; definerer man dette via en Schema.<\/p><p>Videre s&#229; har GraphQL et sterkt type system. Dette f&#248;rer til mindre feil og bedre validering av datatyper.<\/p><p>&#160;<\/p><p>En ulempe&#160;med GraphQL er at den kun kan h&#229;ndtere data i JSON format. I motsetning til REST som kan h&#229;ndtere b&#229;de XML og JSON.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535118,"ext_inspera_userAssessmentSetupId":7140115,"ext_inspera_userAssessmentId":4841325,"dateLastModified":"2020-12-01T10:01:35Z","ext_inspera_startTime":"2020-12-01T08:00:03Z","ext_inspera_endTime":"2020-12-01T10:01:35Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Karlsen Aleksander Westergaard (10099)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330602,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2197,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r det kommer til state har man i tilegg til react hooks eller en class mulighet for &#229; bruke forskjellige state managment verkt&#248;y for &#229; h&#229;ndtere global state for applikasjonene, noe som ville v&#230;rt vanskelig &#229; kun gjennomf&#248;re med f.eks. props fordi det skalerer d&#229;rlig. De tre mest brukte l&#248;sningene for global state er per i dag Reacts context api, Redux, og MobX, men det finnes ogs&#229; andre muligheter for dette, som f.eks. Apollo der man kan bruke Apollo sin chache til &#229; lagre state.<\/p><p>&#160;<\/p><p>React&#160;har default global state innebygd kalt for Context apiet. Dette er en l&#248;sning for &#229; dele data mellom komponenter i hierarkiet, spesielt for de komponentene som ikke er direkte etterf&#248;lgere. Dermed slipper man &#229; bruke mange props, og komponentene blir mer generelle som medf&#248;rer at man kan bruke dem i andre settinger ogs&#229;. Context er enkelt &#229; sette opp fordi det har lite overhead, i motsetning til andre l&#248;sninger slik som Redux. Men en ulempe med Context apiet er at det ikke egner seg til funksjonalitet der data oppdateres jevnlig som f.eks. en knapp for &#229; &#229;pne en meny. Contex er dermed best egent for mer statiske tilstandsvariable som f.eks. temafarger, innlogget bruker eller valgt spr&#229;k p&#229; nettsiden.&#160;<\/p><p>&#160;<\/p><p>Redux er et tredjeparts state managment verkt&#248;y for react applikasjoner, og lar utviklere dele data mellom komponenter p&#229; samme m&#229;te som i React Context, men i redux gj&#248;res dette p&#229; en litt annen m&#229;te. N&#229;r man bruker react context manipulerer (mutater) man state direkte, men i redux er dette ikke mulig fordi state er read only. Her m&#229; man spesifisere en action som sammen med en reducer blir brukt til &#229; finne ut hva neste tilstand til siden er. Reducers er det man kaller for pure functions som betyr at de ikke muterer state, men returnerer en nye en. Dette gj&#248;r at man aldri vil gj&#248;re endringer p&#229; state som ikke er ment til &#229; bli gjort. Det er kun er state objekt som da blir single source of truth. Actions og reducers er fordelen med &#229; bruke redux, men er ogs&#229; kilden til ulempen fordi det medf&#248;rer en del overhead for &#229; sette i gang. Men redux har ogs&#229; noen ekstra fordeler som at det er lett &#229; teste state endringer ved &#229; f.eks logge actions eller skrive vanlige tester, og man sparer tid hvis applikasjonen blir st&#248;rre fordi redux skalerer bra. Man kan derfor argumentere for at den ekstra tiden man bruker i starten blir tatt igjen senere. I motsetning til react context er reduc ogs&#229; egnet for hypping state endring, og kan dermed bli brukt ti lall form for funksjonalitet.&#160;<\/p><p>&#160;<\/p><p>MobX er p&#229; samme m&#229;te som redux et tredjeparts state managment verkt&#248;y for react applikasjoner. MobX har mange av de samme filosofiene som redux, men skiller seg p&#229; noen, og derfor har de valgt &#229; implementere state managment p&#229; en litt annen m&#229;te. M&#229;ten dette funker p&#229; rent teknisk er ved &#229; gj&#248;re komponenter observable for mobx slik at state i komponenter kan bli oppfattet. Sammenlignet med redux bruker ikke mobx reducers for &#229; utf&#248;re sine actions, men derivations som beregner ny state variabler som da p&#229;virker hva slags reactions som skjer f.eks. DOM&#160;updates. En annen viktig sammenligning er mengden overhead. MobX krever nemlig ikke den samme mengden med kode for &#229; komme i gang, og dermed engner det seg til prosjekter med mindre skala og st&#248;rre tidspress. N&#229;r det er sagt betyr det heller ikke at mobx ikke skalerer bra.&#160;<\/p><p>&#160;<\/p><p>N&#229;r det kommer til mer generell dataflyt i react applikasjoner finnes det hovedsaklig to metoder for &#229; gj&#248;re dette med ren react kode: props og callback-funksjoner. props er data man kan sende nedover komponenthierarkiet for &#229; s&#229; brukes av andre komponenter til &#229; f.eks. endre tilstand. Sending av props fungerer kun nedover, og derfor er det n&#248;dvendig &#229; bruke callback-funksjoner hvis man vil l&#248;fte states oppover slik at det kan brukes i ikke-relaterte komponenter. Dette gj&#248;res ved &#229; sende en funksjon ned som en prop. Denne funksjonen kan da bli kalt for &#229; s&#229; sende data oppover i hierarkiet.&#160;<\/p><p>&#160;<\/p><p>N&#229;r det kommer til lokal state for react applikasjoner kan dette gj&#248;res p&#229; to m&#229;ter avhengig av hva man velger. F&#248;r i tiden var det kun mulig &#229; lage class-komponenter i react. Dette ser ut p&#229; sammen m&#229;te som hvilken som helts annet objekt orientert program. Man har en konstrukt&#248;r som initialiserer classen med data. I nyere tid har React lagt til hooks, og dette har gjort det mulig &#229; lage funksjonell komponenter som ikke n&#248;dvendigvis trenger &#229; ha en tilstand, men det er mulig. Det &#229; h&#229;ndtere state i disse to tilfellene blir da litt forskjellig. I en class-komponent bruker man &#34;this&#34; for &#229; aksessere tilstandsvariablene, mens i en funksjonell komponent bruker man hooks for &#229; endre en tilstand.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>&#160;<\/p><p>https://reactjs.org/docs/context.html#when-to-use-context<\/p><p>https://fireup.pro/blog/redux-vs-react-context-which-should-you-use?GA_redux_context&#38;gclid=Cj0KCQiAqo3-BRDoARIsAE5vnaLVekGQ8GQaz3WYCjKs-q7LBV9z8InNJG17MPZidrjzvLOLZZwoK3waAhNvEALw_wcB<\/p><p>https://redux.js.org/introduction/getting-started<\/p><p>https://en.wikipedia.org/wiki/Pure_function<\/p><p>https://mobx.js.org/getting-started<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3387,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et tredjeparts state managment bibliotek for react applikajsoner. Motivasjonen for &#229; lage recoil var et det er best &#229; bruke react sine innebygde l&#248;sninger istedenfor et eksternt global state verkt&#248;y, men dette medf&#248;rer restriksjonene til react sin state managment: pushing av state oppover skalerer d&#229;rlig, og f&#248;rer til un&#248;dvendig rerendering. Samtidig kan react context kun bevare en single verdi. Dette gj&#248;r code-splitting vanskelig i toppen av hierarkiet(&#229; dele koden inn i mindre deler som kan bli lastet i paralell) Recoil skal forbedre dette, men samtidig opptre s&#229; likt som react som mulig med tanke p&#229; api og sematikk.&#160;<\/p><p>&#160;<\/p><p>Sammenlignet med Redux har recoil lite overhead fordi det ikke er krav om &#229; implementere reducers. Det er mulig &#229; legge til reducers hvis man vil, og dette gj&#248;r recoil mer fleksibelt enn de state managment verkt&#248;yene vi har jobbet med i dette faget. P&#229; den ene siden er det den &#248;yeblikkelige oppfatningen om at dette er et bra bibliotek for &#229; f&#229; noe opp &#229; g&#229; raskt, og passer dermed for mindre prosjekter uten tvil. P&#229; den andre siden kan det da komme opp sp&#248;rsm&#229;l som: skalerer recoil like bra som redux og mobx? redux har mye overhead, men det har ikke mobx, og de skalerer godt begge to. Ut i fra informasjonen p&#229; nettsiden deres ser det ogs&#229; ut som skalerbarhet er et fokus ved at de ser kritisk p&#229; react sine default m&#229;ter &#229; behandle state p&#229; i lys av store komponenthierarkier, som essesilet vil si store applikasjoner.&#160;<\/p><p>&#160;<\/p><p>Recoil har to hovedkonsepter: Atoms og selectors. Atoms er &#34;units of state&#34;, alts&#229; tilstandsvariablene til applikasjonen. Atoms er subscriptable, som vil si at komponneter kan subscribe til et atom for &#229; s&#229; bli automatisk rerenderet n&#229;r atomet endrer seg. Dette minner om &#229; gj&#248;re komponenter observable i mobx, men i recoil fungerer det p&#229; en omvendt m&#229;te. I mobx g&#229;r det fra komponenter til state, mens i recoil g&#229;r det fra state til komponenter. En fordel&#160;med atoms er at de ogs&#229; kan brukes istedenfor react lokal state i komponenter. Selectors er pure functions som tar atoms eller andre selectors som input. Selectors kan bli subscribet til p&#229; samme m&#229;te som atoms, og derfor skiller dette seg litt fra redux sine reducers, som ogs&#229; er pure functions for &#229; komme frem til en lovlig state. Siden selectors kan bli subscribet til medf&#248;rer dette ogs&#229; at n&#229;r selectors blir oppdatert av atoms eller andre selectors re-rendres alle subscribers ogs&#229;. I motsetning til default redux oppf&#248;rsel er selectors i stand til &#229; operere asynkront, og dette skiller seg fra redux som dispatcher actions synkront. Selectors kan ogs&#229; fungere synkront, og dette er enda et argument for at recoil er mer fleksibelt enn det vi har sett p&#229; i dette faget.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting<\/p><p>https://redux.js.org/tutorials/fundamentals/part-6-async-logic<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>https://recoiljs.org/docs/introduction/motivation<\/p><p>https://mobx.js.org/getting-started<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1554,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>GraphQL er et sp&#248;rrespr&#229;k som lar utviklere formulere queries i form av objekter. Dette er mulig ved at utvikleren typedefinerer dataen man skal hente, for &#229; s&#229; skrive et query som bruker disse typene. Dette gj&#248;r grapql til et lett spr&#229;k &#229; jobbe med fordi det er ngen tvil om hva man f&#229;r tilbake som respons. En anne fordel er at man kan spesifisere hvilke fleter man har lyst p&#229; fra en type, og dermed slipper man &#229; hente alle, som gj&#248;r sp&#248;rringene mer effektive og man sparer resurser. Dette er mulig i graphql fordi beskrivelsen av data og hva man kan hente ikke er koblet sammen, i motsetning til en REST-l&#248;sning. I graphql definerer man med et schema hva som er mulig &#229; hente, ikke hva man m&#229; hente. Dette sparer ogs&#229; utvikleren for &#229; skrive logikk som filtrerer bort un&#248;dvendig data.<\/p><p>&#160;<\/p><p>REST st&#229;r for representational state transfer og er en stateless arkitektur for &#229; hente data. Med stateless menes det at man ikke trenger noen tileggsinformasjon enn det som er i responsen fra APIet for &#229; kunne tolke dataen. Henting av data skjer ved &#229; bruke URIs (Uniform Resource Identifiers). Det som er en ulempe med REST er at man alltid f&#229;r tilbake hele resursen, og derfor kan det bli n&#248;dvendig &#229; filtrere bort data man ikke trenger i frontend. Dette er det man kaller for &#34;over fetching&#34;, og&#160;kan v&#230;re en god grunn til &#229; heller velge &#229; bruke graphql. Det som gj&#248;r at REST st&#229;r s&#229; sterkt i dag er at det er en industristandard, og derfor er i bruk i alle store applikasjoner. Dette gj&#248;r at det er et st&#248;rre milj&#248; rundt denne arkitekturen, og derfor vil det v&#230;re lettere &#229; sette seg inn i. Graphql er s&#229;pass nytt at det ikke har den samme brede st&#248;tten som REST n&#229;r det kommer til analyseverkt&#248;y, og dette kan v&#230;re et problem for st&#248;rre applikasjoner. En annen stor forskjell mellom REST og graphql er hvordan man henter data og hvordan data er representert. I REST er data i konseptet&#160;som en resource mens i graphql er data en entity graph. Resultatet av dette er at graphql sine entiteter p&#229; grafen ikke blir identifisert av forskjellige URLer, men heller et enkelt endepunkt for alle sp&#248;rringer. Men p&#229; samme m&#229;te som REST blir http GET og POST anvendt i graphql ogs&#229;.&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;<\/p><p>&#160;<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p><p>https://restfulapi.net/<\/p><p>https://graphql.org/learn/serving-over-http/<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11535171,"ext_inspera_userAssessmentSetupId":7140013,"ext_inspera_userAssessmentId":4841505,"dateLastModified":"2020-12-01T10:01:47Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:47Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Slinde Johanna Sofie (10049)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34115836,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2295,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-applikasjoner er bygd opp av komponenter, og i store applikasjoner er det ofte flere lag med komponenter som gjenbrukes for &#229; spare linjekode. Dette er et av hovedkonseptene i React, og det er ogs&#229; her state og props kommer inn. For &#229; kunne sende data fra en komponent til en annen (child-component), brukes <em>props<\/em> (properties). For &#229; h&#229;ndtere endring av data finnes det ogs&#229; noe som heter <em>state.&#160;<\/em>Hovedforskjellen mellom dem er at props sendes til en komponent, mens state endres inni selve komponenten. Dette gj&#248;r at state brukes for &#229; st&#248;tte&#160;data som endres over tid. For &#229; f&#229; tak i n&#229;v&#230;rende verdi (det som rendres for &#248;yeblikket) for variabelen man er ute etter, kan man dermed skrive this.props og this.state. Hvis man &#248;nsker &#229; oppdatere verdien for den spesifikke variabelen, brukes setState, som tar inn state og returnerer variabelens nye verdi. Eksempelvis hvis man &#248;nsker en variablen som teller nedover kan man skrive f&#248;lgende: return {variabel: state.variabel - 1}. setState som funksjon er asynkron, det vil si at dersom b&#229;de en parent og child komponent kaller setState ved en brukerinteraksjon (f. eks. klikk-event), vil ikke child-komponenten rendres dobbelt. I React er det ogs&#229; mulighet for &#229; endre tilstand p&#229; data oppover i komponenthierarkiet (fra child til parent) ved &#229; benytte seg av call-back-funksjoner.&#160;<\/p><p>&#160;<\/p><p>Dersom man har store mengder data som endres over tid, kan det v&#230;re fordelaktig &#229; benytte seg av en state manager. Ved &#229; bruke en state manager slipper man problematikken ved &#229; sende props igjennom en haug av komponenter som kaller hverandre, noe som kan bli uoversiktelig i store applikasjoner. En state manager har oversikt over dataens n&#229;v&#230;rende verdi, og gj&#248;r det enklere &#229; displaye data for brukeren ved &#229; kunne belage seg p&#229; &#229; bruke &#233;n kilde. Eksempler p&#229; slike state managere er Redux og Mobx, som er av forskjellig kompleksitet. For eksempel vil man i Redux oppbevare&#160;dataen i en enkelt store, og man definerer ulike typer actions som er de eneste m&#229;tene man kan forandre dataen p&#229;. I tillegg har man reducers som forteller hvordan dataen endrer seg i henhold til de tidligere spesifiserte handlingene (actions). Mobx fungerer p&#229; mange av de samme m&#229;tene som Redux, hvor hovedforskjellen er at det finnest minst to stores i Mobx og at states kan endres uten &#229; bruke en spesifikk action. Mobx er mer hensiktsmessig dersom man har sm&#229; applikasjoner, da Redux kan bli i overkant kompleks og kreve mye kode for sm&#229; applikasjoner.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2352,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I f&#248;lge dokumentasjonen er Recoil ogs&#229; et state mangement bibliotek for React (p&#229; lik linje med f eks Redux og MobX som tidligere nevnt).&#160;<\/p><p>&#160;<\/p><p>Recoil benytter seg av atoms (delt state) igjennom selectors (rene funksjoner) ned i React komponenten. Recoil baseres seg p&#229; Context APIet og Ract Hooks, og vil derfor kun fungere for funksjonelle komponeneter. Komponenter kan deretter &#34;abonnere&#34; p&#229; oppdateringer av ulike atoms. Det vil si at dersom en atom blir oppdatert et sted i applikasjonen, vil alle abonnenter bli re-rendret med atomens nye verdi. Alle atomer som opprettes&#160;m&#229; ha en spesifisert n&#248;kkel, som m&#229; v&#230;re unik innad i hele applikasjonen, og en default verdi. For &#229; lese og gj&#248;re endringer p&#229; state kan man benytte seg av useRecoilState.&#160;<\/p><p>&#160;<\/p><p>Sammenlignet med state manager teknologiene nevnt i oppgave 1 (Redux og Mobx), virker Recoil ved f&#248;rste &#248;yekast som en&#160;&#34;enklere&#34; fremgangsm&#229;te for &#229; h&#229;ndtere state i React applikasjoner, og krever dermed mindre&#160;kode. Recoil benytter seg av samme type interface som React sine innebygde funskjoner som gettere og settere. Der hvor Redux inneholder mye kode for &#229; sette opp state h&#229;ndteringen (med actions, reducers og store), kan man med Recoil endre data raskt ved &#229; bruke opprette delte state (atoms) som endres ved funksjoner (selectors) ned i komponenten.&#160;<\/p><p>&#160;<\/p><p>For b&#229;de Redux og Recoil m&#229; man wrappe hele applikasjonen i en provider-komponent. Samtidig er dette nesten det eneste du trenger &#229; gj&#248;re for &#229; benytte deg av Recoil, mens man med Redux m&#229; opprette en store med configureStore(), samt bruke useDispatch() og useSelector() for &#229; kunne dispatche de forh&#229;ndsdefinerte actionene. I Recoil kan man opprette en store/atom ved &#229; bruke atom(), som har selector og dispatch innebygd.&#160;<\/p><p>&#160;<\/p><p>P&#229; en annen side er en av fordelene med Redux at man definerer actions og reducers som gj&#248;r at man har kontroll p&#229; hvordan dataen endrer seg og hvilke endringer man definerer som &#34;lovlige&#34; endringer. Slik jeg har tolket det p&#229; dokumentasjonen til Recoil, har man ikke denne fordelen der, da hver komponent kan definere en selector slik de &#248;nsker, som endrer p&#229; atomet i hele applikasjonen.&#160;<\/p><p>&#160;<\/p><p>P&#229; samme m&#229;te som Redux og Mobx, burde man kartlegge behovet for en state manager f&#248;r man implementere Recoil. Dersom man ikke bruker samme data flere steder i applikasjonen, er det helt klart ikke n&#248;dvendig &#229; implementere det. Det er ogs&#229; mulig &#229; kun implementere Recoil i deler av applikasjonen, og bruke det kun der man har behov for det. Det er verdt &#229; bemerke seg at Recoil fortsatt er under utvikling, og at Redux er et mer etablert bibliotek, noe som kan v&#230;re fordelaktig dersom man velger &#229; benytte seg av Redux i utvikling.&#160;&#160;<\/p><p>&#160;<\/p><p>kilder:&#160;https://www.emgoto.com/redux-vs-recoil/<\/p><p>https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2489,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>B&#229;se REST (Representational State Transfer) API og GraphQL er metoder som brukes for &#229; hente data i design av web-applikasjoner. Videre f&#248;lger den vesentlige forskjellen mellom disse to metodene.<\/p><p>&#160;<\/p><p>Hovedforskjellen mellom dem er at man ved &#229; bruke REST definerer endepunkter som man senere bruker for &#229; skrive og lese data. Endepunkter korresponderer til feltene i databasen man har satt opp/benytter seg av, og kan for eksempel v&#230;re /recipe/name. I REST benytter man seg av URI&#160;og HTTP foresp&#248;rslene som PUT, GET, POST, DELETE etc. for &#229; behandle og gj&#248;re endringer p&#229; datasettet. Fordelen med &#229; bruke REST er at man kan benytte seg av cachingen som st&#248;ttes i nettleseren, alts&#229; at kopier av ofte brukt data lagres flere steder p&#229; veien fra server til klient.<\/p><p>&#160;<\/p><p>I GraphQL gj&#248;res denne fetchingen p&#229; en annen m&#229;te: istedenfor &#229; definere endepunkter, sender man sp&#248;rringer i json etter akkurat det datainnholdet man er ute etter. Og det er dette som er hovedfordelen med GraphQL. N&#229;r man utf&#248;rer kall i REST, vil man hele tiden f&#229; hele datasett i retur. Dette kalles overfetching, og er en av hovedulempene med REST, da det ikke er noen m&#229;te &#229; kun motta et subset av den dataen man mottar, om man skulle &#248;nske det. Dette f&#248;rer ogs&#229; til at REST kan bli et offer for underfetching: dersom et endepunkt ikke inneholder all informasjonen man er ute etter, er man n&#248;dt til &#229; uf&#248;re flere kall til ulike endepunkter.&#160;Her er GraphQL mer annvennelig, da du ved &#229; skrive konkrete sp&#248;rringer, kan f&#229; akkurat den dataen du er ute etter i retur.<\/p><p>&#160;<\/p><p>kilder:&#160;https://medium.com/codingthesmartway-com-blog/rest-vs-graphql-418eac2e3083<\/p><p>https://www.howtographql.com/basics/1-graphql-is-the-better-rest/<\/p><p>&#160;<\/p><p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160; &#160;&#160;<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11535429,"ext_inspera_userAssessmentSetupId":7139940,"ext_inspera_userAssessmentId":4841509,"dateLastModified":"2020-12-01T10:01:47Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:47Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Solbjørg Ingrid Amalie (10121)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35039267,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1532,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React-applikasjoner er avhengige av at man har god dataflyt og kontroll p&#229; tilstand. De to viktigste mekanismene for &#229; holde styr p&#229; dette er props&#160;for dataflyt, og state for tilstand. Implementasjonen av de ulike mekanismene avhenger av applikasjonen, eksempelvis skiller implementasjonen av state i klassekomponenter seg fra i funksjonelle komponenter. I klassekomponenter initialiseres state i konstrukt&#248;ren til komponenten. Deretter endres deler av staten ved hjelp av setState-metoden. Alts&#229; kan man ikke endre staten som ved andre variabler, der man direkte endrer variabelens verdi ved &#229; sette den til en ny verdi. I funksjonelle komponenter brukes hooks, som ble innf&#248;rt i React 16.8. F&#248;r hooks ble introdusert, kunne ikke funksjonelle komponenter holde p&#229; tilstand. N&#229; kan state settes ved &#229; definere en hook med useState-hooken.&#160;En vil da f&#229; en funksjon/hook som kan kalles for &#229; endre den tilh&#248;rende staten.&#160;Utover implementasjonen fungerer state-h&#229;ndtering likt i klassekomponenter og funksjonelle komponenter.<\/p><p>&#160;<\/p><p>En utfordring med tilstandsh&#229;nderingen forklart overfor er at state og hooks kun fungerer inne i den bestemte komponenten. For &#229; kunne implementere global state, som da kan brukes hvor som helst i appen, er det&#160;mulig &#229; bruke tredjepartskomponenter. Redux, Mobx og Context API er noen eksempler p&#229; kjente slike komponenter.<\/p><p>&#160;<\/p><p>For &#229; ha god dataflyt brukes som nevnt props. Props kan sees p&#229; som parametre som sendes med en komponent. Se for deg at du har&#160;en applikasjon med flere like knapper og har laget en egen komponent for denne typen knapp. Da vil eksempler p&#229; props vi sender med til denne knappen v&#230;re tittelen/teksten&#160;p&#229; knappen, hva som skal skje n&#229;r knappen trykkes og id-en til knappen. Vi kan ha alle slags mulige datatyper p&#229; disse propsene, som i eksempelet, der vi har b&#229;de strenger og en funksjon. Props brukes alts&#229; til &#229; koble sammen de ulike komponentene i appen, og fortelle hva som sendes med til neste komponent.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2869,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek for &#229; h&#229;ndtere state-management i React som baserer seg p&#229; atomer og selektorer. Et atom best&#229;r av en key og en default, der key-en sier noe om hva atomet holder staten til og default er den initielle verdien til staten. For &#229; f&#229; staten til et atom eller endre den brukes hooken &#34;useRecoileState&#34;. For &#229; modifisere staten, henter man inn dataen fra&#160;atomet, endrer p&#229; dataen og setter deretter atomets data til den nye dataen ved hjelp av &#229; bruke en hook som setter atomets state til detaen som sendes med. Selektorer kan brukes til &#229; vise frem ulike deler av et atoms state. Det kan eksempelvis brukes til &#229; filtrere ut deler av en state, eller finne ut hvor mange instanser man har av en bestemt ting. Et eksempel p&#229; dette, er at hvis vi har en state med savnede hunder, kan en selektor representere antall hunder som heter &#34;Otto&#34; eller vise alle hunder med dette navnet. For &#229; lage en selektor, lager man et atom med key og default-verdi. Deretter kan dette atomet endres slik at man for eksempel viser alle hundene, istedenfor kun hundene med navn Otto.<\/p><p>&#160;<\/p><p>En fordel med &#229; bruke dette biblioteket i utvikling er at det er eopen-source. Det gj&#248;r at mange kan bidra og forbedre det underveis, samt at det er offisielle ressurser tilgjengelig. Dokumentasjonen er kortfattig og konkret, som er fint med tanke p&#229; at den ikke er overfl&#248;dig. Det som derimot er en ulempe med &#229; bruke et s&#229; lite utbredt bibloitek er at det ikke finnes s&#229; mye hjelp ellers p&#229; nettet, for eksempel dersom man havner i situasjoner som ikke beskrives i den offisielle dokumentasjonen til Recoil.<\/p><p>&#160;<\/p><p>En ting som b&#229;de kan v&#230;re en fordel og en ulempe er at alle komponenter som subscriber til en del av staten re-renderes ved enhver endring i denne. Dette er en fordel dersom man &#248;nsker &#229; oppdatere komponentene ved alle endringer, som n&#229;r du vil se hundene med navn Otto. Dersom du derimot har komponenter som ikke er synlige p&#229; siden, trenger ikke disse &#229; re-rendres for hver endring i staten til atomet.&#160;Denne re-rendringen kan heller komme n&#229;r man trenger &#229; vise frem komponenten.<\/p><p>&#160;<\/p><p>Denne re-rendringen av komponentene er veldig lik hvordan MobX sin observer fungerer. Denne krever ogs&#229; at komponentene som lytter til observables som&#160;endrer seg, re-rendres. Det som er en sl&#229;ende likhet, er at begge kun re-rendrer komponenter som lytter til relevante endringer i state. Alts&#229; re-rendres ikke komponentene p&#229; enhver endring i state, men kun p&#229; de som komponenten er tilknyttet.<\/p><p>&#160;<\/p><p>Recoil ligner litt p&#229; implementasjonen av Redux, der man har reducere som holder rede p&#229; en verdi tilh&#248;rende den bestemte staten. Istedenfor &#229; ha key og default, bruker man derimot navnet p&#229; variabelen i reduceren. Dette gj&#248;r ogs&#229; at man kan ha flere variabler i en reducer i Redux, mens man m&#229; ha et atom for hver state i Recoil. En fordel med &#229; kunne ha flere variabler i en reducer er for eksempel om man &#248;nsker &#229; b&#229;de kontroll p&#229; om en bruker er logget inn og denne brukerens token. Her vil man da trenge flere atomer for &#229; kunne ha tilsvarende state, da et atom holder kontroll p&#229; &#233;n variabel.<\/p><p>&#160;<\/p><p>Bruken av Recoil ligner ogs&#229; p&#229; bruken av Context API. I Context hentes staten ved &#229; referere til navnet p&#229; contexten, og den endres ved &#229; kalle den tilh&#248;rende funksjonen. Dette ligner p&#229; bruken av Recoil, bare at man m&#229; koble seg til Recoil-atomet ved &#229; bruke hooks.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://mobx.js.org/react-integration.html<\/p><p>https://recoiljs.org/<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2755,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er ulike API-teknologier. Sistnevnte ble laget av Facebook i 2012 og ble open-source i 2015, mens REST har eksistert lenge. P&#229; grunn av dette finnes det mange flere ressurser om REST-teknologien enn om GraphQL. Dette er en forskjell som kan p&#229;virke valget av API-teknologi.&#160;<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k som ligner litt p&#229; SQL, der man kan spesifere queries s&#229; mye man vil. Responsen du f&#229;r da er et JSON-objekt med den konkrete dataen du har bedt om. Dette skiller seg fra REST, der du gj&#248;r kall til et endepunkt som returnerer hele datasettet i det endepunktet. Det er vanlig &#229; ha flere endepunkt i REST, der hvert har hver sin oppgave, mens man i GraphQL kun har ett endepunkt. Ulempen med &#229; kun ha ett endepunkt, er at GraphQL alltid responderer med HTTP 200 OK, selv om ikke queriet returnerer noe data. Man vil da f&#229; returnert error-meldingen i JSON-responsen. P&#229; dette punktet er REST bedre, der man med en gang vet om kallet returnerer data eller ikke, med tanke p&#229; HTTP-responsen. I tillegg er fordelen med de ulike endepunktene til REST at det er enklere &#229; forst&#229; og vedlikeholde, siden hvert endepunkt har en oppgave.<\/p><p>&#160;<\/p><p>P&#229; grunn av at REST baserer seg p&#229; &#229; ha flere endepunkter, m&#229; man gj&#248;re flere API-kall dersom man trenger data fra flere av disse endepunktene. I GraphQL slipper man dette, da man kan spesifisere sp&#248;rringene selv om ting ikke h&#248;rer helt sammen. Hvis vi ser p&#229; et eksempel der vi &#248;nsker &#229; f&#229;&#160;fornavnet til en person med etternavn &#34;Hansen&#34;&#160;og utgivelses&#229;ret til filmen &#34;Alene hjemme&#34;. I&#160;REST vil dette antakeligvis kreve&#160;to API-kall, da fornavn og filmer sannsynligvis har to ulike endepunkt, mens vi i GraphQL kun trenger ett kall. Dersom vi trenger enda mer data, og potensielt flere kall i REST, vil vi fortsatt kun holde oss p&#229; det ene i GraphQL. Fordelen&#160;med m&#229;ten GraphQL gj&#248;r dette, utover antall kall, er at responsen er liten og konkret - da den er akkurat det du spurte om. I motsetning, vil REST returnere hele datasett, der man deretter m&#229; finne sin &#248;nsket data. Alts&#229; vil vi slippe store mengder data ved &#229; bruke GraphQL til slike sp&#248;rringer, som igjen vil &#248;ke ytelsen.<\/p><p>&#160;<\/p><p>En annen forskjell mellom REST og GraphQL er at oppsettet er ganske ulikt. REST er enklere &#229; sette seg inn i, og siden man bruker ganske generelle sp&#248;rringer, s&#229; trenger man ikke &#229; kjenne datasettet&#160;inn og ut. Hvis du derimot bruker GraphQL, er det vanskeligere &#229; sette seg inn i, men du f&#229;r mer igjen for det n&#229;r du forst&#229;r teknologien. Hvis man kjenner godt til datasettet og vet hva man &#248;nsker, er GraphQL et&#160;veldig bra valg - siden sp&#248;rringene kan gi deg gode resultater.<\/p><p>&#160;<\/p><p>En siste forskjell er at REST har innebygd caching fra HTTP, som gj&#248;r at man kan slippe unna noe pre-fetching av ressurser. GraphQL m&#229; derimot benytte seg av andre komponenter for &#229; f&#229; tilsvarende muligheter.<\/p><p>&#160;<\/p><p>I de senere &#229;r har REST blitt brukt mest til &#229; lage nye API-er, mens GraphQL hovedsakelig brukes til &#229; optimaliesere ytelsen og fleksibilitetene til API-er. &#197;rsaken til dette er at REST er enklere &#229; sette opp, samt at det er enklere &#229; sette seg inn i. Sp&#248;rrespr&#229;ket GraphQL er brukt til optimalisering siden teknologien gir gode muligheter for sortering, filtrering og s&#248;k.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>https://medium.com/better-programming/full-stack-react-graphql-mongodb-apollo-building-an-app-cb1eb647c73a<\/p><p>https://www.rubrik.com/en/blog/technology/19/11/graphql-vs-rest-apis<\/p>"}]}],"ext_inspera_totalScore":10,"score":10}},{"result":{"sourcedId":11535434,"ext_inspera_userAssessmentSetupId":7140045,"ext_inspera_userAssessmentId":4841439,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:04Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Leithe Jorunn (10097)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34495634,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1371,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>State er tilstanden til en komponent og best&#229;r av interne variabler i komponenten. Man oppdaterer gjerne state i funksjoner i komponenten via setState(). Endring av tilstand f&#248;rer gjerne til ny rendering av komponenten som videre vil f&#248;re til ny rendering av barn av denne komponenten. State er private for komponenten og kontrolleres i helhet av komponenten.<\/p><p>&#160;<\/p><p>Man kan sende data mellom komponenter via props (Properties). Props er dataverdier som gis som input n&#229;r en komponenet opprettes i foreldre-komponenten, og denne dataen kan da benyttes av barne-komponeneten. Props kan ogs&#229; benyttes indirekte til &#229; sende verdier oppover i komponenthierarkiet ved at man sender en callback-funksjon som prop n&#229;r barnet opprettes i forelderen. Da kan barnekomponentene bruke funksjonene de mottar til &#229; sette state p&#229; foreldrekomponent.<\/p><p>&#160;<\/p><p>Man kan ogs&#229; bruke benytte seg av global state management for &#229; ha data&#160;som er tilgjengelig for alle komponenter i applikasjonen. Dette er nyttig om man &#248;nsker &#229; ha samme data tilgjengelig i ulike komponenter som er p&#229; ulike steder i komponenthierarkiet, da man slipper &#229; propagere data gjennom hele hierarkiet for &#229; f&#229; tilgang til den.&#160;N&#229;r global verdi endres vil alle komponenter som benytter verdien automatisk rendres p&#229; nytt. Eksempler p&#229; l&#248;sninger som anvendes for global state management er&#160;Redux, Mobx og Context API.&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":4273,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management bibliotek for React. Recoil tar utgangspunkt i&#160;<em>Atoms&#160;<\/em>og&#160;<em>Selectors<\/em>&#160;som utgj&#248;r&#160;fleksibel delt state. <em>Atoms <\/em>er state-enheter som kan oppdateres og som komponenter kan subscribe til. Komponentene som har subscribet rendrer p&#229; nytt n&#229;r atom-verdien oppdateres.&#160;<em>Selectors<\/em>&#160;er funksjoner som tar atomer eller andre&#160;<em>selectors<\/em>&#160;som input. N&#229;r atom-verdiene oppdateres vil selector-funksjonens input verdi endres, og dermed kan ogs&#229; output-verdien endres. Komponenter kan subcribe til selectors, og dermed oppdateres med output-verdien n&#229;r input-verdien til selectoren er endret.&#160;<\/p><p>&#160;<\/p><p>N&#229;r man skal benytte Redux starter man med &#229; opprette en store som fungerer som global state for applikasjonen. Oppstart med Recoil krever ingen tilsvarende prosess. Videre vil man med Redux opprette reducers, tilsvarende oppretter man atom&#160;i Recoil. I redux benytter man actions for &#229; oppdatere globale verdier, i Recoil bruker man selectors til det samme. For &#229; benytte Redux&#39;en som er satt opp bruker man useSelector og useDispatch hooks som kommer med react-redux og wrapper applikasjonen til store via Provider fra redux. For &#229; benytte recoil vil man benytte useRecoilValue og UseRecoilState fra recoil-biblioteket. Her fungerer UseRecoilState som useState som man er vant til fra react, bare at man n&#229; benytter Recoil og f&#229;r det som global state. Man wrapper applikasjonen i RecoilRoot for &#229; benytte Recoil i applikasjonen.<\/p><p>Man ser at Redux og Recoil har mange tilsvarende steg i prosessen for &#229; kunne bruke det, men recoil har noe f&#230;rre steg, samt at de ofte krever f&#230;rre linjer kode, blandt annet fordi man kan kun opprette enkle atomer med key og initiell verdi, som h&#248;rer sammen med en selector. I redux m&#229; man f&#229;r &#229; f&#229; samme resultat opprette en reducer og en action, og her er det en del kode som m&#229; skrives for &#229; f&#229; det til &#229; fungere, men mye av koden er ofte lik mellom ulike reducers og ulike actions. Det ser ut til &#229; v&#230;re vesentlig mindre gjentagende kode som er n&#248;dvendig for &#229; opprette selectors og atomer i recoil.&#160;<\/p><p>&#160;<\/p><p>I motsetning til Recoil s&#229; kan Context&#160;kun lagre &#233;n enkelt verdi (per provider), ikke et uendelig sett av verdier som hver brukes av ulike komponenter. Man har i context ikke mulighet til at en komponent subscriber til kun deler av dataen som er lagret, det kan man i recoil, ved &#229; for eksempel kun subscribe til det atomet eller den selectoren som er aktuell for komponenten.&#160;I context vil man&#160; m&#229;tte ha &#233;n provider per verdi man skal lagre, problemene oppst&#229;r da n&#229;r antall verdier man skal lagre globalt avhenger av brukerinteraksjon, og man vil m&#229;tte legge til providers underveis ved &#229; legge til det til &#248;verst i komponent-hierarkiet. Recoil h&#229;ndterer dette p&#229; en bedre m&#229;te ved at man kun trenger &#229; opprette et nytt atom.<\/p><p>Context ble ikke bygd for eller optimalisert for h&#248;y-frekvens oppdateringer, slik recoil er. Denne ulempen med context g&#229;r ogs&#229; utover kj&#248;retiden til redux, da redux benytter context.<\/p><p>&#160;<\/p><p>Det er tydelig at det er flere fordeler med recoil. Recoil fremst&#229;r intuitivt med relativt forst&#229;elige konsepter som atomer og selectors.&#160;Recoil er relativt enkelt &#229; sette opp i forhold til tilsvarende bibliotek (redux).&#160;Recoil har hooks som st&#248;tter App-wide state observation, alts&#229; mulighet til &#229; lytte til &#229; lagre alle verdier i den felles staten til en hver tid. Dette kan s&#230;rlig v&#230;re praktisk med tanke p&#229; debuging og utvikling.&#160;Recoil har ogs&#229; generelt lavere kj&#248;retid enn andre tilsvarende bibliotek som bygger p&#229; context.<\/p><p>&#160;<\/p><p>Det er ogs&#229; noen ulemper med Recoil. En ulempe er at recoil kun fungerer for funksjonelle komponenter, noe som kommer av at det er basert p&#229; react hooks. Noe annet man kan se for seg at er en ulempe med recoil er at det er relativt nytt, s&#229; det eksisterer f&#230;rre tutorials og guider for det p&#229; nett enn det som finnes for f.eks. redux og MobX. Det er ogs&#229; f&#230;rre debuging-verkt&#248;y utviklet for recoil.&#160;I tillegg er det deler av recoil, eks. Atom Effects, som fortsatt er under utvikling.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1532,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ved bruk av REST definerer man et eller flere endepunkt for &#229; lese, skrive eller endre p&#229; data via URI, og man benytter HTTP-foresp&#248;rsler som GET, POST og DELETE.&#160;&#160;I graphQL sender man derimot kun en query til GraphQL-serveren som inkluderer konkrete data-requirements, s&#229; man har ikke ulike endepunkter for ulik data slik som med&#160;REST.&#160;<\/p><p>&#160;<\/p><p>I REST defineres hva som skal returenres eller oppdateres per endepunkt p&#229; server-siden, i GraphQL defineres hvilke data som skal returneres eller oppdateres i querrien som sendes fra klientsiden. Formen p&#229; sp&#248;rringen/querriet i GraphQL blir gjenspeilet i responsen, og p&#229; den m&#229;ten kan man p&#229; klientsiden definere hvordan man &#248;nsker at dataen man mottar skal v&#230;re utformet. Ved &#229; implementere REST er det da en mulighet at man ender opp med &#229; hente mer data enn man trenger (overfetching), fordi man ikke trenger all dataen endepunktet er satt til &#229; levere, eller man kan m&#229;tte gj&#248;re mange kall for &#229; hente dataen man trenger, fordi ingen endepunkt returnerer n&#248;yaktig den dataen man er interessert i. Dette slipper man i GraphQL, da man i hver sp&#248;rring spesifiserer hva som skal returneres.<\/p><p>&#160;<\/p><p>N&#229;r REST benyttes kan man automatisk dra fordel av caching-mekanismen som st&#248;ttes default av de fleste nettlesere. Med GraphQL kan man ikke benytte denne caching-mekanismen<\/p><p>&#160;<\/p><p>GraphQL st&#248;tter kun JSON-data, mens REST st&#248;tter flere type data, blandt annet JSON, XML og&#160;YAML.<\/p><p>&#160;<\/p><p>GraphQL har ogs&#229; et typesystem som gj&#248;r det mulig &#229; validere, det har ikke REST.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11538420,"ext_inspera_userAssessmentSetupId":7140117,"ext_inspera_userAssessmentId":4841517,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:09Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Døvle Siw (10222)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34519881,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1417,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I react er det innebygd mekanise for state og props som blir brukt til dataflyt. Iforhold til funksjonelle komponenter brukes hooks for &#229; behandle state, via useState hooken. Denne gj&#248;r at man kan definere en lokal state som finnes i den komponenten. React arkitekturen er orndet i et komponent hierarki,&#160;om en komponent under en annen skal ha tak i staten eller en verdi som finnes i komponenten over m&#229; den sendes via props. Dette fungerer godt for mindre applikasjoner, men n&#229;r applikasjonen skalerer kan det bli mange niv&#229;er i hierarkiet. Og f&#229;r at en komponent nederst i hierarkiet skal f&#229; en tak i en state som tilh&#248;rer en av de &#248;verste komponentene&#160;m&#229; den sendes via mange komponenter som kan bli uoversiktelig og f&#248;re til mye redudant kode. Det samme gjelder om en komponent under en annen skal gj&#248;re en endring p&#229; staten i foreldre komponenten. Da m&#229; det foreldre komponenten sende nedover&#160;en callback funksjon via props, slik at komponenten under&#160;kan gj&#248;re endringer p&#229; staten i foreldre komponenten.&#160;<\/p><p>&#160;<\/p><p>Derfor finnes det ulike tredjepartsbiblotek en kan ta i bruk for &#229; l&#248;se dette problemet. React har ogs&#229; en egen innebygd funksjonalitet kalt Context som kan l&#248;se dette problemet med &#229; deklarere&#160;en provider rundt &#34;App&#34;, den &#248;vrste komponenten i hierarkiet. P&#229; denne m&#229;ten kan andre komponenter f&#229; tak i&#160;state som ellers m&#229;tte blitt sendt gjennom mange komponenter.<\/p><p>&#160;<\/p><p>Blir applikasjonen stor skalerer ikke Context like godt som andre alternativer deriblant Mobx og Redux. Redux fungerer slik at man har en store hvor all state lagres og har p&#229; samme m&#229;te som Context en provider rundt den &#248;verste komponentne.&#160;Da kan man hente ut informasjon fra denne storen i alle komponenter ved bruk av useSelector hooken. En kan ogs&#229; endre staten fra alle komponenter uten bruk av callback funksjoner. For &#229; gj&#248;re endringer i storen m&#229; man bruke hooken useDispatch for &#229; kalle en action som igjen kaller en reducer som gj&#248;r endringer i storen. Dette kan igjen bli overfl&#248;dig mye kode i en liten applikasjon og man m&#229; vurdere nytten mot kostnaden.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3062,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state managment biblotek som l&#248;ser det som de fleste andre state mangaement biblotek l&#248;ser, nemlig global state. Men Recoil har mindre som m&#229; settes opp i motsetning til Redux og vil f&#248;les mer som &#229; skrive vanlig React kode. Detter fordi Recoil er laget med tanke p&#229; React og fungerer ikke til andre rammeverk.&#160;Recoil bruker to hovedkonsepter, nemlig atoms og selectors.<\/p><p>Atoms er som state&#160;og kan brukes p&#229; samme m&#229;te som React sin egen lokal state. Men en fordel er at flere komponenter kan dele den samme staten og n&#229;r staten oppdateres s&#229; rerenderes alle komponentene som har tilknyttning til denne.&#160;<\/p><p>Selector derimot er funksjoner som tar atoms eller andre selectors som input. Selectors kan ogs&#229; brukes til&#160;dervied data som vil si data som er sendt som props.&#160;Selectors oppdaterer en eller&#160;flere atom states enten synkront eller asynkront.&#160;<\/p><p>&#160;<\/p><p>Imotsetning til Redux som krever mer oppsett for &#229; fungere og dermed mer komlisert og sette seg inn i vil Recoil v&#230;re mer likt React. For eksempel bytte useState hooken ut med useRecoilState og kan da brukes p&#229; samme m&#229;te. Istenfor som i React hvor man lager egne filer som inneholder actions og&#160;action-creators.<\/p><p>&#160;<\/p><p>B&#229;de Recoil og Redux bruker en provider rundt den &#248;verste komponenten for &#229; dele state mellom alle komponentene.&#160;<\/p><p>En ulempe med alle state management biblotek som l&#248;fter state ut fra lokalt til globalt er un&#248;dvendig med renders, hvis man for eksempel har mange komponenter under&#160;en container kan det f&#248;re til at mye blir rerenderet uten grunn.&#160;<\/p><p>Derfor er det vitkig og vurdere om man trenger &#229; bruke et state management biblotek og om man trenger &#229; bruke det for hele applikasjonen, det kan begrenses til &#229; brukes kun der det er n&#248;dvendig og ellers bruke lokal state.&#160;<\/p><p>&#160;<\/p><p>Imotsetning til Redux kommer ogs&#229; Recoil med mulighet for&#160;asynkron data uten bruk av tredjeparst biblotek som redux-thunk.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2686,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST er den mest utbredte formen for API, men blir mer og mer utfordret av andre m&#229;ter &#229; l&#248;se problematikken p&#229;, deriblant Graphql.<\/p><p>&#160;<\/p><p>REST baserer seg p&#229; mange ulike endepunkt som vil returenre ulik informasjon. Her brukes enten URI eller de ulike HTTP foresp&#248;rslene GET, PUT, POST, DELETE for &#229; lese, endre, opprette eller slette ressurser. En mulig ulempe med REST er at n&#229;r man &#248;nsker informasjon fra flere endepunkter er det fort at at man henter mer data enn det man trenger. Dette er et velkjent problem kalt overfetching. P&#229; den andre siden kan man ogs&#229; oppleve underfetching som vil si at man ikke f&#229;r all den informasjonen man er ute etter og m&#229; gj&#248;re kall til flere endepunkt.&#160;<\/p><p>Dette l&#248;ser graphql p&#229; en gunstig m&#229;te ved kun &#229; ha et endepunkt hvor man spesifiserer i queries akkurat den informasjonen man er ute etter. Ved &#229; skrive sp&#248;rringer hvor man definerer b&#229;de s&#248;k og hivlke data som skal returneres&#160;slipper man unna b&#229;de under- og overfetching.&#160;<\/p><p>&#160;<\/p><p>REST har en caching mekanisme som default st&#248;ttes av alle nettlesere, slik at man ikke trenger &#229; gj&#248;re samme kall flere ganger men heller henter ut informasjonen fra cachen. Dette &#248;ker ytelsen til applikasjonen og reduserer belastningen p&#229; serveren.&#160;Graphql har ikke en slik implisitt caching i HTTP-lage og for &#229; f&#229; til dette i Graphql m&#229; man kominere det med andre teknologier som for eksempel Apollo. Da kan man bruke InMemoryCache funksjon som kan brukes som cache.<\/p><p>&#160;<\/p><p>REST st&#248;tter ulike formater&#160;for data som ren tekst, XML, HTML og JSON, mens graphql kun st&#248;tter JSON-data.&#160;<\/p><p>&#160;<\/p><p>Koblingen mellom klient og tjener er ofte mye tettere ved bruk av graphql, dette er ettersom graphql bruker&#160;skjema som definerer struktur og typer. Samtidig har begge fokus p&#229; &#229; separere klient og tjener slik at implementeringen av de kan gj&#248;res uten at klient og tjener vet om hverandre.&#160;<\/p><p>&#160;<\/p><p>Graphql er et sterkt typet som gj&#248;r at det fungerer godt sammen med typescript.&#160;Man definerer et schema hvor alle typene er beskrevet og strukturen p&#229; dataen. Dette typesystemet bidrar for eksempel til validering, blant annet ved &#229; validere at queries er godkjent slik at man lettere kan vite om noe er feil.&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11537010,"ext_inspera_userAssessmentSetupId":7140030,"ext_inspera_userAssessmentId":4841428,"dateLastModified":"2020-12-01T10:01:42Z","ext_inspera_startTime":"2020-12-01T08:00:05Z","ext_inspera_endTime":"2020-12-01T10:01:42Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Rikheim Andreas Saltom (10203)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35443799,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2412,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Statemanagment og datafly har lenge v&#230;rt en utfordring i React-applikasjoner, spesielt n&#229;r applikasjonene blir litt st&#248;rre og mer oversiktilig. Idag har man Context som innebygde statemanagament, men dette er ikke alltid man f&#248;lter dette er tilstrekklig som gj&#248;r at mange benytter seg av eksterne bibliotker som redxu og mobex for &#229; h&#229;ndtere states. Det disse hovedasklig tilbyr er et global-state-system som gj&#248;r det mulig &#229; for ulike komponenter i appen &#229; benytte seg av samme states. Der states kun er lokale g&#229;r det helt fint an &#229; bruke det eksisterende l&#248;sningenen for lokal komponent-state.<\/p><p>&#160;<\/p><p>Det finnes ogs&#229; ulike teknikker og metoder som ikke inneb&#230;rer disse statemanagementene for tilstand og dataflyt, disse kan v&#230;re litt tungvinte og lett &#229; gj&#248;re feil n&#229;r det blir store apper, men for sm&#229; og enkle apper kan disse fungere. Et godt eksempel p&#229; dette er prop-drilling. Her sender du props fra parent til children, og s&#229; til deres children igjen osv. Helt til alle som trenger dem, noen ganger m&#229; man sende props via funksjoner som i utgansgpunktet ikke trenger dem selv, men deres barn igjen trenger dem. Fordelen med denne l&#248;sningen er at det er lett &#229; se hvor data blir inialisert, oppdatert og brukt. Andre&#160;alternativer for dataflyt&#160;kan v&#230;re Render Props eller&#160;Component Composition.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2157,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nytt statemanagment bibliotek. Recoil benytter noe de kaller for Atoms som enheter for state, disse kan du oppdatere og det er mulig for komponenter &#229; lytte p&#229; disse slik at de kan gj&#248;re endringer n&#229;r Atoms oppdateres. Dette gj&#248;r det altsp mulig &#229; dele state mellom komponenter ved at flere kompontener bruker samme Atom. Vi har ogs&#229; noe som kalles Selectors, dette er funksjoner som tar inn Atoms eller andre selektorer som innput. Komponenter kan ogs&#229; lytte p&#229; Selectors.&#160;<\/p><p>&#160;<\/p><p>Context er Reacts innebygde statemanagement l&#248;sning. I context er den eneste m&#229;ten &#229; dele state p&#229; ved&#160; &#229; pushe oppover i treet til en &#34;common-ancestor&#34;, men dette kan igjen f&#248;re til at store deler trenger &#229; rerendres. I recoil vil state endringer g&#229; fra atoms til selectors og til komponentene som lytter p&#229; disse. En annen fordel er at Recoil tillater &#229; lagre store sett med verdier som har ulike komponenter som kan lytte p&#229; flere verdier, mens context s&#229; kan hver komponent kun lytte til en context.&#160;<\/p><p>&#160;<\/p><p>Redux er et popul&#230;rt statemanagement bibliotek som min gruppe benyttet seg av under prosjekt 3 og 4. For &#229; lage en delt state i redux vil du f&#248;rst m&#229;tte lage en store og s&#229; en reducer. I recoil virker det som du slipper &#229; lage noen store, og at du lager en atom for &#229; dele state. I redux vil du lage actions som gj&#248;res ved hjelp av dispatch metoden for &#229; oppdatere states, i recoil vil du bruke selectors til &#229; gj&#248;re det samme. I redux vil du benytte deg av&#160; useSelctor og useDispatch for &#229; hente og oppdater states og i recoil vil du gj&#248;re det samme ved hjelp av useRecoilValue og useRecoilState. For at dette skal fungere m&#229; du wrappe alt i henholdsvis reduxprovider og recoilroot. Disse kan se veldig like ut, men recoil har noen forbedringer fra redux, ved recoil slipper du&#160;stores og at hele komponent treet m&#229; rerendres, takket v&#230;re data-flyt grafen fra atoms til selectors og komponentene.<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilde brukt:&#160;https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2385,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST API har lenge v&#230;rt ansett som &#34;best practice&#34; n&#229;r det kommer til web-api. REST api setter opp ulike endepunkter(ressurser) som har en egen unik URI. Her kan man sende ulike requests, feks POST, PUT, GET etc&#160;for &#229; hente, endre, legge til data og mye mer. Ved bruk av REST er det ingen tilstand, den er alts&#229; stateless.<\/p><p>&#160;<\/p><p>GraphQL er ett nyere sp&#248;rrespr&#229;k for API, og er av de fleste ansett som den store utfordreren til REST. GraphQL har en ganske annerledes tiln&#230;rming, her anser de nemlig alt som en stor graf som vil si at det kun er ett endepunkt, som igjen har mange &#34;noder&#34; som i en graf.<\/p><p>&#160;<\/p><p>En av fordelene med GraphQL er at ettersom alt er koblet sammen kan du hente akkurat den dataen du trenger med en sp&#248;rring, mens med REST kan du m&#229;tte g&#229; flere runder til ulike endepunkter f&#248;r du har all dataen du trenger. Med REST har du alts&#229; problemer&#160;med under/overfetching som du unng&#229;r med GraphQL. Du f&#229;r akkurat det du trenger p&#229; en sp&#248;rring, ikke for mye og du m&#229; ikke gj&#248;re flere kall.&#160;En fordel med REST er at den st&#248;tter flere formater, feks JSON, html og vanlig tekst, mens GraphQL kun st&#248;tter JSON. Dette gj&#248;r at REST har litt bredre funksjonalitet.&#160;GrapQL har heller ikke noen&#160;innebygde caching muligheter som du har i REST apiet. Dette gj&#248;r at du slipper &#229; gj&#248;re samme kall mange ganger ved REST api, ettersom det lagres hvis det brukes ofte. En annen forskjell er at Rest har noen mer sikkherhets vennlig l&#248;sninger, feks ved bruk av ulike&#160;autentiseringsmetoder som feks http autentisering hvor sensitiv data sendes i header. Det er mulig &#229; lage trygge l&#248;sninger for GraphQL , men dette kan krever ekstra kode. Det er ogs&#229; lettere &#229; oppdage feil ved REST ettersom den bruker HTTP status koder for &#229; identifisere feil, noe som ikke er like lett med GraphQL.<\/p><p>&#160;<\/p><p>Alt i alt kan man si at GraphQL&#160;er litt mer fleksibelt og raskere, men at REST som er mer etablert er en tryggere og mer stabil l&#248;sning.&#160;<\/p><p>&#160;<\/p><p>Kilde:&#160;https://blog.api.rakuten.net/graphql-vs-rest/<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11538267,"ext_inspera_userAssessmentSetupId":7139938,"ext_inspera_userAssessmentId":4841387,"dateLastModified":"2020-12-01T10:01:39Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:39Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Chan Tommy (10226)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331421,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3609,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>All react applications revolve&#160;around the idea of components. These components are building blocks that allow the programmer to easily manipulate, remove, or replace&#160;elements in the application. They typically have &#34;states&#34; in itself (functional components do not need it to function) to hold data that gets used by the component. When the state changes via setState(), it rerenders the whole component, thus making the app highly reactionary, hence the name React.<\/p><p>Component works in a hierarchical&#160;manner where components are nested within another component, but since&#160;&#34;states&#34; shouldn&#39;t be modified by other components other than itself, &#34;props&#34; are used. Child components can receive data via &#34;props&#34; that passed down from the parent component.<\/p><p>Although it is best practice to have a centralized upper component that controls all the children and grandchildren, sometimes data has to be sent upward. This can be done via context API, which creates a sort of global data that can be accessed anywhere down the hierarchy.<\/p><p>Redux is another way to link data between components. This is done using reducers and store data in a global store. This data is reactionary meaning that any component using the data rerenders itself if the data get modified, just like &#34;state&#34;.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2022,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil is a state management library for react applications. The traditional redux approach consists of some disadvantages and recoil was created&#160;to solve these issues.<\/p><p>Mainly, Recoil tries to simplify the process redux needs to create, link,&#160;and store. Here Recoil uses atoms and selectors to link the different components, these act&#160;like the reducers and selectors in redux. The difference here is how much simpler the code is made. With Recoil you don&#39;t need to create a store and the code for atom is far shorter. Actions are more logically created in the atom itself instead of a stand-alone function in redux. This makes Recoil more friendly to new learners.<\/p><p>Overall, Recoil is still new, but it holds a lot of potential. With Facebook backing it, I can see it start growing in popularity.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1344,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Both REST API and GraphQL are both services that handle request to and from the client. There many differences between the two and here are some discussed.<\/p><p>&#160;<\/p><p>REST API as opposed to GraphQL used endpoints to access data from the servers. This allow for flexibility and readability. These endpoints can be accessed anywhere with a url.<\/p><p>&#160;<\/p><p>GraphQL, on the other hand, only have one endpoint and access the data defined by a JSON object. Due to this, GraphQL is highly specific in what data gets fetched and what does not, which avoids ovefetching or underfetching.<\/p><p>&#160;<\/p><p>With REST API it is far more harder to get and only get a specific data from the server as it has to be predefined.<\/p><p>&#160;<\/p><p>Due to the nature of REST API http requests, it is possible to be cached and indexed. While GraphQL can&#8217;t do the same.<\/p><p>&#160;<\/p><p>REST API is general easier to use and thus more widely taught in schools.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}},{"result":{"sourcedId":11540608,"ext_inspera_userAssessmentSetupId":7140025,"ext_inspera_userAssessmentId":4841514,"dateLastModified":"2020-12-01T10:01:47Z","ext_inspera_startTime":"2020-12-01T08:00:13Z","ext_inspera_endTime":"2020-12-01T10:01:47Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Grimstad Solveig Bergan (10019)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35325714,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2663,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>Ofte trenger vi &#229; sende data til forskjellige komponenter. Dette gj&#248;re ofte med props som st&#229;r for Properties. Dette er data som blir gitt en input n&#229;r komponentene oprettes eller kalles.&#160;Da kan vi sende data nedover i hierkiet fra en &#39;parent&#39; til en &#39;child&#39;. Da som kommer fra en &#39;parent&#39; kan ikke bli forndret av &#39;children&#39;, da sier vi at props er immutable.<\/p><p>&#160;<\/p><p>Det &#229; sende data nedover i hierkiet gj&#248;r at det kan v&#230;re flere komponenter som mottar denne dataen uten &#229; ha bruk for den, og m&#229; derfor store und&#248;vendig states. Hvis en komponenet trenger data fra en annen komponent, men de ligger i to helt forskjellige plasser i hierkiet m&#229; man da&#160;l&#248;fte statsene fra de respektive komponetne&#160;opp til&#160;app komponenten. M&#229;ten &#229; unng&#229; dette p&#229; er &#229; bruke &#39;gobal states&#39; for alle komponentene. Teknikker for dette er Redux, context og MobX.&#160;<\/p><p>&#160;<\/p><p>Med Redux trenger du &#229; implementere actions, store, og reducers.&#160;Redux har mye boilerplate i motsetning til MobX som ogs&#229; har flere stores en Redux.<\/p><p>En annen teknikk for &#229; sende data gjennom komponentene i treet&#160;er context. Context er vanskelig &#229; vedlikeholde i komplekse programmer. Her vil Redux v&#230;re en fordel. N&#229;r man f&#248;rst har implementert alt som trengs for Redux blir det gitt stor nytte ut av Redux. S&#229; jo st&#248;rre prosjektet er, jo mer verdt det er det &#229; implementere Redux. Dermed vil Redux v&#230;re mye jobb for mindre prosjekter.&#160;<\/p><p>Context er heller ikke designet for rask endring av data. For dette vil Mobx v&#230;re et bedre alternativ, da det er lett &#229; forandre staten med nye verdier. P&#229; grunn av uforutsett output kan det bli vanskeligere &#229; debugge og teste med MobX. Her vil redux v&#230;re mer forutsigbar og gj&#248;r redux lettere &#229; teste/debugge.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>I React har vi ogs&#229; Hooks som man kan bruke utenfor klassene. Eksempler p&#229; hooks er&#160;useState og useEffect. Hooks gir deg funksjonalitet som en erstatning for det en trenger class til.&#160; UseEffect lar deg bruke effekten fra en funksjonenskomponent. &#34;N&#229;r dette skjer, gj&#248;r dette&#34;. N&#229;r du kaller useEffect kj&#248;rer du din &#39;effekt&#39; etter React har &#39;flushet &#39; DOMet.&#160;Vi&#160;har ogs&#229; state som er interne variabler i komponenten. Disse kan settes med SetState(). N&#229;r man endrer state vil ofte komponenten og barna, rendre p&#229; nytt.&#160;<\/p><p>Dette er to eksempler p&#229; hooks som er blitt mye brukt i l&#248;pet av faget.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2570,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Ved &#229; bruke tredjepartskomponenter kan spare mye tid. Recoil er et &#39;state managment&#39; system for React. Ved &#229; ta i bruk Recoil kan man f&#229; raske og felksible tilstander. Recoil har s&#248;tte for dataflyt og &#39;cross-app observation&#39;, den observerer alle tilstandsendringene i appen din. Dette kan sammenlignes med Redux, MobX og Context som ogs&#229; handler om state-management.&#160; I Recoil bruker man atoms og selectors i motsetning til Redux som har en store, actions og reducers. Og Context som har provider og consumer, og MobX som har flere stores. Context kan bare lagre en enkelt verdi, ikke et uendelig sett med verier med sine egne forbrukere som recoil kan.&#160; Med recoil f&#229;r man ogs&#229; en boilerplate-fre API i motsetning til de andre bibliotekene, spesielt redux&#160;(fra recoils dokumentasjon). N&#229;r context oppdaterer oppdateres hele siden, dette kan skje med redux ogs&#229;. dette ung&#229;r vi med recoil fordi kun de komponenten som abonerer p&#229; atomet rendres n&#229;r atomet oppdateres.<\/p><p>&#160;<\/p><p>Recoil gj&#248;r state management lettere &#229; h&#229;ndtere. Med recoil kan du lage dataflytgrafer som flyter fra &#39;atoms&#39; gjennom &#39;selectors&#39; og ned i&#160;React-komponentene dine. Atomet er tilstandsenheter lar oss lage et stykke data som brukes i stedet for react sin loakle komponentstate. Hvis det samme atomet brukes fra flere komponenter, deler disse komponentene tilstanden. Hvis det da oppdaterers, oppdateres det i alle komponentene som bruker det. Atomer kan ogs&#229; opprettes ved kj&#248;retid.&#160;<\/p><p>&#160;<\/p><p>Selectorene er funksjoner som tar inn atomene eller andre selectors som input og forandrer staten asyn eller sync. Komponenter kan &#39;abonnere&#39; p&#229; selectors og p&#229; atomer. De kan bli bruk ttil &#229; kalkulere data som er basert p&#229; en tilstand.&#160;<\/p><p>&#160;<\/p><p>En positiv ting med &#229; ta i bruk recoil er mindre konfigurasjon og trenger mindre setup f&#248;r man tar det i bruk. En annen ting kan v&#230;re de delte &#39;atomene&#39; hvor kompenetene deler states som recoil effetkiv og konsistent. Kun de&#160;komponenten som abonerer p&#229; atomet rendres n&#229;r atomet oppdateres.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>https://haodev.wordpress.com/2020/07/15/recoil-better-or-worse/<\/p><p>https://recoiljs.org/docs/introduction/getting-started<\/p><p>https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1947,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>&#160;<\/p><p>Graphql har et endepunkt og f&#229;r tak i data gjennom sp&#248;rringer med query. Da sender du&#160; hvilket data som skal returneres eller oppdateres til en server hvor du har definert s&#248;ket ditt. Ved hjelp av dette unng&#229;r du &#229; laste for mye data (overfetching), og alt hentes i en request. Dette er ofte en fordel da man f&#229;r mindre kode som er konsis, og gjennom sp&#248;rringene f&#229;r vi definert akkurat hvilken data vi er ute etter. Det kan og bli en tettere kobling mellom serveren og klient<\/p><p>&#160;<\/p><p>I REST kan vi et eller flere endepunkter for &#229; lese, skrive eller endre p&#229; dataten/entitetene. Til dette bruker vi PUT, GET, POST.. I REST trenger vi ofte flere kall for &#229; hente den eksakte daten som trengs( dette kan skje ved flere endepunkt), og det hentes kanskje mer data en det man trenger. Dette heter overfetching og kan v&#230;re en ulempe i REST som Graphql l&#248;ser med sine sp&#248;rringer. Men dette kan ogs&#229; v&#230;re hensiktsmessig dersom man trenger mye informasjon.<\/p><p>&#160;<\/p><p>Caching mekanismen er ogs&#229; en forskjell mellom REST og Graph. GraphQL f&#248;lger ikke HTTP-spesifikasjonen for caching og bruker i stedet et enkelt endepunkt. Dermed er det opp til utvikleren &#229; sikre at caching implementeres riktig, dette f&#248;rer til mer kompleks jobb for server utviklere. Graphql st&#248;tter ogs&#229; kun JSON-data. Men REST drar fordel av caching-mekanismen som default st&#248;ttes av&#160;alle nettlesere. REST er ogs&#229; stateless, som betyr at klinetenes foresp&#248;rsel ikke skal bli husket av tjener.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11540918,"ext_inspera_userAssessmentSetupId":7139992,"ext_inspera_userAssessmentId":4841499,"dateLastModified":"2020-12-01T10:01:46Z","ext_inspera_startTime":"2020-12-01T08:00:17Z","ext_inspera_endTime":"2020-12-01T10:01:46Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Drange Markus Mangersnes (10061)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":44842921,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2086,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>For den interne tilstanden i en komponent bruker man i dag ofte hooks, feks useState for &#229; sette tilstand. Dette erstatter syntaxen knyttet til klasser der man trenger en konstrukt&#248;r.&#160;<\/p><p>&#160;<\/p><p>React har oprinnelig kun en enkel vei for &#229; sende states mellom komponenter. Dette er fra parent-komponenten til child-komponenten.<\/p><p>&#160;<\/p><p>Dette har dog sine begrensninger og kan f&#248;re til det som kalles prop-drilling, der en m&#229; gjennom mange lag med komponenter for &#229; hente ut relevant state til en annen komponent et annet sted i komponenttreet.<\/p><p>&#160;<\/p><p>Derfor finnes det en rekke andre m&#229;ter &#229; h&#229;ndtere dette p&#229;:<\/p><p>&#160;<\/p><p><strong>Context<\/strong><\/p><p>For context opprettes en provider som blir, som navnet tilsier, det som fors&#248;rger andre komponenter med states. Det vil si at en kan sende states fra en komponent til contexten, som vil kunne gi denne staten til alle komponenter som er omfattet av provideren. Dette er kanskje den enkleste m&#229;ten &#229; unng&#229; parent-child-begrensningen, men til gjengjeld vil alle komponenter som er avhengig av en verdi i contexten bli oppdatert hver gang noe endres i contexten (selv om endringen skjer i en verdi som ikke er relevant) og det egner seg derfor d&#229;rlig om det skal brukes omfattende og med states som endres hyppig.<\/p><p>&#160;<\/p><p><strong>Redux<\/strong><\/p><p>Redux er en annen m&#229;te &#229; lagre states globalt p&#229;. I Redux opprettes en store som er der de valgte statesene lagres. Videre opretter man et sett med actions som er de handlingene en vil &#248;nske &#229; utf&#248;re p&#229; statesene. Deretter har en det som kalles reducers, som etter hvilken action som har blitt kalt utf&#248;rer operasjonen p&#229; statsene i storen. N&#229;r dette er gjort vil verdiene oppdateres overalt de brukes i UIen.<\/p><p>&#160;<\/p><p>Redux er egnet for store prosjekter og har sv&#230;rt mye funksjonalitet. Konsekvensen av dette er at det kan v&#230;re komplisert &#229; jobbe med og krever mye s&#229;kalt boilerplate-kode som er kode som m&#229; v&#230;re med.<\/p><p>&#160;<\/p><p><strong>Mobx<\/strong><\/p><p>Som en slags l&#248;sning p&#229; Redux sin noe kompliserte syntax har Mobx kommet som alternativ. I Mobx opererer man med states som obervables, og n&#229;r det gj&#248;res en action p&#229; en observable (state endres) endres alle stedene der denne staten er brukt (en har s&#229;kalte observers som er komponentene som lytter). Mobx er betraktet som et enklere alternativ enn Redux, men har ogs&#229; mindre funskjonalitet og er mindre skalerbart. Mobx egner seg derfor ikke i st&#248;rre prosjekter.<\/p><p><br />&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2890,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et ganske nytt alternativ til state handling p&#229; tvers av komponenter (men kan og brukes internt i &#233;n komponent). Recoil ligner i funskjonalitet mye p&#229; Redux og Mobx, men mens disse to introduserer sin egen syntax, er Recoil mye likere det en vil finne i klassisk React. Recoil er derfor &#229; betrakte som lettere &#229; bruke enn selv Mobx som har enkelhet som sitt sterkeste argument. For Recoil wrappes den delen av applikasjonen du vil at skal ha tilgang til statesene i RecoilRoot, og det vil etter det v&#230;re mulig for alle komponentene under i treet &#229; n&#229; disse. Recoil vil ikke p&#229; samme m&#229;te som Redux opprette en separat store.<\/p><p>&#160;<\/p><p>Recoil fungerer ved at en oppretter &#34;atoms&#34; som representerer states, med en spesifikk key og en default value. Deretter kan man med funksjoner som useRecoilState utf&#248;re operasjoner. Her ser man likheten med den standard hooken useState, og funskjonaliteten er veldig lik.&#160;I motsetning til Context (og i noen tilfeller Redux) vil ikke en endring p&#229; et av atomsene f&#248;re til rerendering av komponenter som lytter til andre atoms.<\/p><p>&#160;<\/p><p>Recoil bruker og et konsept som kalles selectors. En selector konsumererer en eller flere atoms og/eller andre selectors og returnerer en verdi basert p&#229; hva selectoren gj&#248;r. Selectors er godt egnet for &#229; lytte til endringer p&#229; states.&#160;<\/p><p>&#160;<\/p><p>Recoil er et ungt bibliotek som enda ikke har i n&#230;rheten av dokumentasjonen og erfaringene feks redux har. Redux er ogs&#229; anerkjent for sine middlewares og har gjennom sitt &#229;relange livsl&#248;p f&#229;tt sv&#230;rt mye funksjonalitet knyttet til seg.&#160;&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:&#160;https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10<\/p><p>https://recoiljs.org/docs/introduction/core-concepts<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2158,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I flere &#229;r har det for APIer v&#230;rt en betydelig dominans av REST (representational state transfer). For et REST api har man gjerne definert flere endepunkter som hver har sin overordnede funksjon. Dette kan feks&#160;v&#230;re et get-endepunkt som henter brukere etter s&#248;k, et som henter etter ID og et post-endepunkt som plasserer nye entries i databasen (men det finnes enda flere typer endepunkter som put, patch og delete). REST er med sitt n&#230;re forhold til HTTP godt egnet for caching av GET-requester p&#229; serversiden, funksjonalitet som ikke GraphQL har. I tillegg vil det ved errors&#160;automatisk legges til en status code&#160;som peker mot om erroren ligger i requesten&#160;(400)&#160;eller i kommunikasjonen med serveren (401), noe GraphQL ikke har p&#229; samme m&#229;te.<\/p><p>&#160;<\/p><p>GraphQL beskrives gjerne mer som et query language (derav QL), og kan ligne et klassisk databaseprogram som henter resultat etter konkrete instruksjoner. En av fordelene i GraphQL er at en kan hente ut de spesifikke verdiene til et resultat som man trenger. Skal jeg feks. kun finne adressen til en bruker lagret i databasen kan jeg enkelt gj&#248;re det i en query&#160;med GraphQL, mens en i REST gjerne m&#229; hente ut hele brukeren f&#248;r man kan n&#229; den aktuelle attributten. Dette gj&#248;r at man med GraphQL unng&#229;r fenomenet &#34;over fetching&#34; som beskriver det &#229; hente ut mer data fra databasen enn det som trengs i use caset. I GraphQL kan en med andre ord med kirurgisk presisjon hente ut akkurat den dataen man trenger.&#160;GraphQL opererer med ett endepunkt der enten har en query&#160;eller mutation som henholdsvis finner eller endrer/legger til informasjon i databasen. GraphQL leverer dataen som JSON-objekter p&#229; format etter sp&#248;rringen som ble gjort og kan dermed tas rett i bruk uten &#229; m&#229;tte gj&#248;res om, slik en gjerne m&#229; med et REST api.&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11538345,"ext_inspera_userAssessmentSetupId":7139934,"ext_inspera_userAssessmentId":4841424,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:06Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Støle Ole August (10228)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34429858,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2178,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er et bibliotek for frontend-utvikling. En frontend sin hovedoppgave er &#229; vise frem tilstanden til applikasjonen p&#229; en brukervennlig m&#229;te. For &#229; f&#229; til dette beh&#248;ves det mekanismer og teknikker for &#229; la komponentene inneha tilstand (bruker state videre i besvarelsen). Ikke bare trenger komponenter &#229; ha egen state, men state er - i s&#229; og si alle tilfeller - ogs&#229; n&#248;dvendig &#229; dele til andre komponenter.<\/p><p>&#160;<\/p><p><strong>Lokal state:<\/strong>&#160;<\/p><p>En komponent kan oppn&#229; state ved &#229; gj&#248;res fra et stateless til et stateful komponent. Ved klassekomponenter gj&#248;res dette ved &#229; opprette et eget state-objekt som videre i komponenten kan modifiseres gjennom den spesielle funksjonen &#34;setState&#34;. N&#229;r setState blir kalt vil state-objektet oppdateres slik du har spesifisert og komponentens state og f&#248;lgende UI vil f&#229; en ny tilstand.<br /><br />Ved funksjonelle komponenter kan man oppn&#229; state ved bruk av useState-hooken. Denne hooken gir deg tilgang til &#248;nsket state-variabel samt en dispatch-funskjon for &#229; kunne oppdatere gitt state gjennom applikasjonen. N&#229;r oppdatert vil samme flyt som beskrevet over f&#248;lge.<\/p><p>&#160;<\/p><p><em>Begge disse to m&#229;tene &#229; oppn&#229; state er bare to ulike implementasjoner av samme funksjonalitet.<\/em><\/p><p>&#160;<\/p><p><strong>Dele state:&#160;<\/strong><\/p><p>&#197; la komponenter ha sin egen state er fors&#229;vidt greit. &#34;Problemet&#34; oppst&#229;r n&#229;r denne staten skal deles til andre komponenter. I React er &#34;state-flowen&#34; ensrettet. Dette betyr at en komponent kan dele sin state til en barne-komponent, men det er ikke like &#34;rett frem&#34; &#229; dele staten til f.eks en komponent p&#229; samme hierarkiske niv&#229; (f.eks en &#34;s&#248;sken-komponent&#34;). State kan deles til barne-komponentene ved hjelp av <em>props<\/em>. Informasjon gitt gjennom props kan deretter n&#229;s i komponentene som f&#229;r tildelt informasjonen fra en foreldrekomponent.<\/p><p>&#160;<\/p><p><strong>Okei, man kan dele state til barn, men hva med all annen state-flyt?<\/strong><\/p><p>Dersom vi &#248;nsker &#229; dele state fra barnekomponenten til&#160;foreldrekomponenten m&#229; dette gj&#248;re gjennom <em>callbacks<strong>.&#160;<\/strong><\/em>I foreldrekomponenten kan man definere en funksjon, sende denne funksjonen gjennom props til barnekomponenten og la barnekomponenten kalle denne funksjonen med sin informasjon.<\/p><p>&#160;<\/p><p><strong>Hva f&#248;rer dette til?<\/strong><\/p><p>Denne ensrettede state-flyten er ikke optimal &#229; jobbe med for st&#248;rre applikasjoner. Flyten f&#248;rer til st&#248;rre &#34;higher order components&#34;, typisk &#34;God-components&#34;, som inneholder applikasjonen sin state. State fra denne komponenten sendes deretter nedover komponent-hierarkiet gjennom props, og vi har&#160;<em>prop-drilling.&#160;<\/em>Prop-drilling er et symptom av den ensrettede tilstandsflyten og f&#248;rer til at applikasjonen blir sammensveiset, noe som ikke er bra i utvikling av programvare.<\/p><p>&#160;<\/p><p><strong>Global state<\/strong><\/p><p>Mange av problemene nevnt over er problemer som i 2020 er lett &#229; unng&#229; med ny innebygd funksjonalitet som React Context og ved en mengde andre bibliotek som f.eks Redux, MobX og Flux. Dette er l&#248;sninger for &#34;global state management&#34;. &#197; implementere funksjonalitet for&#160;&#34;state management&#34; hjelper oss med &#229; dele state til komponenter som beh&#248;ver det, uten &#229; un&#248;dig drille gjennom en eneste komponent. M&#229;ten det som regel fungerer p&#229; er at man definerer en &#34;store&#34;, en lagringsplass. I denne lagringsplassen definerer man state som &#248;nskelig skal kunne deles til diverse komponenter rundt om i komponent-hierarkiet. Deretter&#160;<em>wrapper<\/em>&#160;man st&#248;rre deler av applikasjonen (i React er det typisk &#229; wrappe &#60;App /&#62;) med en&#160;<em>Provider<\/em>. Denne provideren gj&#248;r informasjonen lagret i&#160;<em>store<\/em>&#160;tilgjengelig for alle barn, barnebarn osv. som er wrappet.<\/p><p>&#160;<\/p><p><strong>Lagre alt i global state?<\/strong><\/p><p>Det kan kanskje v&#230;re fristende &#229; g&#229; helt bort fra lokal state og lagre all tilstand i gitt store - det er derimot ikke god&#160;<em>practice.&#160;<\/em>Det vil for flere komponenter v&#230;re naturlig &#229; ha lokal state. F.eks vil det v&#230;re naturlig for et&#160;<em>Form<\/em>-komponent &#229; tilstand p&#229; de ulike input-feltene, uten at dette er interessant for andre deler av applikasjonen.<\/p><p>&#160;<\/p><p>&#197; ha tilgang p&#229; global state gjennom et state&#160;management system, men likevel la mindre komponenter ta seg av sitt &#34;area of concern&#34; med lokal state, er i dag kjent som best practice. Det f&#248;rer til strukturert, lesbar, loosely coupled (ikke sammensveiset) og performant kode.<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2869,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et state management system for React, utgitt av Facebook. Bibliotekets motivasjon&#160;er &#229; v&#230;re et super-performant state management system&#160;uten mye&#160;boiler-plate.<\/p><p>&#160;<\/p><p>M&#229;ten biblioteket gj&#248;r applikasjonen din mer performant er gjennom &#229; implementere state i en&#160;graf-struktur med kjernekonseptene&#160;<strong>Atoms<\/strong> og <strong>Selectors<\/strong>. Atoms er deler av state mens selectors er state avledet fra atoms. Lokal state tidligere implementert gjennom useState implementeres heller gjennom Atoms. Ved &#229; implementere den lokale staten gjennom Atoms legges denne delen av state i grafen til Recoil og blir tilgjengelig i andre deler av applikasjonen. En annen komponent kan &#34;abonnere&#34; p&#229; gitt atom, eller den kan avlede annen state ved hjelp av en selector.<\/p><p>&#160;<\/p><p>Ved &#229; implementere state gjennom bruk av atoms og selectors holder man applikasjonens samlede state til et minimum. Dette er med p&#229; &#229; gj&#248;re Recoil til et veldig performant state management bibliotek.<\/p><p>&#160;<\/p><p>For at applikasjonen skal kunne ta i bruk konseptene over m&#229; appen wrappes i en RecoilRoot, p&#229; samme m&#229;te som en typisk Provider.<\/p><p>&#160;<\/p><p><strong>Sammenlignet med andre state management systems:<\/strong><\/p><p>Andre biblioteker vi har tatt for oss i IT2810,&#160;som l&#248;ser samme problematikk om shared state, er Redux, MobX og React Context. Implementasjonen i de ulike bibliotekene/verkt&#248;yene er ulike, men de l&#248;ser samme problem.<\/p><p>&#160;<\/p><p><strong>React Context vs. Recoil<\/strong><\/p><p>Det som virker som hovedfordelen til Recoil over React Context er performance. React Context fungerer str&#229;lende til lav-frekvente applikasjon, men har en flaskehals p&#229; hvor mye data som kan lagres og hvor ofte denne dataen ettersp&#248;rres. Det virker derimot som om Recoil har fors&#248;kt &#229; b&#248;te p&#229; dette ved &#229; opprettholde en minimal state-graf som en <em>single source of truth&#160;<\/em>for all state i applikasjonen.<\/p><p>&#160;<\/p><p>Fordelen med React Context er derimot at dette er inkludert i React, rett &#34;out of the box&#34;. Man trenger ikke laste ned noen pakker eller bibliotek for &#229; f&#229; det opp og kj&#248;re.<\/p><p>&#160;<\/p><p><strong>Redux vs. Recoil<\/strong><\/p><p>Redux er mer performant enn React Context. Terskelen som ofte pekes p&#229; ved Redux er den bratte l&#230;ringskurven, samt &#34;boiler-platen&#34; som f&#248;lger med et fullstendig oppsett. Recoil poengterer veldig tidlig i dokumentasjonen sin at de er et bibliotek hvor det kreves minimalt med boiler-plate for &#229; komme i gang.<\/p><p>&#160;<\/p><p>En av de &#229;penbare fordelene med Redux, sett i et st&#248;rre utviklingsperspektiv, er dets naturlige cross-platform og cross-framework. Dersom man l&#230;rer seg redux er dette et verkt&#248;y man kan benytte samtlige front-end-prosjekter - om det skulle v&#230;re React, Vue, Angular, Flutter osv. Recoil er et veldig spesifikt bibliotek som forel&#248;pig kun er skrevet til React og kostnaden av &#229; investere tid i et s&#229; spesifikt verkt&#248;y er veldig stor.<\/p><p>&#160;<\/p><p><strong>MobX vs. Recoil<\/strong><\/p><p>MobX f&#248;lger et annet pattern enn de overnevnte. MobX f&#248;lger&#160;<em>observer-pattern<strong>&#160;<\/strong><\/em>som er et kjent pattern for alle som har drevet med objektorientert programmering tidligere. Fordelen til MobX er fra f&#248;rste stund hvor lett det er &#229; implementere. Her virker det som om Recoil og MobX er ganske like. Det at MobX derimot ikke virker &#229; kunne m&#229;le seg mot hvor performant Recoil er, gj&#248;r at man m&#229; avgj&#248;re hvor mye man setter pris p&#229; et lettvint, kjent pattern vs. performance.<\/p><p>&#160;<\/p><p><em>PS: De tre sammenlignende avsnittende over er langt fra ut&#248;mmende, men peker p&#229; noen kjente fordeler/ulemper, spesifikt opp mot tre kjente state management systemer.<\/em><\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2078,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":5,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Kort oversikt:<\/strong><\/p><p>REST (REpresentational State Transfer) er en arkitekturisk m&#229;te &#229; sette opp et API p&#229;. Det har over lang tid v&#230;rt ansett som best practice og det er utbredt hvor enn det er snakk om API. Et REST API settes opp ved &#229; definere flere endepunkter for &#229; tilgjengeliggj&#248;re ressurser. Endepunktene settes opp ved &#229; definere ulike&#160;<em>routes<\/em>&#160;hvor det spesifiseres om de f.eks er endepunkter for informasjonshenting (router.get) eller oppdatering av informasjon (router.put).&#160;N&#229;r API-et er satt opp kan en klient sende nettverkskall over HTTP til gitte endepunkt for &#229; ettersp&#248;rre/manipulere ressurser eksponert gjennom grensesnittet. Eksempelvis kan man gj&#248;re en&#160;GET-request til det &#229;pne REST API-et&#160;<em>https://poetrydb.org/<\/em>&#160;og f&#229; tilgang til informasjon lagret hos de.<\/p><p>&#160;<\/p><p>GraphQL er et sp&#248;rrespr&#229;k for ressurs-henting og -manipulering. Det er utviklet av Facebook og er de siste &#229;rene blitt veldig utbredt. Et API for GraphQL er definert gjennom ett eneste endepunkt. Det defineres deretter hvilke&#160;<em>type<\/em>&#160;requests som kan gj&#248;res, hva gitt request <em>tar inn<\/em>&#160;og hva som returneres. N&#229;r dette er definert implementeres selve logikken for behandling av requestene. I GraphQL har man kun to ulike request, <em>Query<\/em> og <em>Mutation.&#160;<\/em>N&#229;r et API er satt opp kan en klient sende en request til gitt endepunkt hvor man (minst) legger ved et JSON-objekt som definerer hvilke felter man &#248;nsker fra ressursen man har etterspurt. Dette er mulig fordi API-et er typesterkt og har definert objektene som returneres i en TypeDef-fil.<\/p><p>&#160;<\/p><p><strong>Diskusjon:<\/strong><\/p><p>Det er store forskjeller mellom REST og GraphQL selvom de l&#248;ser samme problem - &#229; tilgjengeliggj&#248;re seg/manipulere informasjon definert p&#229; et annet system enn klientsystemet. Det er prim&#230;rt to sider av forskjellene: Forskjellene sett fra klienten som gj&#248;r requests, og forskjellene i implementasjonen for utvikleren.<\/p><p>&#160;<\/p><p><strong>Forskjellene sett fra klienten som gj&#248;r requests:<\/strong><\/p><p>GraphQL er som nevnt over typesterkt. Dette gj&#248;r at en klient lett kan f&#229; tilgang til skjemaet som definerer hvilke ressurser som er mulig &#229; ettersp&#248;rre gjennom API-et. REST er derimot ikke typesterkt og det medf&#248;lger ingen definisjon av API-et med mindre utvikleren har tilgengeligjort dette gjennom API-dokumentasjon (typisk Swagger og lignende).<\/p><p>&#160;<\/p><p>N&#229;r man gj&#248;r et kall til et REST API er det ingen m&#229;te &#229; definere spesifikke felter man &#248;nsker/ikke &#248;nsker &#229; f&#229; returnert - man f&#229;r alle ressursene utvikleren av API-et har definert at skal returneres. Dette f&#248;rer til at man i mange tilfeller f&#229;r tilbake mer informasjon enn man trenger, eller at man m&#229; gj&#248;re flere nettverkskall til ulike endepunkt p&#229;&#160;API-et. GraphQL l&#248;ser dette problemet ved at det kun er ett endepunkt hvor all informasjon utvikleren har gjort tilgjengelig, er tilgjengelig gjennom det. En klient kan gjennom et JSON-objekt&#160;spesifisere n&#248;yaktig hvilke felter klienten &#248;nsker &#229; f&#229; returnert fra API-et. GraphQL l&#248;ser derfor <em>over-/under-fetching<\/em> problematikk.<\/p><p>&#160;<\/p><p>REST har noen funksjonaliteter som gj&#248;r det mer egnet enn GraphQL. F.eks har man med et REST-API muligheter for &#229; cache requests, noe som til n&#229; ikke er mulig GraphQL. REST er ogs&#229; veldig lett &#229; ta i bruk, og det er vanvittig mye ressurser for &#229; l&#230;re det. GraphQL er&#160;<em>relativt nytt<\/em>&#160;(les: utgitt 2015) og det kan v&#230;re vanskeligere &#229; bli kjent med.<\/p><p>&#160;<\/p><p><strong>Forskjellene sett fra utvikleren av API-et:<\/strong><\/p><p>Utviklere av et REST-API kan definere flere ulike endepunkt for ulike area of concerns. Dette gj&#248;r et REST-API vedlig oversiktlig og lesbart. GraphQL kan derimot bli noe mer rotete &#229; f&#229; oversikt.<\/p><p>&#160;<\/p><p>GraphQL er typesterkt noe som gj&#248;r at en utvikler selv m&#229; definere hvilke typer en request skal ta inn som parameter og hvilke typer en request skal returnere. For mindre API-er kan det virke un&#248;dvendig, n&#229;r man gjennom et REST-API ikke beh&#248;ver &#229; definere noen typer som helst.<\/p>"}]}],"ext_inspera_totalScore":14,"score":14}},{"result":{"sourcedId":11538355,"ext_inspera_userAssessmentSetupId":7140061,"ext_inspera_userAssessmentId":4841462,"dateLastModified":"2020-12-01T10:01:44Z","ext_inspera_startTime":"2020-12-01T08:00:07Z","ext_inspera_endTime":"2020-12-01T10:01:44Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Hjaltason Hjalti Percy Casimis (10200)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331177,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2830,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Props&#160;er en m&#229;te react feature som tar for seg hvordan data kan overf&#248;res mellom komponenter. Props st&#229;r for properties. Kan tillate deg &#229;&#160;sende&#160;informasjon fra ett komponent til et annet. Dette g&#229;r i en retning, nemling fra parent til child og skal ikke bli endret i child komponentet. Dette vil si at props&#160;er i hovedsak read only.<\/p><p>&#160;<\/p><p>State er et objekt som holder data som er mer dynamisk. Denne vil da kunne endres basert p&#229; handlinger som tar sted i applikasjonen. En state er <em>private <\/em>og kan kun benyttes av komponentet den blir definert i eller et child komponent. For best pratice s&#229; burde endringer i state&#160;ta sted i en set metode.&#160;<\/p><p>&#160;<\/p><p>Context er en metodikk som kan benyttes for &#229; dele informasjon mellom kompnenter uten &#229; m&#229;tte gj&#248;re dette med en prop mellom hvert lag som skiller disse komponentene.&#160;Endering i state med context for&#248;rer til rerendering. Noe som kan gj&#248;re dette noe uegnet til states som kan endres ofte, da dette blir veldig krevende ytselsesmessig og ineffektivt. Veldig lite overhead i forhold til&#160;<\/p><p>&#160;<\/p><p>Redux er en library som kan benyttes for &#229; implementere en sentralisert form for&#160;state mangagement. Denne l&#248;sningen g&#229;r i utgangspunktet ut ifra at du benytter en store,&#160;men flere er mulig, hvor du definerer states.&#160; Her benytter du reducers som endrer p&#229; states, disse kan ligger mer distribuert slik som resten av koden. Dette kan gj&#248;re koden lettere &#229; opprettholde og skalere ettersom du har ett(eller noen f&#229;) punkt hvor du kontrollerer prosjektets states<\/p><p>&#160;<\/p><p>Mobx er et annet alternativ som benyttes for &#229; implementere state management. Her vil du g&#229;&#160;utifra at du benytter minst to stores, noe som kan v&#230;re praktisk ettersom states kan ligge nermere steder hvor de endres. MobX blir derfor ofte foretrukket i sm&#229; prosjekter, hvor scalability ikke er en like stor bekymring. Til gjengjeld har mobx flere fordeler spesielt n&#229;r det gjelder hvor mye mindre komplisert utviklere finner dette biblioteket og hvor mye mindre boilerplate den tar med seg.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2635,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et bibliotek som skal dekke ett par mangler i react sine integrerte state management. I hovedsak skal dette l&#248;se problemer som;&#160;at context har hatt begrensede muligheter til &#229; lagre flere verdier for states og&#160;at endringer i state kan lede til rerendering.<\/p><p>Recoil fungerer ved &#229; benytte atoms, en atom er enheter som holder&#160;en state. N&#229;r du endrer state i en atom vil alle komponentene som subcriber til&#160;informasjonen i&#160;staten rerendere, men ikke alle kompnentene, som context. Atoms&#160;kan plasseres hvor som helst i applikasjonen, noe som minner om hvordan mobx sine stores kan spres ut. Atoms og selectors&#160;kan endres i komponentene, noe som gj&#248;r disse veldig distribuert i likhet med context og mobx, men en slik fordeling kan ha noen negative trekk. Det er i en slik setting viktig at atoms ikke har noe overlapp ettersom du ikke har en <em>singe source of truth, hvor dette kan hondteres<\/em>. Denne formen gj&#248;r ogs&#229; det lettere &#229; splitte opp koden i situasjoner hvor det lnskes.&#160;<\/p><p>Recoil sin semantikk er laget for &#229; likne p&#229; react og har lite i form av boilerplate, noe som i teorien vil gj&#248;re det lett &#229; l&#230;re seg, kode i og med mindre overhead.<\/p><p>Recoil blir da en l&#248;sning som i praksis er ganske lik&#160;context, med noen mobx preg.Men har som hensikt &#229; takle noen av svakhetene i context.&#160;Dette gj&#248;r den i mitt intrykk som facebook sitt svar p&#229; redux men i en mer lavkostnad l&#248;sning med tanke p&#229; overhead og st&#248;rrelse.&#160;<\/p><p>Fordeler:<\/p><p>- Lite boilerplate<\/p><p>- mindre boilerplates, spesielt i forhold til redux<\/p><p>- enklere overgang fra context<\/p><p>- lite kode og overhead<\/p><p>Ulemper:<\/p><p>- states blir mindre samlet enn redux sine stores, noe som kan gj&#248;re koden mindre oversiktelig og potensiellt skape problemer n&#229;r ting blir for lokalt.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1542,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>N&#229;r du benytter REST defineres et sett med endepunkter, i form av data interaksjoner og enderinger, som oppn&#229;s ved HTTP requests. N&#229;r du benytter&#160;GraphQL skriver du en mer &#34;tailored&#34; request i en mer json liknende syntax,&#160;uten &#229; m&#229;tte forholde deg til HTTP i like stor grad. Denne formen for GraphQL request ser p&#229; alle ressurser som mer sammenkoblede, som gj&#248;r at den kan behandle mer disjunkte datasett som sammenkoblede i kilden. Noe som gj&#248;r at hvis du henter fra to separate datasett med en graphQL request, m&#229;tte du ha sendt to HTTP requests hvis du hadde benyttet REST. Noe som kan gj&#248;re disse foresp&#248;rslene mer kraftige.<\/p><p>Disse mer skreddersydde requestene tillater ogs&#229; GraphQL foresp&#248;rsler &#229; v&#230;re mer spesifikke ang&#229;ende hva slags atributter som &#248;nskes i svaret, mens med REST API kan man&#160;begrense svaret til et tilsvarende subset. Slik s&#229; trenger du kun &#229; forhodle deg til&#160;ett endpoint, mens REST kan ha flere mindre spesifikke end points.<\/p><p>GraphQL er p&#229; denne m&#229;ten mer fleksibel, noe som ligger litt i navnet ettersom den behandler dataen sin mer som en graf med &#229; beskrive hvordan forskjellige datasett henger sammen.<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11538357,"ext_inspera_userAssessmentSetupId":7139932,"ext_inspera_userAssessmentId":4841531,"dateLastModified":"2020-12-01T10:01:48Z","ext_inspera_startTime":"2020-12-01T08:00:07Z","ext_inspera_endTime":"2020-12-01T10:01:48Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Håtveit Åse (10024)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35330905,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1912,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>React er en s&#229;kalt SPA (singel page application) som vil si at den lager en enkel webside, hvor&#160;data kan lastes dynamisk inn. Multiple page applications vil i motsetning til dette kun hente fram nye sider fra serveren ved brukerinteraksjoner. Hvis en bruker endrer data som igjen brukes i flere av komponentene p&#229; websiden i en SPA, vil ikke hele websiden lastes inn p&#229; nytt(rerender), men kun de komponentene som bruker dataen som er endret p&#229;. Dette er generelt mer effektivt, og kan f&#229; websiden til &#229; virke mer interaktiv.<\/p><p>React er bygget opp med flere gjenbrukbare separerte komponenter som returnerer HTML via en render funksjon. Alle disse komponentene er satt opp i et rimelig hierarkisk system, og en kan enkelt sende data nedover i systemet via props. Det &#229; sende data eller endre state motsatt vei kan v&#230;re litt mer vrient, men er fullt mulig ved &#229; lage s&#229;kalte &#34;callbackfunctions&#34; hvor&#160;en &#34;childnode&#34; sender en funksjon&#160;tilbake til parent for &#229; endre staten til parentklassen.&#160;<\/p><p>&#160;<\/p><p>Ettersom React er s&#229;pass hierarkisk kan det fort&#160;bli en del &#34;props-drilling&#34; i websiden - det &#229; sende props(data) nedover flere komponenter uten &#229; n&#248;vdendigvis ha behov for de over alt. Dette vil f&#248;re til at komponenter som ikke n&#248;dvendigvis bruker dataen vil rerendre seg n&#229;r dataen endres. For &#229; unng&#229; dette kan en legge til globale states, gjerne ved bruk av React sitt Context API, Redux (bruker actions og reducers) eller MobX (gj&#248;r funksjoner&#160;observable), hvor en definerer variabler som g&#229;r igjen og gjenbrukes flere steder p&#229; websiden. Disse globale states legges gjerne i en &#34;store&#34;, og kan hentes ut og endres i de komponentene som avhenger av disse.&#160;<\/p><p>&#160;<\/p><p>Livssyklusmetoder i React er metoder som s&#248;rger for hvordan &#229; rendre komponenter n&#229;r de vises for f&#248;rste gang p&#229; websiden og er rendret til DOMen, hvis variabler endrer seg, eller hvis komponenten er i ferd med &#229; fjernes fra DOMen. I klassekomponenter i React tar man i bruk funksjonene componentDidMount(), componentDidUpdate() og componentWillUnMount(), mens for funksjonelle komponenter kan en f&#229; samme funksjonalitet ved hjelp av hooken useEffect(). Hvis det for eksempel er en state i komponenten som endres, vil en gjerne rendre hele komponenten igjen med ny data. For eksempel ved useEffect() kan en legge inn et siste argument i en klammeparantes:&#160;<br />useEffect(() =&#62; {<br />&#160;console.log(&#39;render just once!!&#39;);&#160;<\/p><p>}, []) ;&#160;<\/p><p>...Denne tomme parantesen vil gi beskjed til komponenten at useEffecten skal kj&#248;res n&#229;r komponenten er rendret til DOMen.&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3357,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er en state management l&#248;sning som er ment til &#229; fikse React sine begrensninger med h&#229;ndtering av states. Som nevnt tidligere har react en del begrensninger for deling av states over st&#248;rre deler av komponenttreet, da dette kan f&#248;re til rerendring av mange komponenter som ikke n&#248;dvendigvis hadde v&#230;rt n&#248;dvendig. Recoil sin l&#248;sning g&#229;r ut p&#229; &#229; (enkelt forklart) definere en &#34;direkte graf&#34; som g&#229;r gjennom s&#229;kalte&#160;<em>atoms<\/em>&#160;(enheter som definerer staten), gjennom&#160;<em>selectors <\/em>(funksjoner) og ned til komponentene i React-treet. Disse statene er da mulig &#229; oppdatere, og vil automatisk oppdatere andre komponenter som benytter seg av den samme staten.<\/p><p>&#160;<\/p><p>Tilsvarende l&#248;sninger som er nevnt i l&#230;ringsm&#229;lene fra faget er MobX, Redux og Context. Her virker det som at Recoil f&#248;rst og fremst pr&#248;ver &#229; l&#248;se problemet med &#229; splitte toppen av komponent-treet (hvor staten ofte blir definert) med &#34;bladene&#34; (hvor staten blir brukt).&#160;<\/p><p>&#160;<\/p><p>Context-l&#248;sningen som kommer med react, holder kun enkle verdier, og dette &#248;nsker Recoil &#229; forbedre ved &#229; tillate &#34;derived data&#34;. I tillegg er ikke Context APIet lagd for h&#248;yfrekvente oppdateringer, men heller for endringer av tema og brukerinterkasjoner.&#160;<\/p><p>&#160;<\/p><p>Redux er et state management bibliotek som blir mye brukt den dag i dag, men det har noen ulemper ved seg som Recoil kan ha forbedret. For eksempel er det en del boilerplate med oppsett av Redux i et prosjekt. Recoil virker som har en del mindre oppsett, og en kan raskere komme i gang med bruk. For eksempel trenger en ikke &#229; lage en separat &#34;store&#34; eller reducers for &#229; kunne benytte seg av staten. Hvert&#160;<em>Atom&#160;<\/em>kan enkelt benyttes som en delt state, omtrent like enkelt som en useState()-hook i React (bare med useRecoilState()).&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1757,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>REST og GraphQL er begge ment til &#229; brukes som overordnet API arkitektur for kommunikasjon mellom tjener og klient, men de l&#248;ser dette p&#229; et litt ulikt vis. Den dag i dag er REST standarden for mange bedrifter, men en kan se en &#248;kende trend i bruken av GraphQL.<\/p><p>&#160;<\/p><p><strong>GENERELT:<\/strong>&#160;<\/p><p>REST API er noe som har blitt brukt enormt mye den siste tiden, og har fokus p&#229; lesing og skriving av ressurser. Her oppretter man endepunkter som sp&#248;r og endrer&#160;data ved bruk av URI og&#160;HTTP foresp&#248;rslene GET, POST, PUT og DELETE. N&#229;r en henter data med REST vil en f&#229; fulle objekter returnert til klienten.&#160;<\/p><p>&#160;<\/p><p>GraphQL er mer et sp&#248;rrespr&#229;k hvor en spesifiserer i json hva du vil ha tak i av data ved hjelp av skjemaer. Dette er et sterkt typet system, hvor en definerer hvordan klienten skal hente data. Benytter seg kun av ett endepunkt.&#160;<\/p><p>&#160;<\/p><p><strong>FORSKJELLER:&#160;<\/strong><\/p><p>REST API kan fort f&#248;re til &#34;overfetching&#34; av data hvis sp&#248;rringene blir litt kompiserte. Som nevnt over f&#229;r man ut fulle objekter og har gjerne flere endepunkt, som vil si at du fort f&#229;r returnert mer data enn det du trenger. Hvis du skal hente data som er relatert til hverandre, m&#229; en gjere gj&#248;re flere sp&#248;rringer ved flere endepunkt.&#160;GraphQL l&#248;ser dette problemet ved &#229; kun hente ut den dataen du sp&#248;r etter.&#160;<\/p><p>&#160;<\/p><p>REST f&#248;rer til en rimelig separert server og klient, noe som igjen gir et system som er veldig skalerbart. Det vil si at en kan videreutvikle klienten, uten &#229; m&#229;tte i stor grad endre&#160;serversiden. GraphQL legger opp til&#160;en litt tettere kobling mellom klient og server med et s&#229;pass typet system, men dette trenger ikke &#229; v&#230;re s&#229; negativt da det gir mulighet for validering i st&#248;rre grad enn REST.&#160;<\/p><p>&#160;<\/p><p>REST kan&#160;i motsetning til GraphQL benytte seg av caching mekanismen som st&#248;ttes av de fleste weblesere (default). Dette mangler GraphQL. I tillegg st&#248;tter GraphQL&#160;kun JSON, mens REST st&#248;tter flere datatyper.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11538874,"ext_inspera_userAssessmentSetupId":7140124,"ext_inspera_userAssessmentId":4841414,"dateLastModified":"2020-12-01T10:01:41Z","ext_inspera_startTime":"2020-12-01T08:00:11Z","ext_inspera_endTime":"2020-12-01T10:01:41Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Karlsson Aleksander Mats (10081)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":33261606,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2108,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I typisk React har vi mekanismer som:<\/p><ul>\t<li>Props: data som sendes nedover til barn-komponenter. Data renner ned uten &#229; endres. (Props skal alltid h&#229;ndteres med rene (pure)&#160;funksjoner).<\/li>\t<li>State: data som kan endres. Data som kan leses og skrives.&#160;<\/li><\/ul><p>Props er noe som sendes til et komponent hvoras state er noe som lages innad i komponenter.<\/p><p>&#160;<\/p><p>Det finnes ogs&#229; APIer ment til &#229; forenkle visse aspekter av State-managment i React. Dette inkluderer f.eks Context og Redux/MobX (og Recoil).<\/p><p>Context muliggj&#248;r enklere deling av global data, som spr&#229;k, fargetema osv. Uten context vil dette v&#230;re en kostbar operasjon ettersom data m&#229; drilles ned fra toppniv&#229;et til alle relevante barn i komponent-treet. Dette vil f&#248;re til mange props som beh&#248;ves &#229; sendes nedover. Context l&#248;ser dette ved &#229; g&#229; rundt alle mellomledd og kun gi dataen til de komponentene som beh&#248;ver det. Dette gj&#248;r det enklere for utviklere &#229; sende data dit det skal uten &#229; m&#229;tte legge til en hel rekke av props i treet for &#229; s&#248;rge for at det kommer fram.&#160;<br /><br />Redux muliggj&#248;r &#229; samle state i en enkel &#34;store&#34;. Dette gj&#248;r det enklere &#229; h&#229;ndtere oppdatering og lesing av state, spessielt for st&#248;rre prosjekter.&#160;<\/p><p>Redux st&#248;tter serialisering av &#229; endre state gjennom &#34;actions&#34;. Typisk er staten i redux read only, men actions utrykker at de &#248;nsker &#229; oppdatere staten. Ettersom detter er serializable utelukker det en del problemer som race condition. Det brukes reducers, rene funksjoner&#160;som tar inn en action og prev state&#160;for &#229; returnere neste state.&#160;<br /><br /><br />Kilder:<\/p><p>https://reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props<\/p><p>https://redux.js.org/understanding/thinking-in-redux/three-principles<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3066,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil virker som &#229; v&#230;re et nytt alternativ til b&#229;de Context- og Redux/MobX-apiet.<\/p><p>Recoil lar oss lage en data-flow graf som flyter fra atomer (delt state) gjennom selectors (pure&#160;functions, et&#160;statless komponent&#160;som ikke endrer dataen) og ned til React komponentene<\/p><ul>\t<li>Atoms er stateenheter. De kan oppdateres og f&#248;lges, og n&#229;r et atom oppdateres vil alle f&#248;lgerene re-rendre med den nye verdien. Dette muliggj&#248;r delingen av state mellom alle komponenter som bruker det samme atomet.&#160;<\/li>\t<li>Selectors er essensielt (for komponenter) utbyttbare med atomer. Forskjellen er at en selector kan ta b&#229;de atomer eller andre selectors som argument. En selector er et atom som kan ta inn input og vurderer om noe&#160;skal gj&#248;res med det.&#160;En selector kan ogs&#229; f&#248;lges av komponenter og vil re-rendre komponentene dersom selectoren endres.<\/li><\/ul><p>Et atom vil kunne lagre data for f.eks fontst&#248;rrelse for br&#248;dtekst (som vist i dokumentasjonen) og gi alle komponenter som f&#248;lger atomet denne informsjonen. En selector kan f.eks ta denne informasjonen og gi alle &#60;h1&#62; en annen fontst&#248;rrelse basert p&#229; atomet som h&#229;ndterer staten for fonts&#248;rrelse til br&#248;dtekst. Det er ikke n&#248;dvendigvis &#248;nskelig &#229; endre st&#248;rrelsen p&#229; h1 dersom br&#248;dteksten endres 1pt og dette vil ogs&#229; en selector kunne h&#229;ndtere.<\/p><p>&#160;<\/p><p>Til sammens gir dette recoil muligheten til &#229; erstatte state med data som er utledet fra komponenter, uten &#229; endre komponentene som bruker staten. Den utldede dataen kan ogs&#229; bytte mellom &#229; v&#230;re synkron/asynkron uten &#229; endre komponentene.<\/p><p><br /><br />Context var ikke ment til &#229; h&#229;ndtere oppdtaeringer som skjer ofte. Det var i hovedsak ment til ting som temaer og brukerautensiering. En konsekvens av dette er at det ikke har god st&#248;tte for &#34;code splitting&#34; og largring av mange verdier. Recoil lider ikke av de samme limitasjonene. I Recoil er det kun komponenter som f&#248;lger et atom eller selector som blir p&#229;virket av endringer i disse, hvor i Context vill alle komponenter som bruker en&#160;state (den som blir endret) bli oppdatert.<\/p><p>&#160;<\/p><p>I redux er det en egen store der all dataen er lagret. Recoil deler alt dette opp i individueller atomer. L&#248;sningen til Redux kan v&#230;re betydelig mer kostbar da en oppdatering vil m&#229;tte sp&#248;rre alle koblede komponenter om det er behov for &#229; rerendre. Ettersom atomene i Recoil er nettopp atomiske vil ikke dette gjelde her, og i f&#248;lge McCabe (utvikler av Recoil):&#160;<br />&#34;Well, I know that on one tool we saw a 20x or so speedup compared to using Redux. This is because Redux is O(n) in that it has to ask each connected component whether it needs to re-render, whereas we can be O(1).&#34; (1)<\/p><p>&#160;<\/p><p>Dersom en &#248;nsker &#229; ha funksjonaliteten ved &#229; sp&#248;rre alle koblede komponenter (eller bare de relevante for en oppgave) er ogs&#229; dette mulig i Recoil ved &#229; bruke selectors.<br />For meg virker det som at Recoil er en god erstatning for b&#229;de Redux og (spessielt) Context, men det er fortsatt veldig nytt og trenger muligens litt tid til &#229; modnes f&#248;r det kan forventes &#229; se stor bruk.<\/p><p>&#160;<\/p><p>Kilder:<\/p><p>(1) https://news.ycombinator.com/item?id=23183177<br />https://medium.com/@chandan.reddy/react-recoil-vs-redux-the-ultimate-react-state-management-face-off-188a729a70ee<br />https://www.emgoto.com/redux-vs-recoil/<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1839,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>En essensiell forskjell er hvordan de h&#229;ndterer foresp&#248;rsler:<\/p><p>I REST er st&#248;rrelsen og formen p&#229; restultatet av en spr&#248;rring definert av serveren. I GraphQL er det klienten som sp&#248;r serveren etter hva den trenger. Serveren deklarerer kun hva som er tilgjengelig til klienten.&#160;<\/p><p>Dette muliggj&#248;r ogs&#229; at en klient via GraphQL&#160;hente flere ressurser (ved &#229; traversere gjennom forholdene deklarert i skjemaene)&#160;fra forskjellige skjemaer i en database, i en sp&#248;rring. Dette f&#248;rer igjen til bedre responstid&#160;enn hvis klienten&#160;skulle utf&#248;rt en lignende sp&#248;rring via REST da dette ville krevd flere sp&#248;rringer og derfor flere nettverkskall.<\/p><p>&#160;<\/p><p>REST har ogs&#229; en tendens til &#229; over-fetching data. Det vil si at det hentes mer data enn det som klienten faktisk &#248;nsker. Si en bruker &#248;nsker &#229; se om nummeret til en person er oppdatert i en telefonkatalog. Et REST API vil typisk hente hele dataobjektet for denne personen i stede for kun telefonnummeret. REST mangler alts&#229; spesifisitet i felt eller type av data som skal leveres. Dette er ikke et problem i graphQL og det kan v&#230;re spesielt hensiktsmessig &#229; bruke dette dersom det ofte er behov for innsikt i spesifike felt.<\/p><p>&#160;<\/p><p>GraphQL st&#248;tter ikke caching p&#229; serverside i motsetning til REST. Dette gj&#248;r at data som er nylig, eller mye brukt ikke f&#229;r utnyttet denne fordelen i optimalisering.&#160;<\/p><p>&#160;<\/p><p>Ettersom GraphQL har en del funksjonalitet og sammenkoblinger &#248;ker dette ogs&#229; st&#248;rrelsen p&#229; dataen for APIet. Dette kan skade ytelsen til serveren.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>Kilder:<br />https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b/<\/p><p>https://jelvix.com/blog/graphql-vs-rest<\/p>"}]}],"ext_inspera_totalScore":11,"score":11}},{"result":{"sourcedId":11538925,"ext_inspera_userAssessmentSetupId":7139961,"ext_inspera_userAssessmentId":4841311,"dateLastModified":"2020-12-01T10:01:34Z","ext_inspera_startTime":"2020-12-01T08:00:12Z","ext_inspera_endTime":"2020-12-01T10:01:34Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Motland Julie Holte (10184)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":35331070,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":2526,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p><strong>Props:<\/strong><\/p><p>I React brukes state og props i komponenter. Hver komponent har ofte state og props. Props er en mekanisme i react for &#229; sende data nedover i komponenthierarkiet.&#160;Bruker props dersom komponenten ikke trenger &#229; vedlikeholde eller endre state changes (endringer i tilstand). Props kan ikke endres.&#160;<\/p><p>&#160;<\/p><p><strong>State:<\/strong><\/p><p>Hvis dataen man sender til en komponent skal kunne endre seg p&#229; en spesifikk m&#229;te, endre seg ved et event (noe skjer) eller lignende s&#229; kan man bruke states. State lagrer komponentens tilstand (data, oppf&#248;rsel). State kan endres.&#160;<\/p><p>&#160;<\/p><p>Det er utviklet flere teknikker og mekanismer for &#229; h&#229;ndtere states og dele dem mellom komponenter. Noen av disse er context api, redux, mobX&#160;og&#160;react Hooks.<\/p><p>&#160;<\/p><p>React <strong>Context API <\/strong>er nyttig dersom man vil sende tilstander gjennom componenttreet uten &#229; gj&#248;re dette manuelt. Dette brukte vi i prosjekt 2, et eksempel p&#229; hvordan vi gjorde var ved &#229; detektere n&#229;r en knapp ble trykket p&#229; skulle man endre tilstand i alle svg komponenter. For &#229; gj&#248;re dette brukte vi context ved &#229; sende et &#34;theme&#34;-prop som forenkelt prosessen, fremfor om vi skulle ha gjort dette manuelt. Det er hensiktsmessig &#229; bruke context API n&#229;r man har data som skal leses av mange komponenter.&#160;<\/p><p>&#160;<\/p><p><strong>React Hooks<\/strong> gj&#248;r det mulig &#229; dele tilstandslogikk&#160;mellom flere komponenter. For &#229; bruke hooks bruker man blant annet useState(). Hooks brukes i funksjonelle komponenter. Med hooks er state derimot knyttet til en komponent. I noen tilfeller &#248;nsker man gjerne &#229; beholde en instans av tilstanden. Det er her state h&#229;ndtering kommer inn i bildet.&#160;<\/p><p>&#160;<\/p><p><strong>mobX og redux<\/strong> er to typer state-h&#229;ntering mekanismer (state-management). Fordelen ved disse er at dataen er globalt definert hvilket betyr at man f&#229;r kun en instans av dataen. Ekstern data hentes kun &#233;n gang, noe som er hensiktsmessig n&#229;r man har en nettside som skal hente data for god ytelse. MobX og redux har ogs&#229; flere ulikheter og ulike fordeler/ulemper. MobX er brukt p&#229; tvers av plattformer mens redux er hovedsaklig for javascript applikasjoner. Men ingen av dem er spesifikt for React.<\/p><p>&#160;<\/p><p>Stateh&#229;ndtering gj&#248;r det mulig &#229; bruke samme state i flere komponenter. I tillegg&#160;kan man velge &#229; ha globale eller lokale states.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":3291,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil&#160;er et state management bibliotek for React. Det vil si at det i likhet med Redux og MobX handler om &#229; h&#229;ndtere states i React mellom komponeter.&#160;Recoil nevner at de bruker en &#34;directed graph orthogonal&#34;. State changes flyter fra roten til grafen (atoms)&#160;gjennom funksjoner (selectors) og deretter inn i komponenter.&#160;<\/p><p>&#160;<\/p><p>Atomer inneholder states. Komponenter kan &#34;abonnere&#34; p&#229; atomer. N&#229;r en endring i atomet skjer varsles komponentene og oppdateres. Atomer kan leses og skrives til&#160;fra enhver komponent. Recoil bruker ogs&#229; Selectors (funksjoner som tar inn atomer som input) ogs&#229; disse kan komponenter abonnere p&#229;. N&#229;r selector endres s&#229; oppdateres komponentene som abonnerer.&#160;<\/p><p>&#160;<\/p><p>Som sagt ligner recoil p&#229; Redux i det at begge utf&#248;rer state h&#229;ndtering. En viktig forskjell er at Recoil er utviklet spesifikt for React noe som medf&#248;rer at en del av React syntax, semtantikk og react oppf&#248;rsel opprettholdes i recoil dette kan gj&#248;re at det er enklere &#229; l&#230;re dersom man allerede kjenner til react, ettersom man kan oppleve at redux er mer tungvindt &#229; forst&#229;.&#160;Atomer kan brukes istedenfor React lokal komponent state.&#160;<\/p><p>&#160;<\/p><p>Flere fordeler og sammenligninger:<\/p><p>- selectors hjelper med &#229; unng&#229;&#160;overfl&#248;dig tilstand ettersom kun et minimalt sett med tilstand er lagret i atom.<\/p><p>- Recoil er utviklet for react som gj&#248;r at det &#34;f&#248;les som React&#34;. Det kan tenkes at dette gj&#248;r at det er mer naturlig og lettere &#229; sette seg inn i dersom man allerede er kjent med React&#160;<\/p><p>- Recoil er et boilerplate free API, til forskjell fra Redux hvor man m&#229; installere tredjeparts komponenter og bruke reducers, actions og connectors osv.&#160;<\/p><p>- Til forskjell fra Redux (og Context API-et) har ikke recoil global state noe som gj&#248;r code splitting oppn&#229;elig.<\/p><p>- St&#248;tter async uten bruk av tredjepartskomponenter<\/p><p>&#160;<\/p><p>Ulemper:<\/p><p>- fortsatt tidlig i utviklingen, har noen mangler.&#160;<\/p><p>- Recoil er bygget for react og kan ikke brukes &#34;utenfor&#34; react, hvertfall ikke enda.&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p><p>&#160;<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":1192,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>I REST har man ett eller flere endepunkter som brukes for &#229; lese, skrive eller endre p&#229; data. Klient og server kommuniserer med hverandre ved hjelp av URI og HTTP Requests. Med REST kan man oppleve potensielt mange endepunkter og kan risikere &#229; m&#229;tte gj&#248;re mange kall for &#229; hente dataen. Et annet problem er at man i&#160;tillegg kan risikere &#229; hente mer data enn man trenger, s&#229;kalt overfetching. Med REST kan man ogs&#229; bruke caching i nettlesere slik at man slipper &#229; sende sp&#248;rringer helt&#160;til databasen for ofte etterspurt informasjon p&#229; en nettside.&#160;<\/p><p>&#160;<\/p><p>I GraphQL sender man sp&#248;rring til server hvor man definerer s&#248;k og hvilke data som skal returneres. Det som er nyttig med dette er at all&#160;data kan uthentes ved hjelp av en&#160;request og man unng&#229;r innlasting av for mye data, som gjerne skjer i REST. Til forskjell fra REST s&#229; har GraphQL mangler i caching &#34;funksjonalitet&#34; i HTTP laget. En annen ulempe med GraphQL er at det st&#248;tter kun JSON-data. En fordel med GraphQL er at det har et typesystem som muliggj&#248;r validering, dette har ikke REST.<\/p>"}]}],"ext_inspera_totalScore":12,"score":12}},{"result":{"sourcedId":11543737,"ext_inspera_userAssessmentSetupId":7140071,"ext_inspera_userAssessmentId":4841455,"dateLastModified":"2020-12-01T10:01:43Z","ext_inspera_startTime":"2020-12-01T08:09:49Z","ext_inspera_endTime":"2020-12-01T10:01:43Z","ext_inspera_extraTimeMins":0,"ext_inspera_incidentTimeMins":0,"ext_inspera_candidateId":"Sveberg Jørgen Nummedal (10093)","ext_inspera_attendance":true,"lineItem":{"sourcedId":70328409,"type":"lineItem"},"student":{"sourcedId":34496968,"type":"user"},"ext_inspera_autoScore":0,"ext_inspera_questions":[{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70246946,"ext_inspera_questionContentItemId":70039900,"ext_inspera_questionNumber":"1","ext_inspera_questionTitle":"Tilstand og dataflyt i React","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":5262,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":4,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Data kan bli delt og lagret i en react applikasjon p&#229; en del m&#229;ter.<\/p><p>&#160;<\/p><p>Enkleste vil v&#230;re &#229; component <strong>properties<\/strong> som blir gitt til en komponent n&#229;r den blir instansiert. Dette krever minst oppsett av alt, men blir veldig repetetivt og tungvint n&#229;r samme informasjonen ofte skal brukes i flere komponenter eller dataen skal veldig langt ned i komponentstrukturen, da react gengir informasjon i en top-down struktur der en m&#229; gjennom hvert ledd helt ned til komponenten som bruker informasjonen.<\/p><p>&#160;<\/p><p>For &#229; lagre informasjon i react som skal representeres/brukes og endres av interaksjon UI,&#160;bruker vi&#160;<strong>hooks<\/strong>(funksjonelle komponenter) eller <strong>state<\/strong>(klasse komponenter). I motsetning til vanlige variabler vil hooks og state beholde&#160;sin n&#229;v&#230;rende verdi(ikke alltid resettes til default) om komponenten skulle re-rendres, og &#229; oppdatere hooks/state vil triggre en re-render av komponenten for &#229; representere disse endringene. State kan bare brukes direkte innenfor en klasse-komponent, og hooks kan bare brukes innenfor en funksjonell-komponent. Vanlige funksjoner har ikke mulighet til &#229; ha egne&#160;hooks eller state. Informasjonen i state og hooks, og&#160;funksjoner for &#229; endre denne informasjonen kan bli gitt videre som props i andre funksjoner og komponenter.<\/p><p>&#160;<\/p><p>Men en vil ofte ha samme informasjonen delt mellom flere komponenter og ikke m&#229;tte trenge &#229; f&#248;re dem mellom mange steg un&#248;dvendig, og ha muligheten til &#229; endre denne informasjonen globalt.<\/p><p>Da kan vi bruke en del forskjellige metoder som oppfyller samme m&#229;l, <strong>global state<\/strong>. Dette g&#229;r ut p&#229; &#229; dele informasjon mellom alle komponenter innenfor en <strong>Provider<\/strong>&#160;komponent som wrappes rundt scopet du vil ha tilgang til denne informasjonen, ofte rundt hele applikasjonen for &#229; gj&#248;re informasjonen global. Man&#160;kan(sp&#248;rs p&#229; hvilket api/bibliotek en bruker)&#160;ogs&#229; gj&#248;re dette&#160;i mindre scopes for &#229; holde styr p&#229; hva som har tilgang til hva. Dette &#229;pner for mulighet til &#229; gjenbruke navn p&#229; state i forskjellige steder p&#229; siden og deler av nettsiden skal sin egen&#160;state, som kan v&#230;re &#248;nskelig&#160;n&#229;r nettsiden n&#229;r en viss st&#248;rrelse.<\/p><p>Denne globale staten kan v&#230;re <strong>dynamisk <\/strong>slik som komponent-state og -hooks ved &#229; definere staten som et objekt, der objektet har en verdi, og en funksjon/funksjoner for &#229; endre denne verdien.<\/p><p>&#160;<\/p><p>React kommer n&#229; ferdigbygd med en form for provider/global state management, Context-api. Context-api har relativt enkelt oppsett og fungerer bra i mindre applikasjoner, spesielt med f&#230;rre verdier som trengs &#229; endres under kj&#248;retid.<\/p><p>Dette er fordi hver gang noe i state endres vil alt innen Provider komponenten re-rendres, som kan f&#248;re til u&#248;nsket oppf&#248;rsel og reduksjon i ytelse. Da funksjonene til &#229; oppdatere state m&#229; defineres i komponenten man legger Provider komponenten kan det ogs&#229; f&#248;re til veldig lange App komponenter som er lite lesbart. Context-api kommer da med react s&#229; det gj&#248;r at applikasjonen ikke trenger &#229; importere noe ekstra bilblioteker.<\/p><p>&#160;<\/p><p>Redux er en tredjeparts-l&#248;sning p&#229; samme problem og er i dag industri standard. I&#160;motsetning til Context-api vil Redux bare re-rendre komponentene der relevant informasjon er oppdatert. Derimot krever Redux en god del ekstra &#34;boilerplate&#34; kode for &#229; oppn&#229; et relativt likt resultat, da det er bygget opp av &#39;actions&#39;, &#39;reducers&#39; og &#39;store&#39; som kreves for at ting skal oppdateres dynamisk. Dette&#160;legger til en god del kode hvis en bare skal ha en enkel state med f&#229; variabler som endres. Redux har ogs&#229; en global store for alle states som gj&#248;r debugging lettere og har <strong>immutable <\/strong>state, alts&#229; read only(kan bare oppdateres gjennom actions).<\/p><p>&#160;<\/p><p>MobX er en annen tredjeparts-l&#248;sning som gj&#248;r noe lignende, men krever ikke reducers og har minst to stores, og har muligheten for flere. MobX state er observable, noe som gj&#248;r at komponenter som henter state er &#39;<strong>listeners<\/strong>&#39;, som betyr at informasjonen blir automatisk oppdatert n&#229;r state endres. MobX store er ogs&#229; <strong>mutable<\/strong>, som betyr at state kan direkte endres uten actions. Dette kan gj&#248;re ting enklere og redusere boilerplate i mindre applikasjoner, men kan f&#248;re til redusert dataintegritet i st&#248;rre mer kompliserte applikasjoner.<\/p><p>&#160;<\/p><p>Det er derimot <strong>ikke oppfordret<\/strong> til &#229; bruke context api og lignende hvis en bare vil unng&#229; &#229; m&#229;tte gi noen f&#229; props top-down til en enkel komponent. Dette er ment for &#229; dele informasjon mellom flere komponenter rundt om i applikasjonen. Det er ofte enklere &#229; bruke andre m&#229;ter slik som&#160;React sine&#160;metoder innen <strong>Composition&#160;<\/strong>slik som <strong>props.children<\/strong>&#160;som lar deg gi komponenten children&#160;n&#229;r den instansieres, eller spesialisering der man lager en generisk komponent og komponenter som bruker denne og spesialiserer seg til sin usecase.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988253,"ext_inspera_questionContentItemId":70040012,"ext_inspera_questionNumber":"2","ext_inspera_questionTitle":"Recoil","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":372,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":2,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Recoil er et nyere react bibliotek laget av Facebook som er et fors&#248;k p&#229; &#229; beholde fordelene til Context-api over Redux og lignende, men ogs&#229; ha muligheten til &#229; dekke samme bruksomr&#229;det i st&#248;rre og mer komplekse applikasjoner.<\/p><p>&#160;<\/p><p>State i Recoil er kalt &#39;Atoms&#39;, og er observable slik som i MobX, som betyr at alle relevante komponenter vil alltid f&#229; en oppdatert verdi n&#229;r state endres.<\/p><p>&#160;<\/p><p>Vi har ogs&#229; &#39;Selectors&#39;, som er funksjoner som tar Atoms og andre Selectors som input, og kj&#248;rer hver gang disse input elementene oppdateres.<\/p><p>&#160;<\/p><p>Recoil har mange av fordelene til Context-api, for eksempel er boilerplate redusert ved at en ikke m&#229; lage en separat store.<\/p>"}]},{"ext_inspera_maxQuestionScore":10,"ext_inspera_questionId":70988462,"ext_inspera_questionContentItemId":70040071,"ext_inspera_questionNumber":"3","ext_inspera_questionTitle":"REST vs. GraphQL","ext_inspera_questionWeight":1,"ext_inspera_durationSeconds":958,"ext_inspera_autoScore":0,"ext_inspera_manualScores":[{"ext_inspera_manualScore":3,"ext_inspera_gradingTeacherId":71186619,"ext_inspera_gradingTeacherName":"Collaborative grader"}],"ext_inspera_candidateResponses":[{"ext_inspera_response":"<p>Et REST-API vil som oftest sende fler api kall for &#229; hente forskjellig separat informasjon, der en manuelt lager api kall som henter og filtrerer informasjonen, og en vil oftest skreddersy disse kallene til delen av nettsiden som skal hente denne informasjonen som vil gj&#248;re det lettere &#229; hente riktig og relevant informasjon. Nedsiden ved dette er hvis frontend endres ofte og eller drastisk m&#229; sannsynligvis backend endres&#160;slik at applikasjonen ikke henter inn for lite eller for mye data, og det vil ofte kreves store endringer.<\/p><p>&#160;<\/p><p>Graphql &#229;pner muligheten til &#229; sende ett enkelt kall der en spesifiserer spesifikt hvilken informasjon som &#248;nskes uten noe n&#248;dvendig ekstra oppsett. Dette gj&#248;r at en kan alltid hente akkuratt informasjonen som &#248;nskes ved &#229; justere en enkel query. Det blir veldig enkelt &#229; se hva som faktisk kreves av backend og hva som er overfl&#248;dig, da en enkelt ser hva som &#248;nskes av frontend. Det brukes ogs&#229; streng-typing som gj&#248;r det lett &#229; holde styr p&#229; dataen.<\/p><p>&#160;<\/p><p>Det finnes derimot&#160;en del redskap slik som mongoose for &#229; f&#229; mange av samme fordelene som Graphql har uten &#229; p&#229;virke hvordan frontend utf&#248;rer api kall, noe som kan v&#230;re foretrukket. Hovedsakelig ligger fordelene innen REST-API at det er simplistisk, og gir et enkelt endepunk for hvert case.<\/p>"}]}],"ext_inspera_totalScore":9,"score":9}}]}